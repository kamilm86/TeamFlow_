from config import APP_VERSION
import pyodbc
from config import DATABASE_CONFIG
import getpass
from debug_utils import debug_print, log_warning, log_error
from config import SQL_OBJECTS
from app_settings import app_settings

class DatabaseConnector:
    @staticmethod
    def get_connection():
        db_config = DATABASE_CONFIG
        if db_config.get('engine') == 'mssql':
            cs = (f"DRIVER={{{db_config.get('driver')}}};"
                  f"SERVER={db_config.get('server')};"
                  f"DATABASE={db_config.get('database')};")
            if db_config.get('trusted_connection', 'no').lower() == 'yes':
                cs += "Trusted_Connection=yes;"
            else:
                user, pwd = db_config.get('user'), db_config.get('password')
                if user and pwd: cs += f"UID={user};PWD={pwd};"
                else: raise ValueError("Konfiguracja wymaga 'trusted_connection=yes' lub 'user' i 'password'.")
            return pyodbc.connect(cs)
        raise ValueError(f"Nieobsługiwany silnik bazy: {db_config.get('engine')}")

def get_modifier_id():
    username = getpass.getuser()
    try:
        conn = DatabaseConnector.get_connection()
        cursor = conn.cursor()
        cursor.execute(f"SELECT * FROM {SQL_OBJECTS['fn_getuserappinfo']}(?)", username)
        res = cursor.fetchone()
        conn.close()
        return (res[0], res[1], res[2], bool(res[3]), res[4]) if res and len(res) >= 5 else ("System", username, "Użytkownik", False, None)
    except Exception as e:
        log_error(f"Błąd pobierania info o użytkowniku ({username}): {e}", exception=e)
        return "System", username, "Użytkownik", False, None

def load_all_app_settings():
    """Ładuje wszystkie ustawienia z tabeli appsettings i zapisuje w globalnym obiekcie."""
    try:
        conn = DatabaseConnector.get_connection()
        cursor = conn.cursor()
        cursor.execute(f"SELECT SettingKey, SettingValue FROM {SQL_OBJECTS['appsettings']}")
        results = cursor.fetchall()
        conn.close()
        if not results:
            log_error("Błąd krytyczny: Tabela [appsettings] jest pusta lub nie istnieje.")
            return False
        for row in results:
            if row.SettingKey and row.SettingValue:
                app_settings.parse_and_apply(row.SettingKey, row.SettingValue)
        debug_print("Pomyślnie załadowano ustawienia aplikacji z bazy danych.")
        return True
    except Exception as e:
        log_error(f"Błąd krytyczny podczas ładowania ustawień aplikacji: {e}", exception=e)
        return False

def check_application_version():
    """Zwraca załadowane wartości dla kompatybilności."""
    return {'required_version': app_settings.REQUIRED_VERSION, 'force_update': app_settings.FORCE_UPDATE}
