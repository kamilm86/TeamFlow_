import sys
import time
from collections import defaultdict
from datetime import datetime, timedelta, date
from typing import List, Dict, Optional, Tuple, Any 
from PySide6.QtWidgets import (QApplication, QMainWindow, QTableWidget, QTableWidgetItem, QTableView, QItemDelegate,
                              QVBoxLayout, QHBoxLayout, QWidget, QLabel, QComboBox, QCompleter,
                              QPushButton, QHeaderView, QAbstractItemView, QListWidget,
                              QListWidgetItem, QLineEdit, QDialog, QCheckBox, QFrame, QDateEdit,
                              QFormLayout, QDialogButtonBox, QMessageBox, QSplitter, QStyledItemDelegate, QStyle,
                              QGridLayout, QSizePolicy, QTableWidgetSelectionRange)
from PySide6.QtCore import Qt, QThread, Signal, QDate, QTimer, QPoint, QModelIndex, QRect, QEvent, QItemSelectionModel, QAbstractTableModel, QObject
from PySide6.QtGui import QShortcut, QKeySequence, QFont, QColor, QIcon, QPixmap, QPainter, QPolygon, QBrush, QPen, QLinearGradient, QRadialGradient, QStandardItem, QStandardItemModel

from db_connector import DatabaseConnector, get_modifier_id
from settings_dialog import AppSettingsDialog
from schedule_edit_dialogs import InsertSymbolDialog, ScheduleChangeDialog
from settings_db import SettingsDatabase
from data_provider import DataProvider
from styles import AppStyles
from progress_dialog import LoadingProgressDialog, show_loading_dialog_async
from column_select_dialog import ColumnSelectDialog
from column_definitions import ColumnDefinitions

from schedule_model import ScheduleTableModel
from events_model import EventsTableModel
from split_table_view import SplitTableView
from schedule_delegates import OvertimeItemDelegate
from events_delegates import ButtonDelegate
from staffing_details_window import StaffingDetailsWindow

# POPRAWKA: Dodaj import funkcji debug
from debug_utils import debug_print, log_warning, log_error, setup_logging, close_log_file

from symbol_parser import parse_symbol, build_symbol, get_symbol_description
import atexit

# Konfiguracja logowania - dostosuj wed≈Çug potrzeb
def configure_logging():
    """Konfiguruje system logowania aplikacji"""
    setup_logging(
        log_to_file=True,           # Zapisuj do pliku
        log_to_console=True,        # Wy≈õwietlaj w konsoli
        log_file_path=None,         # Automatyczna ≈õcie≈ºka (logs/teamflow_YYYY-MM-DD.log)
        max_file_size=10*1024*1024, # 10MB maksymalny rozmiar pliku
        max_files=5                 # Maksymalnie 5 plik√≥w archiwanych
    )
    
    # Automatyczne zamkniƒôcie pliku log√≥w przy wyj≈õciu z aplikacji
    atexit.register(close_log_file)

# Wywo≈Çaj konfiguracjƒô na poczƒÖtku
configure_logging()


class ScheduleKeyboardFilter(QObject):
    """
    Dedykowany filtr zdarze≈Ñ klawiatury dla tabeli grafiku
    z obs≈ÇugƒÖ dwucyfrowych godzin
    """

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window

        # NOWE: Bufor dla dwucyfrowych godzin
        self._digit_buffer = ""
        self._buffer_timer = QTimer()
        self._buffer_timer.setSingleShot(True)
        self._buffer_timer.timeout.connect(self._clear_buffer)
        self._buffer_timeout = 1500  # 1.5 sekundy na wpisanie drugiej cyfry

        # Bufor dla symboli znakowych
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1500

    def eventFilter(self, obj, event):
        """
        Filtr zdarze≈Ñ dla edycji klawiatury kom√≥rek grafiku z obs≈ÇugƒÖ:
        - dwucyfrowych godzin (dla r√≥l "Pracownik WPR" i "Lider OUT")
        - symboli specjalnych (tylko dla roli "Pracownik WPR")
        """
        # 1. Sprawdzamy, czy zdarzenie dotyczy wci≈õniƒôcia klawisza w tabeli grafiku
        if not (hasattr(self.main_window, 'table') and
                hasattr(self.main_window.table, 'schedule_view') and
                obj == self.main_window.table.schedule_view and
                event.type() == QEvent.KeyPress):
            return False  # To nie jest zdarzenie dla nas, przeka≈º dalej

        key = event.key()
        role = self.main_window.current_user_role

        # 2. Sprawdzamy uprawnienia w zale≈ºno≈õci od wci≈õniƒôtego klawisza
        can_edit_hours = role in ["Pracownik WPR", "Lider OUT"]
        can_edit_symbols = role == "Pracownik WPR"

        is_digit_key = (Qt.Key_0 <= key <= Qt.Key_9)
        is_char_key = (Qt.Key_A <= key <= Qt.Key_Z)
        is_delete_key = key in [Qt.Key_Delete, Qt.Key_Backspace]
        is_escape_key = key == Qt.Key_Escape

        # Zablokuj akcjƒô, je≈õli u≈ºytkownik nie ma odpowiednich uprawnie≈Ñ
        if (is_digit_key and not can_edit_hours) or \
                (is_char_key and not can_edit_symbols) or \
                (is_delete_key and not can_edit_hours):
            return True  # Zablokuj zdarzenie (zjedz je)

        # 3. Sprawdzamy, czy zaznaczone kom√≥rki sƒÖ edytowalne (dla akcji modyfikujƒÖcych)
        if is_digit_key or is_char_key or is_delete_key:
            if not self._validate_selected_cells():
                return True  # Zablokuj, je≈õli kom√≥rki sƒÖ nieedytowalne

        # 4. Obs≈Çuga zdarzenia w zale≈ºno≈õci od klawisza
        if is_digit_key:
            digit = key - Qt.Key_0
            self._handle_digit_input(digit)
            return True

        if is_char_key:
            self._handle_char_input(event.text())
            return True

        if is_delete_key:
            self.main_window.clear_selected_cells()
            self._clear_buffer()  # Wyczy≈õƒá bufor cyfr
            # Upewnij siƒô, ≈ºe masz metodƒô do czyszczenia bufora znak√≥w
            if hasattr(self, '_char_buffer'):
                self._char_buffer = ""
                self._char_buffer_timer.stop()
            return True

        if is_escape_key:
            self._clear_buffer_silent()
            # Upewnij siƒô, ≈ºe masz metodƒô do cichego czyszczenia bufora znak√≥w
            if hasattr(self, '_char_buffer'):
                self._char_buffer = ""
                self._char_buffer_timer.stop()
            if hasattr(self.main_window.table, 'schedule_view'):
                self.main_window.table.schedule_view.clearSelection()
            return True

        # 5. Blokowanie pozosta≈Çych, nieobs≈Çugiwanych klawiszy
        if key in [Qt.Key_Space, Qt.Key_Enter, Qt.Key_Return, Qt.Key_Tab]:
            return True

        # 6. Przeka≈º dalej wszystkie inne, nieobs≈Çu≈ºone zdarzenia
        return False

    def _handle_char_input(self, char: str):
        """Obs≈Çuguje wprowadzanie znak√≥w do bufora symbolu."""
        # Wyczy≈õƒá bufor cyfr, aby uniknƒÖƒá konfliktu
        if self._digit_buffer:
            self._clear_buffer()

        self._char_buffer += char.upper()
        debug_print(f"Wprowadzono znak: {char}, bufor symbolu: '{self._char_buffer}'")

        # Ustaw status bar w g≈Ç√≥wnym oknie
        self.main_window.statusBar().showMessage(f"Wpisywanie symbolu: {self._char_buffer}", 2000)

        # Je≈õli osiƒÖgniƒôto 3 znaki, przetwarzaj od razu
        if len(self._char_buffer) >= 3:
            self._char_buffer_timer.stop()
            self._process_char_buffer()
        else:
            # W przeciwnym razie, zresetuj timer i czekaj na kolejny znak
            self._char_buffer_timer.start(self._char_buffer_timeout)

    def _process_char_buffer(self):
        """Przetwarza wpisany symbol, waliduje go i wywo≈Çuje akcjƒô w g≈Ç√≥wnym oknie."""
        symbol = self._char_buffer
        self._char_buffer = ""  # Zawsze czy≈õƒá bufor po przetworzeniu

        if not symbol:
            return

        # Pobierz listƒô dozwolonych symboli
        valid_symbols = self.main_window.get_all_valid_symbols()

        if symbol in valid_symbols:
            self.main_window.statusBar().showMessage(f"Symbol '{symbol}' jest prawid≈Çowy. Zatwierd≈∫ zmiany.", 3000)
            # Wywo≈Çaj metodƒô w g≈Ç√≥wnym oknie, kt√≥ra poka≈ºe dialog potwierdzenia i zapisze zmiany
            self.main_window.apply_symbol_from_keyboard(symbol)
        else:
            self.main_window.statusBar().showMessage(f"B≈ÇƒÖd: Symbol '{symbol}' jest nieprawid≈Çowy!", 4000)
            # Opcjonalnie mo≈ºna dodaƒá QMessageBox
            QMessageBox.warning(self.main_window, "Nieprawid≈Çowy symbol",
                                f"Wpisany symbol '{symbol}' nie znajduje siƒô na li≈õcie dozwolonych.")

    def _handle_digit_input(self, digit):
        """
        POPRAWIONA METODA: Obs≈Çuguje wprowadzanie cyfr bez podw√≥jnych dialog√≥w
        """
        # Dodaj cyfrƒô do bufora
        self._digit_buffer += str(digit)

        debug_print(f"Wprowadzono cyfrƒô: {digit}, bufor: '{self._digit_buffer}'")

        # Sprawd≈∫ czy mamy kompletnƒÖ godzinƒô
        hour = None
        should_execute = False

        if len(self._digit_buffer) == 1:
            # Pierwsza cyfra - sprawd≈∫ czy to mo≈ºe byƒá jednocyfrowa godzina (0-9)
            # lub poczƒÖtek dwucyfrowej (1 lub 2)
            first_digit = int(self._digit_buffer)

            if first_digit >= 3:
                # 3-9: Na pewno jednocyfrowa godzina - wykonaj natychmiast
                hour = first_digit
                should_execute = True
                self._clear_buffer_silent()  # Wyczy≈õƒá bez wykonywania akcji
            else:
                # 0, 1, 2: Mo≈ºe byƒá jednocyfrowa lub poczƒÖtek dwucyfrowej
                # Czekaj na drugƒÖ cyfrƒô przez okre≈õlony czas
                self._buffer_timer.start(self._buffer_timeout)
                return  # Nie wykonuj jeszcze akcji

        elif len(self._digit_buffer) == 2:
            # Druga cyfra - zatrzymaj timer i sprawd≈∫ czy tworzy prawid≈ÇowƒÖ godzinƒô
            self._buffer_timer.stop()  # KLUCZOWE: Zatrzymaj timer!

            potential_hour = int(self._digit_buffer)

            if 0 <= potential_hour <= 23:
                hour = potential_hour
            else:
                # Nieprawid≈Çowa godzina - u≈ºyj tylko pierwszƒÖ cyfrƒô
                hour = int(self._digit_buffer[0])

            should_execute = True
            self._clear_buffer_silent()  # Wyczy≈õƒá bez wykonywania akcji

        else:
            # Bufor za d≈Çugi - wyczy≈õƒá i u≈ºyj ostatniƒÖ cyfrƒô
            self._buffer_timer.stop()  # Zatrzymaj timer
            hour = digit
            should_execute = True
            self._clear_buffer_silent()

        # Wykonaj akcjƒô tylko je≈õli powinni≈õmy
        if should_execute and hour is not None:
            debug_print(f"Wykonujƒô edycjƒô dla godziny: {hour}")
            self.main_window.quick_edit_selected_cells(hour)

    def _clear_buffer_silent(self):
        """
        NOWA METODA: Czy≈õci bufor bez wykonywania akcji
        """
        self._digit_buffer = ""
        if self._buffer_timer.isActive():
            self._buffer_timer.stop()

    def _clear_buffer(self):
        """
        POPRAWIONA METODA: Czy≈õci bufor cyfr (wywo≈Çywana przez timer)
        """
        if self._digit_buffer:
            # Timer wygas≈Ç - u≈ºyj pierwszƒÖ cyfrƒô z bufora
            hour = int(self._digit_buffer[0])
            debug_print(f"Timeout bufora - u≈ºywam pierwszƒÖ cyfrƒô: {hour}")

            # Wyczy≈õƒá bufor PRZED wykonaniem akcji
            self._digit_buffer = ""
            self._buffer_timer.stop()

            # Wykonaj akcjƒô
            self.main_window.quick_edit_selected_cells(hour)
        else:
            # Bufor pusty - po prostu wyczy≈õƒá
            self._digit_buffer = ""
            self._buffer_timer.stop()

    def _validate_selected_cells(self):
        """
        Sprawdza czy zaznaczone kom√≥rki mo≈ºna edytowaƒá
        (zachowana bez zmian)
        """
        try:
            # Pobierz zaznaczone kom√≥rki
            selected_cells_data = self.main_window.table.get_data_for_selected_cells()

            if not selected_cells_data:
                return False

            editable_cells = 0
            invalid_cells = []

            for cell_data in selected_cells_data:
                if not isinstance(cell_data, dict):
                    continue

                # Sprawd≈∫ czy to kom√≥rka grafiku (ma date_str i uzytkownik_id)
                if 'date_str' not in cell_data or 'uzytkownik_id' not in cell_data:
                    continue

                # Sprawd≈∫ czy kom√≥rka nie jest zablokowana
                user_name = cell_data.get('uzytkownik_dane', 'Nieznany')
                date_str = cell_data.get('date_str', '')

                # Sformatuj datƒô dla czytelno≈õci
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str

                # Sprawd≈∫ warunki edytowalno≈õci
                is_valid = self._is_cell_editable(cell_data)

                if is_valid:
                    editable_cells += 1
                else:
                    invalid_cells.append(f"{user_name} - {formatted_date}")

            # Je≈õli sƒÖ niejedytowalne kom√≥rki, poka≈º komunikat
            if invalid_cells and editable_cells == 0:
                # Wszystkie kom√≥rki sƒÖ nieedytowalne
                QMessageBox.warning(
                    self.main_window,
                    "Kom√≥rki nieedytowalne",
                    f"Wybrane kom√≥rki nie mogƒÖ byƒá edytowane z klawiatury:\n\n" +
                    "\n".join(invalid_cells[:10]) +  # Poka≈º max 10 przyk≈Çad√≥w
                    (f"\n... i {len(invalid_cells) - 10} wiƒôcej" if len(invalid_cells) > 10 else ""),
                    QMessageBox.Ok
                )
                return False

            elif invalid_cells and editable_cells > 0:
                # Czƒô≈õciowo edytowalne
                QMessageBox.information(
                    self.main_window,
                    "Czƒô≈õciowa edycja",
                    f"Edycja zostanie zastosowana tylko do {editable_cells} edytowalnych kom√≥rek.\n\n" +
                    f"Pomijane kom√≥rki ({len(invalid_cells)}):\n" +
                    "\n".join(invalid_cells[:5]) +  # Poka≈º max 5 przyk≈Çad√≥w
                    (f"\n... i {len(invalid_cells) - 5} wiƒôcej" if len(invalid_cells) > 5 else ""),
                    QMessageBox.Ok
                )
                return True

            return editable_cells > 0

        except Exception as e:
            debug_print(f"B≈ÇƒÖd walidacji kom√≥rek: {e}")
            return False

    def _is_cell_editable(self, cell_data):
        """
        Sprawdza czy pojedyncza kom√≥rka mo≈ºe byƒá edytowana
        (zachowana bez zmian)
        """
        try:
            # Sprawd≈∫ czy kom√≥rka ma wymagane dane
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')

            if not user_id or not date_str:
                return False

            # Sprawd≈∫ czy u≈ºytkownik istnieje w active data
            if not str(user_id).isdigit():
                return False

            # Wszystkie sprawdzenia przesz≈Çy
            return True

        except Exception as e:
            debug_print(f"B≈ÇƒÖd sprawdzania edytowalno≈õci kom√≥rki: {e}")
            return False


class CustomMultiComboBox(QComboBox):
    """Niestandardowy ComboBox z obs≈ÇugƒÖ wielokrotnego wyboru (wersja poprawiona)."""
    selection_changed = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)

        self._selected_items = set()
        self._select_all_text = "-Wszystkie-"

        # Konfiguracja modelu
        self.setModel(QStandardItemModel(self))

        # Konfiguracja wyglƒÖdu
        self.setEditable(True)
        self.lineEdit().setReadOnly(True)
        self.setEditText("-Wszystkie-")
        self.setSizeAdjustPolicy(QComboBox.AdjustToContents)

        # U≈ºywamy filtra zdarze≈Ñ do przechwytywania klikniƒôƒá, co zapobiega zamykaniu listy
        self.view().viewport().installEventFilter(self)
        self.lineEdit().installEventFilter(self)

        # Delegat jest potrzebny do poprawnego renderowania
        self.setItemDelegate(QStyledItemDelegate(self))

    def eventFilter(self, obj, event):
        # Przechwytujemy klikniƒôcie myszƒÖ w polu tekstowym, aby pokazaƒá listƒô
        if obj == self.lineEdit() and event.type() == QEvent.MouseButtonPress:
            self.showPopup()
            return True

        # Przechwytujemy zwolnienie przycisku myszy na li≈õcie (widoku)
        if obj == self.view().viewport() and event.type() == QEvent.MouseButtonRelease:
            index = self.view().indexAt(event.position().toPoint())  # U≈ºyj .position().toPoint() zamiast .pos()
            if index.isValid():
                self.handle_item_pressed(index)
            return True

        return False

    def handle_item_pressed(self, index):
        """Logika zaznaczania/odznaczania elementu."""
        item = self.model().itemFromIndex(index)
        if not item:
            return

        if item.text() == self._select_all_text:
            # Logika dla przycisku "Zaznacz wszystkie"
            is_checked = (item.checkState() == Qt.Checked)
            new_state = Qt.Unchecked if is_checked else Qt.Checked
            for i in range(1, self.model().rowCount()):
                self.model().item(i).setCheckState(new_state)
        else:
            # Logika dla zwyk≈Çego elementu
            current_state = item.checkState()
            item.setCheckState(Qt.Checked if current_state == Qt.Unchecked else Qt.Unchecked)

        self._rebuild_selected_items()
        self.update_display_text()

        self.selection_changed.emit()

    def _rebuild_selected_items(self):
        """Przebudowuje zbi√≥r zaznaczonych element√≥w na podstawie stanu modelu."""
        self._selected_items.clear()
        all_selected = True
        # Pƒôtla od 1, aby pominƒÖƒá element "Zaznacz wszystkie"
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.checkState() == Qt.Checked:
                self._selected_items.add(item.text())
            else:
                all_selected = False

        # Aktualizuj stan checkboxa "Zaznacz wszystkie"
        if self.model().rowCount() > 0:
            select_all_item = self.model().item(0)
            select_all_item.setCheckState(Qt.Checked if all_selected else Qt.Unchecked)

    def hidePopup(self):
        """Aktualizuje tekst po zamkniƒôciu listy."""
        self.update_display_text()
        super().hidePopup()

    def add_items(self, items):
        """Dodaje elementy do ComboBoxa."""
        self.clear()

        select_all_item = QStandardItem(self._select_all_text)
        select_all_item.setCheckable(True)
        self.model().appendRow(select_all_item)

        for item_text in sorted(items):
            item = QStandardItem(item_text)
            item.setCheckable(True)
            self.model().appendRow(item)

        self.update_display_text()

    def showPopup(self):
        """Poka≈º menu rozwijane z dostosowanƒÖ szeroko≈õciƒÖ."""
        super().showPopup()  # Najpierw poka≈º listƒô, aby mo≈ºna by≈Ço obliczyƒá jej wymiary

        # Oblicz wymaganƒÖ szeroko≈õƒá na podstawie najd≈Çu≈ºszego elementu
        width = self.view().sizeHintForColumn(0) + 20  # +20 na margines i pasek przewijania

        # OPCJA 1: Ustawienie nowego, wiƒôkszego limitu szeroko≈õci
        # Zwiƒôksz limit z 250 do np. 450 pikseli. Mo≈ºna tu wpisaƒá innƒÖ warto≈õƒá.
        width = min(width, 450)

        # OPCJA 2: Ca≈Çkowite usuniƒôcie limitu (odkomentuj poni≈ºszƒÖ liniƒô i zakomentuj powy≈ºszƒÖ)
        # W tej opcji lista bƒôdzie tak szeroka, jak najd≈Çu≈ºszy element.
        # pass # Nie r√≥b nic, aby nie ograniczaƒá szeroko≈õci

        # Ustaw obliczonƒÖ minimalnƒÖ szeroko≈õƒá dla widoku listy
        self.view().setMinimumWidth(width)

    def clear(self):
        """Czy≈õci listƒô element√≥w."""
        self.model().clear()
        self._selected_items.clear()
        self.setEditText("-Wszystkie-")

    def clear_selection(self):
        """Czy≈õci zaznaczenie wszystkich element√≥w."""
        for i in range(self.model().rowCount()):
            self.model().item(i).setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()

    def get_selected_items(self):
        """Zwraca listƒô zaznaczonych element√≥w."""
        return list(self._selected_items)

    def select_items(self, items_to_select):
        """Zaznacza programowo okre≈õlone elementy na li≈õcie."""
        lookup = set(items_to_select)
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.text() in lookup:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()

    def update_display_text(self):
        """Aktualizuje tekst wy≈õwietlany w comboboxie."""
        if not self._selected_items:
            self.setEditText("-Wszystkie-")
        elif len(self._selected_items) == (self.model().rowCount() - 1):
            self.setEditText("-Wszystkie-")
        else:
            self.setEditText(f"Wybrano {len(self._selected_items)} z {self.model().rowCount() - 1}")

class OvertimeItemDelegate(QStyledItemDelegate):
    """
    Niestandardowy delegat do rysowania kom√≥rek tabeli.
    Wy≈õwietla subtelne znaczniki w prawym dolnym rogu:
    - Czerwony tr√≥jkƒÖt dla nadgodzin
    - Bia≈Çe k√≥≈Çko dla spotka≈Ñ/szkole≈Ñ

    Zoptymalizowana wersja, kt√≥ra korzysta z dedykowanych flag zamiast deserializacji JSON.
    """

    def paint(self, painter, option, index):
        """
        Maluje kom√≥rkƒô z dodatkowymi ikonami dla nadgodzin, spotka≈Ñ i szkole≈Ñ.
        Bezpieczna wersja z obs≈ÇugƒÖ wszystkich typ√≥w danych.
        """
        try:
            # Najpierw spr√≥buj narysowaƒá standardowƒÖ kom√≥rkƒô
            super().paint(painter, option, index)

            # Bezpieczne pobieranie flag - u≈ºywaj metody get() lub defaultowego konwertowania na bool
            from schedule_model import ROLE_HAS_MEETING, ROLE_HAS_OVERTIME
            has_overtime = bool(index.data(ROLE_HAS_OVERTIME))
            has_meeting_or_training = bool(index.data(ROLE_HAS_MEETING))

            # Je≈õli element ma jakiekolwiek oznaczenia
            if has_overtime or has_meeting_or_training:
                painter.save()
                # W≈ÇƒÖcz antyaliasing dla g≈Çadkich krawƒôdzi
                painter.setRenderHint(QPainter.Antialiasing)

                # Okre≈õl szeroko≈õƒá i pozycjƒô znacznik√≥w
                marker_width = 8  # Rozmiar znacznika
                marker_height = 8

                # Rysuj znacznik spotka≈Ñ/szkole≈Ñ (bia≈Çe k√≥≈Çko) w g√≥rnym prawym rogu
                if has_meeting_or_training:
                    # Oblicz pozycjƒô w g√≥rnym prawym rogu
                    top_right_x = option.rect.right() - marker_width - 2  # -2 to margines
                    top_right_y = option.rect.top() + 2  # +2 to margines

                    # Rysujemy k√≥≈Çko z bia≈Çym wype≈Çnieniem i czarnƒÖ obw√≥dkƒÖ
                    painter.setBrush(QBrush(QColor(255, 255, 255, 240)))  # Bia≈Çe wype≈Çnienie
                    painter.setPen(QPen(QColor(0, 0, 0, 220), 1.0))  # Czarna obw√≥dka
                    painter.drawEllipse(
                        top_right_x,
                        top_right_y,
                        marker_width,
                        marker_height
                    )

                # Rysuj znacznik nadgodzin (czerwony tr√≥jkƒÖt) w dolnym prawym rogu
                if has_overtime:
                    # Oblicz pozycjƒô w dolnym prawym rogu
                    bottom_right_x = option.rect.right() - marker_width - 2  # -2 to margines
                    bottom_right_y = option.rect.bottom() - marker_height - 2  # -2 to margines

                    # Czerwony tr√≥jkƒÖt z czarnƒÖ obw√≥dkƒÖ
                    painter.setBrush(QBrush(QColor(220, 0, 0, 220)))  # Czerwone wype≈Çnienie
                    painter.setPen(QPen(Qt.black, 1.0))  # Czarna obw√≥dka

                    triangle = QPolygon()
                    triangle.append(QPoint(bottom_right_x, bottom_right_y + marker_height))
                    triangle.append(QPoint(bottom_right_x + marker_width, bottom_right_y + marker_height))
                    triangle.append(QPoint(bottom_right_x + marker_width, bottom_right_y))
                    painter.drawPolygon(triangle)

                painter.restore()
        except Exception as e:
            # W przypadku b≈Çƒôdu po prostu wy≈õwietl domy≈õlny wyglƒÖd kom√≥rki
            log_error(f"B≈ÇƒÖd podczas rysowania delegata: {e}")
            QStyledItemDelegate.paint(self, painter, option, index)

class WorkScheduleWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # --- SEKCJA 1: Wstƒôpna konfiguracja i wczytanie ustawie≈Ñ ---
        self.staffing_details_win = None
        self.settings_db = SettingsDatabase()
        user_settings = self.settings_db.load_settings()

        self.is_dark_theme = user_settings.get('theme') == 'dark'
        self.current_font = user_settings.get('font_family')
        self.current_font_size = user_settings.get('font_size')
        self.import_grupa = user_settings.get('import_grupa', 3)
        self.import_funkcja = user_settings.get('import_funkcja', 1)
        self.show_comment_column = user_settings.get('show_schedule_comment', False)
        self.can_see_next_month = False

        from data_provider import DataProvider
        self.data_provider = DataProvider()
        self.statusBar().showMessage("Gotowy")

        self.column_definitions = ColumnDefinitions()
        self.employee_columns = self.column_definitions.get_ui_display_columns()
        self.default_visible_columns = self.column_definitions.DEFAULT_VISIBLE_COLUMNS
        saved_columns = user_settings.get('visible_columns')
        self.visible_columns = saved_columns if saved_columns else self.default_visible_columns.copy()

        self.data_provider.data_changed.connect(self.on_data_changed)
        self.setWindowTitle("TeamFlowApp")
        self.setGeometry(100, 100, 1600, 800)  # Zwiƒôkszono domy≈õlny rozmiar okna

        self.left_panel_visible = True
        self._updating_selection = False
        self._cross_filtering_enabled = True

        self.raw_data = []
        self.processed_data = {}
        self.last_modification_date = None
        self.all_events_data = []
        self.user_info_map = {}

        self._selection_timer = QTimer()
        self._selection_timer.setSingleShot(True)
        self._selection_timer.timeout.connect(self._handle_selection_change)

        # --- SEKCJA 2: Budowa UI i sprawdzenie uprawnie≈Ñ ---
        font = QFont(self.current_font, self.current_font_size)
        QApplication.setFont(font)

        # Tworzy wszystkie wid≈ºety, ale jeszcze nie pod≈ÇƒÖcza sygna≈Çu do date_combo
        self.setup_ui()

        # Pobiera rolƒô i uprawnienia u≈ºytkownika
        if not self.check_user_permissions():
            return

        # --- SEKCJA 3: Tworzenie modeli i ≈ÇƒÖczenie z UI ---
        self.schedule_model = ScheduleTableModel(self, user_role=self.current_user_role)
        self.events_model = EventsTableModel(self)

        self.schedule_model.set_visible_columns(self.visible_columns)
        self.schedule_model.set_show_comment_column(self.show_comment_column)
        self.schedule_model.set_theme(self.is_dark_theme)
        self.events_model.set_theme(self.is_dark_theme)

        self.table.set_model(self.schedule_model)
        self.events_table.setModel(self.events_model)

        # Konfiguracja delegat√≥w
        overtime_delegate = OvertimeItemDelegate()
        self.table.schedule_view.setItemDelegate(overtime_delegate)
        button_delegate = ButtonDelegate(parent=self, button_text="Usu≈Ñ", is_dark_theme=self.is_dark_theme)
        self.events_table.setItemDelegateForColumn(9, button_delegate)
        button_delegate.button_clicked.connect(self.delete_event_from_row)

        # --- SEKCJA 4: Za≈Çadowanie DANYCH TYLKO RAZ ---
        self.setup_keyboard_editing()
        self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font, self.current_font_size)

        # Wype≈Çniamy listƒô miesiƒôcy (teraz, gdy uprawnienia sƒÖ znane)
        self.setup_date_combo()

        # ≈Åadujemy dane dla miesiƒÖca ustawionego w date_combo
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data
            self.update_data(year, month)
            self.update_filter_dates()

        self.clear_events_on_startup()

        # --- SEKCJA 5: Pod≈ÇƒÖczenie sygna≈Ç√≥w i uruchomienie timer√≥w ---
        # Dopiero teraz pod≈ÇƒÖczamy sygna≈Ç, aby reagowa≈Ç tylko na akcje u≈ºytkownika
        self.date_combo.currentIndexChanged.connect(self.on_date_combo_changed)

        self.check_timer = QTimer(self)
        self.check_timer.timeout.connect(self.check_for_new_data)
        self.check_timer.start(60000)

        # Skr√≥t F1 do prze≈ÇƒÖczania widoczno≈õci lewego panelu filtr√≥w
        self.shortcut_f1 = QShortcut(QKeySequence(Qt.Key_F1), self)
        self.shortcut_f1.activated.connect(self.toggle_left_panel)

        # Skr√≥t F2 do prze≈ÇƒÖczania widoczno≈õci dolnego panelu zdarze≈Ñ
        self.shortcut_f2 = QShortcut(QKeySequence(Qt.Key_F2), self)
        self.shortcut_f2.activated.connect(self.toggle_events_panel)
        # Skr√≥t F12 do usuwania symbolu specjalnego z kom√≥rki
        self.shortcut_f12 = QShortcut(QKeySequence(Qt.Key_F12), self)
        self.shortcut_f12.activated.connect(self.clear_special_symbol_from_selected_cells)
        self._selection_debounce_delay = 50  # 50ms delay
        # Skr√≥t F3 do wywo≈Çania okna "Wstaw zmianƒô"
        self.shortcut_f3 = QShortcut(QKeySequence(Qt.Key_F3), self)
        self.shortcut_f3.activated.connect(self.show_insert_change_dialog)

        # Skr√≥t F4 do wywo≈Çania okna "Wstaw nieobecno≈õƒá"
        self.shortcut_f4 = QShortcut(QKeySequence(Qt.Key_F4), self)
        self.shortcut_f4.activated.connect(self.show_insert_symbol_dialog)

        # Skr√≥t F5 do wywo≈Çania akcji "Odwo≈Çaj delegacje"
        self.shortcut_f5 = QShortcut(QKeySequence(Qt.Key_F5), self)
        self.shortcut_f5.activated.connect(self.cancel_delegations)

        debug_print("=== APLIKACJA TEAMFLOW URUCHOMIONA ===")
        debug_print(f"U≈ºytkownik: {self.current_user_app_id} ({self.current_user_role})")
        debug_print(f"Motyw: {'ciemny' if self.is_dark_theme else 'jasny'}")
        debug_print(f"Czcionka: {self.current_font} {self.current_font_size}pt")

    def show_staffing_details_window(self):
        # Sprawd≈∫, czy wybrany jest miesiƒÖc
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Brak danych", "Proszƒô wybraƒá miesiƒÖc, aby wy≈õwietliƒá szczeg√≥≈Çy obsady.",
                                QMessageBox.Ok)
            return

        year, month = current_data

        # Je≈õli okno ju≈º istnieje i jest widoczne, aktywuj je i zaktualizuj dane
        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            self.staffing_details_win.activateWindow()
            self.staffing_details_win.raise_()  # Upewnij siƒô, ≈ºe okno jest na wierzchu
            # Ustaw aktualny motyw przed aktualizacjƒÖ danych, na wypadek gdyby siƒô zmieni≈Ç
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.update_for_new_month_or_filters(year, month)
            debug_print(f"StaffingDetailsWindow: Aktywowano i zaktualizowano istniejƒÖce okno dla {year}-{month}.")
        else:
            # Utw√≥rz nowe okno, przekazujƒÖc siebie jako rodzica, data_provider oraz aktualny rok i miesiƒÖc
            debug_print(f"StaffingDetailsWindow: Tworzenie nowego okna dla {year}-{month}.")
            self.staffing_details_win = StaffingDetailsWindow(self, self.data_provider, year, month)
            # Ustaw motyw przed pierwszym pokazaniem
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.show()
            # Po pokazaniu, dane zostanƒÖ za≈Çadowane przez `load_and_display_data` w konstruktorze StaffingDetailsWindow
            # lub przez wywo≈Çanie `update_for_new_month_or_filters` je≈õli dane majƒÖ byƒá ≈Çadowane tylko po pokazaniu.
            # Obecna implementacja StaffingDetailsWindow ≈Çaduje dane w __init__ (poprzez load_and_display_data).

        # Je≈õli chcesz, aby dane by≈Çy ≈Çadowane/od≈õwie≈ºane za ka≈ºdym razem, gdy okno jest pokazywane (nawet je≈õli ju≈º istnia≈Ço):
        # if self.staffing_details_win:
        # self.staffing_details_win.set_current_theme(self.is_dark_theme) # Ustaw motyw
        # self.staffing_details_win.update_for_new_month_or_filters(year, month) #

    def setup_keyboard_editing(self):
        """Konfiguruje edycjƒô klawiatury dla kom√≥rek grafiku"""
        # Sprawd≈∫ czy u≈ºytkownik ma uprawnienia do edycji klawiatury
        allowed_roles = ["Pracownik WPR", "Lider OUT"]
        if not hasattr(self, 'current_user_role') or self.current_user_role not in allowed_roles:
            debug_print(
                f"Edycja klawiatury wy≈ÇƒÖczona - rola '{getattr(self, 'current_user_role', 'Brak')}' nie ma uprawnie≈Ñ.")
            return

        # Utw√≥rz dedykowany filtr klawiatury
        self.keyboard_filter = ScheduleKeyboardFilter(self)

        # Zainstaluj filtr zdarze≈Ñ dla tabeli grafiku
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            self.table.schedule_view.installEventFilter(self.keyboard_filter)
            debug_print(f"W≈ÇƒÖczono edycjƒô klawiatury dla roli: {self.current_user_role}")

    def cleanup_keyboard_filter(self):
        """Czy≈õci filtr klawiatury przy zamykaniu aplikacji"""
        if hasattr(self, 'keyboard_filter'):
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.removeEventFilter(self.keyboard_filter)
            del self.keyboard_filter
            debug_print("Wyczyszczono filtr klawiatury")

    def quick_edit_selected_cells(self, start_hour):
        """
        Szybka edycja zaznaczonych kom√≥rek z klawiatury

        Args:
            start_hour (int): Godzina rozpoczƒôcia (0-9)
        """
        try:
            # Sprawd≈∫ uprawnienia
            allowed_roles = ["Pracownik WPR", "Lider OUT"]
            if not hasattr(self, 'current_user_role') or self.current_user_role not in allowed_roles:
                debug_print("Brak uprawnie≈Ñ do edycji klawiatury")
                return

            # Pobierz zaznaczone kom√≥rki
            selected_cells_data = self.table.get_data_for_selected_cells()

            if not self._can_modify_cells(selected_cells_data):
                return

            if not selected_cells_data:
                debug_print("Brak zaznaczonych kom√≥rek do edycji")
                return

            # Filtruj tylko kom√≥rki grafiku (nie kolumny pracownik√≥w)
            schedule_cells = []
            for cell_data in selected_cells_data:
                if isinstance(cell_data, dict) and 'date_str' in cell_data and 'uzytkownik_id' in cell_data:
                    schedule_cells.append(cell_data)

            if not schedule_cells:
                debug_print("Brak kom√≥rek grafiku do edycji")
                return

            debug_print(f"Szybka edycja: {len(schedule_cells)} kom√≥rek, godzina start: {start_hour}")

            # Pogrupuj kom√≥rki dla lepszego komunikatu potwierdzenia
            grouped_changes = {}
            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                user_name = cell_data.get('uzytkownik_dane', '')
                date_str = cell_data.get('date_str')

                # Formatuj datƒô
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str

                user_key = (user_id, user_name)
                if user_key not in grouped_changes:
                    grouped_changes[user_key] = []
                grouped_changes[user_key].append(formatted_date)

            # Przygotuj komunikat potwierdzenia
            changes_info = f"Zmiana godziny rozpoczƒôcia na {start_hour}:00 dla:\n\n"
            for (user_id, user_name), dates in grouped_changes.items():
                changes_info += f"üë§ {user_name}:\n"
                dates_str = ", ".join(sorted(dates))
                changes_info += f"   üìÖ {dates_str}\n\n"

            changes_info += f"≈ÅƒÖcznie: {len(schedule_cells)} kom√≥rek"

            # Poka≈º potwierdzenie
            reply = QMessageBox.question(
                self,
                "Potwierdzenie szybkiej edycji",
                changes_info,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )

            if reply == QMessageBox.Yes:
                self._apply_quick_changes(schedule_cells, start_hour)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas szybkiej edycji: {e}")
            QMessageBox.critical(
                self,
                "B≈ÇƒÖd",
                f"WystƒÖpi≈Ç b≈ÇƒÖd podczas edycji: {str(e)}",
                QMessageBox.Ok
            )

    def _apply_quick_changes(self, schedule_cells, start_hour):
        """
        POPRAWIONA WERSJA: Stosuje nowƒÖ godzinƒô rozpoczƒôcia, konwertujƒÖc 'etat' na int.
        """
        updated_info = []

        for cell_data in schedule_cells:
            current_symbol = cell_data.get('symbol', '')

            location, work_hours, special = None, None, None

            if current_symbol and current_symbol.strip():
                parsed = parse_symbol(current_symbol)
                location = parsed.get('location')
                work_hours = parsed.get('work_hours')
                special = parsed.get('special_symbol')
            else:
                location = cell_data.get('lokalizacja_domyslna')
                work_hours = cell_data.get('etat')

            # Niezawodne sprawdzenie i konwersja na int
            try:
                # --- ZMIANA TUTAJ ---
                # Najpierw konwertujemy na float, a potem na int
                work_hours = int(float(work_hours))
            except (ValueError, TypeError):
                work_hours = 8  # Bezpieczny fallback jako int

            new_symbol = build_symbol(
                location=location,
                start_hour=start_hour,
                work_hours=work_hours,
                special_symbol=special
            )

            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
            except Exception as e:
                log_error(f"B≈ÇƒÖd wywo≈Çania procedury w _apply_quick_changes: {e}")

        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Pomy≈õlnie zaktualizowano {len(updated_info)} kom√≥rek.", 3000)

    def _show_keyboard_edit_results(self, successful_updates, failed_updates, error_messages, start_hour):
        """
        Pokazuje wyniki edycji klawiatury - uproszczone komunikaty
        """
        if successful_updates > 0:
            message = f"Pomy≈õlnie zaktualizowano {successful_updates} kom√≥rek (cyfra: {start_hour})"

            if failed_updates > 0:
                message += f"\n\n‚ö†Ô∏è {failed_updates} aktualizacji nie powiod≈Ço siƒô"
                if error_messages:
                    message += ":\n" + "\n".join(error_messages[:3])  # Poka≈º tylko 3 b≈Çƒôdy
                    if len(error_messages) > 3:
                        message += f"\n... i {len(error_messages) - 3} wiƒôcej b≈Çƒôd√≥w"

            QMessageBox.information(
                self,
                "Edycja klawiatury",
                message,
                QMessageBox.Ok
            )
        else:
            message = f"Nie uda≈Ço siƒô zaktualizowaƒá ≈ºadnej kom√≥rki (cyfra: {start_hour})"
            if error_messages:
                message += f"\n\nB≈Çƒôdy:\n" + "\n".join(error_messages[:5])

            QMessageBox.warning(
                self,
                "B≈ÇƒÖd edycji klawiatury",
                message,
                QMessageBox.Ok
            )

    def _prepare_deletion_summary_message(self, schedule_cells: list) -> str:
        """
        Przygotowuje sformatowanƒÖ wiadomo≈õƒá podsumowujƒÖcƒÖ, kt√≥re symbole zostanƒÖ usuniƒôte,
        grupujƒÖc je wed≈Çug u≈ºytkownika i dat.
        """
        if not schedule_cells:
            return "Nie wybrano ≈ºadnych kom√≥rek z symbolami do usuniƒôcia."

        grouped_deletions = {}
        # Grupowanie kom√≥rek: U≈ºytkownik -> Lista sformatowanych dat z symbolami
        for cell_data in schedule_cells:
            user_name = cell_data.get('uzytkownik_dane', 'Nieznany U≈ºytkownik')
            date_str = cell_data.get('date_str', 'Nieznana Data')
            symbol = cell_data.get('symbol', '??')  # Pobierz symbol do wy≈õwietlenia

            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except ValueError:
                formatted_date = date_str

            if user_name not in grouped_deletions:
                grouped_deletions[user_name] = []
            grouped_deletions[user_name].append(f"{formatted_date} (symbol: {symbol})")

        summary_lines = ["Czy na pewno chcesz usunƒÖƒá symbole dla nastƒôpujƒÖcych pozycji?\n"]
        for user_name, date_symbol_list in grouped_deletions.items():
            summary_lines.append(f"üë§ {user_name}:")
            # Aby uniknƒÖƒá zbyt d≈Çugich linii, mo≈ºna dzieliƒá listƒô dat
            # Na razie wy≈õwietlimy wszystkie dla danego u≈ºytkownika
            for date_with_symbol in sorted(date_symbol_list):  # Sortuj daty dla sp√≥jno≈õci
                summary_lines.append(f"   ‚Ä¢ {date_with_symbol}")
            summary_lines.append("")  # Pusta linia dla lepszej czytelno≈õci miƒôdzy u≈ºytkownikami

        summary_lines.append(f"≈ÅƒÖcznie zostanie wyczyszczonych: {len(schedule_cells)} kom√≥rek.")
        return "\n".join(summary_lines)

    def clear_selected_cells(self):
        """
        Czy≈õci symbole z zaznaczonych kom√≥rek (Delete/Backspace) z ulepszonym potwierdzeniem.
        """
        try:
            if hasattr(self, 'keyboard_filter') and hasattr(self.keyboard_filter, '_buffer_timer'):
                self.keyboard_filter._buffer_timer.stop()
                self.keyboard_filter._digit_buffer = ""

            allowed_roles = ["Pracownik WPR", "Lider OUT"]
            if not hasattr(self, 'current_user_role') or self.current_user_role not in allowed_roles:
                debug_print("Brak uprawnie≈Ñ do usuwania symboli klawiatury")
                return

            selected_cells_data = self.table.get_data_for_selected_cells()

            if not self._can_modify_cells(selected_cells_data):
                return

            if not selected_cells_data:
                debug_print("Brak zaznaczonych kom√≥rek do wyczyszczenia")
                return

            schedule_cells = []
            for cell_data in selected_cells_data:
                if isinstance(cell_data, dict) and 'date_str' in cell_data and 'uzytkownik_id' in cell_data:
                    current_symbol = cell_data.get('symbol', '')
                    if current_symbol and current_symbol.strip():
                        schedule_cells.append(cell_data)

            if not schedule_cells:
                debug_print("Brak kom√≥rek z symbolami do wyczyszczenia")
                self.statusBar().showMessage("Zaznaczone kom√≥rki sƒÖ puste lub nie zawierajƒÖ symboli do usuniƒôcia.", 3000)
                return

            # Przygotuj szczeg√≥≈Çowy komunikat potwierdzenia
            confirmation_message = self._prepare_deletion_summary_message(schedule_cells)

            # Poka≈º potwierdzenie, ustawiajƒÖc "Tak" jako domy≈õlny przycisk (reagujƒÖcy na Enter)
            reply = QMessageBox.question(
                self,
                "Potwierdzenie usuniƒôcia symboli",
                confirmation_message,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes  # Ustawia "Tak" jako domy≈õlny przycisk
            )

            if reply == QMessageBox.Yes:
                self._clear_cells_symbols(schedule_cells)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas czyszczenia kom√≥rek: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd krytyczny", f"WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd podczas pr√≥by usuniƒôcia symboli: {str(e)}")


    def _clear_cells_symbols(self, schedule_cells: list):
        """
        Usuwa symbole z podanych kom√≥rek poprzez wywo≈Çanie procedury
        p_P_ZZ_ImportZmianyNaSerwer_v3 z pustym symbolem.
        """
        successful_updates = 0
        failed_updates = 0
        error_messages = []
        affected_pairs = []  # Ta lista musi zawieraƒá krotki 3-elementowe

        debug_print(f"Rozpoczynam usuwanie symboli dla {len(schedule_cells)} kom√≥rek.")

        for cell_data in schedule_cells:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            nr_kadrowy = cell_data.get('nr_kadrowy')

            if not user_id or not date_str or not nr_kadrowy:
                failed_updates += 1
                error_detail = f"user_id={user_id}, data={date_str}, nr_kadrowy={nr_kadrowy}"
                if not nr_kadrowy:
                    error_messages.append(f"Brak numeru kadrowego dla u≈ºytkownika {user_id} w dniu {date_str}.")
                else:
                    error_messages.append(f"Niekompletne dane dla kom√≥rki: {error_detail}.")
                log_warning(f"Pominiƒôto kom√≥rkƒô z powodu niekompletnych danych: {error_detail}")
                continue

            try:
                year, month, day = date_str.split('-')
                date_obj = f"{year}-{month}-{day}"

                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy,
                    rok=int(year),
                    miesiac=int(month),
                    data=date_obj,
                    symbol=""  # Pusty symbol oznacza usuniƒôcie
                )

                if result.get('success', False):
                    successful_updates += 1
                    # --- KLUCZOWA POPRAWKA ---
                    # Dodajemy krotkƒô z 3 elementami, w tym symbolem zwrotnym z procedury.
                    # Dla usuwania, zwr√≥cony symbol powinien byƒá pustym stringiem.
                    affected_pairs.append((user_id, date_str, result.get('returned_symbol')))
                    debug_print(f"Pomy≈õlnie usuniƒôto symbol: U≈ºytkownik {user_id} ({nr_kadrowy}), Data {date_str}")
                else:
                    failed_updates += 1
                    error_msg = result.get('message', 'Nieznany b≈ÇƒÖd podczas usuwania symbolu.')
                    error_messages.append(f"Pracownik {nr_kadrowy} (dnia {date_str}): {error_msg}")
                    debug_print(f"B≈ÇƒÖd usuwania symbolu dla {nr_kadrowy} ({date_str}): {error_msg}")

            except ValueError:
                failed_updates += 1
                error_messages.append(f"{nr_kadrowy} ({date_str}): Nieprawid≈Çowy format daty.")
                log_error(f"Nieprawid≈Çowy format daty dla {nr_kadrowy}, {date_str} przy usuwaniu symbolu.")
            except Exception as e:
                failed_updates += 1
                error_messages.append(f"{nr_kadrowy} ({date_str}): B≈ÇƒÖd krytyczny - {str(e)}")
                log_error(f"Krytyczny b≈ÇƒÖd podczas usuwania symbolu dla {user_id}, {date_str}: {e}", exception=e)

        # Od≈õwie≈º dane w UI, je≈õli by≈Çy jakie≈õ udane operacje
        if successful_updates > 0 and affected_pairs:
            # Wywo≈Çanie metody od≈õwie≈ºajƒÖcej z poprawnie sformatowanymi danymi
            self._update_cells_with_new_symbols(affected_pairs)
            debug_print(f"Od≈õwie≈ºono {len(affected_pairs)} kom√≥rek po usuniƒôciu symboli.")

        # Poka≈º wyniki operacji
        self._show_clear_symbols_results(successful_updates, failed_updates, error_messages)

    def _show_clear_symbols_results(self, successful_updates: int, failed_updates: int, error_messages: list):
        """
        Wy≈õwietla u≈ºytkownikowi podsumowanie operacji usuwania symboli.
        """
        if successful_updates > 0:
            message = f"Pomy≈õlnie usuniƒôto symbole z {successful_updates} kom√≥rek."
            if failed_updates > 0:
                message += f"\n\n‚ö†Ô∏è {failed_updates} operacji usuniƒôcia symbolu nie powiod≈Ço siƒô."
                if error_messages:
                    # Formatowanie listy b≈Çƒôd√≥w dla lepszej czytelno≈õci
                    error_list_str = "\n - " + "\n - ".join(error_messages[:5])
                    message += ":" + error_list_str
                    if len(error_messages) > 5:
                        message += f"\n... i {len(error_messages) - 5} wiƒôcej b≈Çƒôd√≥w (sprawd≈∫ logi aplikacji)."

            QMessageBox.information(self, "Wyniki usuwania symboli", message, QMessageBox.Ok)
        else:  # Tylko je≈õli nie by≈Ço ≈ºadnych sukces√≥w
            message = "Nie uda≈Ço siƒô usunƒÖƒá symboli z ≈ºadnej zaznaczonej kom√≥rki."
            if error_messages:
                error_list_str = "\n - " + "\n - ".join(error_messages[:10])
                message += f"\n\nB≈Çƒôdy ({len(error_messages)}):" + error_list_str
                if len(error_messages) > 10:
                    message += f"\n... i {len(error_messages) - 10} wiƒôcej b≈Çƒôd√≥w (sprawd≈∫ logi aplikacji)."

            QMessageBox.warning(self, "B≈ÇƒÖd usuwania symboli", message, QMessageBox.Ok)

  
    def set_cell_data(self, row, col, data_dict):
        """
        Ustawia dane w kom√≥rce modelu.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny
            data_dict: S≈Çownik z danymi do zapisania

        Returns:
            bool: True je≈õli operacja siƒô powiod≈Ça, False w przeciwnym razie
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return False

        if not isinstance(data_dict, dict):
            log_error(f"B≈ÇƒÖd: data_dict nie jest s≈Çownikiem: {type(data_dict)}")
            return False

        # Utw√≥rz indeks modelu dla podanej pozycji
        index = self.schedule_model.index(row, col)
        if not index.isValid():
            return False

        # Ustaw dane w modelu
        return self.schedule_model.setData(index, data_dict, Qt.UserRole)

    def on_data_changed(self, data_type, year, month):
        """Obs≈Çuguje powiadomienie o zmianie danych z DataProvider."""
        current_data = self.date_combo.currentData()
        if not (current_data and current_data == (year, month)):
            return

        if data_type == "schedule":
            self.update_table_content()
        elif data_type == "events":
            # Po prostu od≈õwie≈ºamy tabelƒô zdarze≈Ñ, je≈õli co≈õ siƒô w nich zmieni≈Ço
            self.on_selection_changed()
            


    def log_time(self, label, start_time):
        """Pomocnicza funkcja do logowania czasu"""
        end_time = time.time()
        elapsed = end_time - start_time
        debug_print(f"[CZAS] {label}: {elapsed:.3f} sekundy")
        return end_time

    def setup_ui(self):
        """Ustawia interfejs u≈ºytkownika"""
        # G≈Ç√≥wny widget i layout
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)

        # WA≈ªNA ZMIANA: Usuniƒôcie marginesy g√≥rnego i dolnego
        main_layout.setContentsMargins(10, 0, 10, 0)  # Lewy, G√≥rny, Prawy, Dolny
        main_layout.setSpacing(0)  # Brak odstƒôpu miƒôdzy elementami

        # Tworzenie poszczeg√≥lnych czƒô≈õci interfejsu
        top_bar = self.setup_top_bar(main_layout)

        # Dodanie g√≥rnego paska do g≈Ç√≥wnego layoutu
        main_layout.addWidget(top_bar)

        # Dodanie splittera ≈õrodkowego
        middle_splitter = self.setup_middle_section(main_layout)
        main_layout.addWidget(middle_splitter, 1)  # Dodaj z rozciƒÖganiem (waga 1)

        # Ustawienie g≈Ç√≥wnego widgetu
        self.setCentralWidget(central_widget)

        # Dodatkowe konfiguracje
        self.setup_table_properties()

        # ZMIANA: Pod≈ÇƒÖcz sygna≈Ç selection_changed dopiero po utworzeniu wszystkich komponent√≥w
        if hasattr(self, 'table'):
            # Od≈ÇƒÖcz poprzednie po≈ÇƒÖczenia je≈õli istniejƒÖ
            try:
                self.table.selection_changed.disconnect()
            except:
                pass

            # Pod≈ÇƒÖcz nowe po≈ÇƒÖczenie
            self.table.selection_changed.connect(self.on_selection_changed)

    def setup_top_bar(self, main_layout):
        """Tworzy g√≥rny pasek z przyciskami i kontrolkami"""
        top_bar_frame = QFrame()
        top_bar_frame.setFrameShape(QFrame.StyledPanel)
        top_bar_frame.setFrameShadow(QFrame.Raised)
        top_bar_frame.setFixedHeight(50)

        top_bar_layout = QHBoxLayout(top_bar_frame)
        top_bar_layout.setContentsMargins(5, 5, 5, 5)
        top_bar_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        self.toggle_menu_button = QPushButton()
        self.toggle_menu_button.setFixedSize(32, 32)
        self.toggle_menu_button.setText("‚ò∞")
        self.toggle_menu_button.setToolTip("Poka≈º/ukryj panel filtr√≥w (F1)")
        self.toggle_menu_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))  #
        self.toggle_menu_button.clicked.connect(self.toggle_left_panel)
        top_bar_layout.addWidget(self.toggle_menu_button)

        self.settings_button = QPushButton("Ustawienia")  # NOWY PRZYCISK
        self.settings_button.clicked.connect(self.show_settings_dialog)  # NOWA METODA
        self.settings_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light")) #

        date_label = QLabel("MiesiƒÖc:")
        self.date_combo = QComboBox()
        self.date_combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        self.setup_date_combo()
        # self.date_combo.currentIndexChanged.connect(self.on_date_combo_changed)

        self.refresh_button = QPushButton("Od≈õwie≈º dane")
        self.refresh_button.clicked.connect(self.refresh_data)
        self.refresh_button.setToolTip("Od≈õwie≈º dane (u≈ºywa async loading dla lepszej wydajno≈õci)")
        self.refresh_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light")) #

        self.show_audit_button = QPushButton("Historia Zmian")
        self.show_audit_button.clicked.connect(self.show_audit_log_window)
        self.show_audit_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.show_audit_button.setToolTip("Poka≈º historiƒô modyfikacji grafiku dla wybranego miesiƒÖca i filtr√≥w")

        self.staffing_details_button = QPushButton("Obsada") # Mo≈ºesz wybraƒá innƒÖ nazwƒô
        self.staffing_details_button.clicked.connect(self.show_staffing_details_window) # Po≈ÇƒÖcz z nowƒÖ metodƒÖ
        self.staffing_details_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light")) #
        self.staffing_details_button.setToolTip("Poka≈º szczeg√≥≈Çy obsady godzinowej")

        top_bar_layout.addWidget(self.settings_button)
        top_bar_layout.addWidget(date_label)
        top_bar_layout.addWidget(self.date_combo)
        top_bar_layout.addWidget(self.refresh_button)
        top_bar_layout.addWidget(self.show_audit_button)
        top_bar_layout.addWidget(self.staffing_details_button) # Dodaj nowy przycisk do layoutu
        self.schedule_control_button = QPushButton("ZarzƒÖdzaj Grafikiem")
        self.schedule_control_button.clicked.connect(self.show_schedule_control_dialog)
        self.schedule_control_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.schedule_control_button.setToolTip("Otwiera panel zarzƒÖdzania statusami, publikacjƒÖ i blokadami grafiku")
        top_bar_layout.addWidget(self.schedule_control_button)
        top_bar_layout.addStretch()

        # Nie dodawaj top_bar_frame do main_layout tutaj, je≈õli setup_ui robi to globalnie
        # main_layout.addWidget(top_bar_frame) # Zak≈ÇadajƒÖc, ≈ºe setup_ui dodaje top_bar_frame

        return top_bar_frame

    def setup_date_combo(self):
        """Konfiguruje combobox z datami, uwzglƒôdniajƒÖc uprawnienia."""
        current_date = datetime.now()
        months_to_show = []
        year, month = current_date.year, current_date.month

        # Generowanie 3 miesiƒôcy wstecz
        for i in range(3, 0, -1):
            prev_month, prev_year = (month - i, year)
            while prev_month <= 0:
                prev_month += 12
                prev_year -= 1
            months_to_show.append((prev_year, prev_month))

        # Dodaj bie≈ºƒÖcy miesiƒÖc
        months_to_show.append((year, month))

        # --- ZMIANA: Warunkowe dodawanie przysz≈Çego miesiƒÖca ---
        if self.can_see_next_month:
            next_month, next_year = (month + 1, year)
            if next_month > 12:
                next_month = 1
                next_year += 1
            months_to_show.append((next_year, next_month))
            debug_print("Dodano przysz≈Çy miesiƒÖc do listy wyboru.")

        # Zapisujemy aktualnie wybrany indeks, aby go przywr√≥ciƒá
        current_index = self.date_combo.currentIndex()
        if current_index == -1: # Je≈õli to pierwsze uruchomienie
            current_index = 3 # Domy≈õlnie bie≈ºƒÖcy miesiƒÖc

        self.date_combo.clear()
        for y, m in months_to_show:
            self.date_combo.addItem(f"{y}-{m:02d}", (y, m))

        # Przywracamy indeks, upewniajƒÖc siƒô, ≈ºe jest w zakresie
        if current_index < self.date_combo.count():
            self.date_combo.setCurrentIndex(current_index)
        else:
            # Je≈õli usunƒôli≈õmy przysz≈Çy miesiƒÖc, ustawiamy na ostatni dostƒôpny
            self.date_combo.setCurrentIndex(self.date_combo.count() - 1)

    def setup_middle_section(self, main_layout):
        """Tworzy ≈õrodkowƒÖ sekcjƒô z filtrem i tabelami"""
        # G≈Ç√≥wny kontener na ≈õrodkowƒÖ czƒô≈õƒá (filtry po lewej, tabela po prawej)
        main_splitter = QSplitter(Qt.Horizontal)

        # Ustaw politykƒô rozmiaru - aby element wype≈Çnia≈Ç dostƒôpnƒÖ przestrze≈Ñ
        main_splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Tworzenie lewego panelu filtr√≥w
        self.setup_left_panel()
        # Zapamiƒôtaj standardowƒÖ szeroko≈õƒá lewego panelu
        self.left_panel_width = 280  # Domy≈õlna szeroko≈õƒá panelu

        # Tworzenie prawego panelu z tabelami
        right_panel = self.setup_right_panel()

        # Dodaj panele do g≈Ç√≥wnego splittera
        main_splitter.addWidget(self._left_panel)
        main_splitter.addWidget(right_panel)

        # Ustaw poczƒÖtkowe proporcje dla g≈Ç√≥wnego splittera (np. 25% lewy panel, 75% prawy panel)
        main_splitter.setSizes([280, 720])

        # Zapisz referencjƒô do splittera
        self.main_splitter = main_splitter

        self.main_splitter.setStretchFactor(0, 0)  # Lewy panel (employees_view) nie jest rozciƒÖgany
        self.main_splitter.setStretchFactor(1, 1)  # Prawy panel (schedule_view) jest rozciƒÖgany

        # NIE dodawaj main_splitter do main_layout - zwr√≥ƒá go tylko
        return main_splitter

    def setup_left_panel(self):
        """Tworzy lewy panel z filtrami"""
        self._left_panel = QWidget()
        self._left_panel.setStyleSheet(AppStyles.get_left_panel_style("dark" if self.is_dark_theme else "light"))
        self._left_panel.setMinimumWidth(280)  # Zwiƒôkszamy minimalnƒÖ szeroko≈õƒá panelu
        self._left_panel.setMaximumWidth(280)  # Zwiƒôkszamy maksymalnƒÖ szeroko≈õƒá panelu

        filters_layout = QVBoxLayout(self._left_panel)
        filters_layout.setContentsMargins(10, 10, 10, 10)
        filters_layout.setSpacing(6)  # Zmniejsz odstƒôpy miƒôdzy elementami

        # Tytu≈Ç filtr√≥w
        filters_title = QLabel("Filtry")
        filters_title.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light", is_title=True))
        filters_layout.addWidget(filters_title)

        # Kolejno≈õƒá zgodnie z oznaczeniami na zdjƒôciu
        # 1. Wydzia≈Ç
        self.add_horizontal_filter("Wydzia≈Ç:", "wydzial_combo", filters_layout)

        # 2. Prze≈Ço≈ºony - pole tekstowe i lista w uk≈Çadzie pionowym
        self.add_horizontal_search_filter("Prze≈Ço≈ºony:", "przelozony_filter", filters_layout)
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)

        # Lista prze≈Ço≈ºonych
        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_list.setFixedHeight(150)
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.przelozony_list)

        # 3. U≈ºytkownik
        self.add_horizontal_search_filter("U≈ºytkownik:", "uzytkownik_filter", filters_layout)
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)

        # Lista u≈ºytkownik√≥w
        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_list.setFixedHeight(200)
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.uzytkownik_list)

        # 4. DTN
        self.add_horizontal_filter("DTN:", "dtn_combo", filters_layout)

        # 5. Etat
        self.add_horizontal_filter("Etat:", "etat_combo", filters_layout)

        # 6. Rola
        self.add_horizontal_filter("Rola:", "rola_combo", filters_layout)

        # 7. Jƒôzyk
        self.add_horizontal_filter("Jƒôzyk:", "jezyk_combo", filters_layout)

        # 8. System Czasu Pracy
        self.add_horizontal_filter("System Pracy:", "system_czasu_pracy_combo", filters_layout)

        # Przycisk wyczy≈õƒá filtry
        self.clear_filters_button = QPushButton("Wyczy≈õƒá filtry")
        self.clear_filters_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.clear_filters_button.clicked.connect(self.clear_filters)
        filters_layout.addStretch()
        filters_layout.addWidget(self.clear_filters_button)

    def add_horizontal_filter(self, label_text, combo_name, parent_layout):
        """Dodaje filtr w uk≈Çadzie poziomym (etykieta + kontrolka w jednej linii)"""
        # Uk≈Çad poziomy dla filtru
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)  # Minimalne marginesy
        filter_layout.setSpacing(4)  # Mniejszy odstƒôp

        # Etykieta
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        filter_label.setFixedWidth(80)  # Ustaw sta≈ÇƒÖ szeroko≈õƒá etykiet
        filter_layout.addWidget(filter_label)

        # Kontrolka ComboBox
        combo = CustomMultiComboBox()
        combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        combo.setFixedHeight(24)  # Ustaw wysoko≈õƒá podobnƒÖ do p√≥l tekstowych
        combo.view().setMaximumWidth(250)  # Ograniczenie szeroko≈õci rozwijanej listy
        # combo.activated.connect(self.filter_data)  # Pod≈ÇƒÖcz sygna≈Ç filtrowania
        combo.selection_changed.connect(self.filter_data)

        # Zapisz referencjƒô do kontrolki
        setattr(self, combo_name, combo)

        filter_layout.addWidget(combo, 1)  # Dodaj z rozciƒÖganiem
        parent_layout.addLayout(filter_layout)

    def add_horizontal_search_filter(self, label_text, filter_name, parent_layout):
        """Dodaje filtr wyszukiwania w uk≈Çadzie poziomym (etykieta + pole tekstowe w jednej linii)"""
        # Uk≈Çad poziomy dla filtru
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)  # Minimalne marginesy
        filter_layout.setSpacing(4)  # Mniejszy odstƒôp

        # Etykieta
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        filter_label.setFixedWidth(80)  # Ustaw sta≈ÇƒÖ szeroko≈õƒá etykiet
        filter_layout.addWidget(filter_label)

        # Pole tekstowe
        text_edit = QLineEdit()
        text_edit.setPlaceholderText(f"Filtruj {label_text.lower()[:-1]}...")
        text_edit.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        text_edit.setFixedHeight(24)  # Ustaw sta≈ÇƒÖ wysoko≈õƒá

        # Zapisz referencjƒô do kontrolki
        setattr(self, filter_name, text_edit)

        filter_layout.addWidget(text_edit, 1)  # Dodaj z rozciƒÖganiem
        parent_layout.addLayout(filter_layout)

    def setup_filter_combo(self, label_text, combo_name, parent_layout):
        """Konfiguruje filtr jako ComboBox z wielokrotnym wyborem"""
        # Etykieta filtru
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(filter_label)

        # ComboBox z wielokrotnym wyborem
        combo = CustomMultiComboBox()
        combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        combo.view().setMinimumWidth(200)  # Ustaw minimalnƒÖ szeroko≈õƒá listy rozwijanej

        # Dodaj sygna≈Ç zmiany stanu ComboBoxa
        combo.view().pressed.connect(self.filter_data)

        # Zapisz referencjƒô do ComboBoxa
        setattr(self, combo_name, combo)

        parent_layout.addWidget(combo)
        parent_layout.addSpacing(10)  # Dodaj odstƒôp miƒôdzy filtrami

    # Te metody pozostajƒÖ bez zmian, tylko przenosimy je do oddzielnych funkcji
    def setup_filter_przelozony(self, parent_layout):
        """Konfiguruje filtr prze≈Ço≈ºonego"""
        # Filtr prze≈Ço≈ºonego
        przelozony_label = QLabel("Prze≈Ço≈ºony:")
        przelozony_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(przelozony_label)

        # Lista prze≈Ço≈ºonych
        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_list.setFixedHeight(120)

        # Dodaj pole wyszukiwania dla prze≈Ço≈ºonych
        self.przelozony_filter = QLineEdit()
        self.przelozony_filter.setPlaceholderText("Filtruj prze≈Ço≈ºonych...")
        self.przelozony_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)

        parent_layout.addWidget(self.przelozony_filter)
        parent_layout.addWidget(self.przelozony_list)

        # Pod≈ÇƒÖcz sygna≈Ç zmiany filtru
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)

    def setup_filter_uzytkownik(self, parent_layout):
        """Konfiguruje filtr u≈ºytkownika"""
        # Filtr u≈ºytkownika
        uzytkownik_label = QLabel("U≈ºytkownik:")
        uzytkownik_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(uzytkownik_label)

        # Lista u≈ºytkownik√≥w
        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_list.setFixedHeight(120)

        # Dodaj pole wyszukiwania dla u≈ºytkownik√≥w
        self.uzytkownik_filter = QLineEdit()
        self.uzytkownik_filter.setPlaceholderText("Filtruj u≈ºytkownik√≥w...")
        self.uzytkownik_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)

        parent_layout.addWidget(self.uzytkownik_filter)
        parent_layout.addWidget(self.uzytkownik_list)

        # Pod≈ÇƒÖcz sygna≈Ç zmiany filtru
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)

    def setup_right_panel(self):
        """Tworzy prawy panel z tabelami"""
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)

        # Splitter pionowy dla prawego panelu (grafik | zdarzenia)
        right_splitter = QSplitter(Qt.Vertical)

        # Dodaj sekcje
        schedule_frame = self.setup_schedule_section()
        events_frame = self.setup_events_section()

        # Dodaj panele do pionowego splittera
        right_splitter.addWidget(schedule_frame)
        right_splitter.addWidget(events_frame)

        # Ustaw poczƒÖtkowe proporcje dla pionowego splittera (np. 60% grafik, 40% zdarzenia)
        right_splitter.setSizes([600, 400])

        # Dodaj pionowy splitter do layoutu prawego panelu
        right_layout.addWidget(right_splitter)

        return right_panel

    # W pliku main.py - klasa WorkScheduleWindow, metoda setup_schedule_section

    def setup_schedule_section(self):
        """
        Tworzy sekcjƒô grafiku (g√≥rna czƒô≈õƒá prawego panelu) u≈ºywajƒÖc SplitTableView
        """
        schedule_frame = QFrame()
        schedule_layout = QVBoxLayout(schedule_frame)
        schedule_layout.setContentsMargins(5, 5, 5, 5)

        # NIE INICJALIZUJ employee_columns tutaj, u≈ºyj warto≈õci z inicjalizacji klasy

        # Tworzenie i konfiguracja SplitTableView
        self.table = SplitTableView()

        # Ustaw style dla obu tabel
        self.table.employees_view.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))
        self.table.schedule_view.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))

        # Dodaj przycisk zarzƒÖdzania kolumnami do przycisk√≥w akcji
        self.manage_columns_button = QPushButton("ZarzƒÖdzaj kolumnami")
        self.manage_columns_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.manage_columns_button.clicked.connect(self.show_column_select_dialog)

        # Pod≈ÇƒÖcz sygna≈Ç zmiany zaznaczenia do aktualizacji zdarze≈Ñ
        self.table.selection_changed.connect(self.on_selection_changed)

        # Dodaj tabelƒô do layoutu
        schedule_layout.addWidget(self.table)

        # Dodaj przyciski akcji
        button_frame = self.setup_schedule_buttons()
        button_layout = button_frame.layout()

        # NOWE: Ustaw, aby panel z przyciskami zajmowa≈Ç tylko tyle miejsca, ile potrzebuje
        schedule_layout.addWidget(button_frame, 0)  # 0 = minimum stretch factor

        # Dodaj przycisk zarzƒÖdzania kolumnami do przycisk√≥w akcji
        if isinstance(button_layout, QHBoxLayout):
            button_layout.insertWidget(0, self.manage_columns_button)

        schedule_layout.addWidget(button_frame)

        return schedule_frame

    def setup_schedule_buttons(self):
        """Tworzy przyciski akcji dla sekcji grafiku"""
        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setContentsMargins(0, 0, 0, 0)

        # NOWE: Ustaw sta≈ÇƒÖ wysoko≈õƒá ramki przycisk√≥w
        button_frame.setFixedHeight(40)  # Mo≈ºesz dostosowaƒá wysoko≈õƒá wed≈Çug potrzeb

        # NOWE: Ustaw politykƒô rozmiaru, aby zapobiec rozciƒÖganiu
        button_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        # NOWO≈öƒÜ: Dodajemy przycisk do ukrywania/pokazywania panelu zdarze≈Ñ (po lewej stronie)
        self.toggle_events_panel_button = QPushButton("Ukryj zdarzenia‚Üì")
        self.toggle_events_panel_button.setToolTip(
            "Ukryj panel zdarze≈Ñ (dla wiƒôkszego widoku grafiku) (F2)")  # Dodano (F2)
        self.toggle_events_panel_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.toggle_events_panel_button.clicked.connect(self.toggle_events_panel)

        # Dodaj przycisk po lewej stronie
        button_layout.addWidget(self.toggle_events_panel_button)

        # Dodaj elastyczny odstƒôp, aby rozdzieliƒá przyciski
        button_layout.addStretch()

        # Przycisk "Wstaw zmianƒô"
        self.insert_change_button = QPushButton("Wstaw zmianƒô")
        self.insert_change_button.setToolTip("Wstaw zmianƒô grafiku (F3)")
        self.insert_change_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.insert_change_button.clicked.connect(self.show_insert_change_dialog)
        button_layout.addWidget(self.insert_change_button)

        # Przycisk "Wstaw nieobecno≈õƒá"
        self.insert_symbol_button = QPushButton("Wstaw nieobecno≈õƒá")
        self.insert_symbol_button.setToolTip("Wstaw nieobecno≈õƒá (F4)")
        self.insert_symbol_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.insert_symbol_button.clicked.connect(self.show_insert_symbol_dialog)
        button_layout.addWidget(self.insert_symbol_button)

        # Przycisk "Odwo≈Çaj delegacje"
        self.cancel_delegation_button = QPushButton("Odwo≈Çaj delegacje")
        self.cancel_delegation_button.setToolTip("Odwo≈Çaj delegacje dla zaznaczonych kom√≥rek (F5)")
        self.cancel_delegation_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.cancel_delegation_button.clicked.connect(self.cancel_delegations)
        button_layout.addWidget(self.cancel_delegation_button)

        # Przycisk "Dodaj nadgodziny"
        self.add_overtime_button = QPushButton("Dodaj nadgodziny")
        self.add_overtime_button.setShortcut("Insert")  # Skr√≥t klawiszowy Insert
        self.add_overtime_button.setToolTip("Dodaj nadgodziny dla zaznaczonych kom√≥rek (Insert)")
        self.add_overtime_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.add_overtime_button.clicked.connect(self.show_add_overtime_dialog)

        # ZMODYFIKOWANA LINIA: Zawsze dodawaj przycisk do layoutu
        button_layout.addWidget(self.add_overtime_button)

        # Ewentualnie ustaw widoczno≈õƒá przycisku na podstawie roli
        # Mo≈ºna to zrobiƒá po inicjalizacji wszystkich komponent√≥w
        if hasattr(self, 'current_user_role'):
            self.add_overtime_button.setVisible(self.current_user_role == "Pracownik WPR")
        else:
            # Domy≈õlnie widoczny, mo≈ºemy to zmieniƒá p√≥≈∫niej
            self.add_overtime_button.setVisible(True)

        return button_frame

    def setup_events_section(self):
        """
        Tworzy sekcjƒô zdarze≈Ñ u≈ºywajƒÖc QTableView zamiast QTableWidget
        """
        events_frame = QFrame()
        events_frame.setFrameShape(QFrame.StyledPanel)
        events_frame.setFrameShadow(QFrame.Raised)
        events_layout = QVBoxLayout(events_frame)
        events_layout.setContentsMargins(5, 5, 5, 5)

        # Dodaj kontrolki filtr√≥w
        filters_frame = self.setup_events_filters()
        events_layout.addWidget(filters_frame)

        # Tworzenie tabeli zdarze≈Ñ jako QTableView
        self.events_table = QTableView()
        self.events_table.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.events_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.events_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.events_table.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))

        # Dodaj tabelƒô zdarze≈Ñ do panelu
        events_layout.addWidget(self.events_table)

        return events_frame

    def setup_events_filters(self):
        """Konfiguruje filtry dla tabeli zdarze≈Ñ"""
        events_filter_frame = QFrame()
        events_filter_layout = QHBoxLayout(events_filter_frame)
        events_filter_layout.setContentsMargins(0, 0, 0, 0)

        # Filtry daty od-do
        date_from_label = QLabel("Data od:")
        self.date_from = QDateEdit()
        self.date_from.setDisplayFormat("dd.MM.yyyy")
        self.date_from.setDate(QDate.currentDate().addDays(-30))
        self.date_from.setCalendarPopup(True)
        self.date_from.setStyleSheet(AppStyles.get_date_edit_style("dark" if self.is_dark_theme else "light"))

        date_to_label = QLabel("Data do:")
        self.date_to = QDateEdit()
        self.date_to.setDisplayFormat("dd.MM.yyyy")
        self.date_to.setDate(QDate.currentDate())
        self.date_to.setCalendarPopup(True)
        self.date_to.setStyleSheet(AppStyles.get_date_edit_style("dark" if self.is_dark_theme else "light"))

        # Filtr tematu
        topic_label = QLabel("Temat:")
        self.topic_filter = QLineEdit()
        self.topic_filter.setPlaceholderText("Filtruj po temacie...")
        self.topic_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))

        # Filtr nazwy
        name_label = QLabel("Nazwa:")
        self.name_filter = QLineEdit()
        self.name_filter.setPlaceholderText("Filtruj po nazwie...")
        self.name_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))

        # Checkboxy do filtrowania typ√≥w zdarze≈Ñ
        self.meetings_checkbox = QCheckBox("Spotkania")
        self.meetings_checkbox.setChecked(True)
        self.meetings_checkbox.stateChanged.connect(self.filter_events_table)

        self.trainings_checkbox = QCheckBox("Szkolenia")
        self.trainings_checkbox.setChecked(True)
        self.trainings_checkbox.stateChanged.connect(self.filter_events_table)

        self.overtime_checkbox = QCheckBox("Nadgodziny")
        self.overtime_checkbox.setChecked(True)
        self.overtime_checkbox.stateChanged.connect(self.filter_events_table)

        # Pod≈ÇƒÖcz sygna≈Çy zmiany daty bezpo≈õrednio do filtrowania
        self.date_from.dateChanged.connect(self.filter_events_table)
        self.date_to.dateChanged.connect(self.filter_events_table)
        self.topic_filter.textChanged.connect(self.filter_events_table)
        self.name_filter.textChanged.connect(self.filter_events_table)

        # Dodaj kontrolki do layoutu filtr√≥w zdarze≈Ñ
        events_filter_layout.addWidget(date_from_label)
        events_filter_layout.addWidget(self.date_from)
        events_filter_layout.addWidget(date_to_label)
        events_filter_layout.addWidget(self.date_to)
        events_filter_layout.addWidget(topic_label)
        events_filter_layout.addWidget(self.topic_filter)
        events_filter_layout.addWidget(name_label)
        events_filter_layout.addWidget(self.name_filter)
        events_filter_layout.addWidget(self.meetings_checkbox)
        events_filter_layout.addWidget(self.trainings_checkbox)
        events_filter_layout.addWidget(self.overtime_checkbox)
        events_filter_layout.addStretch()

        return events_filter_frame

    def setup_events_table_columns(self):
        """Konfiguruje kolumny dla tabeli zdarze≈Ñ"""
        self.events_table.setColumnCount(10)
        self.events_table.setHorizontalHeaderLabels([
            "Id", "Typ", "Temat", "Nazwa", "U≈ºytkownik", "Data", "Od", "Do", "Status", "Akcje"
        ])

        # Ustaw szeroko≈õƒá kolumn
        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # U≈ºytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

    def setup_table_properties(self):
        """Konfiguruje w≈Ça≈õciwo≈õci tabel"""
        # Sortowanie
        self.events_table.setSortingEnabled(True)
        self.events_table.sortByColumn(0, Qt.AscendingOrder)

        # Dostosuj dla nowej klasy SplitTableView
        if hasattr(self.table, 'employees_view'):
            self.table.employees_view.setSortingEnabled(True)
            self.table.employees_view.sortByColumn(0, Qt.AscendingOrder)

        # Mo≈ºemy tak≈ºe zachowaƒá informacjƒô o ostatnim sortowaniu
        self.last_sort_column = 0
        self.last_sort_order = Qt.AscendingOrder

        # Pod≈ÇƒÖcz sygna≈Çy sortowania - POPRAWKA: odwo≈Çuj siƒô do konkretnego widoku
        if hasattr(self.table, 'employees_view') and hasattr(self.table.employees_view, 'horizontalHeader'):
            self.table.employees_view.horizontalHeader().sortIndicatorChanged.connect(self.on_sort_changed)

        if hasattr(self.events_table, 'horizontalHeader'):
            self.events_table.horizontalHeader().sortIndicatorChanged.connect(self.on_events_sort_changed)

        # Dodaj delegata do tabeli aby obs≈Çugiwa≈Ç niestandardowe rysowanie
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            # Dla nowej klasy SplitTableView
            self.table.schedule_view.setItemDelegate(OvertimeItemDelegate())
        elif hasattr(self, 'table'):
            # Dla starej klasy SplitTableWidget
            self.table.setItemDelegate(OvertimeItemDelegate())

    def toggle_left_panel(self):
        """Prze≈ÇƒÖcza widoczno≈õƒá lewego panelu filtr√≥w"""
        if self.left_panel_visible:
            # Ukryj panel
            self.left_panel_width = self._left_panel.width()  # Zapamiƒôtaj bie≈ºƒÖcƒÖ szeroko≈õƒá
            self._left_panel.setFixedWidth(0)
            self._left_panel.setVisible(False)  # WA≈ªNE: Ukryj panel ca≈Çkowicie
            self.left_panel_visible = False
            self.toggle_menu_button.setText("‚ò≤")  # Zmie≈Ñ ikonƒô na "poka≈º menu"
            self.toggle_menu_button.setToolTip("Poka≈º panel filtr√≥w")
        else:
            # Poka≈º panel
            self._left_panel.setVisible(True)  # WA≈ªNE: Najpierw poka≈º panel
            self._left_panel.setMinimumWidth(200)
            self._left_panel.setMaximumWidth(250)

            # Sprawd≈∫ czy mamy zapamiƒôtanƒÖ szeroko≈õƒá
            if hasattr(self, 'left_panel_width'):
                self._left_panel.setFixedWidth(self.left_panel_width)
            else:
                self._left_panel.setFixedWidth(200)  # Domy≈õlna szeroko≈õƒá

            self.left_panel_visible = True
            self.toggle_menu_button.setText("‚ò∞")  # Przywr√≥ƒá ikonƒô "burger menu"
            self.toggle_menu_button.setToolTip("Poka≈º/ukryj panel filtr√≥w (F1)")

        # DODANE: Wymu≈õ ponowne roz≈Ço≈ºenie splittera
        current_sizes = self.main_splitter.sizes()
        if not self.left_panel_visible:
            # Gdy ukrywamy panel, dajemy ca≈ÇƒÖ przestrze≈Ñ prawemu panelowi
            self.main_splitter.setSizes([0, sum(current_sizes)])
        else:
            # Gdy pokazujemy panel, przywracamy proporcje
            if hasattr(self, 'left_panel_width'):
                right_size = sum(current_sizes) - self.left_panel_width
                self.main_splitter.setSizes([self.left_panel_width, right_size])
            else:
                # Domy≈õlnie 20% - 80%
                total = sum(current_sizes)
                self.main_splitter.setSizes([int(total * 0.2), int(total * 0.8)])

        # Wymu≈õ aktualizacjƒô widoku
        self.main_splitter.update()

        # DODANE: Od≈õwie≈º uk≈Çad ca≈Çego okna
        QApplication.processEvents()
        self.update()

    def toggle_events_panel(self):
        """Prze≈ÇƒÖcza widoczno≈õƒá panelu zdarze≈Ñ (dolny panel)"""
        # Znajd≈∫ splitter, kt√≥ry organizuje uk≈Çad prawy (grafik | zdarzenia)
        right_splitter = None

        # Szukamy w rodzicu prawego panelu, kt√≥ry zawiera splitter
        for widget in self.findChildren(QSplitter):
            # Sprawd≈∫, czy to pionowy splitter zawierajƒÖcy panel zdarze≈Ñ
            if widget.orientation() == Qt.Vertical and widget.count() > 1:
                right_splitter = widget
                break

        if right_splitter:
            # Pobierz rozmiary paneli
            sizes = right_splitter.sizes()

            # Je≈õli panel zdarze≈Ñ jest widoczny, ukryj go
            if sizes[1] > 0:
                # Zapisz obecny rozmiar panelu zdarze≈Ñ przed ukryciem
                self.events_panel_size = sizes[1]

                # Ustaw nowe rozmiary - ca≈Ça przestrze≈Ñ dla grafiku, 0 dla zdarze≈Ñ
                right_splitter.setSizes([sizes[0] + sizes[1], 0])

                # Zmie≈Ñ tekst przycisku
                self.toggle_events_panel_button.setText("Poka≈º zdarzenia‚Üë")
                self.toggle_events_panel_button.setToolTip("Poka≈º panel zdarze≈Ñ‚Üë (F2)")
            else:
                # Je≈õli panel zdarze≈Ñ jest ukryty, poka≈º go
                # U≈ºyj zapisanego wcze≈õniej rozmiaru lub domy≈õlnego (300)
                events_size = getattr(self, 'events_panel_size', 300)

                # Oblicz nowy rozmiar dla panelu grafiku
                schedule_size = sizes[0] - events_size
                if schedule_size < 200:  # Minimalny rozmiar dla grafiku
                    schedule_size = 200
                    events_size = sizes[0] - schedule_size

                # Ustaw nowe rozmiary
                right_splitter.setSizes([schedule_size, events_size])

                # Zmie≈Ñ tekst przycisku
                self.toggle_events_panel_button.setText("Ukryj zdarzenia‚Üì")
                self.toggle_events_panel_button.setToolTip("Ukryj panel zdarze≈Ñ (dla wiƒôkszego widoku grafiku)")

    def show_column_select_dialog(self):
        """Wy≈õwietla dialog wyboru kolumn, obs≈ÇugujƒÖc nowƒÖ opcjƒô komentarza."""
        try:
            if not hasattr(self, 'schedule_model'):
                QMessageBox.warning(self, "B≈ÇƒÖd", "Model danych nie jest zainicjalizowany.", QMessageBox.Ok)
                return

            dialog = ColumnSelectDialog(
                self,
                self.employee_columns,
                self.visible_columns,
                self.default_visible_columns,
                user_role=self.current_user_role,
                is_comment_column_checked=self.show_comment_column
            )

            if dialog.exec() == QDialog.Accepted:
                selected_columns = dialog.get_selected_columns()

                # U≈ºywamy nowej, poprawnej nazwy metody
                self.show_comment_column = dialog.get_comment_column_state()

                self.schedule_model.set_visible_columns(selected_columns)
                self.schedule_model.set_show_comment_column(self.show_comment_column)

                self.visible_columns = selected_columns

                # Zapisujemy wszystkie ustawienia do bazy
                self.settings_db.save_settings(
                    "dark" if self.is_dark_theme else "light",
                    self.current_font,
                    self.current_font_size,
                    getattr(self, 'load_all_events', True),
                    selected_columns,
                    self.show_comment_column
                )
                debug_print(
                    f"Zapisano ustawienia: widoczne kolumny={selected_columns}, poka≈º komentarz={self.show_comment_column}")

                self.refresh_column_configuration()
                if hasattr(self, 'table'):
                    self.table.set_model(self.schedule_model)
                    self.table.adjust_employees_table_width()
                    self._set_schedule_columns_width()

        except Exception as e:
            log_error(f"B≈ÇƒÖd w show_column_select_dialog: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas zmiany kolumn: {str(e)}", QMessageBox.Ok)

    def _set_schedule_columns_width(self):
        """
        OSTATECZNA, POPRAWIONA WERSJA: Ustawia szeroko≈õƒá i widoczno≈õƒá kolumn w widoku grafiku,
        u≈ºywajƒÖc prawid≈Çowego API QHeaderView.
        """
        if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view') or not self.schedule_model:
            return

        header = self.table.schedule_view.horizontalHeader()
        model = self.schedule_model

        # Poka≈º wszystkie sekcje przed ustawieniem rozmiar√≥w/ukryciem
        for i in range(model.columnCount()):
            if not header.isSectionHidden(i):
                header.showSection(i)

        # Mapa definiujƒÖca niestandardowe szeroko≈õci dla konkretnych nag≈Ç√≥wk√≥w
        special_widths = {
            "Suma\nRBH": 45,
            "Bilans\nRBH": 45,
            "Komentarz": 300
        }

        # Pƒôtla po wszystkich kolumnach w modelu danych
        for logical_index in range(model.columnCount()):
            # Pobieramy tekst nag≈Ç√≥wka z modelu dla danego indeksu logicznego
            header_text = model.headerData(logical_index, Qt.Horizontal, Qt.DisplayRole)

            width_to_set = 65  # Domy≈õlna szeroko≈õƒá dla kolumn dni

            if header_text in special_widths:
                # Je≈õli nag≈Ç√≥wek jest w naszej mapie, u≈ºyj jego specjalnej szeroko≈õci
                width_to_set = special_widths[header_text]

            # Ustaw szeroko≈õƒá dla kolumny o danym indeksie logicznym
            header.resizeSection(logical_index, width_to_set)

        # Ukrywanie niepotrzebnych kolumn dla kr√≥tszych miesiƒôcy
        days_in_month = model._days_in_month
        employee_cols_count = len(model.get_visible_columns())

        # Pƒôtla od pierwszego nieistniejƒÖcego dnia do ko≈Ñca 31-dniowej siatki
        for day_offset in range(days_in_month, 31):
            # Obliczamy indeks logiczny kolumny w pe≈Çnym modelu
            model_col_to_hide = employee_cols_count + day_offset
            # U≈ºywamy poprawnej metody do ukrywania sekcji wg indeksu logicznego
            header.setSectionHidden(model_col_to_hide, True)

    def delete_event_from_row(self, row):
        """
        POPRAWIONA WERSJA: Usuwa zdarzenie na podstawie indeksu wiersza w tabeli zdarze≈Ñ
        z pe≈Çnym od≈õwie≈ºaniem ikon
        """
        # Sprawd≈∫ czy model istnieje
        if not hasattr(self, 'events_model') or not self.events_model:
            return

        # Pobierz zdarzenie z modelu
        event = self.events_model.get_event(row)
        if not event:
            debug_print(f"Nie znaleziono zdarzenia w wierszu {row}")
            return

        # Pobierz dane zdarzenia
        event_id = event.get('id')
        event_type = event.get('type')
        
        debug_print(f"Usuwanie zdarzenia z wiersza {row}: ID={event_id}, typ={event_type}")

        if not event_id or not event_type:
            debug_print(f"Niepe≈Çne dane zdarzenia: ID={event_id}, typ={event_type}")
            return

        # KLUCZOWA ZMIANA: U≈ºyj metody delete_event kt√≥ra ju≈º ma pe≈ÇnƒÖ logikƒô od≈õwie≈ºania
        self.delete_event(event_id, event_type)

    def on_sort_changed(self, logical_index, order):
        """Obs≈Çuguje zmianƒô sortowania w tabeli grafiku"""
        self.last_sort_column = logical_index
        self.last_sort_order = order
        debug_print(
            f"Tabela grafiku: Sortowanie po kolumnie {logical_index}, kolejno≈õƒá: {'rosnƒÖco' if order == Qt.AscendingOrder else 'malejƒÖco'}")

    def on_events_sort_changed(self, logical_index, order):
        """Obs≈Çuguje zmianƒô sortowania w tabeli zdarze≈Ñ"""
        debug_print(f"Tabela zdarze≈Ñ: Sortowanie po kolumnie {logical_index}, kolejno≈õƒá: {'rosnƒÖco' if order == Qt.AscendingOrder else 'malejƒÖco'}")

    def update_buttons_visibility(self):
        """Aktualizuje widoczno≈õƒá przycisk√≥w na podstawie roli u≈ºytkownika"""
        is_next_month_selected = False
        current_data = self.date_combo.currentData()
        if current_data:
            selected_year, selected_month = current_data

            today = QDate.currentDate()
            # Oblicz datƒô dla nastƒôpnego miesiƒÖca
            next_month_date = today.addMonths(1)

            # Sprawd≈∫, czy wybrany rok i miesiƒÖc zgadzajƒÖ siƒô z nastƒôpnym miesiƒÖcem
            if selected_year == next_month_date.year() and selected_month == next_month_date.month():
                is_next_month_selected = True

        if hasattr(self, 'add_overtime_button') and hasattr(self, 'current_user_role'):
            self.add_overtime_button.setVisible(self.current_user_role == "Pracownik WPR")

        # Ustaw widoczno≈õƒá przycisku "Obsada" tylko dla roli "Pracownik WPR"
        if hasattr(self, 'staffing_details_button') and hasattr(self, 'current_user_role'):
            self.staffing_details_button.setVisible(self.current_user_role == "Pracownik WPR")

        if hasattr(self, 'current_user_role') and self.current_user_role == "Pracownik WPR":
            debug_print("Edycja klawiatury w≈ÇƒÖczona: cyfry 0-9 = godzina start, Delete/Backspace = usu≈Ñ symbol")

        if hasattr(self, 'show_audit_button') and hasattr(self, 'current_user_role'):
            self.show_audit_button.setVisible(self.current_user_role == "Pracownik WPR")

        if hasattr(self, 'schedule_control_button') and hasattr(self, 'current_user_role'):
            allowed_roles = ["Pracownik WPR", "Lider OUT"]
            # Przycisk jest widoczny TYLKO, gdy rola siƒô zgadza ORAZ wybrany jest nastƒôpny miesiƒÖc
            is_visible = self.current_user_role in allowed_roles and is_next_month_selected
            self.schedule_control_button.setVisible(is_visible)

    def show_audit_log_window(self):
        """
        Tworzy i pokazuje okno historii zmian, obs≈ÇugujƒÖc jego niezale≈ºne od≈õwie≈ºanie.
        """
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Proszƒô najpierw wybraƒá miesiƒÖc.")
            return

        year, month = current_data

        # Helper do pobierania i filtrowania danych, aby uniknƒÖƒá powtarzania kodu
        def _get_filtered_audit_data():
            full_data = self.data_provider.get_schedule_audit_data(year, month)
            selected_cells = self.table.get_data_for_selected_cells()

            if selected_cells:
                allowed_users_dates = set()
                for cell in selected_cells:
                    if (user_id := cell.get('uzytkownik_id')) and (date_str := cell.get('date_str')):
                        date_obj = QDate.fromString(date_str, "yyyy-MM-dd").toPython()
                        allowed_users_dates.add((user_id, date_obj))

                return [row for row in full_data if
                        row.get('Data') and (int(row.get('Uzytkownik')), row.get('Data').date()) in allowed_users_dates]
            else:
                visible_user_ids = {key[3] for key in self.schedule_model._keys}
                return [row for row in full_data if
                        row.get('Uzytkownik') is not None and int(row.get('Uzytkownik')) in visible_user_ids]

        # Pobierz dane poczƒÖtkowe
        initial_filtered_data = _get_filtered_audit_data()
        if not initial_filtered_data:
            QMessageBox.information(self, "Informacja", "Brak historii zmian dla wybranych filtr√≥w / zaznaczenia.")
            return

        # Utw√≥rz okno dialogowe
        from audit_log_window import AuditLogWindow
        dialog = AuditLogWindow(initial_filtered_data, self.is_dark_theme, self)

        # Zdefiniuj slot do obs≈Çugi od≈õwie≈ºania
        def on_refresh_requested():
            debug_print("Otrzymano ≈ºƒÖdanie od≈õwie≈ºenia historii zmian.")
            # Wyczy≈õƒá cache, aby pobraƒá ≈õwie≈ºe dane z bazy
            self.data_provider.clear_audit_cache(year, month)
            # Pobierz i przefiltruj dane na nowo
            fresh_filtered_data = _get_filtered_audit_data()
            # Zaktualizuj widok w oknie dialogowym
            dialog.update_model_data(fresh_filtered_data)
            QMessageBox.information(dialog, "Od≈õwie≈ºono", "Historia zmian zosta≈Ça zaktualizowana.")

        # Pod≈ÇƒÖcz sygna≈Ç z dialogu do nowo utworzonego slotu
        dialog.refresh_requested.connect(on_refresh_requested)

        # Poka≈º okno
        dialog.exec()

    def check_user_permissions(self):
        """Sprawdza uprawnienia u≈ºytkownika i zapisuje je w atrybutach klasy."""
        # Pobieramy 5 warto≈õci, w tym wydzia≈Ç u≈ºytkownika
        user_id, user_app_id, user_app_role, visible_next_month, user_department = get_modifier_id()

        self.current_user_id = user_id
        self.current_user_app_id = user_app_id
        self.current_user_role = user_app_role
        self.can_see_next_month = visible_next_month
        self.current_user_department = user_department  # NOWY ATRYBUT

        self.update_buttons_visibility()

        # Reszta logiki bez zmian...
        allowed_roles = ["Pracownik WPR", "Lider", "Menad≈ºer", "Lider OUT"]
        if user_app_role not in allowed_roles:
            QMessageBox.critical(
                self, "Brak uprawnie≈Ñ",
                f"Nie masz uprawnie≈Ñ do korzystania z tej aplikacji.\n\nTwoja rola: {user_app_role}",
                QMessageBox.Ok
            )
            return False

        debug_print(f"Zalogowano jako: {user_app_id} ({user_app_role}), Wydzia≈Ç: {self.current_user_department}")
        return True

    def _can_modify_cells(self, selected_cells_data: list) -> bool:
        """
        Sprawdza, czy bie≈ºƒÖcy u≈ºytkownik (Lider) ma uprawnienia do modyfikacji
        grafiku dla pracownik√≥w w zaznaczonych kom√≥rkach.
        """
        # Regu≈Ça dotyczy tylko r√≥l Lider IN i Lider OUT
        leader_roles = ["Lider", "Lider OUT"]  # Za≈Ço≈ºy≈Çem, ≈ºe "Lider IN" to po prostu "Lider"
        if self.current_user_role not in leader_roles:
            return True  # Inne role nie majƒÖ tego ograniczenia

        if not self.current_user_department:
            QMessageBox.warning(self, "B≈ÇƒÖd konfiguracji",
                                "Nie mo≈ºna zweryfikowaƒá Twojego wydzia≈Çu. Edycja niemo≈ºliwa.")
            return False

        unauthorized_employees = set()
        leader_dept = self.current_user_department

        for cell_data in selected_cells_data:
            employee_dept = cell_data.get('wydzial')
            if not employee_dept:
                continue  # Pomi≈Ñ kom√≥rki bez informacji o wydziale

            # Sprawd≈∫, czy wydzia≈Ç lidera zawiera siƒô w wydziale pracownika
            if leader_dept not in employee_dept:
                unauthorized_employees.add(cell_data.get('uzytkownik_dane', 'Nieznany'))

        if unauthorized_employees:
            QMessageBox.warning(
                self,
                "Brak uprawnie≈Ñ",
                "Nie posiadasz uprawnie≈Ñ do edycji grafiku tej osoby.\n\n"
                f"Twoja jednostka: '{leader_dept}'\n"
                "Problem dotyczy pracownik√≥w:\n - " + "\n - ".join(sorted(list(unauthorized_employees)))
            )
            return False

        return True  # Walidacja pomy≈õlna

    def show_insert_symbol_dialog(self):
        """
        Pokazuje okno dialogowe do wstawiania symbolu nieobecno≈õci.
        NOWA WERSJA z procedurƒÖ p_P_ZZ_ImportZmianyNaSerwer_v3
        """
        dialog = InsertSymbolDialog(self)
        if dialog.exec():
            selected_symbol = dialog.get_selected_symbol()

            # Pobierz zaznaczone kom√≥rki z modelu
            selected_cells_data = self.get_selected_cells_data()

            if not self._can_modify_cells(selected_cells_data):
                return

            if not selected_cells_data:
                QMessageBox.warning(
                    self,
                    "Brak zaznaczenia",
                    "Nie zaznaczono ≈ºadnych kom√≥rek do edycji.",
                    QMessageBox.Ok
                )
                return

            # Filtruj tylko kom√≥rki grafiku (nie kolumny pracownik√≥w) i pomijaj puste kom√≥rki
            schedule_cells = []
            for cell_data in selected_cells_data:
                if isinstance(cell_data, dict) and 'date_str' in cell_data and 'uzytkownik_id' in cell_data:
                    # NOWE: Sprawd≈∫ czy kom√≥rka nie jest pusta
                    current_symbol = cell_data.get('symbol', '').strip()
                    if current_symbol:  # Pomijaj puste kom√≥rki
                        schedule_cells.append(cell_data)

            if not schedule_cells:
                QMessageBox.warning(
                    self,
                    "Brak kom√≥rek do edycji",
                    "Nie zaznaczono ≈ºadnych kom√≥rek grafiku z symbolami do edycji.\n\n" +
                    "Uwaga: Puste kom√≥rki sƒÖ pomijane.",
                    QMessageBox.Ok
                )
                return

            # Pogrupuj kom√≥rki dla lepszego komunikatu
            grouped_changes = self._group_cells_for_symbol_changes(schedule_cells)

            # Przygotuj komunikat potwierdzenia
            changes_info = self._prepare_symbol_changes_description(grouped_changes, selected_symbol)

            # Sprawd≈∫ czy sƒÖ zdarzenia do odwo≈Çania
            user_date_pairs = set()
            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    user_date_pairs.add((user_id, date_str))

            events_to_cancel = self._find_events_to_cancel(user_date_pairs)
            delegations_info = ""
            if events_to_cancel:
                grouped_events = self._group_events_by_user_date(events_to_cancel)
                delegations_info = self._prepare_delegations_description(grouped_events)

            # Poka≈º komunikat potwierdzenia
            complete_info = f"Czy na pewno chcesz wprowadziƒá nastƒôpujƒÖce zmiany?\n\n{changes_info}"
            if delegations_info:
                complete_info += f"\n{delegations_info}"
            complete_info += f"\n≈ÅƒÖcznie: {len(schedule_cells)} kom√≥rek zmieni symbol"
            if events_to_cancel:
                complete_info += f", {len(events_to_cancel)} delegacji zostanie odwo≈Çanych"

            reply = QMessageBox.question(
                self,
                "Potwierdzenie wstawienia nieobecno≈õci",
                complete_info,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )

            if reply == QMessageBox.Yes:
                self._apply_absence_symbol_changes(schedule_cells, selected_symbol, events_to_cancel)

    def _group_cells_for_symbol_changes(self, schedule_cells):
        """
        Grupuje kom√≥rki wed≈Çug u≈ºytkownika i daty dla komunikatu potwierdzenia

        Args:
            schedule_cells (list): Lista kom√≥rek do modyfikacji

        Returns:
            dict: Pogrupowane zmiany
        """
        grouped_changes = {}
        for cell_data in schedule_cells:
            user_id = cell_data.get('uzytkownik_id')
            user_name = cell_data.get('uzytkownik_dane', '')
            date_str = cell_data.get('date_str')
            current_symbol = cell_data.get('symbol', '')

            # Formatuj datƒô
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            user_key = (user_id, user_name)
            if user_key not in grouped_changes:
                grouped_changes[user_key] = {}

            if formatted_date not in grouped_changes[user_key]:
                grouped_changes[user_key][formatted_date] = []

            grouped_changes[user_key][formatted_date].append({
                'current_symbol': current_symbol,
                'cell_data': cell_data
            })

        return grouped_changes

    def _prepare_symbol_changes_description(self, grouped_changes, new_special_symbol):
        """
        Przygotowuje opis zmian symboli do komunikatu potwierdzenia

        Args:
            grouped_changes (dict): Pogrupowane zmiany
            new_special_symbol (str): Nowy symbol specjalny

        Returns:
            str: Opis zmian
        """
        changes_info = ""
        for (user_id, user_name), dates in grouped_changes.items():
            changes_info += f"\nüë§ {user_name}:\n"

            for date, cells in dates.items():
                changes_info += f"   üìÖ {date}: "

                # Poka≈º przyk≈Çad jak bƒôdzie wyglƒÖda≈Ç nowy symbol
                example_cell = cells[0]['cell_data']
                current_symbol = cells[0]['current_symbol']

                # Przewiduj jak bƒôdzie wyglƒÖda≈Ç nowy symbol
                predicted_symbol = self._predict_new_symbol(current_symbol, new_special_symbol, example_cell)

                if len(cells) == 1:
                    changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                else:
                    # Je≈õli wiele kom√≥rek w tym dniu
                    current_symbols = [cell['current_symbol'] for cell in cells]
                    unique_symbols = set(current_symbols)
                    if len(unique_symbols) == 1:
                        changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                    else:
                        symbols_str = ", ".join([f"{s}" for s in unique_symbols])
                        changes_info += f"[{symbols_str}] -> {predicted_symbol}\n"

        return changes_info

    def _predict_new_symbol(self, current_symbol, special_symbol, cell_data):
        """
        Przewiduje jak bƒôdzie wyglƒÖda≈Ç nowy symbol po modyfikacji

        Args:
            current_symbol (str): Obecny symbol (nigdy pusty - puste sƒÖ filtrowane)
            special_symbol (str): Nowy symbol specjalny
            cell_data (dict): Dane kom√≥rki

        Returns:
            str: Przewidywany nowy symbol
        """
        from symbol_parser import parse_symbol, build_symbol

        # Sprawd≈∫ czy symbol istnieje (zabezpieczenie dodatkowe)
        if not current_symbol or current_symbol.strip() == '':
            debug_print("Ostrze≈ºenie: _predict_new_symbol otrzyma≈Ç pusty symbol")
            return special_symbol

        # Parsuj obecny symbol
        parsed = parse_symbol(current_symbol)

        # Zachowaj lokalizacjƒô i godziny, zmie≈Ñ tylko symbol specjalny
        new_symbol = build_symbol(
            location=parsed.get('location'),
            start_hour=parsed.get('start_hour'),
            work_hours=parsed.get('work_hours'),
            special_symbol=special_symbol
        )

        return new_symbol if new_symbol else special_symbol

    def _find_events_to_cancel(self, user_date_pairs):
        """
        Znajduje zdarzenia do odwo≈Çania dla podanych par u≈ºytkownik-data

        Args:
            user_date_pairs (set): Pary (user_id, date_str)

        Returns:
            list: Lista zdarze≈Ñ do odwo≈Çania
        """
        events_to_cancel = []

        for user_id, date_str in user_date_pairs:
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

            for event in user_events:
                event_type = event.get('type', '')
                event_id = event.get('id')
                event_status = event.get('status')

                if not event_type or event_id is None:
                    continue

                if event_status is not None:
                    event_status = str(event_status)

                # Dodaj zdarzenia do odwo≈Çania (spotkania, szkolenia, nadgodziny)
                if event_type in ['Spotkanie', 'Szkolenie', 'Nadgodziny'] and event_status != '0':
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),
                    })

        return events_to_cancel

    def _group_events_by_user_date(self, events_to_cancel):
        """
        Grupuje zdarzenia wed≈Çug u≈ºytkownika i daty

        Args:
            events_to_cancel (list): Lista zdarze≈Ñ do odwo≈Çania

        Returns:
            dict: Pogrupowane zdarzenia
        """
        grouped_events = {}
        for event in events_to_cancel:
            key = (event['user_id'], event['date'])
            if key not in grouped_events:
                grouped_events[key] = []
            grouped_events[key].append(event)

        return grouped_events

    def _apply_absence_symbol_changes(self, schedule_cells, special_symbol, events_to_cancel):
        try:
            canceled_count = 0
            if events_to_cancel:
                canceled_count = self._cancel_delegations(events_to_cancel)
                debug_print(f"Odwo≈Çano {canceled_count} delegacji przed wstawieniem nieobecno≈õci.")

            successful_symbol_updates = 0
            failed_symbol_updates = 0
            error_messages_symbol = []
            # Ta lista musi zawieraƒá krotki 3-elementowe
            affected_pairs_for_symbol_change = []

            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                nr_kadrowy = cell_data.get('nr_kadrowy')
                current_symbol = cell_data.get('symbol', '')

                if not user_id or not date_str or not nr_kadrowy:
                    failed_symbol_updates += 1
                    error_messages_symbol.append(f"Brak danych dla kom√≥rki: U:{user_id} D:{date_str} NRK:{nr_kadrowy}")
                    continue

                new_symbol = self._build_new_symbol_with_absence_fixed(current_symbol, special_symbol, cell_data)

                try:
                    year_val, month_val, day_val = map(int, date_str.split('-'))

                    result = self._call_import_changes_procedure(
                        nr_kadrowy=nr_kadrowy,
                        rok=year_val,
                        miesiac=month_val,
                        data=date_str,
                        symbol=new_symbol
                    )

                    if result['success']:
                        successful_symbol_updates += 1
                        # --- KLUCZOWA POPRAWKA ---
                        # Upewniamy siƒô, ≈ºe zawsze dodajemy 3 elementy do krotki
                        affected_pairs_for_symbol_change.append(
                            (user_id, date_str, result.get('returned_symbol'))
                        )
                        debug_print(f"Sukces wstawienia symbolu nieobecno≈õci: {user_id}, {date_str}, symbol: {result.get('returned_symbol', new_symbol)}")
                    else:
                        failed_symbol_updates += 1
                        error_msg = result.get('message', 'Nieznany b≈ÇƒÖd')
                        error_messages_symbol.append(f"{nr_kadrowy} ({date_str}): {error_msg}")
                except Exception as e_proc:
                    failed_symbol_updates += 1
                    error_messages_symbol.append(f"{nr_kadrowy} ({date_str}): {str(e_proc)}")
                    log_error(f"B≈ÇƒÖd procedury importu dla {user_id}, {date_str}: {e_proc}", exception=e_proc)

            # Od≈õwie≈º symbole w grafiku, przekazujƒÖc listƒô z poprawnymi danymi
            if successful_symbol_updates > 0:
                self._update_cells_with_new_symbols(affected_pairs_for_symbol_change)

            # Poka≈º wyniki operacji
            self._show_symbol_change_results(successful_symbol_updates, failed_symbol_updates, error_messages_symbol,
                                             events_to_cancel if canceled_count > 0 else [])

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas wstawiania nieobecno≈õci: {e}", exception=e)
            QMessageBox.critical(
                self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas wstawiania nieobecno≈õci: {str(e)}", QMessageBox.Ok
            )

    def clear_special_symbol_from_selected_cells(self):
        """
        POPRAWIONA WERSJA: Usuwa tylko symbol specjalny z zaznaczonych kom√≥rek,
        u≈ºywajƒÖc nowego, niezawodnego mechanizmu od≈õwie≈ºania UI.
        """
        # 1. Sprawdzenie uprawnie≈Ñ
        if self.current_user_role != "Pracownik WPR":
            self.statusBar().showMessage("Brak uprawnie≈Ñ do wykonania tej operacji.", 3000)
            return

        # 2. Pobranie i walidacja zaznaczonych kom√≥rek
        selected_cells_data = self.table.get_data_for_selected_cells()

        if not self._can_modify_cells(selected_cells_data):
            return

        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono kom√≥rek do modyfikacji.")
            return

        cells_to_modify = [
            cell for cell in selected_cells_data
            if cell.get('symbol') and parse_symbol(cell.get('symbol')).get('special_symbol')
        ]

        if not cells_to_modify:
            QMessageBox.information(self, "Brak zmian",
                                    "W zaznaczonych kom√≥rkach nie ma symboli specjalnych do usuniƒôcia.")
            return

        # 3. Dialog potwierdzenia
        changes_info = f"Czy na pewno chcesz usunƒÖƒá symbole specjalne z {len(cells_to_modify)} kom√≥rek?\n(Godziny pracy i lokalizacja zostanƒÖ zachowane)"
        reply = QMessageBox.question(self, "Potwierdzenie operacji", changes_info,
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

        if reply != QMessageBox.Yes:
            return

        # 4. Logika modyfikacji i zapisu z nowym od≈õwie≈ºaniem
        updated_info = []

        for cell_data in cells_to_modify:
            current_symbol = cell_data.get('symbol', '')
            parsed = parse_symbol(current_symbol)

            # Budowa nowego symbolu bez czƒô≈õci specjalnej
            new_symbol = build_symbol(
                location=parsed.get('location'),
                start_hour=parsed.get('start_hour'),
                work_hours=parsed.get('work_hours'),
                special_symbol=None
            )

            try:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                nr_kadrowy = cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')

                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy,
                    rok=int(year),
                    miesiac=int(month),
                    data=date_str,
                    symbol=new_symbol
                )

                if result.get('success'):
                    # Zbieramy informacje zwrotne do jednej, zbiorczej aktualizacji UI
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
            except Exception as e:
                log_error(f"B≈ÇƒÖd wywo≈Çania procedury w clear_special_symbol_from_selected_cells: {e}")

        # 5. Wywo≈Çanie nowej, niezawodnej metody od≈õwie≈ºajƒÖcej UI
        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Pomy≈õlnie zmodyfikowano {len(updated_info)} kom√≥rek.", 3000)

    def _build_new_symbol_with_absence_fixed(self, current_symbol, special_symbol, cell_data):
        """
        POPRAWIONA WERSJA: Buduje nowy symbol z absencjƒÖ, poprawnie obs≈ÇugujƒÖc
        zar√≥wno puste, jak i wype≈Çnione kom√≥rki.
        """
        from symbol_parser import parse_symbol, build_symbol

        # Inicjalizacja zmiennych
        location = None
        start_hour = None
        work_hours = None

        if current_symbol and current_symbol.strip():
            # Kom√≥rka NIE JEST pusta: parsujemy istniejƒÖcy symbol
            debug_print(f"Kom√≥rka niepusta. Parsowanie symbolu: '{current_symbol}'")
            parsed = parse_symbol(current_symbol)
            location = parsed.get('location')
            start_hour = parsed.get('start_hour')
            work_hours = parsed.get('work_hours')
        else:
            # --- NOWA, POPRAWNA LOGIKA DLA PUSTEJ KOM√ìRKI ---
            debug_print("Kom√≥rka pusta. U≈ºywam danych domy≈õlnych.")
            # Pobierz domy≈õlnƒÖ lokalizacjƒô i godziny z etatu
            location = cell_data.get('lokalizacja_domyslna')
            work_hours = cell_data.get('etat')
            # Dla absencji w dzie≈Ñ wolny, domy≈õlna godzina rozpoczƒôcia to 8
            start_hour = 8

        # Budujemy nowy symbol z nowym symbolem specjalnym, ale zachowujƒÖc godziny/lokalizacjƒô
        new_symbol = build_symbol(
            location=location,
            start_hour=start_hour,
            work_hours=work_hours,
            special_symbol=special_symbol
        )

        debug_print(f"Zbudowano nowy symbol: '{new_symbol}'")
        return new_symbol

    def _call_import_changes_procedure(self, nr_kadrowy, rok, miesiac, data, symbol):
        """
        POPRAWIONA WERSJA: Wywo≈Çuje procedurƒô i bardziej niezawodnie interpretuje jej wyniki.
        Ka≈ºdy komunikat tekstowy, kt√≥ry nie jest nowym symbolem, jest traktowany jako b≈ÇƒÖd.
        """
        try:
            from db_connector import DatabaseConnector

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            debug_print(
                f"Wywo≈Çanie procedury: nr_kadrowy={nr_kadrowy}, rok={rok}, miesiac={miesiac}, data={data}, symbol={symbol}")

            cursor.execute("""
                EXEC [dbo].[p_P_ZZ_ImportZmianyNaSerwer_v3] 
                    @NumerKadrowy = ?, @Rok = ?, @Miesiac = ?, @Data = ?, @Symbol = ?, @CzyPobieranieSugestii = ?
            """, (nr_kadrowy, rok, miesiac, data, symbol, None))

            all_results = []
            while True:
                try:
                    rows = cursor.fetchall()
                    if rows:
                        all_results.extend(rows)
                    if not cursor.nextset():
                        break
                except Exception:
                    break

            conn.commit()
            conn.close()

            returned_symbol = symbol
            success = True
            message = "Operacja zako≈Ñczona pomy≈õlnie"

            for row in all_results:
                if row and len(row) > 0 and row[0] is not None:
                    raw_value = row[0]

                    # --- NOWA, KLUCZOWA ZMIANA ---
                    # Sprawdzamy, czy procedura nie zwr√≥ci≈Ça numerycznego 0,
                    # kt√≥re traktujemy jako sygna≈Ç sukcesu i ignorujemy.
                    if isinstance(raw_value, int) and raw_value == 0:
                        continue  # Przejd≈∫ do nastƒôpnego wyniku

                    value_str = str(raw_value).strip()
                    if not value_str:
                        continue

                    # Sprawdzamy r√≥wnie≈º dla tekstowego "0"
                    if value_str == "0":
                        continue
                    # --- KONIEC KLUCZOWEJ ZMIANY ---

                    is_likely_a_symbol = ' ' not in value_str and len(value_str) <= 50

                    if is_likely_a_symbol:
                        returned_symbol = value_str
                        debug_print(f"Procedura zwr√≥ci≈Ça nowy symbol: {value_str}")
                    else:
                        success = False
                        message = value_str
                        debug_print(f"Procedura zwr√≥ci≈Ça komunikat (traktowany jako b≈ÇƒÖd): {value_str}")
                        break

            if success:
                self._update_modification_date()

            return {
                "success": success,
                "message": message,
                "returned_symbol": returned_symbol
            }

        except Exception as e:
            log_error(f"B≈ÇƒÖd procedury p_P_ZZ_ImportZmianNaSerwer_v4: {e}")
            return {
                "success": False,
                "message": f"B≈ÇƒÖd bazy danych: {str(e)}",
                "returned_symbol": symbol
            }

    def _update_cells_with_new_symbols(self, updated_cells_info: list):
        """
        Aktualizuje kom√≥rki w modelu na podstawie danych zwr√≥conych przez procedurƒô,
        bez ponownego odpytywania bazy danych.

        Args:
            updated_cells_info: Lista krotek (user_id, date_str, new_symbol)
        """
        if not updated_cells_info or not hasattr(self, 'schedule_model'):
            return

        for user_id, date_str, new_symbol in updated_cells_info:
            if new_symbol is not None:
                self._update_single_cell_in_model(user_id, date_str, new_symbol, self.year, self.month)

        debug_print(f"Zaktualizowano {len(updated_cells_info)} kom√≥rek w modelu na podstawie danych zwrotnych.")

    def _update_single_cell_in_model(self, user_id, date_str, new_symbol, year, month):
        """
        NOWA PROSTA METODA: Aktualizuje jednƒÖ kom√≥rkƒô w modelu i wymusza jej od≈õwie≈ºenie
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return False

            # Znajd≈∫ pozycjƒô kom√≥rki
            row_index = -1
            for idx, key in enumerate(self.schedule_model._keys):
                if str(key[3]) == str(user_id):
                    row_index = idx
                    break

            if row_index == -1:
                debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                return False

            # Oblicz kolumnƒô
            try:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)
                if int(year_str) != year or int(month_str) != month:
                    return False
            except:
                return False

            visible_columns_count = len(self.schedule_model.get_visible_columns())
            col_index = visible_columns_count + day - 1

            # KLUCZOWE: U≈ºyj setData aby model wiedzia≈Ç o zmianie
            model_index = self.schedule_model.index(row_index, col_index)
            if model_index.isValid():
                # Ustaw nowy symbol przez model - to wywo≈Ça automatyczne od≈õwie≈ºenie
                success = self.schedule_model.setData(model_index, new_symbol, Qt.EditRole)

                if success:
                    debug_print(f"SUKCES: Zaktualizowano kom√≥rkƒô [{row_index},{col_index}] = '{new_symbol}'")
                    return True
                else:
                    debug_print(f"B≈ÅƒÑD: Nie uda≈Ço siƒô zaktualizowaƒá kom√≥rki [{row_index},{col_index}]")

            return False

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji kom√≥rki {user_id}/{date_str}: {e}")
            return False

    def _update_model_with_new_symbols(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje symbole bezpo≈õrednio w modelu
        """
        try:
            if not updated_symbols or not hasattr(self, 'schedule_model'):
                return

            processed_data = self.schedule_model.get_processed_data()
            if not processed_data:
                return

            updated_count = 0
            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Znajd≈∫ klucz u≈ºytkownika w processed_data
                target_key = None
                for key in processed_data.keys():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        target_key = key
                        break

                if not target_key:
                    debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                    continue

                # Oblicz dzie≈Ñ z daty
                try:
                    year_str, month_str, day_str = date_str.split('-')
                    day = int(day_str)

                    if int(year_str) != year or int(month_str) != month:
                        continue

                except ValueError:
                    continue

                # Aktualizuj symbol w processed_data
                user_data = processed_data[target_key]
                days_data = user_data.setdefault('days', {})
                day_data = days_data.setdefault(day, {})

                old_symbol = day_data.get('symbol', '')
                day_data['symbol'] = new_symbol

                # Przelicz godziny na podstawie nowego symbolu
                from symbol_parser import parse_symbol
                parsed = parse_symbol(new_symbol)
                day_data['hours'] = parsed.get('work_hours', 0) or 0
                day_data['start_hour'] = parsed.get('start_hour')

                # Aktualizuj total_hours u≈ºytkownika
                old_hours = 0
                if old_symbol:
                    old_parsed = parse_symbol(old_symbol)
                    old_hours = old_parsed.get('work_hours', 0) or 0

                new_hours = day_data['hours']
                user_data['total_hours'] = (user_data.get('total_hours', 0) or 0) - old_hours + new_hours

                updated_count += 1
                debug_print(
                    f"Model: Zaktualizowano {user_id}/{day}: '{old_symbol}' -> '{new_symbol}' ({old_hours}h -> {new_hours}h)")

            debug_print(f"Zaktualizowano {updated_count} kom√≥rek w modelu")

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji modelu: {e}")

    def _fetch_single_cell_symbol(self, user_id, date_str, year, month):
        """
        NOWA METODA: Pobiera aktualny symbol dla pojedynczej kom√≥rki z bazy danych

        Args:
            user_id (int): ID u≈ºytkownika
            date_str (str): Data w formacie YYYY-MM-DD
            year (int): Rok
            month (int): MiesiƒÖc

        Returns:
            str|None: Aktualny symbol lub None je≈õli nie znaleziono
        """
        try:
            from db_connector import DatabaseConnector

            # Zapytanie do pobrania symbolu dla konkretnej kom√≥rki
            query = """
            SELECT Symbol 
            FROM [dbo].[fn_GetScheduleData](?, ?) 
            WHERE Uzytkownik = ? AND Data = ?
            """

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query, (year, month, user_id, date_str))
            result = cursor.fetchone()
            conn.close()

            if result and result[0] is not None:
                return str(result[0])

            return None

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas pobierania symbolu dla kom√≥rki {user_id}/{date_str}: {e}")
            return None

    def _update_data_provider_cache(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje cache w DataProvider
        """
        try:
            if not updated_symbols or not hasattr(self.data_provider, 'monthly_cache'):
                return

            month_key = (year, month)
            if month_key not in self.data_provider.monthly_cache:
                return

            container = self.data_provider.monthly_cache[month_key]

            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Aktualizuj processed_data w kontenerze
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):
                        try:
                            year_str, month_str, day_str = date_str.split('-')
                            day = int(day_str)

                            if int(year_str) == year and int(month_str) == month:
                                days_data = user_data.setdefault('days', {})
                                day_data = days_data.setdefault(day, {})
                                day_data['symbol'] = new_symbol

                                # Przelicz godziny
                                from symbol_parser import parse_symbol
                                parsed = parse_symbol(new_symbol)
                                day_data['hours'] = parsed.get('work_hours', 0) or 0
                                day_data['start_hour'] = parsed.get('start_hour')

                                debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")
                                break
                        except:
                            continue

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji DataProvider cache: {e}")

    def _force_full_refresh(self):
        """Fallback - pe≈Çne od≈õwie≈ºenie danych"""
        try:
            current_data = self.date_combo.currentData()
            if current_data:
                year, month = current_data
                self.data_provider.refresh_data(year, month)
                self.update_table_content()
        except Exception as e:
            log_error(f"B≈ÇƒÖd pe≈Çnego od≈õwie≈ºenia: {e}")

    def _force_refresh_specific_cells(self, affected_pairs, year, month):
        """
        POPRAWIONA METODA: Wymusza od≈õwie≈ºenie konkretnych kom√≥rek w widoku
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycjƒô kom√≥rki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajd≈∫ wiersz u≈ºytkownika w modelu
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnƒô dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymusza od≈õwie≈ºenie kom√≥rki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej kom√≥rki
                        self.schedule_model.dataChanged.emit(model_index, model_index,
                                                             [Qt.DisplayRole, Qt.BackgroundRole])

                        # Metoda 2: Wymu≈õ update widoku dla tej kom√≥rki
                        self.table.schedule_view.update(model_index)

                        refreshed_cells += 1
                        debug_print(f"Od≈õwie≈ºono kom√≥rkƒô tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"B≈ÇƒÖd od≈õwie≈ºania kom√≥rki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymu≈õ ca≈Ço≈õciowy update viewport je≈õli zmieniono jakie≈õ kom√≥rki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po od≈õwie≈ºeniu {refreshed_cells} kom√≥rek")

                # DODATKOWE: Wymu≈õ te≈º od≈õwie≈ºenie tabeli pracownik√≥w (dla sum RBH)
                if hasattr(self.table, 'employees_view'):
                    self.table.employees_view.viewport().update()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas wymuszania od≈õwie≈ºenia kom√≥rek tabeli: {e}")

    def _update_model_cells_directly(self, updated_symbols, year, month):
        """
        Aktualizuje symbole bezpo≈õrednio w modelu i DataProvider

        Args:
            updated_symbols (dict): S≈Çownik {(user_id, date_str): symbol}
            year (int): Rok
            month (int): MiesiƒÖc
        """
        try:
            if not updated_symbols:
                return

            updated_count = 0

            # AKTUALIZACJA 1: Schedule Model processed_data
            if hasattr(self, 'schedule_model') and self.schedule_model:
                processed_data = self.schedule_model.get_processed_data()

                if processed_data:
                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        if self._update_single_cell_in_processed_data(processed_data, user_id, date_str, new_symbol,
                                                                      year, month):
                            updated_count += 1

            # AKTUALIZACJA 2: DataProvider cache (je≈õli istnieje)
            if hasattr(self.data_provider, 'monthly_cache'):
                month_key = (year, month)
                if month_key in self.data_provider.monthly_cache:
                    container = self.data_provider.monthly_cache[month_key]

                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        self._update_single_cell_in_data_provider(container, user_id, date_str, new_symbol, year, month)

            debug_print(f"Zaktualizowano {updated_count} kom√≥rek w modelu")

        except Exception as e:
            log_error(f"B≈ÇƒÖd bezpo≈õredniej aktualizacji modelu: {e}")

    def _update_single_cell_in_processed_data(self, processed_data, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczƒÖ kom√≥rkƒô w processed_data

        Returns:
            bool: True je≈õli zaktualizowano
        """
        try:
            # Znajd≈∫ klucz u≈ºytkownika
            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if not target_key:
                debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                return False

            # Oblicz dzie≈Ñ
            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)

            if int(year_str) != year or int(month_str) != month:
                return False

            # Aktualizuj symbol
            user_data = processed_data[target_key]
            days_data = user_data.setdefault('days', {})
            day_data = days_data.setdefault(day, {})

            old_symbol = day_data.get('symbol', '')
            day_data['symbol'] = new_symbol

            # Przelicz godziny i inne parametry
            from symbol_parser import parse_symbol
            parsed = parse_symbol(new_symbol)
            day_data['hours'] = parsed.get('work_hours', 0) or 0
            day_data['start_hour'] = parsed.get('start_hour')

            debug_print(f"Model: {user_id}/{day} '{old_symbol}' -> '{new_symbol}'")
            return True

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji kom√≥rki processed_data {user_id}/{date_str}: {e}")
            return False

    def _update_single_cell_in_data_provider(self, container, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczƒÖ kom√≥rkƒô w DataProvider cache
        """
        try:
            if not hasattr(container, 'processed_data') or not container.processed_data:
                return

            # Podobna logika jak dla processed_data w modelu
            processed_data = container.processed_data

            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if target_key:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)

                if int(year_str) == year and int(month_str) == month:
                    user_data = processed_data[target_key]
                    days_data = user_data.setdefault('days', {})
                    day_data = days_data.setdefault(day, {})
                    day_data['symbol'] = new_symbol

                    # Przelicz godziny
                    from symbol_parser import parse_symbol
                    parsed = parse_symbol(new_symbol)
                    day_data['hours'] = parsed.get('work_hours', 0) or 0
                    day_data['start_hour'] = parsed.get('start_hour')

                    debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji DataProvider cache: {e}")

    def _force_refresh_table_cells(self, affected_pairs, year, month):
        """
        WYMUSZA od≈õwie≈ºenie konkretnych kom√≥rek w widoku tabeli

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
            year (int): Rok
            month (int): MiesiƒÖc
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycjƒô kom√≥rki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajd≈∫ wiersz u≈ºytkownika
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnƒô dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymu≈õ od≈õwie≈ºenie kom√≥rki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej kom√≥rki
                        self.schedule_model.dataChanged.emit(model_index, model_index, [])

                        # Metoda 2: Wymu≈õ update widoku (backup)
                        self.table.schedule_view.update(model_index)

                        # Metoda 3: Invalidate item (backup)
                        if hasattr(self.table.schedule_view, 'setDirtyRegion'):
                            rect = self.table.schedule_view.visualRect(model_index)
                            if not rect.isEmpty():
                                self.table.schedule_view.viewport().update(rect)

                        refreshed_cells += 1
                        debug_print(f"Od≈õwie≈ºono kom√≥rkƒô tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"B≈ÇƒÖd od≈õwie≈ºania kom√≥rki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymu≈õ ca≈Ço≈õciowy update viewport je≈õli zmieniono jakie≈õ kom√≥rki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po od≈õwie≈ºeniu {refreshed_cells} kom√≥rek")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas wymuszania od≈õwie≈ºenia kom√≥rek tabeli: {e}")

    def _find_user_row_in_model(self, user_id):
        """
        POPRAWIONA METODA: Znajduje indeks wiersza dla danego u≈ºytkownika w modelu
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return -1

            # Pobierz klucze z modelu
            if hasattr(self.schedule_model, '_keys'):
                keys = self.schedule_model._keys
            else:
                return -1

            user_id_str = str(user_id)

            for row_index, key in enumerate(keys):
                if len(key) > 3 and str(key[3]) == user_id_str:
                    return row_index

            return -1

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas szukania wiersza u≈ºytkownika {user_id}: {e}")
            return -1

    def _update_local_events_for_cells(self, affected_pairs):
        """
        Aktualizuje lokalny events_data tylko dla zmienionych kom√≥rek

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
        """
        try:
            if not hasattr(self, 'events_data'):
                return

            # Sprawd≈∫ czy jakie≈õ z zmienionych kom√≥rek sƒÖ obecnie zaznaczone
            if not hasattr(self, 'table'):
                return

            current_selection = self.table.get_data_for_selected_cells()
            selected_pairs = set()

            for cell_data in current_selection:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    selected_pairs.add((user_id, date_str))

            # Sprawd≈∫ czy kt√≥ra≈õ ze zmienionych kom√≥rek jest zaznaczona
            intersection = set(affected_pairs) & selected_pairs

            if intersection:
                debug_print(f"Zaktualizowano {len(intersection)} zmienionych kom√≥rek w events_data")
                # Je≈õli tak, od≈õwie≈º events_data tylko dla zaznaczonych kom√≥rek
                self.on_selection_changed()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji lokalnych events: {e}")

    def _show_symbol_change_results(self, successful_updates, failed_updates, error_messages, events_to_cancel):
        """
        Pokazuje wyniki operacji wstawiania symboli

        Args:
            successful_updates (int): Liczba udanych aktualizacji
            failed_updates (int): Liczba nieudanych aktualizacji
            error_messages (list): Lista komunikat√≥w b≈Çƒôd√≥w
            events_to_cancel (list): Lista odwo≈Çanych zdarze≈Ñ
        """
        if successful_updates > 0:
            message = f"Pomy≈õlnie zaktualizowano {successful_updates} kom√≥rek"

            if events_to_cancel:
                message += f" i odwo≈Çano {len(events_to_cancel)} delegacji"

            if failed_updates > 0:
                message += f"\n\n‚ö†Ô∏è {failed_updates} aktualizacji nie powiod≈Ço siƒô"
                if error_messages:
                    message += ":\n" + "\n".join(error_messages[:5])
                    if len(error_messages) > 5:
                        message += f"\n... i {len(error_messages) - 5} wiƒôcej b≈Çƒôd√≥w"

            if failed_updates == 0:
                QMessageBox.information(
                    self, "Sukces", message, QMessageBox.Ok
                )
            else:
                QMessageBox.warning(
                    self, "Czƒô≈õciowy sukces", message, QMessageBox.Ok
                )
        else:
            message = f"Nie uda≈Ço siƒô zaktualizowaƒá ≈ºadnej kom√≥rki"
            if error_messages:
                message += f"\n\nB≈Çƒôdy ({len(error_messages)}):\n"
                message += "\n".join(error_messages[:10])
                if len(error_messages) > 10:
                    message += f"\n... i {len(error_messages) - 10} wiƒôcej b≈Çƒôd√≥w"

            QMessageBox.critical(
                self, "B≈ÇƒÖd aktualizacji", message, QMessageBox.Ok
            )

    def _prepare_delegations_description(self, grouped_events, max_groups=10):
        """
        Przygotowuje opis delegacji do odwo≈Çania.

        Args:
            grouped_events: S≈Çownik zdarze≈Ñ pogrupowanych wed≈Çug u≈ºytkownika i daty
            max_groups: Maksymalna liczba grup do wy≈õwietlenia

        Returns:
            str: Opis delegacji do odwo≈Çania
        """
        delegations_info = ""

        if not grouped_events:
            return delegations_info

        delegations_info += "\nNastƒôpujƒÖce delegacje zostanƒÖ automatycznie odwo≈Çane:\n"

        # Licznik dla ograniczenia liczby wy≈õwietlanych grup
        group_count = 0

        for (user_id, date_str), events in grouped_events.items():
            # Ograniczenie liczby wy≈õwietlanych grup
            if group_count >= max_groups:
                delegations_info += f"\n...oraz wiƒôcej zdarze≈Ñ dla innych u≈ºytkownik√≥w/dni ({len(grouped_events) - max_groups} wiƒôcej grup)...\n"
                break

            # Pobierz nazwƒô u≈ºytkownika z pierwszego zdarzenia
            user_name = events[0].get('user_name', f"ID: {user_id}")

            # Przygotuj datƒô w ≈Çadniejszym formacie (DD.MM.YYYY)
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            delegations_info += f"   üë§ {user_name} - üìÖ {formatted_date}:\n"

            # Wy≈õwietl zdarzenia dla tego u≈ºytkownika i daty
            for i, event in enumerate(events):
                delegations_info += f"      {i + 1}. {event['type']}: {event['name']}\n"

            group_count += 1

        return delegations_info

    def filter_processed_data(self):
        """
        Filtruje przetworzone dane na podstawie bie≈ºƒÖcych filtr√≥w.
        Zwraca przefiltrowane dane w formacie s≈Çownikowym.

        Returns:
            dict: Przefiltrowane dane
        """
        # Pobierz wszystkie dane z processed_data
        all_data = self.processed_data.copy() if hasattr(self, 'processed_data') else {}

        # Je≈õli nie ma danych do filtrowania, zwr√≥ƒá pusty s≈Çownik
        if not all_data:
            return {}

        # Pobierz wybrane filtry
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self,
                                                                                            'przelozony_list') else []
        selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list) if hasattr(self,
                                                                                             'uzytkownik_list') else []
        selected_dtn = self.dtn_combo.get_selected_items() if hasattr(self, 'dtn_combo') else []
        selected_role = self.rola_combo.get_selected_items() if hasattr(self, 'rola_combo') else []
        selected_jezyki = self.jezyk_combo.get_selected_items() if hasattr(self, 'jezyk_combo') else []
        selected_etaty = self.etat_combo.get_selected_items() if hasattr(self, 'etat_combo') else []
        selected_scp = self.system_czasu_pracy_combo.get_selected_items() if hasattr(self,
                                                                                     'system_czasu_pracy_combo') else []

        # Filtruj dane
        filtered_data = {}
        for key, data in all_data.items():
            wydzial, przelozony, uzytkownik_dane, uzytkownik = key

            # Pobierz warto≈õci p√≥l do filtrowania
            dtn = str(data.get('dtn', ''))
            rola_nazwa = data.get('rola_nazwa', '')
            jezyk = data.get('jezyk', '')
            etat = str(data.get('etat', '')) if data.get('etat') is not None else ''
            system_czasu_pracy = data.get('system_czasu_pracy', '')
            # Sprawd≈∫, czy dane spe≈ÇniajƒÖ kryteria filtrowania
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni) and \
                    (not selected_uzytkownicy or str(uzytkownik_dane) in selected_uzytkownicy) and \
                    (not selected_dtn or dtn in selected_dtn) and \
                    (not selected_role or rola_nazwa in selected_role) and \
                    (not selected_jezyki or jezyk in selected_jezyki) and \
                    (not selected_etaty or etat in selected_etaty):
                # Dodaj dane do przefiltrowanych wynik√≥w
                filtered_data[key] = data

        return filtered_data

    def _cancel_delegations(self, events_to_cancel_input: List[Dict]):
        debug_print(f"Rozpoczynam _cancel_delegations dla {len(events_to_cancel_input)} zdarze≈Ñ.")
        if not events_to_cancel_input:
            return 0

        successful_db_updates = 0
        # Lista par (user_id, date_key) dla zdarze≈Ñ, kt√≥re zosta≈Çy pomy≈õlnie zaktualizowane w DB
        affected_user_date_pairs_for_refresh = set()

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            _, user_app_id, _, _, _ = get_modifier_id()

            for event_details in events_to_cancel_input:
                event_id = event_details.get('id')
                event_type = event_details.get('type')
                user_id_for_event = event_details.get('user_id')  # U≈ºyj user_id z event_details
                date_key_for_event = event_details.get('date_key', event_details.get('date'))

                if not event_id or not event_type or not user_id_for_event or not date_key_for_event:
                    log_warning(f"Pominiƒôto zdarzenie z niepe≈Çnymi danymi w _cancel_delegations: {event_details}")
                    continue

                table_name = ""
                if event_type == "Spotkanie":
                    table_name = "p_t_zz_Spotkania"
                elif event_type == "Szkolenie":
                    table_name = "p_t_zz_Szkolenia"
                elif event_type == "Nadgodziny":
                    table_name = "p_t_zz_Nadgodziny"

                if not table_name:
                    log_warning(f"Nieznany typ zdarzenia w _cancel_delegations: {event_type}")
                    continue

                try:
                    if event_type in ["Spotkanie", "Szkolenie"]:
                        update_query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                        cursor.execute(update_query, (user_app_id, event_id))
                    else:  # Nadgodziny
                        delete_query = f"DELETE FROM {table_name} WHERE Id = ?"
                        cursor.execute(delete_query, (event_id,))

                    if cursor.rowcount > 0:
                        successful_db_updates += 1
                        affected_user_date_pairs_for_refresh.add((user_id_for_event, date_key_for_event))
                        debug_print(f"DB: Pomy≈õlnie zaktualizowano/usuniƒôto {event_type} ID {event_id}")
                    else:
                        log_warning(f"DB: Nie znaleziono {event_type} ID {event_id} do aktualizacji/usuniƒôcia.")

                except Exception as db_err:
                    log_error(f"B≈ÇƒÖd DB podczas odwo≈Çywania {event_type} ID {event_id}: {db_err}", exception=db_err)

            if successful_db_updates > 0:
                conn.commit()
                debug_print(f"DB: Zatwierdzono {successful_db_updates} zmian.")
                # Rejestrujemy, ≈ºe to my dokonali≈õmy zmiany w bazie danych
                self._update_modification_date()
            conn.close()

        except Exception as e:
            log_error(f"Generalny b≈ÇƒÖd w _cancel_delegations podczas operacji DB: {e}", exception=e)
            return 0  # Zwr√≥ƒá 0 je≈õli wystƒÖpi≈Ç b≈ÇƒÖd przed aktualizacjƒÖ UI

        # Je≈õli by≈Çy jakiekolwiek udane aktualizacje w DB
        if affected_user_date_pairs_for_refresh:
            debug_print(
                f"_cancel_delegations: Uruchamiam od≈õwie≈ºanie DataProvider dla {len(affected_user_date_pairs_for_refresh)} par.")
            # Krok 1: Uniewa≈ºnij i od≈õwie≈º cache DataProvider dla dotkniƒôtych zdarze≈Ñ/miesiƒôcy
            self.data_provider.invalidate_complete_cache_for_pairs(list(affected_user_date_pairs_for_refresh))

            # Krok 2: Od≈õwie≈º tabelƒô zdarze≈Ñ - on_selection_changed u≈ºyje ≈õwie≈ºych danych z DataProvider
            # Ta metoda zaktualizuje self.events_data i self.events_model
            debug_print(f"_cancel_delegations: Uruchamiam on_selection_changed() w celu od≈õwie≈ºenia tabeli zdarze≈Ñ.")
            selected_cells_data = self.table.get_data_for_selected_cells()  # Pobierz aktualnie zaznaczone kom√≥rki
            if selected_cells_data:
                self.on_selection_changed()  # To powinno teraz poprawnie wyczy≈õciƒá zdarzenia
            else:  # Je≈õli nic nie jest zaznaczone, wyczy≈õƒá tabelƒô zdarze≈Ñ rƒôcznie
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])
                debug_print("_cancel_delegations: Brak zaznaczenia, wyczyszczono tabelƒô zdarze≈Ñ.")

            # Krok 3: Zaktualizuj ikony w tabeli grafiku na podstawie ≈õwie≈ºych danych z DataProvider
            if hasattr(self, 'schedule_model'):
                debug_print(
                    f"_cancel_delegations: Uruchamiam aktualizacjƒô ikon grafiku dla {len(affected_user_date_pairs_for_refresh)} par.")
                for user_id, date_str in affected_user_date_pairs_for_refresh:
                    # Pobierz aktualne aktywne zdarzenia dla tej kom√≥rki z DataProvider
                    # DataProvider powinien teraz mieƒá ≈õwie≈ºe dane po invalidate_complete_cache_for_pairs
                    remaining_active_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                    has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_active_events)
                    has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_active_events)
                    has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_active_events)

                    self.schedule_model.update_cell_icons_directly(
                        user_id, date_str, has_meetings, has_trainings, has_overtime
                    )

            # Wymu≈õ od≈õwie≈ºenie widok√≥w tabel, je≈õli to konieczne
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        debug_print(f"_cancel_delegations: Zako≈Ñczono, pomy≈õlnie przetworzono w DB: {successful_db_updates} zdarze≈Ñ.")
        return successful_db_updates

    def update_filter_dates(self):
        """Aktualizuje daty filtrowania do pierwszego i ostatniego dnia wybranego miesiƒÖca"""
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # KLUCZOWA POPRAWKA: Blokuj sygna≈Çy przed zmianƒÖ dat
        self.date_from.blockSignals(True)
        self.date_to.blockSignals(True)
        
        try:
            # Pierwszy dzie≈Ñ miesiƒÖca
            first_day = QDate(year, month, 1)
            self.date_from.setDate(first_day)

            # Ostatni dzie≈Ñ miesiƒÖca
            if month == 12:
                next_month = QDate(year + 1, 1, 1)
            else:
                next_month = QDate(year, month + 1, 1)

            last_day = next_month.addDays(-1)
            self.date_to.setDate(last_day)
            
        finally:
            # ZAWSZE odblokuj sygna≈Çy
            self.date_from.blockSignals(False)
            self.date_to.blockSignals(False)

        # Wywo≈Çaj filtrowanie tylko RAZ po wszystkich zmianach
        self.filter_events_table()

    def on_date_combo_changed(self):
        """
        ZMODYFIKOWANA: Zmiana miesiƒÖca z async loading
        """
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            if self.staffing_details_win and not self.staffing_details_win.isHidden():
                self.staffing_details_win.update_for_new_month_or_filters(year, month)

            if hasattr(self.data_provider, 'on_month_change'):
                self.data_provider.on_month_change(year, month)

            self.update_data(year, month, use_async=True)
            self.update_filter_dates()

            # --- DODAJ Tƒò LINIƒò ---
            self.update_buttons_visibility()

    def update_data(self, year, month, use_async=True):
        """
        NOWA WERSJA: ≈Åadowanie danych z opcjƒÖ async

        Args:
            year: Rok
            month: MiesiƒÖc
            use_async: Czy u≈ºyƒá asynchronicznego ≈Çadowania (domy≈õlnie True)
        """
        debug_print(f"Rozpoczynam ≈Çadowanie danych dla {year}-{month} (async={use_async})")

        self.year = year
        self.month = month

        # Sprawd≈∫ czy modele zosta≈Çy zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            debug_print("Tworzƒô nowy model grafiku")
            self.schedule_model = ScheduleTableModel(self)
            self.schedule_model.set_theme(self.is_dark_theme)

            ui_columns = self.column_definitions.get_ui_display_columns()
            visible_cols = self.visible_columns
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

        if not hasattr(self, 'events_model') or not self.events_model:
            debug_print("Tworzƒô nowy model zdarze≈Ñ")
            self.events_model = EventsTableModel(self)
            self.events_model.set_theme(self.is_dark_theme)

        # KLUCZOWA ZMIANA: U≈ºyj async loading dla du≈ºych zbior√≥w danych
        if use_async:
            self._load_data_async(year, month)
        else:
            self._load_data_sync(year, month)

    def _load_data_sync(self, year, month):
        """
        Synchroniczne ≈Çadowanie danych (fallback), teraz sp√≥jne z logikƒÖ asynchronicznƒÖ.
        """
        debug_print(f"≈Åadowanie synchroniczne dla {year}-{month}")

        try:
            if hasattr(self, 'statusBar'):
                self.statusBar().showMessage(f"≈Åadowanie danych {year}-{month}...")

            # Krok 1: Pobierz kontener z danymi bazowymi
            container = self.data_provider._get_or_load_monthly_data(
                year, month, self.import_grupa, self.import_funkcja, use_cache=False
            )

            if container:
                # Krok 2: Pobierz przetworzone dane z na≈Ço≈ºonymi ikonami
                processed_data_with_icons = self.data_provider.get_processed_data(
                    year, month, self.import_grupa, self.import_funkcja
                )

                # Krok 3: Zastosuj wszystkie dane
                self._apply_loaded_data({
                    'schedule_data': container.schedule_data,
                    'events_data': container.events_data,
                    'processed_data': processed_data_with_icons,  # U≈ºywamy danych z ikonami
                    'year': year,
                    'month': month
                })
            else:
                log_error("Nie uda≈Ço siƒô pobraƒá danych z DataProvider w trybie synchronicznym.")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas synchronicznego ≈Çadowania: {e}", exception=e)

        finally:
            if hasattr(self, 'statusBar'):
                self.statusBar().clearMessage()

    def _load_data_async(self, year, month):
        """
        NOWA METODA: Asynchroniczne ≈Çadowanie danych z progress dialog
        """
        debug_print(f"Uruchamiam async ≈Çadowanie dla {year}-{month}")

        # Poka≈º dialog ≈Çadowania
        self.loading_dialog = LoadingProgressDialog(
            self, self.data_provider, year, month, self.import_grupa, self.import_funkcja
        )

        # Pod≈ÇƒÖcz sygna≈Çy
        self.loading_dialog.loading_completed.connect(self._on_async_data_loaded)
        self.loading_dialog.loading_cancelled.connect(self._on_async_loading_cancelled)
        self.loading_dialog.loading_failed.connect(self._on_async_loading_failed)

        # Poka≈º dialog
        result = self.loading_dialog.exec()

        # SprzƒÖtanie
        if hasattr(self, 'loading_dialog'):
            self.loading_dialog.deleteLater()
            delattr(self, 'loading_dialog')

    def _on_async_data_loaded(self, data):
        """
        NOWA METODA: Obs≈Çuguje pomy≈õlne za≈Çadowanie danych async
        """
        debug_print("Otrzymano dane z async loading")

        try:
            self._apply_loaded_data(data)
            debug_print("Pomy≈õlnie zastosowano dane z async loading")
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas stosowania za≈Çadowanych danych: {e}")

    def _on_async_loading_cancelled(self):
        """
        NOWA METODA: Obs≈Çuguje anulowanie ≈Çadowania
        """
        debug_print("Async loading zosta≈Ç anulowany przez u≈ºytkownika")
        # Mo≈ºna dodaƒá logikƒô powrotu do poprzedniego stanu

    def _on_async_loading_failed(self, error_message):
        """
        NOWA METODA: Obs≈Çuguje b≈Çƒôdy async loading
        """
        debug_print(f"Async loading failed: {error_message}")

        # Poka≈º komunikat b≈Çƒôdu u≈ºytkownikowi
        from PySide6.QtWidgets import QMessageBox
        QMessageBox.critical(
            self,
            "B≈ÇƒÖd ≈Çadowania danych",
            f"Nie uda≈Ço siƒô za≈Çadowaƒá danych:\n{error_message}\n\nSpr√≥buj ponownie lub skontaktuj siƒô z administratorem.",
            QMessageBox.Ok
        )

        # Fallback - spr√≥buj za≈Çadowaƒá synchronicznie
        try:
            debug_print("Pr√≥bujƒô fallback do synchronicznego ≈Çadowania")
            self._load_data_sync(self.year, self.month)
        except Exception as e:
            log_error(f"Fallback loading te≈º nie powi√≥d≈Ç siƒô: {e}")

    def _apply_loaded_data(self, data):
        """
        NOWA METODA: Aplikuje za≈Çadowane dane do modeli i UI
        """
        schedule_data = data['schedule_data']
        events_data = data['events_data']
        processed_data = data['processed_data']
        year = data['year']
        month = data['month']

        debug_print(f"Aplikujƒô dane: {len(schedule_data)} wierszy grafiku, "
                    f"{len(events_data)} zdarze≈Ñ, {len(processed_data)} u≈ºytkownik√≥w")

        # Aktualizuj model grafiku
        self.schedule_model.update_data(self.data_provider, year, month, self.import_grupa, self.import_funkcja)

        # Wyczy≈õƒá model zdarze≈Ñ
        debug_print("Model zdarze≈Ñ pozostaje pusty - oczekuje na zaznaczenie kom√≥rek")
        if not hasattr(self, 'events_data'):
            self.events_data = []
        if hasattr(self, 'events_model'):
            self.events_model.update_data([])  # Pusta tabela zdarze≈Ñ

        # Zachowaj dane dla kompatybilno≈õci
        self.raw_data = schedule_data
        self.all_events_data = events_data
        self.processed_data = processed_data

        # Filtruj dane grafiku
        debug_print("Filtrujƒô dane grafiku...")
        filtered_data = self.filter_processed_data()
        self.schedule_model.update_filtered_data(filtered_data)

        # Aktualizuj widoki
        if hasattr(self, 'table') and self.table:
            debug_print("Aktualizujƒô widok grafiku...")
            self.table.set_model(self.schedule_model)

        if hasattr(self, 'events_table') and self.events_table:
            debug_print("Aktualizujƒô widok zdarze≈Ñ (pusty)...")
            self.events_table.setModel(self.events_model)
            self.setup_event_table_columns()

        # Aktualizuj filtry
        debug_print("Aktualizujƒô filtry...")
        self.update_filters()

        # Ustaw daty filtrowania BEZ emitowania sygna≈Ç√≥w
        if hasattr(self, 'date_from') and hasattr(self, 'date_to'):
            # Oblicz pierwszy i ostatni dzie≈Ñ miesiƒÖca
            first_day = QDate(year, month, 1)

            # Ostatni dzie≈Ñ miesiƒÖca
            if month == 12:
                next_month = QDate(year + 1, 1, 1)
            else:
                next_month = QDate(year, month + 1, 1)
            last_day = next_month.addDays(-1)

            # Blokuj sygna≈Çy przed zmianƒÖ dat
            self.date_from.blockSignals(True)
            self.date_to.blockSignals(True)

            try:
                self.date_from.setDate(first_day)
                self.date_to.setDate(last_day)
            finally:
                # ZAWSZE odblokuj sygna≈Çy
                self.date_from.blockSignals(False)
                self.date_to.blockSignals(False)

        # Od≈õwie≈º widoki
        if hasattr(self, 'table'):
            if hasattr(self.table, 'employees_view'):
                self.table.employees_view.viewport().update()
            if hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

        debug_print("Zako≈Ñczono aplikowanie danych")
        self._set_schedule_columns_width()

    def clear_events_cache(self, year, month):
        """
        Czy≈õci cache zdarze≈Ñ dla danego miesiƒÖca - UPROSZCZONA WERSJA
        
        Args:
            year: Rok
            month: MiesiƒÖc
        """
        # POPRAWKA: Deleguj TYLKO do DataProvider, bez dodatkowych akcji
        if hasattr(self.data_provider, 'invalidate_icons_cache'):
            self.data_provider.invalidate_icons_cache(year, month)
            debug_print(f"Wyczyszczono cache zdarze≈Ñ dla {year}-{month}")
        else:
            debug_print(f"DataProvider nie ma metody invalidate_icons_cache")

    def get_events_for_user_date(self, user_id, date_str):
        """
        UPROSZCZONA METODA: Deleguje do DataProvider
        """
        return self.data_provider.get_events_for_user_date(user_id, date_str)

    def refresh_column_configuration(self):
        """Od≈õwie≈ºa konfiguracjƒô kolumn z ColumnDefinitions"""
        # ZMODYFIKOWANE: U≈ºywaj self.column_definitions zamiast column_manager
        # Pobierz zaktualizowane dane kolumn
        ui_columns = self.column_definitions.get_ui_display_columns()
        visible_cols = self.visible_columns

        # Aktualizuj referencje w g≈Ç√≥wnej klasie
        self.employee_columns = ui_columns

        # Aktualizuj model
        if hasattr(self, 'schedule_model') and self.schedule_model:
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

            # Je≈õli tabela ju≈º istnieje, zaktualizuj widok
            if hasattr(self, 'table') and self.table:
                self.table.set_model(self.schedule_model)
                # Dostosuj szeroko≈õƒá tabeli pracownik√≥w
                self.table.adjust_employees_table_width()

    def setup_event_table_columns(self):
        """
        Konfiguruje szeroko≈õci kolumn tabeli zdarze≈Ñ.
        Wyodrƒôbnione z metody update_data dla lepszej czytelno≈õci.
        """
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # U≈ºytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje


    def show_loading_indicator(self, message="≈Åadowanie..."):
        """
        Pokazuje wska≈∫nik ≈Çadowania w UI
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().showMessage(message)

        # Wy≈ÇƒÖcz niekt√≥re kontrolki podczas ≈Çadowania
        self.date_combo.setEnabled(False)
        self.refresh_button.setEnabled(False)

        if hasattr(self, 'left_panel_visible') and self.left_panel_visible:
            self._left_panel.setEnabled(False)

    def hide_loading_indicator(self):
        """
        Ukrywa wska≈∫nik ≈Çadowania
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().clearMessage()

        # W≈ÇƒÖcz z powrotem kontrolki
        self.date_combo.setEnabled(True)
        self.refresh_button.setEnabled(True)

        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(True)

    def get_loading_preferences(self):
        """
        Zwraca preferencje u≈ºytkownika dotyczƒÖce ≈Çadowania
        """
        # Mo≈ºna dodaƒá ustawienia w settings_db dla kontroli async loading
        # Na razie zawsze async dla du≈ºych zbior√≥w danych
        return {
            'use_async_threshold': 1000,  # U≈ºyj async dla >1000 wierszy
            'show_progress_dialog': True,
            'auto_fallback_to_sync': True
        }

    def check_for_new_data(self):
        """
        Sprawdza, czy w bazie pojawi≈Çy siƒô nowe dane grafiku lub zdarze≈Ñ,
        i tworzy szczeg√≥≈Çowe powiadomienie.
        """
        try:
            current_date_data = self.date_combo.currentData()
            if not current_date_data:
                return

            year, month = current_date_data

            if not hasattr(self, 'last_modification_date') or not self.last_modification_date:
                self._update_modification_date()
                debug_print(f"Zainicjowano datƒô ostatniej modyfikacji: {self.last_modification_date}")
                return

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # 1. Sprawd≈∫ najnowszƒÖ modyfikacjƒô w grafiku
            cursor.execute("SELECT MAX(DataModyfikacji) FROM [dbo].[p_T_ZZ_GrafikiPracy] WHERE Rok = ? AND Miesiac = ?", (year, month))
            schedule_max_date = cursor.fetchone()[0]

            # 2. Sprawd≈∫ najnowszƒÖ modyfikacjƒô w zdarzeniach
            cursor.execute("SELECT MAX(DataModyfikacji) FROM [dbo].[fn_GetEventsData](?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]

            conn.close()

            # --- NOWA LOGIKA: Oddzielna analiza obu ≈∫r√≥de≈Ç ---

            new_data_types = []

            # Sprawd≈∫, czy dane grafiku sƒÖ nowsze
            if schedule_max_date and schedule_max_date > self.last_modification_date:
                new_data_types.append("grafiku")

            # Sprawd≈∫, czy dane zdarze≈Ñ sƒÖ nowsze
            if events_max_date and events_max_date > self.last_modification_date:
                new_data_types.append("zdarze≈Ñ")

            # Je≈õli wykryto jakiekolwiek zmiany, sprawd≈∫, czy nie sƒÖ to zmiany w≈Çasne
            if new_data_types:
                latest_overall_modification = max(d for d in [schedule_max_date, events_max_date] if d)

                is_self_change = False
                if hasattr(self, 'last_self_modification_date') and self.last_self_modification_date:
                    time_diff = abs(latest_overall_modification - self.last_self_modification_date)
                    if time_diff < timedelta(seconds=2):
                        is_self_change = True

                # Je≈õli zmiana nie jest naszƒÖ w≈ÇasnƒÖ, wy≈õwietl szczeg√≥≈Çowe powiadomienie
                if not is_self_change:
                    change_type_text = " i ".join(new_data_types)

                    debug_print(f"Wykryto nowe dane w sekcji: {change_type_text}.")
                    self.refresh_button.setText(f"Nowe dane {change_type_text}!")
                    self.refresh_button.setToolTip(
                        f"Wykryto zmiany w sekcji: {change_type_text}. Kliknij, aby za≈Çadowaƒá.")

                    new_data_style = """
                        QPushButton {
                            background-color: #f39c12; color: white; font-weight: bold;
                            border: 1px solid #e67e22;
                        }
                        QPushButton:hover { background-color: #e67e22; }
                    """
                    self.refresh_button.setStyleSheet(new_data_style)
                    self.check_timer.stop()
                else:
                    # To nasza w≈Çasna zmiana, wiƒôc tylko aktualizujemy datƒô w tle
                    self.last_modification_date = latest_overall_modification
                    debug_print("Wykryto w≈ÇasnƒÖ zmianƒô, powiadomienie zignorowane.")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas sprawdzania nowych danych: {e}", exception=e)

    def refresh_data(self):
        """
        Pe≈Çne od≈õwie≈ºenie danych z async loading i aktualizacja daty ostatniej modyfikacji.
        """
        button_style = AppStyles.get_button_style("dark" if self.is_dark_theme else "light")
        self.refresh_button.setText("Od≈õwie≈º dane")
        self.refresh_button.setStyleSheet(button_style)
        self.refresh_button.setToolTip("Od≈õwie≈º dane")

        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            self.data_provider.refresh_data(year, month)
            self.update_data(year, month, use_async=True)

            # --- KLUCZOWA ZMIANA: Zaktualizuj bazowƒÖ datƒô po od≈õwie≈ºeniu ---
            # To sprawi, ≈ºe kolejne sprawdzanie bƒôdzie siƒô odnosiƒá do nowej, aktualnej daty.
            self._update_modification_date()

            if hasattr(self, 'check_timer'):
                self.check_timer.start(60000)
                debug_print("Dane od≈õwie≈ºone przez u≈ºytkownika, wznowiono automatyczne sprawdzanie.")

    def _update_modification_date(self):
        """
        Aktualizuje datƒô ostatniej modyfikacji po dokonaniu zmian,
        sprawdzajƒÖc oba ≈∫r√≥d≈Ça danych (grafik i zdarzenia).
        """
        try:
            current_date_data = self.date_combo.currentData()
            if not current_date_data:
                return

            year, month = current_date_data

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # 1. Sprawd≈∫ najnowszƒÖ modyfikacjƒô w grafiku
            cursor.execute("SELECT MAX(DataModyfikacji) FROM [dbo].[p_T_ZZ_GrafikiPracy] WHERE Rok = ? AND Miesiac = ?", (year, month))
            schedule_max_date = cursor.fetchone()[0]

            # 2. Sprawd≈∫ najnowszƒÖ modyfikacjƒô w zdarzeniach
            cursor.execute("SELECT MAX(DataModyfikacji) FROM [dbo].[fn_GetEventsData](?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]

            conn.close()

            all_dates = [d for d in [schedule_max_date, events_max_date] if d is not None]
            if not all_dates:
                return

            latest_modification = max(all_dates)

            # Zapisz jako ostatniƒÖ modyfikacjƒô w≈ÇasnƒÖ ORAZ jako og√≥lnƒÖ ostatniƒÖ znanƒÖ modyfikacjƒô
            self.last_self_modification_date = latest_modification
            self.last_modification_date = latest_modification
            debug_print(f"Zarejestrowano w≈ÇasnƒÖ modyfikacjƒô z datƒÖ: {self.last_self_modification_date}")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji daty modyfikacji: {e}", exception=e)

    def filter_data(self):
        """
        Filtruje dane grafiku i aktualizuje widok.
        ZMIENIONA WERSJA z wzajemnym filtrowaniem.
        """
        # Sprawd≈∫ czy model istnieje
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # POPRAWKA: Sprawd≈∫ czy nie jeste≈õmy ju≈º w trakcie filtrowania
        if getattr(self, '_updating_filters', False):
            return
            
        self._updating_filters = True
        
        try:
            # NOWE: Najpierw aktualizuj cross-filtry
            self.update_cross_filters()

            # Pobierz przefiltrowane dane
            filtered_data = self.filter_processed_data()

            # Aktualizuj model z przefiltrowanymi danymi
            self.schedule_model.update_filtered_data(filtered_data)
            
        finally:
            self._updating_filters = False
            current_data = self.date_combo.currentData()
            if current_data and self.staffing_details_win and not self.staffing_details_win.isHidden():
                year, month = current_data
                self.staffing_details_win.update_for_new_month_or_filters(year, month)

    def update_cross_filters(self):
        """
        NOWA METODA: Aktualizuje filtry wzajemnie na podstawie aktualnych wybor√≥w
        """
        # Sprawd≈∫ czy cross-filtering jest w≈ÇƒÖczone
        if not getattr(self, '_cross_filtering_enabled', True):
            return
            
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return
        
        # KLUCZOWA POPRAWKA: Sprawd≈∫ czy ju≈º jeste≈õmy w trakcie aktualizacji
        if getattr(self, '_updating_cross_filters', False):
            return
            
        # Ustaw flagƒô blokujƒÖcƒÖ
        self._updating_cross_filters = True

        try:
            # Pobierz aktualne wybory
            selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self, 'przelozony_list') else []
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list) if hasattr(self, 'uzytkownik_list') else []

            debug_print(f"Cross-filter: Wydzia≈Çy={len(selected_wydzialy)}, Prze≈Ço≈ºeni={len(selected_przelozeni)}, U≈ºytkownicy={len(selected_uzytkownicy)}")

            # === AKTUALIZACJA WYDZIA≈Å√ìW na podstawie prze≈Ço≈ºonych/u≈ºytkownik√≥w ===
            if hasattr(self, 'wydzial_combo'):
                available_wydzialy = set()
                
                # Je≈õli wybrano prze≈Ço≈ºonych, poka≈º tylko ich wydzia≈Çy
                if selected_przelozeni:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        if przelozony in selected_przelozeni and wydzial:
                            available_wydzialy.add(wydzial)
                
                # Je≈õli wybrano u≈ºytkownik√≥w, poka≈º tylko ich wydzia≈Çy
                elif selected_uzytkownicy:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        if str(uzytkownik_dane) in selected_uzytkownicy and wydzial:
                            available_wydzialy.add(wydzial)
                
                # Je≈õli nic nie wybrano, poka≈º wszystkie wydzia≈Çy
                else:
                    for key in self.processed_data.keys():
                        wydzial = key[0]
                        if wydzial:
                            available_wydzialy.add(wydzial)
                
                # Zachowaj wybrane wydzia≈Çy kt√≥re sƒÖ dostƒôpne
                valid_selected_wydzialy = [w for w in selected_wydzialy if w in available_wydzialy]
                
                # Aktualizuj combo wydzia≈Ç√≥w
                self.wydzial_combo.clear()
                self.wydzial_combo.add_items(sorted(available_wydzialy))
                self.wydzial_combo.select_items(valid_selected_wydzialy)

            # === AKTUALIZACJA PRZE≈ÅO≈ªONYCH na podstawie wydzia≈Ç√≥w/u≈ºytkownik√≥w ===
            if hasattr(self, 'przelozony_list'):
                available_przelozeni = set()
                
                # Je≈õli wybrano wydzia≈Çy, poka≈º tylko prze≈Ço≈ºonych z tych wydzia≈Ç√≥w
                if selected_wydzialy:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        if wydzial in selected_wydzialy and przelozony:
                            available_przelozeni.add(przelozony)
                
                # Je≈õli wybrano u≈ºytkownik√≥w, poka≈º tylko ich prze≈Ço≈ºonych
                elif selected_uzytkownicy:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        if str(uzytkownik_dane) in selected_uzytkownicy and przelozony:
                            available_przelozeni.add(przelozony)
                
                # Je≈õli nic nie wybrano, poka≈º wszystkich prze≈Ço≈ºonych
                else:
                    for key in self.processed_data.keys():
                        przelozony = key[1]
                        if przelozony:
                            available_przelozeni.add(przelozony)
                
                # Zachowaj wybranych prze≈Ço≈ºonych kt√≥rzy sƒÖ dostƒôpni
                valid_selected_przelozeni = [p for p in selected_przelozeni if p in available_przelozeni]
                
                # Aktualizuj listƒô prze≈Ço≈ºonych BEZPIECZNIE
                self.update_list_safely(self.przelozony_list, available_przelozeni, valid_selected_przelozeni)

            # === AKTUALIZACJA U≈ªYTKOWNIK√ìW na podstawie wydzia≈Ç√≥w/prze≈Ço≈ºonych ===
            if hasattr(self, 'uzytkownik_list'):
                available_uzytkownicy = set()
                
                # Je≈õli wybrano wydzia≈Çy i/lub prze≈Ço≈ºonych
                if selected_wydzialy or selected_przelozeni:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        
                        # Sprawd≈∫ czy pasuje do filtr√≥w wydzia≈Çu i prze≈Ço≈ºonego
                        wydzial_match = not selected_wydzialy or wydzial in selected_wydzialy
                        przelozony_match = not selected_przelozeni or przelozony in selected_przelozeni
                        
                        if wydzial_match and przelozony_match and uzytkownik_dane:
                            available_uzytkownicy.add(str(uzytkownik_dane))
                
                # Je≈õli nic nie wybrano, poka≈º wszystkich u≈ºytkownik√≥w
                else:
                    for key in self.processed_data.keys():
                        uzytkownik_dane = key[2]
                        if uzytkownik_dane:
                            available_uzytkownicy.add(str(uzytkownik_dane))
                
                # Zachowaj wybranych u≈ºytkownik√≥w kt√≥rzy sƒÖ dostƒôpni
                valid_selected_uzytkownicy = [u for u in selected_uzytkownicy if u in available_uzytkownicy]
                
                # Aktualizuj listƒô u≈ºytkownik√≥w BEZPIECZNIE
                self.update_list_safely(self.uzytkownik_list, available_uzytkownicy, valid_selected_uzytkownicy)

            debug_print("Cross-filter zako≈Ñczone")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas cross-filtrowania: {e}")
            import traceback
            traceback.print_exc()
        finally:
            # KLUCZOWA POPRAWKA: Zawsze odblokuj flagƒô
            self._updating_cross_filters = False

    def update_list_safely(self, list_widget, items, selected_items):
        """
        NOWA METODA: Bezpiecznie aktualizuje listƒô bez wywo≈Çania sygna≈Ç√≥w
        """
        if not list_widget:
            return
            
        # Blokuj sygna≈Çy podczas aktualizacji
        list_widget.blockSignals(True)
        
        try:
            list_widget.clear()
            for item_text in sorted(items):
                item = QListWidgetItem(item_text)
                list_widget.addItem(item)
                if item_text in selected_items:
                    item.setSelected(True)
        finally:
            # Zawsze odblokuj sygna≈Çy
            list_widget.blockSignals(False)

    def clear_filters(self):
        """
        Czy≈õci wszystkie filtry i aktualizuje model.
        ZMIENIONA WERSJA z pe≈Çnym resetem cross-filtr√≥w.
        """
        # NOWE: Tymczasowo wy≈ÇƒÖcz cross-filtering podczas czyszczenia
        self._cross_filtering_enabled = False
        
        try:
            # Wyczy≈õƒá filtry ComboBox z wielokrotnym wyborem
            for combo_name in ['wydzial_combo', 'dtn_combo', 'rola_combo', 'jezyk_combo', 'etat_combo']:
                if hasattr(self, combo_name):
                    combo = getattr(self, combo_name)
                    combo.clear_selection()

            # Wyczy≈õƒá filtry list BEZPIECZNIE
            if hasattr(self, 'przelozony_list'):
                self.przelozony_list.blockSignals(True)
                self.przelozony_list.clearSelection()
                self.przelozony_list.blockSignals(False)

            if hasattr(self, 'uzytkownik_list'):
                self.uzytkownik_list.blockSignals(True)
                self.uzytkownik_list.clearSelection()
                self.uzytkownik_list.blockSignals(False)

            # Wyczy≈õƒá pola filtrowania
            if hasattr(self, 'przelozony_filter'):
                self.przelozony_filter.clear()

            if hasattr(self, 'uzytkownik_filter'):
                self.uzytkownik_filter.clear()

            # Poka≈º wszystkie elementy list
            if hasattr(self, 'przelozony_list'):
                for i in range(self.przelozony_list.count()):
                    self.przelozony_list.item(i).setHidden(False)

            if hasattr(self, 'uzytkownik_list'):
                for i in range(self.uzytkownik_list.count()):
                    self.uzytkownik_list.item(i).setHidden(False)

            # Resetuj zmienne ≈õledzƒÖce filtry
            self._last_selected_wydzialy = []
            self._last_selected_przelozeni = []

            # NOWE: W≈ÇƒÖcz z powrotem cross-filtering
            self._cross_filtering_enabled = True

            # Flaga zabezpieczajƒÖca przed pƒôtlƒÖ w cross-filtering
            self._updating_cross_filters = False
            # Flaga zabezpieczajƒÖca przed pƒôtlƒÖ w filter_data
            self._updating_filters = False
            
            # Pe≈Çne od≈õwie≈ºenie filtr√≥w po wyczyszczeniu
            self.update_filters()  # Prze≈Çaduj wszystkie dostƒôpne opcje
            
            # Aktualizuj dane
            self.filter_data()
        
        finally:
            # Upewnij siƒô ≈ºe cross-filtering jest w≈ÇƒÖczone
            self._cross_filtering_enabled = True

    def filter_przelozony_list(self, text):
        """
        Filtruje listƒô prze≈Ço≈ºonych na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'przelozony_list'):
            return

        text = text.lower()
        for i in range(self.przelozony_list.count()):
            item = self.przelozony_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_uzytkownik_list(self, text):
        """
        Filtruje listƒô u≈ºytkownik√≥w na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'uzytkownik_list'):
            return

        text = text.lower()
        for i in range(self.uzytkownik_list.count()):
            item = self.uzytkownik_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def update_filtered_table(self):
        """
        Aktualizuje widok tabeli na podstawie zaznaczonych filtr√≥w
        """
        # Bezpo≈õrednio aktualizuj ca≈ÇƒÖ tabelƒô z przefiltrowanymi danymi
        self.update_table_content()

    def get_list_selected_items(self, list_widget):
        """
        Zwraca teksty zaznaczonych element√≥w z listy.
        POPRAWKA: Zmieniono nazwƒô metody z get_selected_items na get_list_selected_items,
        aby uniknƒÖƒá konfliktu z metodƒÖ get_selected_items w CustomMultiComboBox.

        Args:
            list_widget: QListWidget do pobrania zaznaczonych element√≥w

        Returns:
            list: Lista zaznaczonych tekst√≥w
        """
        if not list_widget:
            return []

        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item and item.isSelected():
                selected.append(item.text())
        return selected

    def update_filters(self):
        """
        LEKKO ZMODYFIKOWANA: processed_data przychodzi gotowe
        """
        try:
            debug_print("Rozpoczynam aktualizacjƒô filtr√≥w...")

            # Sprawd≈∫ czy mamy processed_data (ju≈º gotowe z DataProvider)
            if not hasattr(self, 'processed_data') or not self.processed_data:
                debug_print("Brak processed_data - pomijam aktualizacjƒô filtr√≥w")
                return

            # Zapamiƒôtaj bie≈ºƒÖce zaznaczenia
            selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
            selected_dtn = self.dtn_combo.get_selected_items() if hasattr(self, 'dtn_combo') else []
            selected_role = self.rola_combo.get_selected_items() if hasattr(self, 'rola_combo') else []
            selected_jezyki = self.jezyk_combo.get_selected_items() if hasattr(self, 'jezyk_combo') else []
            selected_etaty = self.etat_combo.get_selected_items() if hasattr(self, 'etat_combo') else []
            selected_scp = self.system_czasu_pracy_combo.get_selected_items() if hasattr(self, 'system_czasu_pracy_combo') else []
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

            # ZMIANA: Korzystaj z gotowego processed_data zamiast budowaƒá je od nowa
            if hasattr(self, 'wydzial_combo'):
                wydzialy = set()
                for key in self.processed_data.keys():
                    wydzial = key[0]
                    if wydzial:
                        wydzialy.add(wydzial)
                self.wydzial_combo.add_items(sorted(wydzialy))
                self.wydzial_combo.select_items(selected_wydzialy)
                debug_print(f"Dodano {len(wydzialy)} wydzia≈Ç√≥w")

            # Reszta logiki bez zmian - wszystkie pozosta≈Çe filtry
            if hasattr(self, 'dtn_combo'):
                dtn_values = set()
                for _, data in self.processed_data.items():
                    dtn = str(data.get('dtn', ''))
                    if dtn:
                        dtn_values.add(dtn)
                self.dtn_combo.add_items(sorted(dtn_values))
                self.dtn_combo.select_items(selected_dtn)

            if hasattr(self, 'rola_combo'):
                role = set()
                for _, data in self.processed_data.items():
                    rola = data.get('rola_nazwa', '')
                    if rola:
                        role.add(rola)
                self.rola_combo.add_items(sorted(role))
                self.rola_combo.select_items(selected_role)

            if hasattr(self, 'jezyk_combo'):
                jezyki = set()
                for _, data in self.processed_data.items():
                    jezyk = data.get('jezyk', '')
                    if jezyk:
                        jezyki.add(jezyk)
                self.jezyk_combo.add_items(sorted(jezyki))
                self.jezyk_combo.select_items(selected_jezyki)

            if hasattr(self, 'etat_combo'):
                etaty = set()
                for _, data in self.processed_data.items():
                    etat = str(data.get('etat', '')) if data.get('etat') is not None else ''
                    if etat:
                        etaty.add(etat)
                sorted_etaty = sorted(etaty, key=lambda x: float(x) if x.replace('.', '', 1).isdigit() else 0)
                self.etat_combo.add_items(sorted_etaty)
                self.etat_combo.select_items(selected_etaty)

            if hasattr(self, 'system_czasu_pracy_combo'):
                scp_values = set()
                for _, data in self.processed_data.items():
                    scp = data.get('system_czasu_pracy', '')
                    if scp:
                        scp_values.add(scp)
                self.system_czasu_pracy_combo.add_items(sorted(scp_values))
                self.system_czasu_pracy_combo.select_items(selected_scp)  # selected_scp zdefiniujemy w kolejnym kroku

            # Aktualizacja prze≈Ço≈ºonych i u≈ºytkownik√≥w
            self.update_przelozony_filter(selected_przelozeni)
            self.update_uzytkownik_filter(selected_uzytkownicy)

            debug_print("Zako≈Ñczono aktualizacjƒô filtr√≥w")

        except Exception as e:
            import traceback
            log_error(f"B≈ÇƒÖd podczas aktualizacji filtr√≥w: {e}")
            traceback.print_exc()

    def update_przelozony_filter(self, selected_przelozeni=None):
        """
        Aktualizuje listƒô prze≈Ço≈ºonych na podstawie wybranych wydzia≈Ç√≥w.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_przelozeni: Lista zaznaczonych prze≈Ço≈ºonych (opcjonalnie)
        """
        if not hasattr(self, 'przelozony_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiƒôtaj bie≈ºƒÖcƒÖ selekcjƒô je≈õli nie podano
        if selected_przelozeni is None:
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)

        self.przelozony_list.clear()

        # Pobierz wybrane wydzia≈Çy
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []

        # Zbi√≥r unikalnych prze≈Ço≈ºonych
        przelozeni = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, _, _ = key

            # Je≈õli nie wybrano wydzia≈Ç√≥w lub wydzia≈Ç pasuje do filtra
            if not selected_wydzialy or wydzial in selected_wydzialy:
                # Dodaj prze≈Ço≈ºonego do zbioru (tylko niepuste warto≈õci)
                if przelozony:
                    przelozeni.add(przelozony)

        # Dodaj posortowanych prze≈Ço≈ºonych do listy
        for przelozony in sorted(przelozeni):
            item = QListWidgetItem(przelozony)
            self.przelozony_list.addItem(item)

            # Przywr√≥ƒá zaznaczenie je≈õli by≈Ço
            if przelozony in selected_przelozeni:
                item.setSelected(True)

    def update_uzytkownik_filter(self, selected_uzytkownicy=None):
        """
        Aktualizuje listƒô u≈ºytkownik√≥w na podstawie wybranych wydzia≈Ç√≥w i prze≈Ço≈ºonych.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_uzytkownicy: Lista zaznaczonych u≈ºytkownik√≥w (opcjonalnie)
        """
        if not hasattr(self, 'uzytkownik_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiƒôtaj bie≈ºƒÖcƒÖ selekcjƒô je≈õli nie podano
        if selected_uzytkownicy is None:
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

        self.uzytkownik_list.clear()

        # Pobierz wybrane wydzia≈Çy i prze≈Ço≈ºonych
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self,
                                                                                            'przelozony_list') else []

        # Zbi√≥r unikalnych u≈ºytkownik√≥w (u≈ºyj stringa jako tekstowej reprezentacji)
        uzytkownicy = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, uzytkownik_dane, _ = key

            # Sprawd≈∫ czy dane pasujƒÖ do filtr√≥w
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni):
                # Dodaj u≈ºytkownika do zbioru (tylko niepuste warto≈õci)
                if uzytkownik_dane:
                    # Konwertuj do stringa dla sp√≥jno≈õci
                    uzytkownicy.add(str(uzytkownik_dane))

        # Dodaj posortowanych u≈ºytkownik√≥w do listy
        for uzytkownik in sorted(uzytkownicy):
            item = QListWidgetItem(uzytkownik)
            self.uzytkownik_list.addItem(item)

            # Przywr√≥ƒá zaznaczenie je≈õli by≈Ço
            if uzytkownik in selected_uzytkownicy:
                item.setSelected(True)

    def update_table_content(self):
        """
        Aktualizuje zawarto≈õƒá tabeli grafiku u≈ºywajƒÖc modelu danych.
        Zoptymalizowana wersja wykorzystujƒÖca precyzyjne aktualizacje.
        """
        # Sprawd≈∫ czy modele zosta≈Çy zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # Pobierz aktualny rok i miesiƒÖc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # Ustaw rok i miesiƒÖc w modelu (je≈õli jeszcze nie sƒÖ ustawione)
        if self.schedule_model._year != year or self.schedule_model._month != month:
            # Pobierz dane dla wybranego roku i miesiƒÖca
            schedule_data = self.data_provider.get_schedule_data(year, month, self.import_grupa, self.import_funkcja)

            # Aktualizuj model - to wywo≈Ça zoptymalizowanƒÖ metodƒô update_data
            self.schedule_model.update_data(schedule_data, year, month)
            self._set_schedule_columns_width()
        else:
            # Je≈õli rok i miesiƒÖc nie uleg≈Çy zmianie, tylko zastosuj filtry
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

    

    def get_cell_color_by_time(self, hour):
        """
        Zwraca kolor t≈Ça kom√≥rki na podstawie godziny rozpoczƒôcia.
        Godziny sƒÖ mapowane na kolory w bardziej czytelnej palecie.

        Args:
            hour (int): Godzina rozpoczƒôcia zmiany (0-23)

        Returns:
            QColor: Kolor t≈Ça kom√≥rki
        """
        # Domy≈õlny kolor (przezroczysty) gdy godzina nie jest zdefiniowana
        if hour is None or hour < 0 or hour > 23:
            return QColor(255, 255, 255, 0)  # Przezroczysty

        # Mapowanie godzin na kolory - zharmonizowana paleta
        if hour == 5:
            return QColor(204, 255, 255)  # Jasny b≈Çƒôkit (bardzo jasny cyjan)
        elif hour == 6:
            return QColor(204, 255, 255)  # Jasny b≈Çƒôkit (bardzo jasny cyjan)
        elif hour == 7:
            return QColor(0, 255, 255)  # Cyjan (akwamaryna)
        elif hour == 8:
            return QColor(0, 204, 255)  # Jasny b≈Çƒôkit (niebieskozielony)
        elif hour == 9:
            return QColor(0, 255, 0)  # Limonkowy (czysty zielony)
        elif hour == 10:
            return QColor(153, 204, 0)  # Oliwkowy (≈º√≥≈Çtozielony)
        elif hour == 11:
            return QColor(204, 255, 204)  # Bardzo jasny zielony (miƒôtowy)
        elif hour == 12:
            return QColor(255, 255, 153)  # Bardzo jasny ≈º√≥≈Çty (kremowy)
        elif hour == 13:
            return QColor(255, 204, 153)  # Jasny ≈Çososiowy (brzoskwiniowy)
        elif hour == 14:
            return QColor(255, 153, 0)  # Ciemny pomara≈Ñczowy
        elif hour == 15:
            return QColor(255, 0, 255)  # Magenta (fuksja)
        elif hour == 16:
            return QColor(204, 0, 0)  # Ciemnoczerwony
        elif hour == 17:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 18:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 19:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 20:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 21:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 22:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 23:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 0:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour in [1, 2, 3, 4]:
            return QColor(51, 51, 51)  # Ciemny szary

        # Domy≈õlny kolor dla innych warto≈õci
        return QColor(255, 255, 255, 0)  # Przezroczysty

    def on_selection_changed(self):
        """
        POPRAWIONA WERSJA: Debounced selection handling
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # DODANE: Sprawd≈∫ czy nie jeste≈õmy w trakcie aktualizacji
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        # NOWE: Zastop poprzedni timer i uruchom nowy (debouncing)
        if hasattr(self, '_selection_timer'):
            self._selection_timer.stop()
            self._selection_timer.start(self._selection_debounce_delay)

    def _handle_selection_change(self):
        """
        NOWA METODA: Faktyczna obs≈Çuga zmiany zaznaczenia (wywo≈Çywana po debounce)
        """
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        self._updating_selection = True

        try:
            debug_print("Zmiana zaznaczenia - aktualizujƒô tabelƒô zdarze≈Ñ...")

            # Pobierz dane dla zaznaczonych kom√≥rek
            selected_cells_data = self.table.get_data_for_selected_cells()
            debug_print(f"Zaznaczono {len(selected_cells_data)} kom√≥rek")

            if selected_cells_data and len(selected_cells_data) > 0:
                # MAMY ZAZNACZONE KOM√ìRKI - poka≈º zdarzenia
                events = []

                for cell_data in selected_cells_data:
                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')

                    if user_id and date_str:
                        # Pobierz aktualne zdarzenia z DataProvider
                        user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                        # Filtruj tylko aktywne zdarzenia (status != '0')
                        active_events = []
                        for event in user_events:
                            status = str(event.get('status', '1'))  # Domy≈õlnie aktywne
                            if status != '0':  # Tylko aktywne zdarzenia
                                # DODANE: Skonwertuj format na lokalny format UI
                                local_event = self._convert_dp_event_to_local(event)
                                active_events.append(local_event)

                        events.extend(active_events)

                debug_print(f"Pobrano {len(events)} aktywnych zdarze≈Ñ dla zaznaczonych kom√≥rek")

                # Zaktualizuj events_data
                self.events_data = events

                # Aktualizuj model zdarze≈Ñ
                if hasattr(self, 'events_model'):
                    self.events_model.update_data(self.events_data)

                    # WA≈ªNE: Zastosuj filtry po aktualizacji danych
                    self.filter_events_table()
            else:
                # BRAK ZAZNACZENIA - wyczy≈õƒá tabelƒô zdarze≈Ñ
                debug_print("Brak zaznaczenia - czyszczƒô tabelƒô zdarze≈Ñ")
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])

            # DODANE: Wymu≈õ od≈õwie≈ºenie widoku tabeli zdarze≈Ñ
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        finally:
            self._updating_selection = False

    def clear_events_on_startup(self):
        """
        NOWA METODA: Czy≈õci tabelƒô zdarze≈Ñ przy starcie aplikacji
        """
        debug_print("Czyszczƒô tabelƒô zdarze≈Ñ przy starcie aplikacji")

        # Wyczy≈õƒá dane zdarze≈Ñ
        self.events_data = []

        # Wyczy≈õƒá model zdarze≈Ñ je≈õli istnieje
        if hasattr(self, 'events_model') and self.events_model:
            self.events_model.update_data([])

        # Od≈õwie≈º widok tabeli zdarze≈Ñ
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

    def _convert_dp_event_to_local(self, dp_event):
        """
        NOWA METODA: Konwertuje format zdarzenia z DataProvider na lokalny format UI
        """
        try:
            # Skonwertuj datƒô z YYYY-MM-DD na DD.MM.YYYY
            date_key = dp_event.get('date_key', dp_event.get('date', ''))
            if date_key and '-' in date_key:
                year, month, day = date_key.split('-')
                display_date = f"{day}.{month}.{year}"
            else:
                display_date = dp_event.get('date_display', date_key)

            # Skonwertuj czas z formatu bazy na HH:MM
            time_from = dp_event.get('time_from', '')
            time_to = dp_event.get('time_to', '')
            
            if time_from and 'T' in time_from:
                time_from = time_from.split('T')[1].split(':')[0] + ':' + time_from.split('T')[1].split(':')[1]
            elif time_from and ' ' in time_from:
                time_from = time_from.split(' ')[1][:5]
                
            if time_to and 'T' in time_to:
                time_to = time_to.split('T')[1].split(':')[0] + ':' + time_to.split('T')[1].split(':')[1]
            elif time_to and ' ' in time_to:
                time_to = time_to.split(' ')[1][:5]

            # Pobierz nazwƒô u≈ºytkownika
            user_name = dp_event.get('user_name', '')
            if not user_name:
                user_id = dp_event.get('user_id')
                if user_id and hasattr(self, 'user_info_map') and user_id in self.user_info_map:
                    user_name = self.user_info_map[user_id].get('uzytkownik_dane', f"ID: {user_id}")
                else:
                    user_name = f"ID: {user_id}"

            # Utw√≥rz zdarzenie w lokalnym formacie
            local_event = {
                'type': dp_event.get('event_type', dp_event.get('type', '')),
                'topic': dp_event.get('topic', ''),
                'name': dp_event.get('name', ''),
                'user_id': dp_event.get('user_id'),
                'user_name': user_name,
                'date': display_date,
                'date_key': date_key,
                'time_from': time_from,
                'time_to': time_to,
                'status': dp_event.get('status', ''),
                'id': dp_event.get('event_id', dp_event.get('id'))
            }

            return local_event

        except Exception as e:
            log_error(f"B≈ÇƒÖd konwersji zdarzenia: {e}")
            # Zwr√≥ƒá zdarzenie w oryginalnym formacie w przypadku b≈Çƒôdu
            return dp_event
    
    def temporarily_disable_filters(self):
        """Tymczasowo wy≈ÇƒÖcza filtry zdarze≈Ñ aby zapewniƒá wy≈õwietlenie wszystkich danych"""
        # Zapamiƒôtaj obecny stan filtr√≥w
        self._saved_filters = {
            'meetings': self.meetings_checkbox.isChecked() if hasattr(self, 'meetings_checkbox') else True,
            'trainings': self.trainings_checkbox.isChecked() if hasattr(self, 'trainings_checkbox') else True,
            'overtime': self.overtime_checkbox.isChecked() if hasattr(self, 'overtime_checkbox') else True,
            'topic': self.topic_filter.text() if hasattr(self, 'topic_filter') else "",
            'name': self.name_filter.text() if hasattr(self, 'name_filter') else "",
            'date_from': self.date_from.date() if hasattr(self, 'date_from') else None,
            'date_to': self.date_to.date() if hasattr(self, 'date_to') else None
        }

        # Ustaw wszystkie filtry na warto≈õci, kt√≥re pokazujƒÖ wszystkie dane
        if hasattr(self, 'meetings_checkbox'):
            self.meetings_checkbox.setChecked(True)
        if hasattr(self, 'trainings_checkbox'):
            self.trainings_checkbox.setChecked(True)
        if hasattr(self, 'overtime_checkbox'):
            self.overtime_checkbox.setChecked(True)
        if hasattr(self, 'topic_filter'):
            self.topic_filter.setText("")
        if hasattr(self, 'name_filter'):
            self.name_filter.setText("")

        # Daty zostawiamy bez zmian, filtrowanie bƒôdzie nadpisane przez model

        debug_print("Tymczasowo wy≈ÇƒÖczono filtry zdarze≈Ñ")

    def restore_filters(self):
        """Przywraca filtry zdarze≈Ñ do ich poprzedniego stanu"""
        if not hasattr(self, '_saved_filters'):
            return

        # Przywr√≥ƒá filtry do ich poprzedniego stanu
        if hasattr(self, 'meetings_checkbox') and 'meetings' in self._saved_filters:
            self.meetings_checkbox.setChecked(self._saved_filters['meetings'])
        if hasattr(self, 'trainings_checkbox') and 'trainings' in self._saved_filters:
            self.trainings_checkbox.setChecked(self._saved_filters['trainings'])
        if hasattr(self, 'overtime_checkbox') and 'overtime' in self._saved_filters:
            self.overtime_checkbox.setChecked(self._saved_filters['overtime'])
        if hasattr(self, 'topic_filter') and 'topic' in self._saved_filters:
            self.topic_filter.setText(self._saved_filters['topic'])
        if hasattr(self, 'name_filter') and 'name' in self._saved_filters:
            self.name_filter.setText(self._saved_filters['name'])

        # Nie przywracamy dat, aby zapewniƒá sp√≥jno≈õƒá z zaznaczonymi kom√≥rkami

        debug_print("Przywr√≥cono filtry zdarze≈Ñ")

        # Wymu≈õ od≈õwie≈ºenie z nowymi filtrami
        self.filter_events_table()

    def filter_events_table(self):
        """
        Filtruje tabelƒô zdarze≈Ñ na podstawie zaznaczonych filtr√≥w i zakres√≥w dat.
        Zoptymalizowana wersja wykorzystujƒÖca model danych.
        """
        try:
            # Sprawd≈∫ czy model istnieje
            if not hasattr(self, 'events_model') or not self.events_model:
                return

            # KLUCZOWA ZMIANA: Najpierw sprawd≈∫, czy w og√≥le mamy dane do filtrowania
            if not hasattr(self, 'events_data') or not self.events_data:
                # Je≈õli nie ma danych, po prostu wyczy≈õƒá model
                self.events_model.update_data([])
                return

            # NAJWA≈ªNIEJSZE: U≈ºyj lokalnych danych events_data zamiast wszystkich zdarze≈Ñ
            # To zapewni, ≈ºe filtrujemy tylko zdarzenia dla zaznaczonych kom√≥rek
            base_data = self.events_data.copy()
            filtered_data = base_data.copy()

            # Przygotuj parametry filtrowania
            allowed_types = []
            if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
                allowed_types.append('Spotkanie')
            if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
                allowed_types.append('Szkolenie')
            if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
                allowed_types.append('Nadgodziny')

            # Filtruj po typach zdarze≈Ñ
            if allowed_types:
                filtered_data = [e for e in filtered_data if e.get('type') in allowed_types]

            # Filtruj po temacie
            topic_filter = self.topic_filter.text().lower() if hasattr(self, 'topic_filter') else ""
            if topic_filter:
                filtered_data = [e for e in filtered_data if topic_filter in str(e.get('topic', '')).lower()]

            # Filtruj po nazwie
            name_filter = self.name_filter.text().lower() if hasattr(self, 'name_filter') else ""
            if name_filter:
                filtered_data = [e for e in filtered_data if name_filter in str(e.get('name', '')).lower()]

            # Filtruj po datach (tylko je≈õli nie sƒÖ ustawione na zakres wybranego miesiƒÖca)
            date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
            date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

            if date_from_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') >= date_from_str]
            if date_to_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') <= date_to_str]

            # Aktualizuj model po filtrowaniu
            debug_print(f"Filtrowanie lokalne: z {len(base_data)} zdarze≈Ñ po filtrach zosta≈Ço {len(filtered_data)}")
            self.events_model.filtered_update(filtered_data)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas filtrowania zdarze≈Ñ: {str(e)}")
            import traceback
            traceback.print_exc()

    def diagnose_events_table(self):
        """Metoda diagnostyczna do sprawdzenia stanu tabeli zdarze≈Ñ"""
        debug_print("\n=== DIAGNOSTYKA TABELI ZDARZE≈É ===")

        if not hasattr(self, 'events_table') or not self.events_table:
            log_error("ERROR: Brak obiektu events_table!")
            return

        if not hasattr(self, 'events_model') or not self.events_model:
            log_error("ERROR: Brak obiektu events_model!")
            return

        # Sprawd≈∫ model
        debug_print(f"events_model ma {self.events_model.rowCount()} wierszy i {self.events_model.columnCount()} kolumn")
        debug_print(f"Dane w events_model: {len(self.events_model._data)} zdarze≈Ñ")
        debug_print(f"Przefiltrowane dane w events_model: {len(self.events_model._filtered_data)} zdarze≈Ñ")

        # Sprawd≈∫ filtry
        debug_print("\nAktualne filtry:")
        if hasattr(self, 'meetings_checkbox'):
            debug_print(f"Spotkania: {self.meetings_checkbox.isChecked()}")
        if hasattr(self, 'trainings_checkbox'):
            debug_print(f"Szkolenia: {self.trainings_checkbox.isChecked()}")
        if hasattr(self, 'overtime_checkbox'):
            debug_print(f"Nadgodziny: {self.overtime_checkbox.isChecked()}")
        if hasattr(self, 'topic_filter'):
            debug_print(f"Filtr tematu: '{self.topic_filter.text()}'")
        if hasattr(self, 'name_filter'):
            debug_print(f"Filtr nazwy: '{self.name_filter.text()}'")

        # Sprawd≈∫ przyk≈Çadowe dane
        if self.events_model._data:
            debug_print("\nPrzyk≈Çadowe zdarzenie z danych (przed filtrowaniem):")
            debug_print(self.events_model._data[0])

        if self.events_model._filtered_data:
            debug_print("\nPrzyk≈Çadowe zdarzenie z danych po filtrowaniu:")
            debug_print(self.events_model._filtered_data[0])

        # Sprawd≈∫ widok
        debug_print(f"\nWidok events_table: {self.events_table.model().rowCount()} wierszy")

        debug_print("=== KONIEC DIAGNOSTYKI TABELI ZDARZE≈É ===\n")

    def standardize_date(self, date_obj):
        """
        Standaryzuje format daty do 'YYYY-MM-DD' dla por√≥wna≈Ñ
        """
        if not date_obj:
            return ''

        # Je≈õli to ju≈º string, wyciƒÖgnij tylko datƒô
        if isinstance(date_obj, str):
            # Obs≈Çuga r√≥≈ºnych format√≥w
            if 'T' in date_obj:  # Format ISO 'YYYY-MM-DDThh:mm:ss'
                return date_obj.split('T')[0]
            elif ' ' in date_obj:  # Format 'YYYY-MM-DD hh:mm:ss'
                return date_obj.split(' ')[0]
            elif len(date_obj) == 10 and date_obj.count('-') == 2:  # Format 'YYYY-MM-DD'
                return date_obj
            # Je≈õli nie dopasowano do ≈ºadnego formatu, zwr√≥ƒá oryginalny string
            return date_obj

        # Je≈õli to obiekt datetime, skonwertuj na string
        if hasattr(date_obj, 'strftime'):
            return date_obj.strftime('%Y-%m-%d')

        # W przypadku nieznanego typu, zwr√≥ƒá pusty string
        return ''

    def diagnose_table_view(self):
        """Metoda diagnostyczna do sprawdzenia stanu SplitTableView"""
        if not hasattr(self, 'table') or not self.table:
            log_error("ERROR: Brak obiektu table!")
            return

        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            log_error("ERROR: Brak obiektu schedule_model!")
            return

        debug_print("\n=== DIAGNOSTYKA TABELI ===")

        # Sprawd≈∫ model
        debug_print(f"Model ma {self.schedule_model.rowCount()} wierszy i {self.schedule_model.columnCount()} kolumn")
        debug_print(f"Widoczne kolumny: {self.schedule_model.get_visible_columns()}")

        # Sprawd≈∫ widoki
        debug_print(
            f"Employees view ma {self.table.employees_view.model().rowCount()} wierszy i {self.table.employees_view.model().columnCount()} kolumn")
        debug_print(
            f"Schedule view ma {self.table.schedule_view.model().rowCount()} wierszy i {self.table.schedule_view.model().columnCount()} kolumn")

        # Sprawd≈∫ kolumny w employees_view
        for col in range(self.table.employees_view.model().columnCount()):
            hidden = self.table.employees_view.isColumnHidden(col)
            width = self.table.employees_view.columnWidth(col)
            debug_print(f"Kolumna {col} w employees_view: ukryta={hidden}, szeroko≈õƒá={width}px")

        # Sprawd≈∫ przyk≈Çadowe dane w pierwszym wierszu
        if self.schedule_model.rowCount() > 0:
            debug_print("\nPrzyk≈Çadowe dane z pierwszego wiersza:")
            for col in range(len(self.schedule_model.get_visible_columns())):
                index = self.schedule_model.index(0, col)
                text = self.schedule_model.data(index, Qt.DisplayRole)
                debug_print(f"Kolumna {col}: '{text}'")

        debug_print("=== KONIEC DIAGNOSTYKI ===\n")

    def diagnose_application_state(self):
        """Wykonuje pe≈ÇnƒÖ diagnostykƒô stanu aplikacji i wy≈õwietla szczeg√≥≈Çowe informacje"""
        try:
            debug_print("\n===== DIAGNOSTYKA STANU APLIKACJI =====")

            # 1. Sprawd≈∫ tabele i dane
            debug_print("\n--- TABELA GRAFIKU ---")
            debug_print(f"Liczba wierszy: {self.table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.table.columnCount()}")

            # Sprawd≈∫ pierwsze 3 wiersze i kolumny dla przyk≈Çadu
            debug_print("\nPrzyk≈Çadowe kom√≥rki z tabeli grafiku:")
            for row in range(min(3, self.table.rowCount())):
                for col in range(min(6, self.table.columnCount())):
                    item = self.table.item(row, col)
                    if item:
                        debug_print(f"[{row},{col}] Tekst: {item.text()}")
                        user_role_data = item.data(Qt.UserRole)
                        user_role_2 = item.data(Qt.UserRole + 2)
                        user_role_3 = item.data(Qt.UserRole + 3)
                        debug_print(
                            f"  UserRole: {type(user_role_data)}, UserRole+2: {user_role_2}, UserRole+3: {user_role_3}")
                        if isinstance(user_role_data, dict):
                            debug_print(f"  Zawarto≈õƒá: {user_role_data}")
                    else:
                        debug_print(f"[{row},{col}] Brak elementu")

            debug_print("\n--- TABELA ZDARZE≈É ---")
            debug_print(f"Liczba wierszy: {self.events_table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.events_table.columnCount()}")

            # Sprawd≈∫ zawarto≈õƒá events_data
            debug_print(
                f"\nLiczba zdarze≈Ñ w events_data: {len(self.events_data) if hasattr(self, 'events_data') else 'Brak'}")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print("Pierwsze zdarzenie:")
                for key, value in self.events_data[0].items():
                    debug_print(f"  {key}: {value}")

            # Sprawd≈∫ pierwsze 3 wiersze tabeli zdarze≈Ñ
            debug_print("\nPrzyk≈Çadowe wiersze z tabeli zdarze≈Ñ:")
            for row in range(min(3, self.events_table.rowCount())):
                row_data = []
                for col in range(self.events_table.columnCount() - 1):  # Pomijamy ostatniƒÖ kolumnƒô z przyciskami
                    item = self.events_table.item(row, col)
                    if item:
                        row_data.append(f"{col}:{item.text()}")
                debug_print(f"Wiersz {row}: {', '.join(row_data)}")

            # 2. Sprawd≈∫ delegaty i style
            debug_print("\n--- DELEGATY I STYLE ---")
            item_delegate = self.table.itemDelegate()
            debug_print(f"Delegat tabeli grafiku: {item_delegate.__class__.__name__}")
            if isinstance(item_delegate, OvertimeItemDelegate):
                debug_print("  Delegat OvertimeItemDelegate poprawnie przypisany")
            else:
                debug_print("  UWAGA: Delegat OvertimeItemDelegate nie jest przypisany!")

            # 3. Sprawd≈∫ filtrowanie danych
            debug_print("\n--- FILTROWANIE DANYCH ---")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print(f"Liczba zdarze≈Ñ przed filtrowaniem: {len(self.events_data)}")
                # Sprawd≈∫, czy metoda filter_events_table jest wywo≈Çywana
                debug_print("Spr√≥buj wykonaƒá filter_events_table:")
                try:
                    self.filter_events_table()
                    debug_print("  Metoda filter_events_table wykonana bez b≈Çƒôd√≥w")
                except Exception as e:
                    debug_print(f"  B≈ÅƒÑD podczas wykonywania filter_events_table: {e}")

            debug_print("\n===== KONIEC DIAGNOSTYKI =====\n")

        except Exception as e:
            debug_print(f"B≈ÅƒÑD podczas diagnostyki: {e}")
            import traceback
            traceback.print_exc()

    def show_schedule_control_dialog(self):
        """Pokazuje odpowiednie okno dialogowe w zale≈ºno≈õci od roli u≈ºytkownika."""
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Proszƒô najpierw wybraƒá miesiƒÖc.")
            return

        year, month = current_data

        # Importuj klasy dialogowe
        from schedule_control_dialog import ScheduleControlDialog, SuggestionsOutDialog

        # Sprawd≈∫ rolƒô i otw√≥rz odpowiednie okno
        if self.current_user_role == "Pracownik WPR":
            dialog = ScheduleControlDialog(self, year, month)
            dialog.data_refresh_needed.connect(self.refresh_data)
            dialog.exec()
        elif self.current_user_role == "Lider OUT":
            dialog = SuggestionsOutDialog(self, year, month)
            dialog.data_refresh_needed.connect(self.refresh_data)
            dialog.exec()
        else:
            QMessageBox.information(self, "Brak uprawnie≈Ñ", "Twoja rola nie ma dostƒôpu do tej funkcji.")

    def _get_current_event_filter_params(self):
        """
        Pobiera bie≈ºƒÖce parametry filtrowania zdarze≈Ñ.

        Returns:
            dict: Parametry filtrowania
        """
        filter_params = {}

        # Dodaj filtr typ√≥w zdarze≈Ñ
        allowed_types = []
        if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
            allowed_types.append('Spotkanie')
        if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
            allowed_types.append('Szkolenie')
        if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
            allowed_types.append('Nadgodziny')

        if allowed_types:
            filter_params['allowed_types'] = allowed_types

        # Dodaj filtry tematu i nazwy
        topic_filter = self.topic_filter.text().lower() if hasattr(self,
                                                                   'topic_filter') and self.topic_filter.text() else None
        name_filter = self.name_filter.text().lower() if hasattr(self,
                                                                 'name_filter') and self.name_filter.text() else None

        if topic_filter:
            filter_params['topic'] = topic_filter
        if name_filter:
            filter_params['name'] = name_filter

        # Dodaj filtry zakresu dat
        date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
        date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

        if date_from_str:
            filter_params['date_from'] = date_from_str
        if date_to_str:
            filter_params['date_to'] = date_to_str

        return filter_params

    def find_cell_position(self, user_id, date_str):
        """
        Znajduje pozycjƒô kom√≥rki dla podanego u≈ºytkownika i daty, korzystajƒÖc z modelu.

        Args:
            user_id: ID u≈ºytkownika
            date_str: Data w formacie YYYY-MM-DD

        Returns:
            tuple: (wiersz, dzie≈Ñ) lub (-1, -1) je≈õli nie znaleziono
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return -1, -1

        # Pobierz dzie≈Ñ z daty
        try:
            year, month, day_str = date_str.split('-')
            day = int(day_str)
        except:
            return -1, -1

        # Pobierz liczbƒô wierszy w modelu
        row_count = self.schedule_model.rowCount()

        # Dla ka≈ºdego wiersza sprawd≈∫, czy odpowiada szukanemu u≈ºytkownikowi
        for row in range(row_count):
            # Pobierz ID u≈ºytkownika z pierwszej kolumny
            index = self.schedule_model.index(row, 0)
            user_data = self.schedule_model.data(index, Qt.UserRole)

            if isinstance(user_data, dict) and str(user_data.get('uzytkownik_id', '')) == str(user_id):
                return row, day

        return -1, -1

    def _get_cell_data_for_user_date_pairs(self, user_date_pairs: list) -> list:
        """
        Na podstawie listy par (user_id, date_str) odnajduje i zwraca
        pe≈Çne dane kom√≥rek z modelu grafiku.
        """
        if not self.schedule_model or not user_date_pairs:
            return []

        cells_data_to_return = []
        # Stw√≥rz mapƒô dla szybszego wyszukiwania wierszy
        user_row_map = {str(key[3]): idx for idx, key in enumerate(self.schedule_model._keys)}

        for user_id, date_str in user_date_pairs:
            row = user_row_map.get(str(user_id))
            if row is not None:
                try:
                    # Oblicz indeks kolumny na podstawie daty
                    day = int(date_str.split('-')[2])
                    col_offset = len(self.schedule_model.get_visible_columns())
                    col = col_offset + day - 1

                    # Pobierz pe≈Çne dane kom√≥rki z modelu
                    index = self.schedule_model.index(row, col)
                    cell_data = self.schedule_model.data(index, self.schedule_model.ROLE_DATA)
                    if isinstance(cell_data, dict):
                        cells_data_to_return.append(cell_data)
                except (ValueError, IndexError) as e:
                    log_warning(f"Nie uda≈Ço siƒô znale≈∫ƒá danych dla kom√≥rki ({user_id}, {date_str}): {e}")

        return cells_data_to_return

    def cancel_delegations(self):
        """
        POPRAWIONA WERSJA: Odwo≈Çuje delegacje z pe≈Çnym od≈õwie≈ºaniem ikon i tabeli zdarze≈Ñ
        """
        debug_print("\n=== ROZPOCZYNAM OPERACJƒò ODWO≈ÅYWANIA DELEGACJI ===")

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Brak danych",
                "Nie wybrano miesiƒÖca lub brak dostƒôpnych danych do wy≈õwietlenia.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone kom√≥rki
        selected_cells_data = self.get_selected_cells_data()

        if not self._can_modify_cells(selected_cells_data):
            return  # Zatrzymaj operacjƒô, je≈õli u≈ºytkownik nie ma uprawnie≈Ñ

        if not selected_cells_data:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono ≈ºadnych kom√≥rek. Zaznacz kom√≥rki, dla kt√≥rych chcesz odwo≈Çaƒá delegacje.",
                QMessageBox.Ok
            )
            return

        # Zbierz pary (user_id, date_str) z zaznaczonych kom√≥rek
        user_date_pairs = []
        for cell_data in selected_cells_data:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if user_id and date_str:
                user_date_pairs.append((user_id, date_str))

        if not user_date_pairs:
            QMessageBox.information(
                self,
                "Brak danych",
                "Nie znaleziono danych dla zaznaczonych kom√≥rek.",
                QMessageBox.Ok
            )
            return

        debug_print(f"Sprawdzam delegacje dla {len(user_date_pairs)} par (u≈ºytkownik, data)")

        # Znajd≈∫ delegacje do odwo≈Çania
        events_to_cancel = []
        grouped_events = {}

        for user_id, date_str in user_date_pairs:
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)
            
            for event in user_events:
                event_type = event.get('type', '')
                event_id = event.get('id')
                event_status = event.get('status')

                if not event_type or event_id is None:
                    continue

                if event_status is not None:
                    event_status = str(event_status)

                if event_type in ['Spotkanie', 'Szkolenie', 'Nadgodziny'] and event_status != '0':
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),
                    })

                    key = (user_id, date_str)
                    if key not in grouped_events:
                        grouped_events[key] = []
                    grouped_events[key].append(event)

        debug_print(f"Znaleziono {len(events_to_cancel)} delegacji do odwo≈Çania")

        if not events_to_cancel:
            QMessageBox.information(
                self,
                "Brak delegacji",
                "Nie znaleziono delegacji do odwo≈Çania dla zaznaczonych kom√≥rek.",
                QMessageBox.Ok
            )
            return

        # Poka≈º potwierdzenie
        delegations_info = self._prepare_delegations_description(grouped_events)
        confirm_message = f"Czy na pewno chcesz odwo≈Çaƒá nastƒôpujƒÖce delegacje?\n\n{delegations_info}\n"
        confirm_message += f"≈ÅƒÖcznie: {len(events_to_cancel)} delegacji dla {len(user_date_pairs)} kom√≥rek"

        reply = QMessageBox.question(
            self,
            "Potwierdzenie odwo≈Çania delegacji",
            confirm_message,
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply != QMessageBox.Yes:
            debug_print("=== OPERACJA ANULOWANA PRZEZ U≈ªYTKOWNIKA ===")
            return

        try:
            # Odwo≈Çaj delegacje w bazie danych
            canceled_count = self._cancel_delegations(events_to_cancel)

            if canceled_count > 0:
                # KLUCZOWA ZMIANA 1: Usu≈Ñ zdarzenia z lokalnych danych
                affected_pairs = []
                for event in events_to_cancel:
                    user_id = event.get('user_id')
                    date_str = event.get('date_key', event.get('date'))
                    if user_id and date_str:
                        affected_pairs.append((user_id, date_str))
                        
                    # Usu≈Ñ z events_data (tabela zdarze≈Ñ)
                    if hasattr(self, 'events_data'):
                        self.events_data = [e for e in self.events_data 
                                        if not (e.get('id') == event.get('id') and 
                                                e.get('type') == event.get('type'))]
                    
                    # Usu≈Ñ z all_events_data
                    if hasattr(self, 'all_events_data'):
                        self.all_events_data = [e for e in self.all_events_data 
                                            if not (e.get('id') == event.get('id') and 
                                                    e.get('type') == event.get('type'))]

                # KLUCZOWA ZMIANA 2: Od≈õwie≈º model zdarze≈Ñ
                if hasattr(self, 'events_model') and hasattr(self, 'events_data'):
                    self.events_model.update_data(self.events_data)
                    debug_print(f"Zaktualizowano model zdarze≈Ñ - pozosta≈Ço {len(self.events_data)} zdarze≈Ñ")

                # KLUCZOWA ZMIANA 3: Wyczy≈õƒá cache i od≈õwie≈º ikony
                affected_pairs = list(set(affected_pairs))  # Usu≈Ñ duplikaty
                
                # Wyczy≈õƒá cache zdarze≈Ñ w DataProvider
                self.data_provider.invalidate_icons_cache(year, month)
                
                # Od≈õwie≈º konkretne ikony
                self.data_provider.invalidate_specific_icons(affected_pairs)
                debug_print(f"Od≈õwie≈ºono ikony dla {len(affected_pairs)} zmienionych kom√≥rek")

                # KLUCZOWA ZMIANA 4: Od≈õwie≈º model grafiku dla zmienionych kom√≥rek
                if hasattr(self, 'schedule_model'):
                    for user_id, date_str in affected_pairs:
                        # Aktualizuj wska≈∫niki zdarze≈Ñ w modelu
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', False)
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', False)
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', False)

                # KLUCZOWA ZMIANA 5: Wymu≈õ od≈õwie≈ºenie widok√≥w
                if hasattr(self, 'table'):
                    if hasattr(self.table, 'schedule_view'):
                        self.table.schedule_view.viewport().update()
                    if hasattr(self.table, 'employees_view'):
                        self.table.employees_view.viewport().update()

                if hasattr(self, 'events_table'):
                    self.events_table.viewport().update()

                # KLUCZOWA ZMIANA 6: Kompleksowe od≈õwie≈ºenie po odwo≈Çaniu delegacji
                # 1. Kompletne czyszczenie cache
                if hasattr(self.data_provider, 'invalidate_complete_cache_for_pairs'):
                    self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)

                # 2. Aktualizuj ikony w modelu grafiku
                if hasattr(self, 'schedule_model'):
                    for user_id, date_str in affected_pairs:
                        # Sprawd≈∫ pozosta≈Çe zdarzenia w lokalnych danych
                        remaining_events = [e for e in self.events_data 
                                        if e.get('user_id') == user_id and e.get('date_key') == date_str]
                        
                        # Oblicz ikony na podstawie pozosta≈Çych zdarze≈Ñ  
                        has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                        has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                        has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)
                        
                        # Aktualizuj ikony w modelu
                        self.schedule_model.update_cell_icons_directly(
                            user_id, date_str, has_meetings, has_trainings, has_overtime
                        )

                # 3. Od≈õwie≈º tabelƒô zdarze≈Ñ dla zaznaczonych kom√≥rek
                selected_cells = self.table.get_data_for_selected_cells()
                if selected_cells:
                    self.on_selection_changed()
                else:
                    self.events_data = []
                    if hasattr(self, 'events_model'):
                        self.events_model.update_data([])

                QMessageBox.information(
                    self,
                    "Sukces",
                    f"Pomy≈õlnie odwo≈Çano {canceled_count} delegacji z {len(events_to_cancel)} znalezionych.",
                    QMessageBox.Ok
                )

                debug_print(f"=== ZAKO≈ÉCZONO POMY≈öLNIE - ODWO≈ÅANO {canceled_count} DELEGACJI ===")
            else:
                QMessageBox.warning(
                    self,
                    "Brak zmian",
                    "Nie uda≈Ço siƒô odwo≈Çaƒá ≈ºadnej delegacji. Sprawd≈∫ logi aplikacji.",
                    QMessageBox.Ok
                )

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas odwo≈Çywania delegacji: {e}")
            QMessageBox.critical(
                self,
                "B≈ÇƒÖd",
                f"WystƒÖpi≈Ç b≈ÇƒÖd podczas odwo≈Çywania delegacji: {str(e)}",
                QMessageBox.Ok
            )

    def get_data_from_model(self, row, col):
        """
        Pobiera dane z kom√≥rki modelu na podstawie wierszy i kolumn.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny

        Returns:
            dict: Dane kom√≥rki lub pusty s≈Çownik
        """
        if not hasattr(self, 'schedule_model'):
            return {}

        # Pobierz dane z modelu
        index = self.schedule_model.index(row, col)
        cell_data = self.schedule_model.data(index, Qt.UserRole)

        # Upewnij siƒô, ≈ºe dane sƒÖ s≈Çownikiem
        if not isinstance(cell_data, dict):
            return {}

        return cell_data

    def get_selected_cells_data(self):
        """
        Pobiera dane dla zaznaczonych kom√≥rek z modelu.

        Returns:
            list: Lista danych zaznaczonych kom√≥rek
        """
        if not hasattr(self, 'table') or not self.table:
            return []

        # Deleguj do metody w SplitTableView, kt√≥ra ju≈º obs≈Çuguje model
        return self.table.get_data_for_selected_cells()

    def update_model_after_data_change(self, user_id, date_str):
        """
        Aktualizuje dane w modelu po zmianach w bazie danych.

        Args:
            user_id: ID u≈ºytkownika
            date_str: Data w formacie YYYY-MM-DD
        """
        if not user_id or not date_str:
            return

        # Pobierz rok i miesiƒÖc z daty
        if date_str.count('-') != 2:
            return

        year, month, _ = date_str.split('-')
        try:
            year = int(year)
            month = int(month)
        except ValueError:
            return

        # Pobierz aktualne dane z DataProvider - wymu≈õ od≈õwie≈ºenie cache
        self.data_provider.clear_cache()
        schedule_data = self.data_provider.get_schedule_data(year, month, use_cache=False)

        # Aktualizuj model
        if schedule_data and hasattr(self, 'schedule_model'):
            # Aktualizuj model bezpo≈õrednio
            self.schedule_model.update_data(schedule_data, year, month)

            # Zaktualizuj przefiltrowane dane
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

            # Od≈õwie≈º widok
            if hasattr(self, 'table'):
                self.table.update()

    def setup_model_connections(self):
        """
        ≈ÅƒÖczy sygna≈Çy modeli z obs≈ÇugƒÖ interfejsu u≈ºytkownika.
        """
        # Po≈ÇƒÖcz zmiany w modelach z aktualizacjƒÖ interfejsu
        if hasattr(self, 'schedule_model'):
            self.schedule_model.dataChanged.connect(self.on_schedule_data_changed)

        if hasattr(self, 'events_model'):
            self.events_model.dataChanged.connect(self.on_events_data_changed)

    def on_schedule_data_changed(self, topLeft, bottomRight):
        """
        Obs≈Çuguje zmianƒô danych w modelu grafiku.

        Args:
            topLeft: Indeks g√≥rnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Od≈õwie≈º widok
        if hasattr(self, 'table'):
            self.table.update()

        # Je≈õli zmieni≈Ço siƒô zaznaczenie, zaktualizuj tabelƒô zdarze≈Ñ
        if self.table.selection_changed.receivers() > 0:
            selected_rows = self.table.get_selected_rows()
            if selected_rows:
                self.on_selection_changed()

    def on_events_data_changed(self, topLeft, bottomRight):
        """
        Obs≈Çuguje zmianƒô danych w modelu zdarze≈Ñ.

        Args:
            topLeft: Indeks g√≥rnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Od≈õwie≈º tabelƒô zdarze≈Ñ
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

  
    def show_insert_change_dialog(self):
        """Pokazuje okno dialogowe do wstawiania zmian w grafiku"""
        # Pobierz aktualnƒÖ datƒô z tabeli grafiku
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "B≈ÇƒÖd",
                "Nie wybrano miesiƒÖca. Nie mo≈ºna dodaƒá zmiany grafiku.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # ZMIANA: U≈ºyj metody get_data_for_selected_cells z SplitTableView
        selected_cells = self.table.get_data_for_selected_cells()

        if not self._can_modify_cells(selected_cells):
            return

        if not selected_cells:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono ≈ºadnych kom√≥rek do edycji.",
                QMessageBox.Ok
            )
            return

        # Grupuj kom√≥rki wed≈Çug u≈ºytkownika i dnia dla ≈Çatwiejszej edycji
        grouped_cells = self.group_cells_by_user_and_day(selected_cells)

        # Utw√≥rz dialog
        dialog = ScheduleChangeDialog(self, grouped_cells, year, month)
        dialog.exec()

    def get_selected_schedule_cells(self):
        """Zwraca listƒô zaznaczonych kom√≥rek z siatki grafiku"""
        selected_cells = []
        selected_ranges = self.table.selectedRanges()

        for range_item in selected_ranges:
            for row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawd≈∫ czy to kom√≥rka z grafikiem
                    if col >= 3:
                        # Pobierz element tabeli
                        cell_item = self.table.item(row, col)
                        if not cell_item:
                            continue

                        # Pobierz dane z kom√≥rki
                        cell_data = self.get_cell_data(cell_item)
                        if not cell_data:
                            continue

                        # Dodaj dane do listy wybranych kom√≥rek
                        selected_cells.append(cell_data)

        return selected_cells

    def group_cells_by_user_and_day(self, cells):
        """Grupuje kom√≥rki wed≈Çug u≈ºytkownika i dnia dla ≈Çatwiejszej edycji"""
        grouped = {}
        for cell in cells:
            # ZMIANA: Dostosuj do nowej struktury danych z modelu
            user_id = cell.get('uzytkownik_id')  # Zmieniono z 'user_id'
            date_str = cell.get('date_str')      # Zmieniono z 'date'

            if not user_id or not date_str:
                continue

            if user_id not in grouped:
                grouped[user_id] = {}

            if date_str not in grouped[user_id]:
                grouped[user_id][date_str] = []

            grouped[user_id][date_str].append(cell)

        return grouped

    def delete_event(self, event_id, event_type):
        """Wersja z weryfikacjƒÖ uprawnie≈Ñ przed usuniƒôciem."""
        # Krok 1: Znajd≈∫ kom√≥rki, kt√≥rych dotyczy zmiana
        affected_pairs = []
        event_to_delete = None
        # Przeszukujemy dane zdarze≈Ñ (te aktualnie wy≈õwietlane w tabeli)
        for event in (self.events_data or []):
            if event.get('id') == event_id and event.get('type') == event_type:
                user_id = event.get('user_id')
                date_key = event.get('date_key')
                if user_id and date_key:
                    affected_pairs.append((user_id, date_key))
                    event_to_delete = event
                    break  # Zak≈Çadamy unikalne ID, wiƒôc mo≈ºemy przerwaƒá

        if not event_to_delete:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Nie mo≈ºna odnale≈∫ƒá zdarzenia do usuniƒôcia.")
            return

        # Krok 2: Pobierz pe≈Çne dane kom√≥rek i przeprowad≈∫ walidacjƒô uprawnie≈Ñ
        cells_to_check = self._get_cell_data_for_user_date_pairs(affected_pairs)
        if not self._can_modify_cells(cells_to_check):
            return  # Zatrzymaj, je≈õli brak uprawnie≈Ñ

        # Krok 3: Popro≈õ o potwierdzenie (je≈õli walidacja przesz≈Ça pomy≈õlnie)
        reply = QMessageBox.question(
            self, "Potwierdzenie",
            f"Czy na pewno chcesz usunƒÖƒá {event_type.lower()} o ID {event_id}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.Yes
        )

        if reply != QMessageBox.StandardButton.Yes:
            return

        # Krok 4: Wykonaj operacjƒô usuniƒôcia (istniejƒÖca logika)
        try:
            _, user_app_id, _, _, _ = get_modifier_id()
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            table_name = ""
            if event_type == "Spotkanie":
                table_name = "p_t_zz_Spotkania"
            elif event_type == "Szkolenie":
                table_name = "p_t_zz_Szkolenia"
            elif event_type == "Nadgodziny":
                table_name = "p_t_zz_Nadgodziny"
            else:
                return

            if event_type in ["Spotkanie", "Szkolenie"]:
                query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                cursor.execute(query, (user_app_id, event_id))
            else:
                query = f"DELETE FROM {table_name} WHERE Id = ?"
                cursor.execute(query, (event_id,))

            conn.commit()
            conn.close()
            self._update_modification_date()

            self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)

            if hasattr(self, 'schedule_model'):
                for user_id, date_str in affected_pairs:
                    remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                    has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                    has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                    has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)
                    self.schedule_model.update_cell_icons_directly(
                        user_id, date_str, has_meetings, has_trainings, has_overtime
                    )

            self.on_selection_changed()

            QMessageBox.information(self, "Sukces", f"{event_type} o ID {event_id} zosta≈Ço pomy≈õlnie usuniƒôte.",
                                    QMessageBox.StandardButton.Ok)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas usuwania zdarzenia: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas usuwania zdarzenia: {str(e)}",
                                 QMessageBox.StandardButton.Ok)

    def show_add_overtime_dialog(self):
        """
        Pokazuje okno dialogowe do dodawania nadgodzin.
        POPRAWIONA WERSJA - bez duplikacji zdarze≈Ñ i z prawid≈Çowym ustawianiem ikon.
        """
        # Pobierz bie≈ºƒÖcƒÖ datƒô z tabeli grafiku
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "B≈ÇƒÖd",
                "Nie wybrano miesiƒÖca. Nie mo≈ºna dodaƒá nadgodzin.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone kom√≥rki z modelu
        selected_cells_data = self.table.get_data_for_selected_cells()

        if not self._can_modify_cells(selected_cells_data):
            return

        # Sprawd≈∫ liczbƒô zaznaczonych kom√≥rek
        if not selected_cells_data:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono ≈ºadnej kom√≥rki. Zaznacz dok≈Çadnie jednƒÖ kom√≥rkƒô, aby dodaƒá nadgodziny.",
                QMessageBox.Ok
            )
            return

        # Je≈õli zaznaczono wiƒôcej ni≈º jednƒÖ kom√≥rkƒô, wy≈õwietl komunikat i zako≈Ñcz
        if len(selected_cells_data) > 1:
            QMessageBox.warning(
                self,
                "Zbyt wiele zaznaczonych kom√≥rek",
                "Zaznaczono zbyt wiele kom√≥rek. Zaznacz dok≈Çadnie jednƒÖ kom√≥rkƒô, aby dodaƒá nadgodziny.",
                QMessageBox.Ok
            )
            return

        # Pobierz dane pierwszej (i jedynej) zaznaczonej kom√≥rki
        cell_data = selected_cells_data[0]

        # Pobierz podstawowe informacje o kom√≥rce
        selected_user_id = cell_data.get('uzytkownik_id')
        selected_user_name = cell_data.get('uzytkownik_dane')
        day = cell_data.get('day')
        date_str = cell_data.get('date_str')
        nr_kadrowy = cell_data.get('nr_kadrowy')
        start_hour = cell_data.get('start_hour')
        current_symbol = cell_data.get('symbol', '')
        
        # NOWE: Pobierz lokalizacjƒô domy≈õlnƒÖ z danych u≈ºytkownika
        lokalizacja_domyslna = cell_data.get('lokalizacja_domyslna', 'h')

        if not selected_user_id or not day or not date_str:
            QMessageBox.warning(
                self,
                "B≈ÇƒÖd",
                "Brak wymaganych danych w zaznaczonej kom√≥rce.",
                QMessageBox.Ok
            )
            return

        # Utw√≥rz datƒô QDate
        selected_date = QDate.fromString(date_str, "yyyy-MM-dd")

        # Flaga okre≈õlajƒÖca, czy to dzie≈Ñ wolny (brak danych lub pusty symbol)
        is_day_off = not current_symbol or current_symbol.strip() == ''

        # Je≈õli nr_kadrowy jest None, spr√≥buj znale≈∫ƒá go w danych u≈ºytkownika
        if nr_kadrowy is None and selected_user_id in self.user_info_map:
            nr_kadrowy = self.user_info_map[selected_user_id].get('nr_kadrowy')

        # Ustaw domy≈õlnƒÖ godzinƒô rozpoczƒôcia
        if start_hour is None:
            start_hour = 9 if is_day_off else 8

        # POPRAWIONE: Pobierz lokalizacjƒô z symbolu lub u≈ºyj domy≈õlnej
        current_location = lokalizacja_domyslna  # Domy≈õlna z danych u≈ºytkownika
        
        if current_symbol and ';' in current_symbol:
            from symbol_parser import parse_symbol
            parsed_symbol = parse_symbol(current_symbol)
            if parsed_symbol['location']:
                current_location = parsed_symbol['location']

        # Utw√≥rz okno dialogowe
        dialog = QDialog(self)

        # Nazwy miesiƒôcy po polsku
        polish_months = [
            "stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca",
            "lipca", "sierpnia", "wrze≈õnia", "pa≈∫dziernika", "listopada", "grudnia"
        ]

        month_name = polish_months[selected_date.month() - 1]
        dialog.setWindowTitle(f"Dodaj nadgodziny w dniu {selected_date.day()} {month_name} {selected_date.year()}")
        dialog.setMinimumWidth(300)

        layout = QVBoxLayout(dialog)

        # Informacja o pracowniku
        user_info_label = QLabel(f"Pracownik: {selected_user_name}")
        user_info_label.setStyleSheet("font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(user_info_label)

        # Informacja o numerze kadrowym
        if nr_kadrowy:
            kadrowy_info_label = QLabel(f"Numer kadrowy: {nr_kadrowy}")
            kadrowy_info_label.setStyleSheet("margin-bottom: 10px;")
            layout.addWidget(kadrowy_info_label)

        # Informacja o miesiƒÖcu rozliczenia
        settlement_month = month
        settlement_year = year
        settlement_info = QLabel(f"MiesiƒÖc rozliczenia: {settlement_month:02d}.{settlement_year}")
        settlement_info.setStyleSheet("margin-bottom: 10px;")
        layout.addWidget(settlement_info)

        # Informacja o dniu wolnym (je≈õli to dzie≈Ñ wolny)
        if is_day_off:
            day_off_info = QLabel("Zaznaczony dzie≈Ñ jest dniem wolnym pracownika.")
            day_off_info.setStyleSheet("color: blue; font-weight: bold; margin-bottom: 10px;")
            layout.addWidget(day_off_info)

        # Formularz wprowadzania
        form_frame = QFrame()
        form_frame.setFrameShape(QFrame.StyledPanel)
        form_frame.setFrameShadow(QFrame.Raised)
        form_layout = QGridLayout(form_frame)

        # Etykiety
        od_label = QLabel("od kiedy")
        ile_label = QLabel("ile godzin")
        typ_label = QLabel("typ")
        ld_label = QLabel("LD")
        zalegle_label = QLabel("czy zaleg≈Çe")

        # Kontrolki wprowadzania
        time_combo = QComboBox()
        time_combo.setMinimumWidth(60)

        # Ustal domy≈õlny czas
        if is_day_off:
            default_time = "09:00"  # Dla dnia wolnego
        else:
            # Oblicz koniec zmiany (godzina rozpoczƒôcia + 8 godzin)
            end_hour = (start_hour + 8) % 24
            default_time = f"{end_hour:02d}:00"

        # Dodaj opcje czasu
        for hour in range(0, 24):
            for minute in [0, 30]:
                time_combo.addItem(f"{hour:02d}:{minute:02d}", f"{hour:02d}:{minute:02d}")

        # Ustaw domy≈õlny czas
        index = time_combo.findText(default_time)
        if index != -1:
            time_combo.setCurrentIndex(index)
        else:
            time_combo.setCurrentText(default_time)

        # Combo z liczbƒÖ godzin do 13.0
        hours_combo = QComboBox()
        hours_combo.setMinimumWidth(50)
        for hours in [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5,
                    10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0]:
            hours_combo.addItem(f"{hours:.1f}", hours)
        hours_combo.setCurrentIndex(1)  # Domy≈õlnie 1.0

        # Typ: wyp≈Çata, odbi√≥r, odpracowanie
        type_combo = QComboBox()
        type_combo.addItem("wyp≈Çata", "wyp≈Çata")
        type_combo.addItem("odbi√≥r", "odbi√≥r")
        type_combo.addItem("odpracowanie", "odpracowanie")

        # LD (lokalizacja): h, p, s
        ld_combo = QComboBox()
        ld_combo.addItem("h", "h")  # Hybrydowa
        ld_combo.addItem("p", "p")  # Praca zdalna
        ld_combo.addItem("s", "s")  # Stacjonarna

        # POPRAWIONE: Ustaw domy≈õlnƒÖ lokalizacjƒô na podstawie symbolu lub domy≈õlnej u≈ºytkownika
        if current_location == 'h':
            ld_combo.setCurrentIndex(0)
        elif current_location == 'p':
            ld_combo.setCurrentIndex(1)
        elif current_location == 's':
            ld_combo.setCurrentIndex(2)
        else:
            ld_combo.setCurrentIndex(0)  # Domy≈õlnie 'h'

        # Czy zaleg≈Çe
        overdue_combo = QComboBox()
        overdue_combo.addItem("nie", 0)
        overdue_combo.addItem("tak", 1)

        # Przycisk dodawania
        add_button = QPushButton("Dodaj")
        add_button.setStyleSheet("background-color: #333; color: white; font-weight: bold;")

        # Dodaj kontrolki do layoutu
        form_layout.addWidget(od_label, 0, 0)
        form_layout.addWidget(time_combo, 0, 1)
        form_layout.addWidget(ile_label, 0, 2)
        form_layout.addWidget(hours_combo, 0, 3)
        form_layout.addWidget(typ_label, 0, 4)
        form_layout.addWidget(type_combo, 0, 5)
        form_layout.addWidget(ld_label, 0, 6)
        form_layout.addWidget(ld_combo, 0, 7)
        form_layout.addWidget(zalegle_label, 0, 8)
        form_layout.addWidget(overdue_combo, 0, 9)
        form_layout.addWidget(add_button, 0, 10)

        # Dodaj formularz do g≈Ç√≥wnego layoutu
        layout.addWidget(form_frame)

        # POPRAWIONA funkcja dodawania nadgodzin - BEZ _update_after_adding_overtime
        def add_overtime():
            try:
                # Pobierz dane z formularza
                start_time = time_combo.currentText()
                hours = float(hours_combo.currentData())
                overtime_type = type_combo.currentData()
                location = ld_combo.currentData()
                is_overdue = overdue_combo.currentData()

                # Data rozliczenia to pierwszy dzie≈Ñ bie≈ºƒÖcego miesiƒÖca
                settlement_date_str = f"{settlement_year}-{settlement_month:02d}-01"

                # UPROSZCZONE WYWO≈ÅANIE - bez user_name
                result = self.call_add_overtime_procedure_fixed(
                    selected_user_id,
                    selected_date.year(),
                    selected_date.month(),
                    selected_date.toString("yyyy-MM-dd"),
                    start_time,
                    hours,
                    settlement_date_str,
                    is_overdue,
                    overtime_type,
                    location,
                    nr_kadrowy
                )

                if result["success"]:
                    QMessageBox.information(dialog, "Sukces", result["message"], QMessageBox.Ok)
                    dialog.accept()
                else:
                    QMessageBox.warning(dialog, "B≈ÇƒÖd", result["message"], QMessageBox.Ok)

            except Exception as e:
                QMessageBox.critical(dialog, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd: {str(e)}", QMessageBox.Ok)

        # Pod≈ÇƒÖcz funkcjƒô do przycisku
        add_button.clicked.connect(add_overtime)

        # Poka≈º dialog
        dialog.exec()

   
        
    def _update_overtime_icon_single(self, user_id, date_str, year, month):
        """
        NOWA METODA: Aktualizuje ikonƒô nadgodzin bez wp≈Çywania na cache innych danych.
        """
        try:
            # 1. Aktualizuj bezpo≈õrednio w modelu grafiku
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonƒô nadgodzin w modelu dla ({user_id}, {date_str})")

            # 2. Wyczy≈õƒá tylko cache ikon dla tej konkretnej kom√≥rki w DataProvider
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla kom√≥rki ({user_id}, {date_str})")

            # 3. Od≈õwie≈º widok grafiku
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji ikony nadgodzin: {e}")

    

    def connect_model_signals(self):
        """Pod≈ÇƒÖcz sygna≈Çy modelu - DODAJ TO DO METODY setup_ui lub __init__"""
        if hasattr(self, 'data_provider'):
            self.data_provider.data_changed.connect(self.on_data_changed)
            
            # NOWE: Pod≈ÇƒÖcz sygna≈Ç od≈õwie≈ºania konkretnych ikon
            if hasattr(self.data_provider, 'data_changed'):
                self.data_provider.data_changed.connect(self._handle_specific_icons_refresh)

    def _handle_specific_icons_refresh(self, data_type, year, month):
        """NOWA METODA: Obs≈Çuguje sygna≈Ç od≈õwie≈ºenia konkretnych ikon"""
        if data_type == "icons" and hasattr(self, 'schedule_model') and self.schedule_model:
            # Model sam od≈õwie≈ºy ikony przy nastƒôpnym dostƒôpie - nie r√≥b nic wiƒôcej
            debug_print(f"Otrzymano sygna≈Ç od≈õwie≈ºenia ikon dla {year}-{month}")

    def call_add_overtime_procedure_fixed(self, user_id, year, month, date_str, start_time, hours,
                                          settlement_date, is_overdue, overtime_type, location,
                                          nr_kadrowy):
        """
        Dodaje nadgodziny i zapewnia natychmiastowƒÖ, niezawodnƒÖ aktualizacjƒô
        tabeli zdarze≈Ñ oraz ikony w grafiku.
        """
        try:
            # Krok 1: Dodanie rekordu do bazy danych
            location_map = {'h': 1, 'p': 2, 's': 3}
            location_value = location_map.get(location, 1)
            param_value = 1 if overtime_type == 'odpracowanie' else None
            odebrane_value = 1 if overtime_type == 'odbi√≥r' else 0

            from datetime import datetime, timedelta
            start_datetime = datetime.strptime(f"{date_str} {start_time}", "%Y-%m-%d %H:%M")
            end_datetime = start_datetime + timedelta(hours=float(hours))
            end_time = end_datetime.strftime("%H:%M")

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            params = [
                nr_kadrowy, year, month, date_str, start_time, end_time,
                settlement_date, is_overdue, odebrane_value, location_value,
                param_value
            ]
            sql = f"{{CALL [dbo].[p_P_ZZ_NadgodzinyWstawienie_v3] ({', '.join(['?'] * len(params))})}}"
            cursor.execute(sql, params)
            conn.commit()
            conn.close()

            # Krok 2: Rejestracja w≈Çasnej zmiany i uniewa≈ºnienie cache
            self._update_modification_date()
            self.data_provider.invalidate_complete_cache_for_pairs([(user_id, date_str)])

            # --- NOWA, KLUCZOWA LOGIKA (skopiowana z `delete_event`) ---
            # Krok 3: Bezpo≈õrednia aktualizacja ikony w modelu
            if hasattr(self, 'schedule_model'):
                # Sprawdzamy, jakie zdarzenia istniejƒÖ dla kom√≥rki PO dodaniu nowego
                remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)

                # Bezpo≈õrednio aktualizujemy stan ikon w modelu
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_meetings, has_trainings, has_overtime
                )

            # Krok 4: Od≈õwie≈ºenie dolnej tabeli zdarze≈Ñ
            self.on_selection_changed()

            # Zwracamy sukces
            return {
                "success": True,
                "message": "Nadgodziny zosta≈Çy pomy≈õlnie dodane."
            }

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas dodawania nadgodzin: {e}", exception=e)
            return {
                "success": False,
                "message": f"WystƒÖpi≈Ç b≈ÇƒÖd podczas dodawania nadgodzin: {str(e)}"
            }

    def _refresh_data_after_overtime_addition(self, new_id, user_id, date_str, year, month):
        """
        NOWA METODA: Od≈õwie≈ºa dane z bazy po dodaniu nadgodzin
        """
        try:
            debug_print(f"Od≈õwie≈ºam dane po dodaniu nadgodzin ID={new_id}")
            
            # Upewnij siƒô, ≈ºe column_mapper jest dostƒôpny
            if not hasattr(self, 'column_mapper'):
                from column_mapper import ColumnMapper
                self.column_mapper = ColumnMapper()
            
            # 1. POBIERZ NOWE ZDARZENIE Z BAZY DANYCH
            new_event = self._fetch_specific_event_from_db(year, month, new_id, 'Nadgodziny')
            
            if not new_event:
                log_error(f"Nie znaleziono dodanych nadgodzin o ID {new_id} w bazie danych")
                return
            
            debug_print(f"Pobrano nowe zdarzenie z bazy: {new_event}")
            
            # 2. AKTUALIZUJ CACHE DATAPROVIDER
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]
                
                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data")
                
                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []
                
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache")
                
                # Aktualizuj processed_data - ustaw ikonƒô nadgodzin
                try:
                    day = int(date_str.split('-')[2])
                    for key, user_data in container.processed_data.items():
                        if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonƒô nadgodzin w processed_data")
                            break
                except Exception as e:
                    log_error(f"B≈ÇƒÖd aktualizacji processed_data: {e}")
            
            # 3. AKTUALIZUJ LOKALNE DANE
            # Konwertuj na lokalny format
            local_event = self._convert_dp_event_to_local(new_event)
            
            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(local_event)
                    debug_print(f"Dodano nadgodziny do all_events_data")
            
            # 4. AKTUALIZUJ events_data TYLKO JE≈öLI KOM√ìRKA JEST ZAZNACZONA
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )
                
                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(local_event)
                        debug_print(f"Dodano nadgodziny do events_data")
                        
                        # Aktualizuj model zdarze≈Ñ
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()
            
            # 5. AKTUALIZUJ MODEL GRAFIKU
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_overtime=True
                )
                debug_print(f"Zaktualizowano ikony w schedule_model")
            
            # 6. WYCZY≈öƒÜ CACHE IKON
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon")
            
            # 7. OD≈öWIE≈ª WIDOKI
            if hasattr(self, 'table'):
                if hasattr(self.table, 'schedule_view'):
                    self.table.schedule_view.viewport().update()
            
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()
            
            debug_print(f"=== OD≈öWIE≈ªENIE DANYCH ZAKO≈ÉCZONE ===")
            
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas od≈õwie≈ºania danych: {e}")
            import traceback
            traceback.print_exc()

    def _fetch_specific_event_from_db(self, year, month, event_id, event_type):
        """
        NOWA METODA: Pobiera konkretne zdarzenie z bazy danych
        """
        try:
            # Zapytanie do pobrania konkretnego zdarzenia
            query = """
            SELECT * FROM [dbo].[fn_GetEventsData](?, ?) 
            WHERE EventType = ? AND ID = ?
            """
            
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query, (year, month, event_type, event_id))
            result = cursor.fetchone()
            conn.close()
            
            if not result:
                return None
            
            # Konwertuj na format DataProvider u≈ºywajƒÖc column_mapper
            event_dict = self.column_mapper.map_events_row_to_dict(result)
            
            # Dodaj pola wymagane przez DataProvider
            if 'event_type' in event_dict:
                event_dict['type'] = event_dict['event_type']
            if 'event_id' in event_dict:
                event_dict['id'] = event_dict['event_id']
            
            # Formatuj daty
            raw_date = event_dict.get('date', '')
            if hasattr(raw_date, 'strftime'):
                event_dict['date_display'] = raw_date.strftime('%d.%m.%Y')
                event_dict['date_key'] = raw_date.strftime('%Y-%m-%d')
            elif isinstance(raw_date, str) and raw_date:
                event_dict['date_display'] = self.data_provider._format_date_display(raw_date)
                event_dict['date_key'] = self.data_provider._standardize_date(raw_date)
            
            # Formatuj czasy
            time_from = event_dict.get('time_from')
            time_to = event_dict.get('time_to')
            
            if hasattr(time_from, 'strftime'):
                event_dict['time_from'] = time_from.strftime('%H:%M')
            elif isinstance(time_from, str) and 'T' in time_from:
                event_dict['time_from'] = time_from.split(' ')[1][:5]
            
            if hasattr(time_to, 'strftime'):
                event_dict['time_to'] = time_to.strftime('%H:%M')
            elif isinstance(time_to, str) and 'T' in time_to:
                event_dict['time_to'] = time_to.split(' ')[1][:5]
            
            debug_print(f"Skonwertowano zdarzenie z bazy: {event_dict}")
            return event_dict
            
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas pobierania zdarzenia z bazy: {e}")
            return None
        
             
    def _add_event_to_data_provider(self, new_id, user_id, user_name, date_str, start_time, 
                               end_time, overtime_type, is_overdue, year, month):
        """
        NOWA METODA: Dodaje zdarzenie bezpo≈õrednio do DataProvider i wszystkich cache'y
        """
        try:
            # Utw√≥rz obiekt zdarzenia w formacie DataProvider
            display_date = ".".join(reversed(date_str.split("-")))
            
            # Status na podstawie typu i flagi zaleg≈Ço≈õci
            if overtime_type == 'wyp≈Çata':
                status = "Wyp≈Çata - zaleg≈Çe" if is_overdue else "Wyp≈Çata"
            elif overtime_type == 'odbi√≥r':
                status = "Odbi√≥r"
            elif overtime_type == 'odpracowanie':
                status = "Odpracowanie"
            else:
                status = "Aktywne"

            # Utw√≥rz zdarzenie w formacie zgodnym z DataProvider
            new_event_dp_format = {
                'event_type': 'Nadgodziny',
                'event_id': new_id,
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'date': date_str,  # DataProvider oczekuje YYYY-MM-DD
                'time_from': f"1900-01-01 {start_time}:00",  # Format z bazy
                'time_to': f"1900-01-01 {end_time}:00",
                'status': 'Wstawione',  # Status w formacie bazy
                'type': 'Nadgodziny',
                'id': new_id,
                'date_display': display_date,
                'date_key': date_str
            }

            # Utw√≥rz zdarzenie w formacie lokalnym
            new_event_local_format = {
                'type': 'Nadgodziny',
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'user_name': user_name,
                'date': display_date,
                'date_key': date_str,
                'time_from': start_time,
                'time_to': end_time,
                'status': status,
                'id': new_id
            }

            # KLUCZOWA ZMIANA 1: Dodaj do cache DataProvider
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]
                
                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data (ID: {new_id})")
                
                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []
                
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache (ID: {new_id})")
                
                # Aktualizuj processed_data - dodaj ikonƒô nadgodzin
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        try:
                            day = int(date_str.split('-')[2])
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonƒô nadgodzin w processed_data dla {user_id}, dzie≈Ñ {day}")
                            break
                        except:
                            pass

            # KLUCZOWA ZMIANA 2: Dodaj do lokalnych danych
            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(new_event_local_format)
                    debug_print(f"Dodano nadgodziny do all_events_data (ID: {new_id})")

            # KLUCZOWA ZMIANA 3: Dodaj do events_data tylko je≈õli kom√≥rka jest zaznaczona
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )
                
                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(new_event_local_format)
                        debug_print(f"Dodano nadgodziny do events_data (ID: {new_id})")
                        
                        # Aktualizuj model zdarze≈Ñ
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # KLUCZOWA ZMIANA 4: Aktualizuj ikonƒô w modelu
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonƒô nadgodzin w modelu dla ({user_id}, {date_str})")

            # KLUCZOWA ZMIANA 5: Wyczy≈õƒá tylko cache ikon dla tej kom√≥rki (nie ca≈Çy cache)
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla kom√≥rki ({user_id}, {date_str})")

            # Od≈õwie≈º widok
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas dodawania zdarzenia do DataProvider: {e}")

    def debug_check_event_in_index(self, event_id, event_type='Nadgodziny'):
        """
        Sprawdza, czy zdarzenie o podanym ID istnieje w indeksie zdarze≈Ñ
        i wy≈õwietla informacje diagnostyczne.

        Args:
            event_id: ID zdarzenia
            event_type: Typ zdarzenia (domy≈õlnie 'Nadgodziny')

        Returns:
            bool: True je≈õli znaleziono zdarzenie, False w przeciwnym wypadku
        """
        debug_print(f"\n--- DIAGNOSTYKA INDEKSU ZDARZE≈É ---")
        debug_print(f"Szukam zdarzenia o ID {event_id} i typie {event_type}")

        # Sprawd≈∫ w indeksie zdarze≈Ñ DataProvider
        if hasattr(self.data_provider, 'events_index'):
            # Sprawd≈∫ bezpo≈õrednio przez indeks ID
            event = self.data_provider.events_index.get_event_by_id(event_id)
            if event:
                debug_print(f"ZNALEZIONO w indeksie ID: {event}")
                return True

            # Alternatywnie, przeszukaj wszystkie zdarzenia
            found_in_all = False
            for e in self.data_provider.events_index.all_events:
                if e.get('id') == event_id and e.get('type') == event_type:
                    debug_print(f"ZNALEZIONO w all_events: {e}")
                    found_in_all = True

            # Przeszukaj indeks typ√≥w
            found_in_type_index = False
            type_events = self.data_provider.events_index.type_index.get(event_type, [])
            for e in type_events:
                if e.get('id') == event_id:
                    debug_print(f"ZNALEZIONO w type_index: {e}")
                    found_in_type_index = True

            if not found_in_all and not found_in_type_index:
                debug_print("NIE ZNALEZIONO w indeksie zdarze≈Ñ")
                return False

            return found_in_all or found_in_type_index
        else:
            debug_print("BRAK indeksu zdarze≈Ñ w data_provider")
            return False

    def show_settings_dialog(self):
        """Otwiera nowe, kompleksowe okno ustawie≈Ñ."""
        current_settings = {
            'theme': 'dark' if self.is_dark_theme else 'light',
            'font_family': self.current_font,
            'font_size': self.current_font_size,
            'import_grupa': self.import_grupa,
            'import_funkcja': self.import_funkcja
        }

        dialog = AppSettingsDialog(self, settings=current_settings)

        if dialog.exec() == QDialog.Accepted:
            new_settings = dialog.get_current_settings()

            # Zastosuj i zapisz ustawienia
            self.is_dark_theme = new_settings['theme'] == 'dark'
            self.current_font = new_settings['font_family']
            self.current_font_size = new_settings['font_size']
            self.import_grupa = new_settings['import_grupa']
            self.import_funkcja = new_settings['import_funkcja']

            self.apply_theme_settings(new_settings['theme'], new_settings['font_family'], new_settings['font_size'])

            if new_settings['save_to_db']:
                self.settings_db.save_settings(
                    theme=new_settings['theme'],
                    font_family=new_settings['font_family'],
                    font_size=new_settings['font_size'],
                    visible_columns=self.visible_columns,
                    show_schedule_comment=self.show_comment_column,
                    import_grupa=self.import_grupa,
                    import_funkcja=self.import_funkcja
                )

            # Wymu≈õ od≈õwie≈ºenie danych z nowymi parametrami importu
            self.refresh_data()

    def update_cell_data(self, user_id, date_str, event_type=None, action="update"):
        """
        Aktualizuje dane kom√≥rki i ikony po r√≥≈ºnych operacjach.
        Zoptymalizowana wersja wykorzystujƒÖca precyzyjne aktualizacje.

        Args:
            user_id: ID u≈ºytkownika
            date_str: Data w formacie 'YYYY-MM-DD'
            event_type: Typ zdarzenia (Spotkanie, Szkolenie, Nadgodziny lub None)
            action: Rodzaj operacji - "update", "add", "delete"

        Returns:
            bool: True je≈õli operacja siƒô powiod≈Ça, False w przeciwnym wypadku
        """
        if not user_id or not date_str:
            return False

        # Standardyzuj format daty
        date_str = self.data_provider._standardize_date(date_str)

        # Wyczy≈õƒá cache dla miesiƒÖca tej daty
        if date_str and date_str.count('-') == 2:
            year, month, _ = date_str.split('-')
            self.clear_events_cache(int(year), int(month))

        # Pobierz zdarzenia dla tej pary (u≈ºytkownik, data)
        events = self.data_provider.get_events_for_user_date(user_id, date_str)

        # Sprawd≈∫ typy zdarze≈Ñ
        has_meeting = any(
            e.get('type') == 'Spotkanie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_training = any(
            e.get('type') == 'Szkolenie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_overtime = any(e.get('type') == 'Nadgodziny' for e in events)

        # Aktualizuj wska≈∫niki w modelu - u≈ºywajƒÖc zoptymalizowanej metody
        if hasattr(self, 'schedule_model'):
            if event_type == 'Spotkanie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Szkolenie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Nadgodziny':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny',
                                                                  is_active=(action != "delete"))
            else:
                # Aktualizuj wszystkie wska≈∫niki
                result1 = self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', has_meeting)
                result2 = self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', has_training)
                result3 = self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', has_overtime)
                return result1 or result2 or result3

        return False

    def get_all_valid_symbols(self) -> set:
        """Zwraca zbi√≥r wszystkich prawid≈Çowych symboli specjalnych."""
        # Definicje skopiowane z InsertSymbolDialog dla centralizacji
        symbol_lists = [
            ("U", "Urlop wypoczynkowy"), ("UZ", "Urlop na ≈ºƒÖdanie"), ("CO", "Zwolnienie lekarskie"),
            ("CR", "Zwolnienie lekarskie na innƒÖ osobƒô"), ("UB", "Urlop bezp≈Çatny"),
            ("UD", "Urlop dodatkowy z tytu≈Çu niepe≈Çnosprawno≈õci"), ("UM", "Urlop macierzy≈Ñski"),
            ("UO", "Urlop okoliczno≈õciowy"), ("UOD", "Opieka nad dzieckiem"),
            ("US", "Urlop szkolny"), ("UT", "Urlop ojcowski"), ("UW", "Urlop wychowawczy"),
            ("UOP", "Urlop opieku≈Ñczy (5 dni)"), ("CRW", "Zwolnienie na opiekƒô (wyjƒÖtkowe)"),
            ("CSR", "≈öwiadczenie rehabilitacyjne"), ("ZO", "Zwolnienie z obowiƒÖzku ≈õwiadczenia pracy"),
            ("ZS", "Zwolnienie z obowiƒÖzku ≈õwiadczenia pracy (wyjƒÖtkowe)"),
            ("DK", "Delegacja krajowa"), ("DZ", "Delegacja zagraniczna"),
            ("HO", "Home Office"), ("P", "Czasowe oddelegowanie"), ("PD", "Prace dodatkowe"),
            ("BC", "Backup"), ("BK", "Badanie kontrolne"), ("BO", "Badanie okresowe"),
            ("CW", "ƒÜwiczenia wojskowe"), ("DYS", "Dyspozycja"), ("MW", "mWolne"),
            ("NN", "Nieobecno≈õƒá nieusprawiedliwiona"), ("NU", "Nieobecno≈õƒá usprawiedliwiona"),
            ("NW", "Nieobecno≈õƒá do wyja≈õnienia"), ("O", "Odbi√≥r godzin"),
            ("OS", "Odbi√≥r dnia wolnego za ≈õwiƒôto"), ("S", "Szkolenie"), ("T", "Testy"),
            ("USW", "Zwolnienie z powodu si≈Çy wy≈ºszej (2 dni)"), ("Z", "RozwiƒÖzanie umowy")
        ]
        return {symbol for symbol, desc in symbol_lists}

    def apply_symbol_from_keyboard(self, special_symbol: str):
        """
        Stosuje podany symbol specjalny, budujƒÖc nowy symbol zgodnie z nowymi zasadami.
        """
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono kom√≥rek do edycji.")
            return

        # Dialog potwierdzenia (bez zmian)
        user_dates = defaultdict(list)
        for cell in selected_cells_data:
            user_dates[cell.get('uzytkownik_dane', 'Nieznany')].append(cell.get('date_str'))
        changes_info = f"Czy na pewno chcesz wstawiƒá symbol '{special_symbol}' dla:\n\n"
        for user, dates in user_dates.items():
            dates_str = ", ".join(sorted(dates))
            changes_info += f"üë§ {user}: {dates_str}\n"

        reply = QMessageBox.question(self, "Potwierdzenie zmiany symbolu", changes_info,
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

        if reply != QMessageBox.Yes:
            return

        # Nowa logika budowania symbolu i zapisu
        updated_info = []
        error_messages = []  # Nowa lista do zbierania b≈Çƒôd√≥w
        for cell_data in selected_cells_data:
            current_symbol = cell_data.get('symbol', '')

            location = None
            start_hour = None
            work_hours = None

            if current_symbol and current_symbol.strip():
                # Kom√≥rka NIE JEST pusta: pobieramy godziny z istniejƒÖcego symbolu
                parsed = parse_symbol(current_symbol)
                start_hour = parsed.get('start_hour')
                work_hours = parsed.get('work_hours')
            else:
                # Kom√≥rka JEST pusta: u≈ºywamy warto≈õci domy≈õlnych
                start_hour = 11
                work_hours = cell_data.get('etat')

            # Budujemy nowy symbol
            new_symbol = build_symbol(
                location=location,
                start_hour=start_hour,
                work_hours=work_hours,
                special_symbol=special_symbol
            )

            # Wywo≈Çujemy procedurƒô
            try:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                nr_kadrowy = cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                user_name = cell_data.get('uzytkownik_dane')

                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy,
                    rok=int(year),
                    miesiac=int(month),
                    data=date_str,
                    symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    # Zbierz komunikat o b≈Çƒôdzie do p√≥≈∫niejszego wy≈õwietlenia
                    error_message = result.get('message', 'Nieznany b≈ÇƒÖd')
                    error_messages.append(f"üë§ {user_name} ({date_str}): {error_message}")
            except Exception as e:
                log_error(f"B≈ÇƒÖd wywo≈Çania procedury w apply_symbol_from_keyboard: {e}")
                error_messages.append(f"B≈ÇƒÖd aplikacji: {e}")

        # Po przetworzeniu wszystkich kom√≥rek, najpierw zaktualizuj te, kt√≥re siƒô uda≈Çy
        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Pomy≈õlnie zaktualizowano {len(updated_info)} kom√≥rek.", 4000)

        # A nastƒôpnie, je≈õli wystƒÖpi≈Çy b≈Çƒôdy, wy≈õwietl je w jednym oknie
        if error_messages:
            QMessageBox.warning(
                self,
                "B≈Çƒôdy podczas zapisu",
                "WystƒÖpi≈Çy nastƒôpujƒÖce b≈Çƒôdy i niekt√≥re zmiany nie zosta≈Çy zapisane:\n\n" + "\n".join(
                    error_messages),
                QMessageBox.Ok
                    )

    def apply_theme_settings(self, theme, font_family, font_size):
        """Stosuje wybrane ustawienia motywu z wykorzystaniem centralnych styl√≥w"""
        # Zapamiƒôtaj wybrane ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Zastosuj czcionkƒô do ca≈Çej aplikacji
        font = QFont(font_family, font_size)
        QApplication.setFont(font)

        # Zastosuj g≈Ç√≥wny styl dla ca≈Çego okna aplikacji
        self.setStyleSheet(AppStyles.get_main_window_style(theme))

        # Bezpieczne ustawianie styl√≥w z sprawdzaniem istnienia atrybut√≥w

        # Przyciski w g√≥rnym pasku
        if hasattr(self, 'theme_button'): self.theme_button.setStyleSheet(AppStyles.get_button_style(theme))
        if hasattr(self, 'refresh_button'): self.refresh_button.setStyleSheet(AppStyles.get_button_style(theme))
        if hasattr(self, 'toggle_menu_button'): self.toggle_menu_button.setStyleSheet(AppStyles.get_button_style(theme))
        if hasattr(self, 'date_combo'): self.date_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'staffing_details_button'): self.staffing_details_button.setStyleSheet(AppStyles.get_button_style(theme))
        if hasattr(self, 'show_audit_button'): self.show_audit_button.setStyleSheet(AppStyles.get_button_style(theme))
        # Lewy panel i jego elementy
        if hasattr(self, '_left_panel'): self._left_panel.setStyleSheet(AppStyles.get_left_panel_style(theme))
        if hasattr(self, 'wydzial_combo'): self.wydzial_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'dtn_combo'): self.dtn_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'rola_combo'): self.rola_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'jezyk_combo'): self.jezyk_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'etat_combo'): self.etat_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'system_czasu_pracy_combo'): self.system_czasu_pracy_combo.setStyleSheet(AppStyles.get_combobox_style(theme))

        if hasattr(self, 'przelozony_filter'): self.przelozony_filter.setStyleSheet(
            AppStyles.get_line_edit_style(theme))
        if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.setStyleSheet(
            AppStyles.get_line_edit_style(theme))
        if hasattr(self, 'przelozony_list'): self.przelozony_list.setStyleSheet(AppStyles.get_list_style(theme))
        if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style(theme))
        if hasattr(self, 'clear_filters_button'): self.clear_filters_button.setStyleSheet(
            AppStyles.get_button_style(theme))

        # Przyciski w dolnym panelu
        if hasattr(self, 'manage_columns_button'): self.manage_columns_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'toggle_events_panel_button'): self.toggle_events_panel_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'insert_change_button'): self.insert_change_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'insert_symbol_button'): self.insert_symbol_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'cancel_delegation_button'): self.cancel_delegation_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'add_overtime_button'): self.add_overtime_button.setStyleSheet(
            AppStyles.get_button_style(theme))

        # Elementy panelu zdarze≈Ñ
        if hasattr(self, 'date_from'): self.date_from.setStyleSheet(AppStyles.get_date_edit_style(theme))
        if hasattr(self, 'date_to'): self.date_to.setStyleSheet(AppStyles.get_date_edit_style(theme))
        if hasattr(self, 'topic_filter'): self.topic_filter.setStyleSheet(AppStyles.get_line_edit_style(theme))
        if hasattr(self, 'name_filter'): self.name_filter.setStyleSheet(AppStyles.get_line_edit_style(theme))
        if hasattr(self, 'meetings_checkbox'): self.meetings_checkbox.setStyleSheet(AppStyles.get_checkbox_style(theme))
        if hasattr(self, 'trainings_checkbox'): self.trainings_checkbox.setStyleSheet(
            AppStyles.get_checkbox_style(theme))
        if hasattr(self, 'overtime_checkbox'): self.overtime_checkbox.setStyleSheet(AppStyles.get_checkbox_style(theme))

        # Aktualizacja modeli
        if hasattr(self, 'schedule_model'): self.schedule_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'events_model'): self.events_model.set_theme(self.is_dark_theme)

        # Aktualizacja widok√≥w tabel
        if hasattr(self, 'table'):
            if hasattr(self.table, 'employees_view'):
                self.table.employees_view.setStyleSheet(AppStyles.get_table_style(theme))
                self.table.employees_view.viewport().update()
            if hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.setStyleSheet(AppStyles.get_table_style(theme))
                self.table.schedule_view.viewport().update()

        if hasattr(self, 'events_table'):
            self.events_table.setStyleSheet(AppStyles.get_table_style(theme))
            self.events_table.viewport().update()

        # Je≈õli okno szczeg√≥≈Ç√≥w obsady jest otwarte, zaktualizuj r√≥wnie≈º jego motyw.
        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            is_dark = (theme == "dark")
            self.staffing_details_win.set_current_theme(is_dark)

    def closeEvent(self, event):
        """Obs≈Çuguje zamkniƒôcie aplikacji"""
        try:
            debug_print("=== ZAMYKANIE APLIKACJI TEAMFLOW ===")
            debug_print(f"Sesja trwa≈Ça od uruchomienia aplikacji")

            # NOWE: Wyczy≈õƒá filtr klawiatury
            self.cleanup_keyboard_filter()

            close_log_file()
        except:
            pass  # Ignoruj b≈Çƒôdy podczas zamykania
        finally:
            event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = WorkScheduleWindow()
    window.show()
    sys.exit(app.exec())
