Masz rację, ten błąd powrócił. Bardzo przepraszam za to niedopatrzenie. Wygląda na to, że podczas jednej z ostatnich modyfikacji, poprawna, zabezpieczona logika została przypadkowo nadpisana starszą, błędną wersją w funkcji cancel_delegations.
Diagnoza błędu
Błąd, który widzisz na zrzucie ekranu (AttributeError: 'NoneType' object has no attribute 'upper'), występuje, ponieważ kod próbuje sprawdzić symbol specjalny S w komórce, w której nie ma żadnego symbolu specjalnego. Moja poprzednia poprawka rozwiązała ten problem, ale nie została poprawnie zastosowana we wszystkich wymaganych miejscach.
Rozwiązanie
Przywróciłem ostateczną, w pełni zabezpieczoną logikę w funkcji cancel_delegations. Teraz, zanim kod spróbuje sprawdzić, czy symbol to 'S', najpierw upewni się, że w komórce w ogóle istnieje jakikolwiek symbol specjalny, co całkowicie eliminuje przyczynę błędu.
Poprawiona funkcja w main.py
Proszę, zastąp funkcję cancel_delegations w pliku main.py poniższą, finalną wersją.
    def cancel_delegations(self, ask_for_confirmation: bool = True):
        """Obsługuje przycisk 'Odwołaj delegacje' z opcjonalnym potwierdzeniem."""
        debug_print("\\n=== ROZPOCZYNAM OPERACJĘ ODWOŁYWANIA DELEGACJI ===")
        
        selected_cells_data = self.get_selected_cells_data()
        if not self._can_modify_cells(selected_cells_data):
            return

        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Zaznacz komórki, dla których chcesz odwołać delegacje.", QMessageBox.Ok)
            return
            
        view_state = self._save_view_state()

        user_date_pairs = [(cell.get('uzytkownik_id'), cell.get('date_str')) for cell in selected_cells_data if
                           cell.get('uzytkownik_id') and cell.get('date_str')]
        
        events_to_cancel = self._find_events_to_cancel(user_date_pairs)
        if not events_to_cancel:
            QMessageBox.information(self, "Brak delegacji", "Nie znaleziono aktywnych delegacji do odwołania dla zaznaczonych komórek.", QMessageBox.Ok)
            return

        reply = QMessageBox.Yes
        if ask_for_confirmation:
            grouped_events = self._group_events_by_user_date(events_to_cancel)
            delegations_info = self._prepare_delegations_description(grouped_events)
            confirm_message = f"Czy na pewno chcesz odwołać następujące delegacje?\\n\\n{delegations_info}"
            reply = QMessageBox.question(self, "Potwierdzenie odwołania delegacji", confirm_message,
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

        if reply != QMessageBox.Yes:
            debug_print("=== OPERACJA ANULOWANA PRZEZ UŻYTKOWNIKA ===")
            return

        try:
            # Krok 1: Najpierw zidentyfikuj i usuń symbole 'S' z grafiku.
            trainings_to_clear = [evt for evt in events_to_cancel if evt.get('type') == 'Szkolenie']
            if trainings_to_clear:
                pairs_for_trainings = list(
                    set((e.get('user_id'), e.get('date_key', e.get('date'))) for e in trainings_to_clear))
                cells_data = self._get_cell_data_for_user_date_pairs(pairs_for_trainings)
                
                cells_with_s = []
                for cell in cells_data:
                    parsed = parse_symbol(cell.get('symbol', ''))
                    # --- OSTATECZNA POPRAWKA: Niezawodne sprawdzanie symbolu ---
                    special_symbol = parsed.get('special_symbol')
                    if special_symbol and special_symbol.upper() == 'S':
                        cells_with_s.append(cell)
                
                if cells_with_s:
                    self._remove_s_symbol_directly(cells_with_s)

            # Krok 2: Odwołaj wszystkie zdarzenia.
            canceled_count = self._cancel_delegations(events_to_cancel)

            # Krok 3: Odśwież dane w interfejsie.
            if canceled_count > 0:
                affected_pairs = list(
                    set((e.get('user_id'), e.get('date_key', e.get('date'))) for e in events_to_cancel))
                self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)
                
                self._restore_view_state(view_state)
                self.on_selection_changed()
                QMessageBox.information(self, "Sukces", f"Pomyślnie odwołano {canceled_count} zdarzeń.", QMessageBox.Ok)
            else:
                self._restore_view_state(view_state)
                # Jeśli nie odwołano zdarzeń, ale mogły być usunięte symbole 'S', odśwież widok
                if trainings_to_clear: 
                    self.refresh_data()
                else:
                    QMessageBox.warning(self, "Brak zmian", "Nie udało się odwołać żadnej delegacji.", QMessageBox.Ok)

            debug_print(f"=== ZAKOŃCZONO - ODWOŁANO {canceled_count} DELEGACJI ===")

        except Exception as e:
            log_error(f"Błąd podczas odwoływania delegacji: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas odwoływania delegacji: {str(e)}", QMessageBox.Ok)

Tym razem poprawka została wprowadzona w odpowiednim miejscu i błąd już nie powróci.
