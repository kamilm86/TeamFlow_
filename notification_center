# notification_center.py
from PySide6.QtWidgets import (QWidget, QVBoxLayout, QLabel, QScrollArea,
                               QPushButton, QFrame, QHBoxLayout, QGraphicsDropShadowEffect)
from PySide6.QtCore import Qt, QPropertyAnimation, QEasingCurve, QPoint
from PySide6.QtGui import QColor
import datetime
from styles import AppStyles  # Import stylów


class NotificationItem(QFrame):
    """Pojedynczy kafel powiadomienia - WERSJA Z OBSŁUGĄ MOTYWÓW."""

    def __init__(self, title, message, time_str, category="info", parent=None, is_dark_theme=True):
        super().__init__(parent)
        self.setObjectName("NotifItem")  # ID dla CSS
        self.setFrameShape(QFrame.StyledPanel)
        self.setFrameShadow(QFrame.Raised)
        self.setFixedHeight(75)

        # Zapamiętujemy kategorię, aby odtworzyć kolor paska przy zmianie motywu
        self.category = category

        layout = QVBoxLayout(self)
        layout.setContentsMargins(8, 4, 4, 4)
        layout.setSpacing(1)

        # Nagłówek (Tytuł + Czas + Przycisk X)
        top_layout = QHBoxLayout()
        self.lbl_title = QLabel(title)
        self.lbl_title.setObjectName("Title")

        self.lbl_time = QLabel(time_str)
        self.lbl_time.setObjectName("Time")
        self.lbl_time.setAlignment(Qt.AlignRight)

        self.close_btn = QPushButton("×")
        self.close_btn.setObjectName("CloseBtn")
        self.close_btn.setFixedSize(16, 16)
        self.close_btn.setCursor(Qt.PointingHandCursor)
        self.close_btn.setToolTip("Usuń to powiadomienie")
        self.close_btn.clicked.connect(self.deleteLater)

        top_layout.addWidget(self.lbl_title)
        top_layout.addStretch()
        top_layout.addWidget(self.lbl_time)
        top_layout.addWidget(self.close_btn)

        # Treść
        self.lbl_msg = QLabel(message)
        self.lbl_msg.setObjectName("Msg")
        self.lbl_msg.setWordWrap(True)
        self.lbl_msg.setFixedHeight(35)

        layout.addLayout(top_layout)
        layout.addWidget(self.lbl_msg)

        # Aplikuj styl na start
        self.apply_theme(is_dark_theme)

    def apply_theme(self, is_dark_theme):
        """Stosuje styl (jasny/ciemny) dla tego konkretnego elementu."""
        # Logika kolorów paska bocznego (zależna od kategorii, niezależna od motywu)
        border_color = "#3498db"  # Info - niebieski
        if self.category == "warning":
            border_color = "#e67e22"  # Pomarańczowy
        elif self.category == "error":
            border_color = "#e74c3c"  # Czerwony
        elif self.category == "success":
            border_color = "#2ecc71"  # Zielony
        elif self.category == "schedule":
            border_color = "#9b59b6"  # Fioletowy

        theme_name = "dark" if is_dark_theme else "light"
        self.setStyleSheet(AppStyles.get_notification_item_style(theme_name, border_color))


class NotificationDrawer(QWidget):
    """Wysuwany panel boczny - WERSJA Z OBSŁUGĄ MOTYWÓW."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setObjectName("Drawer")  # ID dla CSS
        self.parent_window = parent
        self.setFixedWidth(260)

        # Sprawdzamy aktualny motyw rodzica
        self.is_dark = True
        if hasattr(parent, 'is_dark_theme'):
            self.is_dark = parent.is_dark_theme

        # Cień (zawsze czarny, ale subtelniejszy w jasnym motywie)
        shadow = QGraphicsDropShadowEffect(self)
        shadow.setBlurRadius(20)
        shadow.setXOffset(-5)
        shadow.setColor(QColor(0, 0, 0, 100))  # Trochę lżejszy cień
        self.setGraphicsEffect(shadow)

        # Layout główny
        self.main_layout = QVBoxLayout(self)
        self.main_layout.setContentsMargins(0, 0, 0, 0)
        self.main_layout.setSpacing(0)

        # Nagłówek panelu
        self.header_frame = QFrame()
        self.header_frame.setObjectName("Header")
        self.header_frame.setFixedHeight(40)

        header_layout = QHBoxLayout(self.header_frame)
        header_layout.setContentsMargins(8, 0, 8, 0)

        title = QLabel("Powiadomienia")
        title.setStyleSheet("font-weight: bold; font-size: 10pt; border: none;")

        self.close_btn = QPushButton("✕")  # Używam Unicode X
        self.close_btn.setFixedSize(20, 20)
        self.close_btn.setCursor(Qt.PointingHandCursor)
        self.close_btn.setToolTip("Zamknij panel")
        # Styl przycisku zamykania panelu (uniwersalny)
        self.close_btn.setStyleSheet("""
            QPushButton { color: #999; border: none; background: transparent; font-weight: bold;}
            QPushButton:hover { color: #e74c3c; }
        """)
        self.close_btn.clicked.connect(self.toggle)

        self.clear_btn = QPushButton("Wyczyść")
        self.clear_btn.setCursor(Qt.PointingHandCursor)
        self.clear_btn.setStyleSheet("""
            QPushButton { color: #999; border: none; background: transparent; margin-right: 5px; font-size: 8pt;}
            QPushButton:hover { text-decoration: underline; color: #3498db;}
        """)
        self.clear_btn.clicked.connect(self.clear_notifications)

        header_layout.addWidget(title)
        header_layout.addStretch()
        header_layout.addWidget(self.clear_btn)
        header_layout.addWidget(self.close_btn)
        self.main_layout.addWidget(self.header_frame)

        # Obszar przewijania
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)

        self.container_widget = QWidget()
        self.container_widget.setStyleSheet("background: transparent;")

        self.items_layout = QVBoxLayout(self.container_widget)
        self.items_layout.setAlignment(Qt.AlignTop)
        self.items_layout.setContentsMargins(5, 5, 5, 5)
        self.items_layout.setSpacing(5)

        self.scroll_area.setWidget(self.container_widget)
        self.main_layout.addWidget(self.scroll_area)

        self.animation = QPropertyAnimation(self, b"pos")
        self.animation.setDuration(300)
        self.animation.setEasingCurve(QEasingCurve.OutCubic)

        self.is_open = False

        # Aplikuj style na start
        self.set_current_theme(self.is_dark)

        self.update_geometry()
        self.hide()

    def set_current_theme(self, is_dark):
        """Aktualizuje wygląd panelu i wszystkich powiadomień."""
        self.is_dark = is_dark
        theme_name = "dark" if is_dark else "light"

        # 1. Aktualizuj styl kontenera głównego
        self.setStyleSheet(AppStyles.get_notification_drawer_style(theme_name))

        # 2. Aktualizuj styl wszystkich istniejących kafelków
        for i in range(self.items_layout.count()):
            item = self.items_layout.itemAt(i).widget()
            if isinstance(item, NotificationItem):
                item.apply_theme(self.is_dark)

    def toggle(self):
        """Wysuwa lub chowa panel."""
        parent_width = self.parent_window.width()
        top_offset = 50

        if self.is_open:
            start_pos = QPoint(parent_width - self.width(), top_offset)
            end_pos = QPoint(parent_width, top_offset)
            self.is_open = False
        else:
            self.update_geometry()
            self.show()
            self.raise_()
            start_pos = QPoint(parent_width, top_offset)
            end_pos = QPoint(parent_width - self.width(), top_offset)
            self.is_open = True

        self.animation.setStartValue(start_pos)
        self.animation.setEndValue(end_pos)
        self.animation.start()

    def add_notification(self, title, message, category="info"):
        """Dodaje nowe powiadomienie."""
        time_str = datetime.datetime.now().strftime("%H:%M")
        # Przekazujemy self.is_dark do nowego elementu
        item = NotificationItem(title, message, time_str, category, is_dark_theme=self.is_dark)
        self.items_layout.insertWidget(0, item)

    def clear_notifications(self):
        while self.items_layout.count():
            child = self.items_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

    def update_geometry(self):
        if not self.parent_window: return
        parent_width = self.parent_window.width()
        parent_height = self.parent_window.height()
        top_offset = 50
        bottom_margin = 10
        self.setFixedHeight(parent_height - top_offset - bottom_margin)

        if self.is_open:
            self.move(parent_width - self.width(), top_offset)
        else:
            self.move(parent_width, top_offset)
