# preparation_thread.py

from PySide6.QtCore import QThread, Signal
from debug_utils import log_error, debug_print
import time
from concurrent.futures import ThreadPoolExecutor


class PreparationThread(QThread):
    """
    Wątek roboczy do asynchronicznego ładowania i przygotowywania danych.
    Wersja zoptymalizowana: pobiera grafik i zdarzenia równolegle.
    """
    progress_updated = Signal(int)
    preparation_finished = Signal(object)
    error_occurred = Signal(str)

    def __init__(self, data_provider, year, month, grupa, funkcja, parent=None):
        super().__init__(parent)
        self.data_provider = data_provider
        self.year = year
        self.month = month
        self.grupa = grupa
        self.funkcja = funkcja
        self._is_cancelled = False

    def run(self):
        """Główna metoda wątku ładującego dane."""
        try:
            start_time = time.time()
            if self.is_cancelled(): return

            # Używamy ThreadPoolExecutor do równoległego pobierania danych
            # Dzięki temu długie zapytanie o grafik nie blokuje pobierania zdarzeń
            with ThreadPoolExecutor(max_workers=2) as executor:
                future_schedule = executor.submit(
                    self.data_provider._get_or_load_monthly_data,
                    self.year, self.month, self.grupa, self.funkcja, use_cache=False
                )

                # Pobieranie prognozy też można by tu dodać, jeśli jest wolne
                # future_forecast = ...

                # Oczekiwanie na wyniki
                container = future_schedule.result()

            if self.is_cancelled(): return

            if not container:
                error_msg = f"Nie udało się załadować kontenera danych dla {self.year}-{self.month}"
                self.error_occurred.emit(error_msg)
                return

            debug_print(f"[PERFORMANCE] Pobieranie danych z bazy zajęło: {time.time() - start_time:.2f}s")

            # Krok 2: Pobierz przetworzone dane z nałożonymi ikonami
            # To jest operacja w pamięci (CPU-bound), więc robimy ją tutaj
            processing_start = time.time()
            processed_data_with_icons = self.data_provider.get_processed_data(
                self.year, self.month, self.grupa, self.funkcja
            )
            debug_print(f"[PERFORMANCE] Przetwarzanie danych (ikony) zajęło: {time.time() - processing_start:.2f}s")

            if self.is_cancelled(): return

            result_data = {
                'schedule_data': container.schedule_data,
                'events_data': container.events_data,
                'processed_data': processed_data_with_icons,
                'year': self.year,
                'month': self.month
            }

            self.preparation_finished.emit(result_data)

        except Exception as e:
            log_error(f"Krytyczny błąd w wątku ładowania danych: {e}", exception=e)
            if not self.is_cancelled():
                self.error_occurred.emit(str(e))

    def cancel(self):
        """Metoda do bezpiecznego anulowania wątku."""
        self._is_cancelled = True

    def is_cancelled(self):
        """Sprawdza, czy zażądano anulowania."""
        return self._is_cancelled
