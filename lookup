Rozumiem, to jest frustrujÄ…ce. Skoro bÅ‚Ä…d nadal wystÄ™puje, oznacza to jednÄ… z dwÃ³ch rzeczy:
 * Formatowanie liczb: Masz liczby z przecinkiem (np. '12,5') zamiast kropki, a Python nie traktuje ich jako liczb, wiÄ™c pd.to_numeric ich nie rusza (jeÅ›li nie obsÅ‚uÅ¼ymy tego rÄ™cznie), a Oracle wywala siÄ™ na przecinku.
 * PominiÄ™te kolumny: PÄ™tla for col, dtype in numpy_dtype_dict.items() pominÄ™Å‚a kolumny, ktÃ³re sprawiajÄ… problem (np. TIMEINIVR), poniewaÅ¼ w numpy_dtype_dict mogÄ… byÄ‡ bÅ‚Ä™dnie oznaczone jako object (tekst).
Musimy zastosowaÄ‡ agresywne czyszczenie, ktÃ³re wymusi konwersjÄ™ na liczby niezaleÅ¼nie od tego, co "myÅ›li" sÅ‚ownik typÃ³w.
ğŸ› ï¸ RozwiÄ…zanie: Agresywne czyszczenie z obsÅ‚ugÄ… przecinkÃ³w
ZastÄ…p fragment czyszczenia w insert_data (ten, ktÃ³ry Ci ostatnio daÅ‚em) poniÅ¼szym kodem. Ten kod robi trzy rzeczy:
 * Ignoruje sÅ‚ownik typÃ³w i prÃ³buje naprawiÄ‡ kaÅ¼dÄ… kolumnÄ™, ktÃ³ra wyglÄ…da na liczbowÄ….
 * Zamienia przecinki na kropki (kluczowe dla polskich danych).
 * Zamienia wszystko, co siÄ™ nie uda, na None.
Wklej to w insert_data po astype:
            self.logger.info(f"Wykonanie df_to_load.astype(numpy_dtype_dict)") 
            df_to_load = df_to_load.astype(numpy_dtype_dict) 
            self.logger.info(f"df_to_load.astype(numpy_dtype_dict) - done") 
            
            # ğŸ’¥ğŸ’¥ğŸ’¥ AGRESYWNE CZYSZCZENIE (WERSJA 2.0) ğŸ’¥ğŸ’¥ğŸ’¥
            import numpy as np

            # Lista kolumn, ktÃ³re NA PEWNO sÄ… liczbowe w bazie Oracle (na podstawie Twoich logÃ³w)
            # Dodaj tu kaÅ¼dÄ… kolumnÄ™, ktÃ³ra wywala bÅ‚Ä…d ORA-01722
            numeric_cols = [
                'TIMEINIVR', 'CALLDURATION', 'ILE_INT', 'SEGMENTID_START', 
                'SEGMENTID_END', 'LASTASSIGNEDWORKGROUPID'
            ]
            
            # Dodajemy teÅ¼ wszystkie kolumny, ktÃ³re w mapowaniu sÄ… int/float
            for col, dtype in numpy_dtype_dict.items():
                if ('int' in str(dtype) or 'float' in str(dtype)) and col not in numeric_cols:
                    numeric_cols.append(col)

            self.logger.info(f"Wymuszanie typÃ³w liczbowych dla kolumn: {numeric_cols}")

            for col in numeric_cols:
                if col in df_to_load.columns:
                    # 1. Konwersja na string, Å¼eby mÃ³c operowaÄ‡ na tekÅ›cie
                    # errors='ignore' pozwala zachowaÄ‡ None jeÅ›li juÅ¼ tam sÄ…
                    df_to_load[col] = df_to_load[col].astype(str)

                    # 2. Czyszczenie Å›mieci tekstowych (<NA>, nan, None)
                    # Zamieniamy je na "zwykÅ‚e" NaN, ktÃ³re to_numeric zrozumie
                    replace_dict = {
                        '<NA>': np.nan, 'nan': np.nan, 'NaN': np.nan, 'None': np.nan, 
                        'NaT': np.nan, '': np.nan, ' ': np.nan
                    }
                    for k, v in replace_dict.items():
                         df_to_load[col] = df_to_load[col].replace(k, v)

                    # 3. ğŸ’¥ ZAMIANA PRZECINKA NA KROPKÄ˜ ğŸ’¥
                    # JeÅ›li masz dane '12,5', to Python tego nie zrozumie bez tej zmiany
                    if df_to_load[col].dtype == 'object':
                        df_to_load[col] = df_to_load[col].str.replace(',', '.', regex=False)

                    # 4. Konwersja na liczby (coerce zamieni bÅ‚Ä™dy na NaN)
                    df_to_load[col] = pd.to_numeric(df_to_load[col], errors='coerce')

            # 5. Ostateczna zamiana NaN -> None (dla SQL NULL)
            df_to_load = df_to_load.where(pd.notnull(df_to_load), None)
            
            # DEBUG: PokaÅ¼ przykÅ‚adowy wiersz w logu, Å¼eby zobaczyÄ‡ czy <NA> zniknÄ™Å‚o
            if not df_to_load.empty:
                self.logger.info(f"PrzykÅ‚adowe dane po czyszczeniu (pierwszy wiersz):\n{df_to_load.iloc[0].to_dict()}")

            # ğŸ’¥ğŸ’¥ğŸ’¥ KONIEC POPRAWKI ğŸ’¥ğŸ’¥ğŸ’¥

Dlaczego to powinno zadziaÅ‚aÄ‡?
PowyÅ¼szy schemat obrazuje problem:
 * Lista numeric_cols: WymieniÅ‚em rÄ™cznie kolumny, ktÃ³re widziaÅ‚em w Twoich bÅ‚Ä™dach (TIMEINIVR itd.). DziÄ™ki temu, nawet jeÅ›li numpy_dtype_dict siÄ™ pomyliÅ‚, my wymusimy na nich czyszczenie.
 * str.replace(',', '.'): To jest najczÄ™stsza przyczyna ORA-01722 w Polsce. Excel/CSV daje 0,5, Python chce 0.5, a Oracle gÅ‚upieje, dostajÄ…c tekst z przecinkiem.
 * Logowanie: DodaÅ‚em na koÅ„cu self.logger.info, ktÃ³ry wypisze pierwszy wiersz danych. JeÅ›li bÅ‚Ä…d wystÄ…pi znowu, spÃ³jrz w logi "powyÅ¼ej" bÅ‚Ä™du â€“ zobaczysz dokÅ‚adnie, co prÃ³bujemy wysÅ‚aÄ‡.
