# -*- coding: utf-8 -*-

from PySide6.QtCore import QThread, Signal, Qt
from PySide6.QtWidgets import QProgressDialog, QMessageBox
from enum import Enum, auto
import pyodbc

from db_connector import DatabaseConnector, SQL_OBJECTS
from debug_utils import log_error, debug_print
from symbol_parser import parse_symbol, build_symbol
from app_settings import app_settings

class ChangeType(Enum):
    """Definiuje typy operacji, jakie może przetwarzać ScheduleChangeProcessor."""
    QUICK_EDIT_START_HOUR = auto()
    MODIFY_WORK_HOURS = auto()
    APPLY_SPECIAL_SYMBOL = auto()
    QUICK_EDIT_START_HOUR_NO_LOCATION = auto()
    CLEAR_CELL = auto()
    APPLY_BUILT_SYMBOL = auto()

class ScheduleChangeThread(QThread):
    """Wątek roboczy do wykonywania zmian w grafiku w tle."""
    progress_updated = Signal(int)
    finished = Signal(list)  # Zwraca listę wyników
    error_occurred = Signal(str)

    def __init__(self, change_requests, main_window, parent=None):
        super().__init__(parent)
        self.change_requests = change_requests
        self.main_window = main_window
        self._is_cancelled = False

    def run(self):
        conn = None
        results = []
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            total_changes = len(self.change_requests)

            for i, (change_type, cell_data, value) in enumerate(self.change_requests):
                if self._is_cancelled:
                    break

                new_symbol = self._prepare_new_symbol(change_type, cell_data, value, cursor)
                if new_symbol is None:
                    continue

                # Wykonanie procedury w bazie danych
                req = {
                    'nr_kadrowy': cell_data.get('nr_kadrowy'),
                    'rok': self.main_window.year,
                    'miesiac': self.main_window.month,
                    'data': cell_data.get('date_str'),
                    'symbol': new_symbol,
                    'user_id': cell_data.get('uzytkownik_id'),
                    'user_name': cell_data.get('uzytkownik_dane', '')
                }
                result = self._execute_and_parse_change(cursor, req)
                results.append(result)
                self.progress_updated.emit(i + 1)

            if not self._is_cancelled:
                conn.commit()
            self.finished.emit(results)

        except Exception as e:
            log_error(f"Krytyczny błąd w ScheduleChangeThread: {e}", exception=e)
            self.error_occurred.emit(str(e))
        finally:
            if conn:
                conn.close()

    def _prepare_new_symbol(self, change_type, cell_data, value, cursor):
        """Przygotowuje nowy symbol na podstawie typu operacji."""
        current_symbol = cell_data.get('symbol', '')
        parsed = parse_symbol(current_symbol)

        if change_type == ChangeType.QUICK_EDIT_START_HOUR:
            start_hour = value
            try:
                work_hours = int(float(cell_data.get('etat', 8.0)))
            except (ValueError, TypeError):
                work_hours = 8

            location = parsed.get('location') or self.main_window.determine_correct_location(cell_data, cursor=cursor)
            return build_symbol(
                location=location,
                start_hour=start_hour,
                work_hours=parsed.get('work_hours') or work_hours,
                special_symbol=parsed.get('special_symbol')
            )
        elif change_type == ChangeType.QUICK_EDIT_START_HOUR_NO_LOCATION:
            start_hour = value
            try:
                work_hours = int(float(cell_data.get('etat', 8.0)))
            except (ValueError, TypeError):
                work_hours = 8

            # Używamy istniejącej lokalizacji lub żadnej, bez sprawdzania w bazie
            location = parsed.get('location')
            return build_symbol(
                location=location,
                start_hour=start_hour,
                work_hours=parsed.get('work_hours') or work_hours,
                special_symbol=parsed.get('special_symbol')
            )
        elif change_type == ChangeType.MODIFY_WORK_HOURS:
            # value to delta (+1 lub -1)
            if parsed.get('work_hours') is None:
                return None
            current_hours = int(parsed['work_hours'])
            new_hours = min(12, current_hours + value) if value > 0 else max(1, current_hours + value)
            if new_hours == current_hours:
                return None
            return build_symbol(
                location=parsed.get('location'),
                start_hour=parsed.get('start_hour'),
                work_hours=new_hours,
                special_symbol=parsed.get('special_symbol')
            )
        elif change_type == ChangeType.APPLY_SPECIAL_SYMBOL:
            # value to special_symbol
            special_symbol = value
            system_pracy = cell_data.get('system_czasu_pracy', '').strip().lower()
            is_equivalent_system = (system_pracy == 'równoważny')
            # --- POPRAWKA: Sprawdź, czy special_symbol nie jest None przed wywołaniem .upper() ---
            is_absence_symbol = special_symbol is not None and special_symbol.upper() in app_settings.get_absence_symbols()

            final_start_hour = parsed.get('start_hour')
            final_work_hours = parsed.get('work_hours')

            if is_equivalent_system and is_absence_symbol:
                try:
                    final_work_hours = int(float(cell_data.get('etat')))
                except (ValueError, TypeError):
                    final_work_hours = 8

            final_location = None
            # --- POPRAWKA: Użyj `determine_correct_location` przy usuwaniu symbolu specjalnego ---
            # Jeśli `special_symbol` jest None (usuwanie), lub jest to symbol "pracujący",
            # musimy aktywnie ustalić prawidłową lokalizację.
            if (special_symbol and special_symbol.upper() in app_settings.WORK_LIKE_SYMBOLS) or not special_symbol:
                final_location = self.main_window.determine_correct_location(cell_data, cursor=cursor)

            new_symbol = build_symbol(
                location=final_location,
                start_hour=final_start_hour,
                work_hours=final_work_hours,
                special_symbol=special_symbol
            )
            if not new_symbol.strip() and special_symbol and special_symbol.strip():
                return special_symbol.strip()
            return new_symbol.strip() if new_symbol else ""


        elif change_type == ChangeType.CLEAR_CELL:
            # Sprawdź, czy symbol specjalny to urlop - logika biznesowa jest w main.py
            # Tutaj po prostu zwracamy pusty string, aby wyczyścić komórkę
            return ""  # Pusty symbol czyści komórkę

        elif change_type == ChangeType.APPLY_BUILT_SYMBOL:
            # Wartość 'value' zawiera już gotowy, nowy symbol
            return value if value is not None else ""

        return None  # Domyślnie, jeśli typ nie pasuje

    def _execute_and_parse_change(self, cursor, req):
        """Wykonuje pojedynczą operację i interpretuje jej wynik."""
        try:
            cursor.execute(
                f"EXEC {SQL_OBJECTS['p_importzmianynaserwer']} @Nr_Kadrowy = ?, @Rok = ?, @Miesiac = ?, @Data = ?, @Symbol = ?, @CzyPobieranieSugestii = ?",
                (req['nr_kadrowy'], req['rok'], req['miesiac'], req['data'], req['symbol'], None)
            )
            all_results = []
            while True:
                try:
                    rows = cursor.fetchall()
                    if rows: all_results.extend(rows)
                    if not cursor.nextset(): break
                except pyodbc.ProgrammingError: break

            returned_symbol, success, message = req.get('symbol', ''), True, "OK"
            for row in all_results:
                if row and len(row) > 0 and row[0] is not None:
                    raw_value = row[0]
                    if isinstance(raw_value, int) and raw_value == 0: continue
                    value_str = str(raw_value).strip()
                    if not value_str or value_str == "0": continue
                    is_likely_a_symbol = ' ' not in value_str and len(value_str) <= 50
                    if is_likely_a_symbol: returned_symbol = value_str
                    else: success, message = False, value_str; break
            
            req_result = req.copy()
            req_result.update({'success': success, 'message': message, 'returned_symbol': returned_symbol})
            return req_result
        except Exception as e:
            error_msg = f"Błąd wykonania procedury: {e}"
            log_error(f"Błąd przetwarzania żądania {req}: {e}", exception=e)
            req_result = req.copy()
            req_result.update({'success': False, 'message': error_msg, 'returned_symbol': req.get('symbol', '')})
            return req_result

    def cancel(self):
        self._is_cancelled = True


class ScheduleChangeProcessor:
    """Klasa zarządzająca procesem asynchronicznych zmian w grafiku."""

    def __init__(self, parent_window):
        self.parent = parent_window
        self.thread = None
        self.on_results_processed_callback = None  # <-- Nowy atrybut

    def start_changes(self, change_requests: list, on_results_processed=None):
        if not change_requests:
            return
        self.on_results_processed_callback = on_results_processed  # <-- Zapisz callback
        self.progress_dialog = QProgressDialog("Aktualizowanie grafiku...", "Anuluj", 0, len(change_requests), self.parent)
        self.progress_dialog.setWindowModality(Qt.WindowModal)
        self.progress_dialog.setWindowTitle("Przetwarzanie zmian")

        self.thread = ScheduleChangeThread(change_requests, self.parent)
        self.thread.progress_updated.connect(self.progress_dialog.setValue)
        self.thread.finished.connect(self._on_finished)
        self.thread.error_occurred.connect(self._on_error)
        self.progress_dialog.canceled.connect(self.thread.cancel)

        self.thread.start()
        self.progress_dialog.open()

    def _on_finished(self, results):
        self.progress_dialog.close()
        successful_updates = [res for res in results if res.get('success')]
        failed_updates = [res for res in results if not res.get('success')]

        if successful_updates:
            updates_for_ui = [(res['user_id'], res['data'], res.get('returned_symbol')) for res in successful_updates]
            self.parent._update_cells_with_new_symbols(updates_for_ui)
            self.parent.statusBar().showMessage(f"Pomyślnie zaktualizowano {len(successful_updates)} komórek.", 5000)

        # --- NOWA LOGIKA: Wywołaj callback, jeśli istnieje ---
        if self.on_results_processed_callback:
            try:
                # Przekaż pełne wyniki (sukcesy i porażki) do callbacka
                self.on_results_processed_callback(results)
            except Exception as e:
                log_error(f"Błąd podczas wywoływania on_results_processed_callback w ScheduleChangeProcessor: {e}",
                          exception=e)
        # --- KONIEC NOWEJ LOGIKI ---

        # Wyświetlanie błędów (bez zmian)
        if failed_updates:
            error_messages = [
                f"- {res.get('user_name', '')} ({res.get('data', '')}): {res.get('message', 'Błąd')}" for res in
                failed_updates]
            # Rozważ użycie ErrorSummaryDialog zamiast QMessageBox dla długich list błędów
            QMessageBox.warning(self.parent, "Błędy", "Wystąpiły błędy:<br>" + "<br>".join(error_messages))

        self.parent._update_modification_date()
        self.thread = None
        self.on_results_processed_callback = None  # <-- Zresetuj callback

    def _on_error(self, error_message):
        self.progress_dialog.close()
        QMessageBox.critical(self.parent, "Błąd krytyczny", f"Wystąpił błąd podczas aktualizacji:\n{error_message}")
        self.thread = None
