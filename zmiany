Doskonale, to bardzo waÅ¼na i czÄ™sta sytuacja w analizie danych! Praca na danych surowych (per poÅ‚Ä…czenie) daje nam znacznie wiÄ™ksze moÅ¼liwoÅ›ci. PorÃ³wnanie niepeÅ‚nego roku do adekwatnego okresu w przeszÅ‚oÅ›ci to standard "best practice".
PrzygotowaÅ‚em zaktualizowanÄ… wersjÄ™ notatnika, ktÃ³ra uwzglÄ™dnia nowÄ… strukturÄ™ danych i logikÄ™ porÃ³wnawczÄ… "rok do dziÅ›" (Year-to-Date, YTD).
Analiza PorÃ³wnawcza PoÅ‚Ä…czeÅ„ z InfoliniÄ… - Wersja YTD (Year-to-Date)
Data: 16 wrzeÅ›nia 2025
Autor: Gemini - Analityk Danych
ğŸ¯ 1. Cel Analizy (Bez Zmian)
GÅ‚Ã³wnym celem tej analizy jest przeprowadzenie szczegÃ³Å‚owego porÃ³wnania rocznego (Year-over-Year) kluczowych wskaÅºnikÃ³w wydajnoÅ›ci (KPI) infolinii dla porÃ³wnywalnych okresÃ³w. Skupimy siÄ™ na zrozumieniu zmian w wolumenie, efektywnoÅ›ci i charakterystyce interakcji klientÃ³w.
ğŸ¤” 2. ZaÅ‚oÅ¼enia i Dane
Kluczowa zmiana: Pracujemy na danych granularnych, gdzie kaÅ¼dy wiersz to jedna, unikalna interakcja identyfikowana przez callid. Tabela nie jest juÅ¼ pogrupowana.
Struktura danych:
 * callid: Unikalny identyfikator kaÅ¼dej interakcji.
 * Data: Data interakcji (zakÅ‚adam, Å¼e zawiera rÃ³wnieÅ¼ czas, jeÅ›li nie, analiza godzinowa bÄ™dzie niemoÅ¼liwa).
 * PozostaÅ‚e kolumny bez zmian: Kanal_kontakt, Typ_interakcji, czy_odebrane, wejscie, gdzie_koniec, czas_rozmowy.
Logika porÃ³wnawcza:
Analiza bÄ™dzie porÃ³wnywaÄ‡ okres od poczÄ…tku roku do ostatniej dostÄ™pnej daty w bieÅ¼Ä…cym roku z dokÅ‚adnie tym samym okresem w roku poprzednim. Na przykÅ‚ad, jeÅ›li najnowsze dane sÄ… z 15 wrzeÅ›nia 2024, porÃ³wnamy okres 01.01.2024 - 15.09.2024 z 01.01.2023 - 15.09.2023.
ğŸ 3. Przygotowanie Åšrodowiska i Wczytanie Danych
Kod do poÅ‚Ä…czenia pozostaje ten sam, ale tworzÄ™ nowy, bardziej realistyczny przykÅ‚ad danych.
# Import bibliotek
import pandas as pd
import sqlalchemy as sa
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np # Dodajemy numpy do obliczeÅ„

# Ustawienia wizualizacji
sns.set_theme(style="whitegrid")
plt.rcParams['figure.figsize'] = (12, 6)

# --- Åadowanie danych z MS SQL Server ---
# WypeÅ‚nij poniÅ¼sze zmienne swoimi danymi dostÄ™powymi
server_name = "TWOJ_SERWER"
database_name = "TWOJA_BAZA_DANYCH"
table_name = "NAZWA_TWOJEJ_TABELI_RAW"

try:
    # ... (kod poÅ‚Ä…czenia taki sam jak poprzednio) ...
    query = f"SELECT * FROM {table_name}"
    df_raw = pd.read_sql(query, engine)
    print("âœ… PomyÅ›lnie wczytano dane granularne.")

except Exception as e:
    print(f"âŒ BÅ‚Ä…d: {e}")
    # Nowy, przykÅ‚adowy zbiÃ³r danych granularnych
    data = {'callid': range(1000),
            'Data': pd.to_datetime(pd.date_range(start='2023-01-01', periods=500, freq='D').tolist() + 
                                   pd.date_range(start='2024-01-01', periods=500, freq='D').tolist()),
            'Kanal_kontakt': np.random.choice(['voice', 'czat', 'wideo'], 1000),
            'czy_odebrane': np.random.choice([1, 0], 1000, p=[0.8, 0.2]),
            'wejscie': np.random.choice(['ivr', 'bot', 'vendor'], 1000),
            'gdzie_koniec': np.random.choice(['konsultant', 'bot', 'transfer'], 1000),
            'czas_rozmowy': np.random.randint(30, 600, 1000)}
    df_raw = pd.DataFrame(data)
    # Ustawiamy niektÃ³re czasy na 0 dla nieodebranych
    df_raw.loc[df_raw['czy_odebrane'] == 0, 'czas_rozmowy'] = 0
    print("âš ï¸ Utworzono przykÅ‚adowy, granularny zbiÃ³r danych.")
    
display(df_raw.head())

ğŸ› ï¸ 4. Przygotowanie Danych (Logika YTD)
To jest kluczowy, nowy krok. Tworzymy porÃ³wnywalne zbiory danych.
# Konwersja kolumny 'Data' i tworzenie cech
df_raw['Data'] = pd.to_datetime(df_raw['Data'])
df_raw['Rok'] = df_raw['Data'].dt.year
df_raw['Miesiac'] = df_raw['Data'].dt.month
df_raw['Dzien_Roku'] = df_raw['Data'].dt.dayofyear # DzieÅ„ roku (1-366) jest idealny do porÃ³wnaÅ„ YTD

# --- Implementacja logiki Year-to-Date (YTD) ---

# 1. ZnajdÅº ostatniÄ… datÄ™ w bieÅ¼Ä…cym roku
current_year = df_raw['Rok'].max()
latest_date_cy = df_raw[df_raw['Rok'] == current_year]['Data'].max()
latest_day_of_year = latest_date_cy.dayofyear

print(f"Najnowsze dane pochodzÄ… z: {latest_date_cy.strftime('%Y-%m-%d')}")
print(f"Analiza zostanie przeprowadzona do {latest_day_of_year}. dnia roku.")

# 2. Odfiltruj dane z obu lat, aby obejmowaÅ‚y ten sam okres
df_ytd = df_raw[df_raw['Dzien_Roku'] <= latest_day_of_year].copy()

# 3. Sprawdzenie
print("\nZakres dat w analizowanym zbiorze:")
print(f"BieÅ¼Ä…cy rok: {df_ytd[df_ytd['Rok'] == current_year]['Data'].min().date()} - {df_ytd[df_ytd['Rok'] == current_year]['Data'].max().date()}")
print(f"Poprzedni rok: {df_ytd[df_ytd['Rok'] == current_year-1]['Data'].min().date()} - {df_ytd[df_ytd['Rok'] == current_year-1]['Data'].max().date()}")


ğŸ“Š 5. Analiza PorÃ³wnawcza i Wizualizacja Danych (YTD)
Wszystkie poniÅ¼sze analizy uÅ¼ywajÄ… juÅ¼ przefiltrowanego zbioru df_ytd.
5.1. OgÃ³lny Wolumen Interakcji (YTD)
# Agregacja YTD - liczymy callid
total_volume_ytd = df_ytd.groupby('Rok')['callid'].count().reset_index().rename(columns={'callid': 'liczba_polaczen'})

# Obliczenia i wizualizacja (kod wizualizacji pozostaje bardzo podobny)
# ... (uÅ¼yj kodu z poprzedniej odpowiedzi, ale na ramce total_volume_ytd) ...
# PamiÄ™taj o zmianie tytuÅ‚u na 'CaÅ‚kowity Wolumen Interakcji (YTD)'

Wnioski (YTD):
 * PorÃ³wnujÄ…c adekwatne okresy, widzimy [wzrost/spadek] wolumenu. DziÄ™ki temu podejÅ›ciu eliminujemy wpÅ‚yw sezonowoÅ›ci z pozostaÅ‚ej czÄ™Å›ci roku, dajÄ…c bardziej rzetelny obraz sytuacji.
5.2. Analiza Wolumenu w Podziale na KanaÅ‚y (YTD)
# Agregacja YTD po kanaÅ‚ach
channel_volume_ytd = df_ytd.groupby(['Rok', 'Kanal_kontakt'])['callid'].count().reset_index().rename(columns={'callid': 'liczba_polaczen'})

# Wizualizacja (kod podobny, zmieÅ„ tytuÅ‚ na '... (YTD)')
# ...

Wnioski (YTD):
 * Analiza YTD potwierdza/zmienia obraz z analizy caÅ‚orocznej. ByÄ‡ moÅ¼e wzrost na kanale czat nastÄ…piÅ‚ dopiero w drugiej poÅ‚owie poprzedniego roku, a porÃ³wnanie YTD pokazuje bardziej wyrÃ³wnany poziom.
5.3. Analiza Åšredniego Czasu ObsÅ‚ugi (AHT) (YTD)
Teraz AHT liczymy jako prostÄ… Å›redniÄ… z czas_rozmowy dla poÅ‚Ä…czeÅ„ odebranych.
# Filtrujemy tylko odebrane poÅ‚Ä…czenia
df_answered_ytd = df_ytd[df_ytd['czy_odebrane'] == 1]

# Agregacja YTD AHT
aht_ytd = df_answered_ytd.groupby('Rok')['czas_rozmowy'].mean().reset_index().rename(columns={'czas_rozmowy': 'Sredni_AHT_s'})

# Wizualizacja (kod podobny, zmieÅ„ tytuÅ‚ na '... (YTD)')
# ...

Wnioski (YTD):
 * Analiza AHT w okresach porÃ³wnywalnych jest kluczowa. ByÄ‡ moÅ¼e w poprzednim roku pod koniec roku mieliÅ›my seriÄ™ trudnych zgÅ‚oszeÅ„, ktÃ³re zawyÅ¼yÅ‚y Å›redniÄ… rocznÄ…, a analiza YTD pokazuje, Å¼e nasza efektywnoÅ›Ä‡ faktycznie siÄ™ poprawiÅ‚a.
(PozostaÅ‚e analizy 5.4 i 5.5 wykonuje siÄ™ analogicznie, zawsze grupujÄ…c dane z df_ytd i liczÄ…c callid za pomocÄ… .count())
ğŸ’ 6. GÅ‚Ä™bsza Analiza DziÄ™ki Danym Granularnym (Bonus)
Praca na surowych danych otwiera drzwi do analiz, ktÃ³re wczeÅ›niej byÅ‚y niemoÅ¼liwe.
6.1. Dystrybucja Czasu Trwania RozmÃ³w
Åšrednia (AHT) to nie wszystko. Czy wiÄ™kszoÅ›Ä‡ rozmÃ³w jest krÃ³tka, a kilka ekstremalnie dÅ‚ugich zawyÅ¼a Å›redniÄ…?
plt.figure(figsize=(14, 7))
# UÅ¼ywamy danych z bieÅ¼Ä…cego roku jako przykÅ‚ad
sns.histplot(data=df_answered_ytd[df_answered_ytd['Rok'] == current_year], x='czas_rozmowy', bins=50, kde=True)
plt.title(f'Dystrybucja Czasu Trwania RozmÃ³w (Histogram) w {current_year} (YTD)')
plt.xlabel('Czas rozmowy (sekundy)')
plt.ylabel('Liczba poÅ‚Ä…czeÅ„')
plt.axvline(df_answered_ytd[df_answered_ytd['Rok'] == current_year]['czas_rozmowy'].mean(), color='red', linestyle='--', label='Åšrednia (AHT)')
plt.legend()
plt.show()

Wnioski:
 * Histogram pokazuje faktyczny rozkÅ‚ad czasÃ³w rozmÃ³w. JeÅ›li jest on prawostronnie skoÅ›ny (co jest typowe), oznacza to, Å¼e wiÄ™kszoÅ›Ä‡ rozmÃ³w jest krÃ³tsza niÅ¼ Å›rednia, ale mamy "ogon" bardzo dÅ‚ugich rozmÃ³w.
 * Rekomendacja: Zamiast skupiaÄ‡ siÄ™ tylko na obniÅ¼aniu Å›redniej, warto zidentyfikowaÄ‡ te najdÅ‚uÅ¼sze rozmowy (callid z top 5% czas_rozmowy) i zbadaÄ‡ ich przyczyny. ByÄ‡ moÅ¼e sÄ… to zÅ‚oÅ¼one problemy techniczne lub nowi agenci, ktÃ³rzy potrzebujÄ… wsparcia.
6.2. Analiza obciÄ…Å¼enia w ciÄ…gu dnia (Peak Hour Analysis)
JeÅ›li kolumna Data zawiera czas, moÅ¼emy sprawdziÄ‡, o ktÃ³rej godzinie mamy najwiÄ™cej poÅ‚Ä…czeÅ„.
# Wzbogacenie danych o godzinÄ™
df_ytd['Godzina'] = df_ytd['Data'].dt.hour

# Agregacja godzinowa dla bieÅ¼Ä…cego roku
hourly_volume = df_ytd[df_ytd['Rok'] == current_year].groupby('Godzina')['callid'].count().reset_index()

plt.figure(figsize=(14, 7))
sns.barplot(data=hourly_volume, x='Godzina', y='callid', color='skyblue')
plt.title(f'RozkÅ‚ad PoÅ‚Ä…czeÅ„ w CiÄ…gu Dnia w {current_year} (YTD)')
plt.xlabel('Godzina Dnia')
plt.ylabel('Liczba PoÅ‚Ä…czeÅ„')
plt.show()

Wnioski:
 * Ten wykres jest absolutnie kluczowy dla Workforce Managementu. Pozwala zidentyfikowaÄ‡ godziny szczytu (np. 10:00-12:00) oraz okresy mniejszego ruchu.
 * Rekomendacja: DopasowaÄ‡ grafiki konsultantÃ³w do faktycznego obciÄ…Å¼enia. W godzinach szczytu zapewniÄ‡ peÅ‚nÄ… obsadÄ™, a w godzinach o mniejszym ruchu zaplanowaÄ‡ czas na szkolenia, spotkania czy odpisywanie na maile.
ğŸ’¡ 7. Podsumowanie i Rekomendacje (Wersja YTD)
Ta zaktualizowana analiza, oparta na danych granularnych i porÃ³wnaniu YTD, daje znacznie dokÅ‚adniejszy i bardziej wiarygodny obraz sytuacji.
Kluczowe zmiany w stosunku do poprzedniej analizy:
 * WiarygodnoÅ›Ä‡: PorÃ³wnujemy te same, adekwatne okresy, co eliminuje bÅ‚Ä™dy wynikajÄ…ce z sezonowoÅ›ci w pÃ³Åºniejszych miesiÄ…cach.
 * GÅ‚Ä™bia: Analiza dystrybucji AHT i obciÄ…Å¼enia godzinowego dostarcza nowych, praktycznych wnioskÃ³w, ktÃ³re byÅ‚y niemoÅ¼liwe do uzyskania na danych zagregowanych.
Rekomendacje z poprzedniej analizy pozostajÄ… w mocy, ale teraz sÄ… poparte solidniejszymi danymi i wzbogacone o nowe, bardziej szczegÃ³Å‚owe sugestie dotyczÄ…ce zarzÄ…dzania najdÅ‚uÅ¼szymi rozmowami i planowania grafikÃ³w pracy.
