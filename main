import sys
import time
from collections import defaultdict
from datetime import datetime, timedelta, date
from typing import List, Dict, Optional, Tuple, Any 
from PySide6.QtWidgets import (QApplication, QMainWindow, QTableWidget, QTableWidgetItem, QTableView, QItemDelegate,
                              QVBoxLayout, QHBoxLayout, QWidget, QLabel, QComboBox, QCompleter,
                              QPushButton, QHeaderView, QAbstractItemView, QListWidget,
                              QListWidgetItem, QLineEdit, QDialog, QCheckBox, QFrame, QDateEdit,
                              QFormLayout, QDialogButtonBox, QMessageBox, QSplitter, QStyledItemDelegate, QStyle,
                              QGridLayout, QSizePolicy, QTableWidgetSelectionRange)
from PySide6.QtCore import Qt, QThread, Signal, QDate, QTimer, QPoint, QModelIndex, QRect, QEvent, QItemSelectionModel, QAbstractTableModel, QObject
from PySide6.QtGui import QShortcut, QKeySequence, QFont, QColor, QIcon, QPixmap, QPainter, QPolygon, QBrush, QPen, QLinearGradient, QRadialGradient, QStandardItem, QStandardItemModel

from db_connector import DatabaseConnector, get_modifier_id
from settings_dialog import AppSettingsDialog
from schedule_edit_dialogs import InsertSymbolDialog, ScheduleChangeDialog
from settings_db import SettingsDatabase
from data_provider import DataProvider
from styles import AppStyles
from progress_dialog import LoadingProgressDialog, show_loading_dialog_async
from column_select_dialog import ColumnSelectDialog
from column_definitions import ColumnDefinitions

from schedule_model import ScheduleTableModel
from events_model import EventsTableModel
from split_table_view import SplitTableView
from schedule_delegates import OvertimeItemDelegate
from events_delegates import ButtonDelegate
from staffing_details_window import StaffingDetailsWindow

# POPRAWKA: Dodaj import funkcji debug
from debug_utils import debug_print, log_warning, log_error, setup_logging, close_log_file

from symbol_parser import parse_symbol, build_symbol, get_symbol_description
import atexit

# Konfiguracja logowania - dostosuj według potrzeb
def configure_logging():
    """Konfiguruje system logowania aplikacji"""
    setup_logging(
        log_to_file=True,           # Zapisuj do pliku
        log_to_console=True,        # Wyświetlaj w konsoli
        log_file_path=None,         # Automatyczna ścieżka (logs/teamflow_YYYY-MM-DD.log)
        max_file_size=10*1024*1024, # 10MB maksymalny rozmiar pliku
        max_files=5                 # Maksymalnie 5 plików archiwanych
    )
    
    # Automatyczne zamknięcie pliku logów przy wyjściu z aplikacji
    atexit.register(close_log_file)

# Wywołaj konfigurację na początku
configure_logging()


class ScheduleKeyboardFilter(QObject):
    """
    Dedykowany filtr zdarzeń klawiatury dla tabeli grafiku
    z obsługą dwucyfrowych godzin
    """

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window

        # NOWE: Bufor dla dwucyfrowych godzin
        self._digit_buffer = ""
        self._buffer_timer = QTimer()
        self._buffer_timer.setSingleShot(True)
        self._buffer_timer.timeout.connect(self._clear_buffer)
        self._buffer_timeout = 1500  # 1.5 sekundy na wpisanie drugiej cyfry

        # Bufor dla symboli znakowych
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1500

    def eventFilter(self, obj, event):
        """
        Filtr zdarzeń dla edycji klawiatury komórek grafiku z obsługą:
        - dwucyfrowych godzin (dla ról "Pracownik WPR" i "Lider OUT")
        - symboli specjalnych (tylko dla roli "Pracownik WPR")
        """
        # 1. Sprawdzamy, czy zdarzenie dotyczy wciśnięcia klawisza w tabeli grafiku
        if not (hasattr(self.main_window, 'table') and
                hasattr(self.main_window.table, 'schedule_view') and
                obj == self.main_window.table.schedule_view and
                event.type() == QEvent.KeyPress):
            return False  # To nie jest zdarzenie dla nas, przekaż dalej

        key = event.key()
        role = self.main_window.current_user_role

        # 2. Sprawdzamy uprawnienia w zależności od wciśniętego klawisza
        can_edit_hours = role in ["Pracownik WPR", "Lider OUT"]
        can_edit_symbols = role == "Pracownik WPR"

        is_digit_key = (Qt.Key_0 <= key <= Qt.Key_9)
        is_char_key = (Qt.Key_A <= key <= Qt.Key_Z)
        is_delete_key = key in [Qt.Key_Delete, Qt.Key_Backspace]
        is_escape_key = key == Qt.Key_Escape

        # Zablokuj akcję, jeśli użytkownik nie ma odpowiednich uprawnień
        if (is_digit_key and not can_edit_hours) or \
                (is_char_key and not can_edit_symbols) or \
                (is_delete_key and not can_edit_hours):
            return True  # Zablokuj zdarzenie (zjedz je)

        # 3. Sprawdzamy, czy zaznaczone komórki są edytowalne (dla akcji modyfikujących)
        if is_digit_key or is_char_key or is_delete_key:
            if not self._validate_selected_cells():
                return True  # Zablokuj, jeśli komórki są nieedytowalne

        # 4. Obsługa zdarzenia w zależności od klawisza
        if is_digit_key:
            digit = key - Qt.Key_0
            self._handle_digit_input(digit)
            return True

        if is_char_key:
            self._handle_char_input(event.text())
            return True

        if is_delete_key:
            self.main_window.clear_selected_cells()
            self._clear_buffer()  # Wyczyść bufor cyfr
            # Upewnij się, że masz metodę do czyszczenia bufora znaków
            if hasattr(self, '_char_buffer'):
                self._char_buffer = ""
                self._char_buffer_timer.stop()
            return True

        if is_escape_key:
            self._clear_buffer_silent()
            # Upewnij się, że masz metodę do cichego czyszczenia bufora znaków
            if hasattr(self, '_char_buffer'):
                self._char_buffer = ""
                self._char_buffer_timer.stop()
            if hasattr(self.main_window.table, 'schedule_view'):
                self.main_window.table.schedule_view.clearSelection()
            return True

        # 5. Blokowanie pozostałych, nieobsługiwanych klawiszy
        if key in [Qt.Key_Space, Qt.Key_Enter, Qt.Key_Return, Qt.Key_Tab]:
            return True

        # 6. Przekaż dalej wszystkie inne, nieobsłużone zdarzenia
        return False

    def _handle_char_input(self, char: str):
        """Obsługuje wprowadzanie znaków do bufora symbolu."""
        # Wyczyść bufor cyfr, aby uniknąć konfliktu
        if self._digit_buffer:
            self._clear_buffer()

        self._char_buffer += char.upper()
        debug_print(f"Wprowadzono znak: {char}, bufor symbolu: '{self._char_buffer}'")

        # Ustaw status bar w głównym oknie
        self.main_window.statusBar().showMessage(f"Wpisywanie symbolu: {self._char_buffer}", 2000)

        # Jeśli osiągnięto 3 znaki, przetwarzaj od razu
        if len(self._char_buffer) >= 3:
            self._char_buffer_timer.stop()
            self._process_char_buffer()
        else:
            # W przeciwnym razie, zresetuj timer i czekaj na kolejny znak
            self._char_buffer_timer.start(self._char_buffer_timeout)

    def _process_char_buffer(self):
        """Przetwarza wpisany symbol, waliduje go i wywołuje akcję w głównym oknie."""
        symbol = self._char_buffer
        self._char_buffer = ""  # Zawsze czyść bufor po przetworzeniu

        if not symbol:
            return

        # Pobierz listę dozwolonych symboli
        valid_symbols = self.main_window.get_all_valid_symbols()

        if symbol in valid_symbols:
            self.main_window.statusBar().showMessage(f"Symbol '{symbol}' jest prawidłowy. Zatwierdź zmiany.", 3000)
            # Wywołaj metodę w głównym oknie, która pokaże dialog potwierdzenia i zapisze zmiany
            self.main_window.apply_symbol_from_keyboard(symbol)
        else:
            self.main_window.statusBar().showMessage(f"Błąd: Symbol '{symbol}' jest nieprawidłowy!", 4000)
            # Opcjonalnie można dodać QMessageBox
            QMessageBox.warning(self.main_window, "Nieprawidłowy symbol",
                                f"Wpisany symbol '{symbol}' nie znajduje się na liście dozwolonych.")

    def _handle_digit_input(self, digit):
        """
        POPRAWIONA METODA: Obsługuje wprowadzanie cyfr bez podwójnych dialogów
        """
        # Dodaj cyfrę do bufora
        self._digit_buffer += str(digit)

        debug_print(f"Wprowadzono cyfrę: {digit}, bufor: '{self._digit_buffer}'")

        # Sprawdź czy mamy kompletną godzinę
        hour = None
        should_execute = False

        if len(self._digit_buffer) == 1:
            # Pierwsza cyfra - sprawdź czy to może być jednocyfrowa godzina (0-9)
            # lub początek dwucyfrowej (1 lub 2)
            first_digit = int(self._digit_buffer)

            if first_digit >= 3:
                # 3-9: Na pewno jednocyfrowa godzina - wykonaj natychmiast
                hour = first_digit
                should_execute = True
                self._clear_buffer_silent()  # Wyczyść bez wykonywania akcji
            else:
                # 0, 1, 2: Może być jednocyfrowa lub początek dwucyfrowej
                # Czekaj na drugą cyfrę przez określony czas
                self._buffer_timer.start(self._buffer_timeout)
                return  # Nie wykonuj jeszcze akcji

        elif len(self._digit_buffer) == 2:
            # Druga cyfra - zatrzymaj timer i sprawdź czy tworzy prawidłową godzinę
            self._buffer_timer.stop()  # KLUCZOWE: Zatrzymaj timer!

            potential_hour = int(self._digit_buffer)

            if 0 <= potential_hour <= 23:
                hour = potential_hour
            else:
                # Nieprawidłowa godzina - użyj tylko pierwszą cyfrę
                hour = int(self._digit_buffer[0])

            should_execute = True
            self._clear_buffer_silent()  # Wyczyść bez wykonywania akcji

        else:
            # Bufor za długi - wyczyść i użyj ostatnią cyfrę
            self._buffer_timer.stop()  # Zatrzymaj timer
            hour = digit
            should_execute = True
            self._clear_buffer_silent()

        # Wykonaj akcję tylko jeśli powinniśmy
        if should_execute and hour is not None:
            debug_print(f"Wykonuję edycję dla godziny: {hour}")
            self.main_window.quick_edit_selected_cells(hour)

    def _clear_buffer_silent(self):
        """
        NOWA METODA: Czyści bufor bez wykonywania akcji
        """
        self._digit_buffer = ""
        if self._buffer_timer.isActive():
            self._buffer_timer.stop()

    def _clear_buffer(self):
        """
        POPRAWIONA METODA: Czyści bufor cyfr (wywoływana przez timer)
        """
        if self._digit_buffer:
            # Timer wygasł - użyj pierwszą cyfrę z bufora
            hour = int(self._digit_buffer[0])
            debug_print(f"Timeout bufora - używam pierwszą cyfrę: {hour}")

            # Wyczyść bufor PRZED wykonaniem akcji
            self._digit_buffer = ""
            self._buffer_timer.stop()

            # Wykonaj akcję
            self.main_window.quick_edit_selected_cells(hour)
        else:
            # Bufor pusty - po prostu wyczyść
            self._digit_buffer = ""
            self._buffer_timer.stop()

    def _validate_selected_cells(self):
        """
        Sprawdza czy zaznaczone komórki można edytować
        (zachowana bez zmian)
        """
        try:
            # Pobierz zaznaczone komórki
            selected_cells_data = self.main_window.table.get_data_for_selected_cells()

            if not selected_cells_data:
                return False

            editable_cells = 0
            invalid_cells = []

            for cell_data in selected_cells_data:
                if not isinstance(cell_data, dict):
                    continue

                # Sprawdź czy to komórka grafiku (ma date_str i uzytkownik_id)
                if 'date_str' not in cell_data or 'uzytkownik_id' not in cell_data:
                    continue

                # Sprawdź czy komórka nie jest zablokowana
                user_name = cell_data.get('uzytkownik_dane', 'Nieznany')
                date_str = cell_data.get('date_str', '')

                # Sformatuj datę dla czytelności
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str

                # Sprawdź warunki edytowalności
                is_valid = self._is_cell_editable(cell_data)

                if is_valid:
                    editable_cells += 1
                else:
                    invalid_cells.append(f"{user_name} - {formatted_date}")

            # Jeśli są niejedytowalne komórki, pokaż komunikat
            if invalid_cells and editable_cells == 0:
                # Wszystkie komórki są nieedytowalne
                QMessageBox.warning(
                    self.main_window,
                    "Komórki nieedytowalne",
                    f"Wybrane komórki nie mogą być edytowane z klawiatury:\n\n" +
                    "\n".join(invalid_cells[:10]) +  # Pokaż max 10 przykładów
                    (f"\n... i {len(invalid_cells) - 10} więcej" if len(invalid_cells) > 10 else ""),
                    QMessageBox.Ok
                )
                return False

            elif invalid_cells and editable_cells > 0:
                # Częściowo edytowalne
                QMessageBox.information(
                    self.main_window,
                    "Częściowa edycja",
                    f"Edycja zostanie zastosowana tylko do {editable_cells} edytowalnych komórek.\n\n" +
                    f"Pomijane komórki ({len(invalid_cells)}):\n" +
                    "\n".join(invalid_cells[:5]) +  # Pokaż max 5 przykładów
                    (f"\n... i {len(invalid_cells) - 5} więcej" if len(invalid_cells) > 5 else ""),
                    QMessageBox.Ok
                )
                return True

            return editable_cells > 0

        except Exception as e:
            debug_print(f"Błąd walidacji komórek: {e}")
            return False

    def _is_cell_editable(self, cell_data):
        """
        Sprawdza czy pojedyncza komórka może być edytowana
        (zachowana bez zmian)
        """
        try:
            # Sprawdź czy komórka ma wymagane dane
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')

            if not user_id or not date_str:
                return False

            # Sprawdź czy użytkownik istnieje w active data
            if not str(user_id).isdigit():
                return False

            # Wszystkie sprawdzenia przeszły
            return True

        except Exception as e:
            debug_print(f"Błąd sprawdzania edytowalności komórki: {e}")
            return False


class CustomMultiComboBox(QComboBox):
    """Niestandardowy ComboBox z obsługą wielokrotnego wyboru (wersja poprawiona)."""
    selection_changed = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)

        self._selected_items = set()
        self._select_all_text = "-Wszystkie-"

        # Konfiguracja modelu
        self.setModel(QStandardItemModel(self))

        # Konfiguracja wyglądu
        self.setEditable(True)
        self.lineEdit().setReadOnly(True)
        self.setEditText("-Wszystkie-")
        self.setSizeAdjustPolicy(QComboBox.AdjustToContents)

        # Używamy filtra zdarzeń do przechwytywania kliknięć, co zapobiega zamykaniu listy
        self.view().viewport().installEventFilter(self)
        self.lineEdit().installEventFilter(self)

        # Delegat jest potrzebny do poprawnego renderowania
        self.setItemDelegate(QStyledItemDelegate(self))

    def eventFilter(self, obj, event):
        # Przechwytujemy kliknięcie myszą w polu tekstowym, aby pokazać listę
        if obj == self.lineEdit() and event.type() == QEvent.MouseButtonPress:
            self.showPopup()
            return True

        # Przechwytujemy zwolnienie przycisku myszy na liście (widoku)
        if obj == self.view().viewport() and event.type() == QEvent.MouseButtonRelease:
            index = self.view().indexAt(event.position().toPoint())  # Użyj .position().toPoint() zamiast .pos()
            if index.isValid():
                self.handle_item_pressed(index)
            return True

        return False

    def handle_item_pressed(self, index):
        """Logika zaznaczania/odznaczania elementu."""
        item = self.model().itemFromIndex(index)
        if not item:
            return

        if item.text() == self._select_all_text:
            # Logika dla przycisku "Zaznacz wszystkie"
            is_checked = (item.checkState() == Qt.Checked)
            new_state = Qt.Unchecked if is_checked else Qt.Checked
            for i in range(1, self.model().rowCount()):
                self.model().item(i).setCheckState(new_state)
        else:
            # Logika dla zwykłego elementu
            current_state = item.checkState()
            item.setCheckState(Qt.Checked if current_state == Qt.Unchecked else Qt.Unchecked)

        self._rebuild_selected_items()
        self.update_display_text()

        self.selection_changed.emit()

    def _rebuild_selected_items(self):
        """Przebudowuje zbiór zaznaczonych elementów na podstawie stanu modelu."""
        self._selected_items.clear()
        all_selected = True
        # Pętla od 1, aby pominąć element "Zaznacz wszystkie"
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.checkState() == Qt.Checked:
                self._selected_items.add(item.text())
            else:
                all_selected = False

        # Aktualizuj stan checkboxa "Zaznacz wszystkie"
        if self.model().rowCount() > 0:
            select_all_item = self.model().item(0)
            select_all_item.setCheckState(Qt.Checked if all_selected else Qt.Unchecked)

    def hidePopup(self):
        """Aktualizuje tekst po zamknięciu listy."""
        self.update_display_text()
        super().hidePopup()

    def add_items(self, items):
        """Dodaje elementy do ComboBoxa."""
        self.clear()

        select_all_item = QStandardItem(self._select_all_text)
        select_all_item.setCheckable(True)
        self.model().appendRow(select_all_item)

        for item_text in sorted(items):
            item = QStandardItem(item_text)
            item.setCheckable(True)
            self.model().appendRow(item)

        self.update_display_text()

    def showPopup(self):
        """Pokaż menu rozwijane z dostosowaną szerokością."""
        super().showPopup()  # Najpierw pokaż listę, aby można było obliczyć jej wymiary

        # Oblicz wymaganą szerokość na podstawie najdłuższego elementu
        width = self.view().sizeHintForColumn(0) + 20  # +20 na margines i pasek przewijania

        # OPCJA 1: Ustawienie nowego, większego limitu szerokości
        # Zwiększ limit z 250 do np. 450 pikseli. Można tu wpisać inną wartość.
        width = min(width, 450)

        # OPCJA 2: Całkowite usunięcie limitu (odkomentuj poniższą linię i zakomentuj powyższą)
        # W tej opcji lista będzie tak szeroka, jak najdłuższy element.
        # pass # Nie rób nic, aby nie ograniczać szerokości

        # Ustaw obliczoną minimalną szerokość dla widoku listy
        self.view().setMinimumWidth(width)

    def clear(self):
        """Czyści listę elementów."""
        self.model().clear()
        self._selected_items.clear()
        self.setEditText("-Wszystkie-")

    def clear_selection(self):
        """Czyści zaznaczenie wszystkich elementów."""
        for i in range(self.model().rowCount()):
            self.model().item(i).setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()

    def get_selected_items(self):
        """Zwraca listę zaznaczonych elementów."""
        return list(self._selected_items)

    def select_items(self, items_to_select):
        """Zaznacza programowo określone elementy na liście."""
        lookup = set(items_to_select)
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.text() in lookup:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()

    def update_display_text(self):
        """Aktualizuje tekst wyświetlany w comboboxie."""
        if not self._selected_items:
            self.setEditText("-Wszystkie-")
        elif len(self._selected_items) == (self.model().rowCount() - 1):
            self.setEditText("-Wszystkie-")
        else:
            self.setEditText(f"Wybrano {len(self._selected_items)} z {self.model().rowCount() - 1}")

class OvertimeItemDelegate(QStyledItemDelegate):
    """
    Niestandardowy delegat do rysowania komórek tabeli.
    Wyświetla subtelne znaczniki w prawym dolnym rogu:
    - Czerwony trójkąt dla nadgodzin
    - Białe kółko dla spotkań/szkoleń

    Zoptymalizowana wersja, która korzysta z dedykowanych flag zamiast deserializacji JSON.
    """

    def paint(self, painter, option, index):
        """
        Maluje komórkę z dodatkowymi ikonami dla nadgodzin, spotkań i szkoleń.
        Bezpieczna wersja z obsługą wszystkich typów danych.
        """
        try:
            # Najpierw spróbuj narysować standardową komórkę
            super().paint(painter, option, index)

            # Bezpieczne pobieranie flag - używaj metody get() lub defaultowego konwertowania na bool
            from schedule_model import ROLE_HAS_MEETING, ROLE_HAS_OVERTIME
            has_overtime = bool(index.data(ROLE_HAS_OVERTIME))
            has_meeting_or_training = bool(index.data(ROLE_HAS_MEETING))

            # Jeśli element ma jakiekolwiek oznaczenia
            if has_overtime or has_meeting_or_training:
                painter.save()
                # Włącz antyaliasing dla gładkich krawędzi
                painter.setRenderHint(QPainter.Antialiasing)

                # Określ szerokość i pozycję znaczników
                marker_width = 8  # Rozmiar znacznika
                marker_height = 8

                # Rysuj znacznik spotkań/szkoleń (białe kółko) w górnym prawym rogu
                if has_meeting_or_training:
                    # Oblicz pozycję w górnym prawym rogu
                    top_right_x = option.rect.right() - marker_width - 2  # -2 to margines
                    top_right_y = option.rect.top() + 2  # +2 to margines

                    # Rysujemy kółko z białym wypełnieniem i czarną obwódką
                    painter.setBrush(QBrush(QColor(255, 255, 255, 240)))  # Białe wypełnienie
                    painter.setPen(QPen(QColor(0, 0, 0, 220), 1.0))  # Czarna obwódka
                    painter.drawEllipse(
                        top_right_x,
                        top_right_y,
                        marker_width,
                        marker_height
                    )

                # Rysuj znacznik nadgodzin (czerwony trójkąt) w dolnym prawym rogu
                if has_overtime:
                    # Oblicz pozycję w dolnym prawym rogu
                    bottom_right_x = option.rect.right() - marker_width - 2  # -2 to margines
                    bottom_right_y = option.rect.bottom() - marker_height - 2  # -2 to margines

                    # Czerwony trójkąt z czarną obwódką
                    painter.setBrush(QBrush(QColor(220, 0, 0, 220)))  # Czerwone wypełnienie
                    painter.setPen(QPen(Qt.black, 1.0))  # Czarna obwódka

                    triangle = QPolygon()
                    triangle.append(QPoint(bottom_right_x, bottom_right_y + marker_height))
                    triangle.append(QPoint(bottom_right_x + marker_width, bottom_right_y + marker_height))
                    triangle.append(QPoint(bottom_right_x + marker_width, bottom_right_y))
                    painter.drawPolygon(triangle)

                painter.restore()
        except Exception as e:
            # W przypadku błędu po prostu wyświetl domyślny wygląd komórki
            log_error(f"Błąd podczas rysowania delegata: {e}")
            QStyledItemDelegate.paint(self, painter, option, index)

class WorkScheduleWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # --- SEKCJA 1: Wstępna konfiguracja i wczytanie ustawień ---
        self.staffing_details_win = None
        self.settings_db = SettingsDatabase()
        user_settings = self.settings_db.load_settings()

        self.is_dark_theme = user_settings.get('theme') == 'dark'
        self.current_font = user_settings.get('font_family')
        self.current_font_size = user_settings.get('font_size')
        self.import_grupa = user_settings.get('import_grupa', 3)
        self.import_funkcja = user_settings.get('import_funkcja', 1)
        self.show_comment_column = user_settings.get('show_schedule_comment', False)
        self.can_see_next_month = False

        from data_provider import DataProvider
        self.data_provider = DataProvider()
        self.statusBar().showMessage("Gotowy")

        self.column_definitions = ColumnDefinitions()
        self.employee_columns = self.column_definitions.get_ui_display_columns()
        self.default_visible_columns = self.column_definitions.DEFAULT_VISIBLE_COLUMNS
        saved_columns = user_settings.get('visible_columns')
        self.visible_columns = saved_columns if saved_columns else self.default_visible_columns.copy()

        self.data_provider.data_changed.connect(self.on_data_changed)
        self.setWindowTitle("TeamFlowApp")
        self.setGeometry(100, 100, 1600, 800)  # Zwiększono domyślny rozmiar okna

        self.left_panel_visible = True
        self._updating_selection = False
        self._cross_filtering_enabled = True

        self.raw_data = []
        self.processed_data = {}
        self.last_modification_date = None
        self.all_events_data = []
        self.user_info_map = {}

        self._selection_timer = QTimer()
        self._selection_timer.setSingleShot(True)
        self._selection_timer.timeout.connect(self._handle_selection_change)

        # --- SEKCJA 2: Budowa UI i sprawdzenie uprawnień ---
        font = QFont(self.current_font, self.current_font_size)
        QApplication.setFont(font)

        # Tworzy wszystkie widżety, ale jeszcze nie podłącza sygnału do date_combo
        self.setup_ui()

        # Pobiera rolę i uprawnienia użytkownika
        if not self.check_user_permissions():
            return

        # --- SEKCJA 3: Tworzenie modeli i łączenie z UI ---
        self.schedule_model = ScheduleTableModel(self, user_role=self.current_user_role)
        self.events_model = EventsTableModel(self)

        self.schedule_model.set_visible_columns(self.visible_columns)
        self.schedule_model.set_show_comment_column(self.show_comment_column)
        self.schedule_model.set_theme(self.is_dark_theme)
        self.events_model.set_theme(self.is_dark_theme)

        self.table.set_model(self.schedule_model)
        self.events_table.setModel(self.events_model)

        # Konfiguracja delegatów
        overtime_delegate = OvertimeItemDelegate()
        self.table.schedule_view.setItemDelegate(overtime_delegate)
        button_delegate = ButtonDelegate(parent=self, button_text="Usuń", is_dark_theme=self.is_dark_theme)
        self.events_table.setItemDelegateForColumn(9, button_delegate)
        button_delegate.button_clicked.connect(self.delete_event_from_row)

        # --- SEKCJA 4: Załadowanie DANYCH TYLKO RAZ ---
        self.setup_keyboard_editing()
        self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font, self.current_font_size)

        # Wypełniamy listę miesięcy (teraz, gdy uprawnienia są znane)
        self.setup_date_combo()

        # Ładujemy dane dla miesiąca ustawionego w date_combo
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data
            self.update_data(year, month)
            self.update_filter_dates()

        self.clear_events_on_startup()

        # --- SEKCJA 5: Podłączenie sygnałów i uruchomienie timerów ---
        # Dopiero teraz podłączamy sygnał, aby reagował tylko na akcje użytkownika
        self.date_combo.currentIndexChanged.connect(self.on_date_combo_changed)

        self.check_timer = QTimer(self)
        self.check_timer.timeout.connect(self.check_for_new_data)
        self.check_timer.start(60000)

        # Skrót F1 do przełączania widoczności lewego panelu filtrów
        self.shortcut_f1 = QShortcut(QKeySequence(Qt.Key_F1), self)
        self.shortcut_f1.activated.connect(self.toggle_left_panel)

        # Skrót F2 do przełączania widoczności dolnego panelu zdarzeń
        self.shortcut_f2 = QShortcut(QKeySequence(Qt.Key_F2), self)
        self.shortcut_f2.activated.connect(self.toggle_events_panel)
        # Skrót F12 do usuwania symbolu specjalnego z komórki
        self.shortcut_f12 = QShortcut(QKeySequence(Qt.Key_F12), self)
        self.shortcut_f12.activated.connect(self.clear_special_symbol_from_selected_cells)
        self._selection_debounce_delay = 50  # 50ms delay
        # Skrót F3 do wywołania okna "Wstaw zmianę"
        self.shortcut_f3 = QShortcut(QKeySequence(Qt.Key_F3), self)
        self.shortcut_f3.activated.connect(self.show_insert_change_dialog)

        # Skrót F4 do wywołania okna "Wstaw nieobecność"
        self.shortcut_f4 = QShortcut(QKeySequence(Qt.Key_F4), self)
        self.shortcut_f4.activated.connect(self.show_insert_symbol_dialog)

        # Skrót F5 do wywołania akcji "Odwołaj delegacje"
        self.shortcut_f5 = QShortcut(QKeySequence(Qt.Key_F5), self)
        self.shortcut_f5.activated.connect(self.cancel_delegations)

        debug_print("=== APLIKACJA TEAMFLOW URUCHOMIONA ===")
        debug_print(f"Użytkownik: {self.current_user_app_id} ({self.current_user_role})")
        debug_print(f"Motyw: {'ciemny' if self.is_dark_theme else 'jasny'}")
        debug_print(f"Czcionka: {self.current_font} {self.current_font_size}pt")

    def show_staffing_details_window(self):
        # Sprawdź, czy wybrany jest miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Brak danych", "Proszę wybrać miesiąc, aby wyświetlić szczegóły obsady.",
                                QMessageBox.Ok)
            return

        year, month = current_data

        # Jeśli okno już istnieje i jest widoczne, aktywuj je i zaktualizuj dane
        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            self.staffing_details_win.activateWindow()
            self.staffing_details_win.raise_()  # Upewnij się, że okno jest na wierzchu
            # Ustaw aktualny motyw przed aktualizacją danych, na wypadek gdyby się zmienił
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.update_for_new_month_or_filters(year, month)
            debug_print(f"StaffingDetailsWindow: Aktywowano i zaktualizowano istniejące okno dla {year}-{month}.")
        else:
            # Utwórz nowe okno, przekazując siebie jako rodzica, data_provider oraz aktualny rok i miesiąc
            debug_print(f"StaffingDetailsWindow: Tworzenie nowego okna dla {year}-{month}.")
            self.staffing_details_win = StaffingDetailsWindow(self, self.data_provider, year, month)
            # Ustaw motyw przed pierwszym pokazaniem
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.show()
            # Po pokazaniu, dane zostaną załadowane przez `load_and_display_data` w konstruktorze StaffingDetailsWindow
            # lub przez wywołanie `update_for_new_month_or_filters` jeśli dane mają być ładowane tylko po pokazaniu.
            # Obecna implementacja StaffingDetailsWindow ładuje dane w __init__ (poprzez load_and_display_data).

        # Jeśli chcesz, aby dane były ładowane/odświeżane za każdym razem, gdy okno jest pokazywane (nawet jeśli już istniało):
        # if self.staffing_details_win:
        # self.staffing_details_win.set_current_theme(self.is_dark_theme) # Ustaw motyw
        # self.staffing_details_win.update_for_new_month_or_filters(year, month) #

    def setup_keyboard_editing(self):
        """Konfiguruje edycję klawiatury dla komórek grafiku"""
        # Sprawdź czy użytkownik ma uprawnienia do edycji klawiatury
        allowed_roles = ["Pracownik WPR", "Lider OUT"]
        if not hasattr(self, 'current_user_role') or self.current_user_role not in allowed_roles:
            debug_print(
                f"Edycja klawiatury wyłączona - rola '{getattr(self, 'current_user_role', 'Brak')}' nie ma uprawnień.")
            return

        # Utwórz dedykowany filtr klawiatury
        self.keyboard_filter = ScheduleKeyboardFilter(self)

        # Zainstaluj filtr zdarzeń dla tabeli grafiku
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            self.table.schedule_view.installEventFilter(self.keyboard_filter)
            debug_print(f"Włączono edycję klawiatury dla roli: {self.current_user_role}")

    def cleanup_keyboard_filter(self):
        """Czyści filtr klawiatury przy zamykaniu aplikacji"""
        if hasattr(self, 'keyboard_filter'):
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.removeEventFilter(self.keyboard_filter)
            del self.keyboard_filter
            debug_print("Wyczyszczono filtr klawiatury")

    def quick_edit_selected_cells(self, start_hour):
        """
        Szybka edycja zaznaczonych komórek z klawiatury

        Args:
            start_hour (int): Godzina rozpoczęcia (0-9)
        """
        try:
            # Sprawdź uprawnienia
            allowed_roles = ["Pracownik WPR", "Lider OUT"]
            if not hasattr(self, 'current_user_role') or self.current_user_role not in allowed_roles:
                debug_print("Brak uprawnień do edycji klawiatury")
                return

            # Pobierz zaznaczone komórki
            selected_cells_data = self.table.get_data_for_selected_cells()

            if not self._can_modify_cells(selected_cells_data):
                return

            if not selected_cells_data:
                debug_print("Brak zaznaczonych komórek do edycji")
                return

            # Filtruj tylko komórki grafiku (nie kolumny pracowników)
            schedule_cells = []
            for cell_data in selected_cells_data:
                if isinstance(cell_data, dict) and 'date_str' in cell_data and 'uzytkownik_id' in cell_data:
                    schedule_cells.append(cell_data)

            if not schedule_cells:
                debug_print("Brak komórek grafiku do edycji")
                return

            debug_print(f"Szybka edycja: {len(schedule_cells)} komórek, godzina start: {start_hour}")

            # Pogrupuj komórki dla lepszego komunikatu potwierdzenia
            grouped_changes = {}
            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                user_name = cell_data.get('uzytkownik_dane', '')
                date_str = cell_data.get('date_str')

                # Formatuj datę
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str

                user_key = (user_id, user_name)
                if user_key not in grouped_changes:
                    grouped_changes[user_key] = []
                grouped_changes[user_key].append(formatted_date)

            # Przygotuj komunikat potwierdzenia
            changes_info = f"Zmiana godziny rozpoczęcia na {start_hour}:00 dla:\n\n"
            for (user_id, user_name), dates in grouped_changes.items():
                changes_info += f"👤 {user_name}:\n"
                dates_str = ", ".join(sorted(dates))
                changes_info += f"   📅 {dates_str}\n\n"

            changes_info += f"Łącznie: {len(schedule_cells)} komórek"

            # Pokaż potwierdzenie
            reply = QMessageBox.question(
                self,
                "Potwierdzenie szybkiej edycji",
                changes_info,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )

            if reply == QMessageBox.Yes:
                self._apply_quick_changes(schedule_cells, start_hour)

        except Exception as e:
            log_error(f"Błąd podczas szybkiej edycji: {e}")
            QMessageBox.critical(
                self,
                "Błąd",
                f"Wystąpił błąd podczas edycji: {str(e)}",
                QMessageBox.Ok
            )

    def _apply_quick_changes(self, schedule_cells, start_hour):
        """
        POPRAWIONA WERSJA: Stosuje nową godzinę rozpoczęcia, konwertując 'etat' na int.
        """
        updated_info = []

        for cell_data in schedule_cells:
            current_symbol = cell_data.get('symbol', '')

            location, work_hours, special = None, None, None

            if current_symbol and current_symbol.strip():
                parsed = parse_symbol(current_symbol)
                location = parsed.get('location')
                work_hours = parsed.get('work_hours')
                special = parsed.get('special_symbol')
            else:
                location = cell_data.get('lokalizacja_domyslna')
                work_hours = cell_data.get('etat')

            # Niezawodne sprawdzenie i konwersja na int
            try:
                # --- ZMIANA TUTAJ ---
                # Najpierw konwertujemy na float, a potem na int
                work_hours = int(float(work_hours))
            except (ValueError, TypeError):
                work_hours = 8  # Bezpieczny fallback jako int

            new_symbol = build_symbol(
                location=location,
                start_hour=start_hour,
                work_hours=work_hours,
                special_symbol=special
            )

            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
            except Exception as e:
                log_error(f"Błąd wywołania procedury w _apply_quick_changes: {e}")

        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Pomyślnie zaktualizowano {len(updated_info)} komórek.", 3000)

    def _show_keyboard_edit_results(self, successful_updates, failed_updates, error_messages, start_hour):
        """
        Pokazuje wyniki edycji klawiatury - uproszczone komunikaty
        """
        if successful_updates > 0:
            message = f"Pomyślnie zaktualizowano {successful_updates} komórek (cyfra: {start_hour})"

            if failed_updates > 0:
                message += f"\n\n⚠️ {failed_updates} aktualizacji nie powiodło się"
                if error_messages:
                    message += ":\n" + "\n".join(error_messages[:3])  # Pokaż tylko 3 błędy
                    if len(error_messages) > 3:
                        message += f"\n... i {len(error_messages) - 3} więcej błędów"

            QMessageBox.information(
                self,
                "Edycja klawiatury",
                message,
                QMessageBox.Ok
            )
        else:
            message = f"Nie udało się zaktualizować żadnej komórki (cyfra: {start_hour})"
            if error_messages:
                message += f"\n\nBłędy:\n" + "\n".join(error_messages[:5])

            QMessageBox.warning(
                self,
                "Błąd edycji klawiatury",
                message,
                QMessageBox.Ok
            )

    def _prepare_deletion_summary_message(self, schedule_cells: list) -> str:
        """
        Przygotowuje sformatowaną wiadomość podsumowującą, które symbole zostaną usunięte,
        grupując je według użytkownika i dat.
        """
        if not schedule_cells:
            return "Nie wybrano żadnych komórek z symbolami do usunięcia."

        grouped_deletions = {}
        # Grupowanie komórek: Użytkownik -> Lista sformatowanych dat z symbolami
        for cell_data in schedule_cells:
            user_name = cell_data.get('uzytkownik_dane', 'Nieznany Użytkownik')
            date_str = cell_data.get('date_str', 'Nieznana Data')
            symbol = cell_data.get('symbol', '??')  # Pobierz symbol do wyświetlenia

            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except ValueError:
                formatted_date = date_str

            if user_name not in grouped_deletions:
                grouped_deletions[user_name] = []
            grouped_deletions[user_name].append(f"{formatted_date} (symbol: {symbol})")

        summary_lines = ["Czy na pewno chcesz usunąć symbole dla następujących pozycji?\n"]
        for user_name, date_symbol_list in grouped_deletions.items():
            summary_lines.append(f"👤 {user_name}:")
            # Aby uniknąć zbyt długich linii, można dzielić listę dat
            # Na razie wyświetlimy wszystkie dla danego użytkownika
            for date_with_symbol in sorted(date_symbol_list):  # Sortuj daty dla spójności
                summary_lines.append(f"   • {date_with_symbol}")
            summary_lines.append("")  # Pusta linia dla lepszej czytelności między użytkownikami

        summary_lines.append(f"Łącznie zostanie wyczyszczonych: {len(schedule_cells)} komórek.")
        return "\n".join(summary_lines)

    def clear_selected_cells(self):
        """
        Czyści symbole z zaznaczonych komórek (Delete/Backspace) z ulepszonym potwierdzeniem.
        """
        try:
            if hasattr(self, 'keyboard_filter') and hasattr(self.keyboard_filter, '_buffer_timer'):
                self.keyboard_filter._buffer_timer.stop()
                self.keyboard_filter._digit_buffer = ""

            allowed_roles = ["Pracownik WPR", "Lider OUT"]
            if not hasattr(self, 'current_user_role') or self.current_user_role not in allowed_roles:
                debug_print("Brak uprawnień do usuwania symboli klawiatury")
                return

            selected_cells_data = self.table.get_data_for_selected_cells()

            if not self._can_modify_cells(selected_cells_data):
                return

            if not selected_cells_data:
                debug_print("Brak zaznaczonych komórek do wyczyszczenia")
                return

            schedule_cells = []
            for cell_data in selected_cells_data:
                if isinstance(cell_data, dict) and 'date_str' in cell_data and 'uzytkownik_id' in cell_data:
                    current_symbol = cell_data.get('symbol', '')
                    if current_symbol and current_symbol.strip():
                        schedule_cells.append(cell_data)

            if not schedule_cells:
                debug_print("Brak komórek z symbolami do wyczyszczenia")
                self.statusBar().showMessage("Zaznaczone komórki są puste lub nie zawierają symboli do usunięcia.", 3000)
                return

            # Przygotuj szczegółowy komunikat potwierdzenia
            confirmation_message = self._prepare_deletion_summary_message(schedule_cells)

            # Pokaż potwierdzenie, ustawiając "Tak" jako domyślny przycisk (reagujący na Enter)
            reply = QMessageBox.question(
                self,
                "Potwierdzenie usunięcia symboli",
                confirmation_message,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes  # Ustawia "Tak" jako domyślny przycisk
            )

            if reply == QMessageBox.Yes:
                self._clear_cells_symbols(schedule_cells)

        except Exception as e:
            log_error(f"Błąd podczas czyszczenia komórek: {e}", exception=e)
            QMessageBox.critical(self, "Błąd krytyczny", f"Wystąpił nieoczekiwany błąd podczas próby usunięcia symboli: {str(e)}")


    def _clear_cells_symbols(self, schedule_cells: list):
        """
        Usuwa symbole z podanych komórek poprzez wywołanie procedury
        p_P_ZZ_ImportZmianyNaSerwer_v3 z pustym symbolem.
        """
        successful_updates = 0
        failed_updates = 0
        error_messages = []
        affected_pairs = []  # Ta lista musi zawierać krotki 3-elementowe

        debug_print(f"Rozpoczynam usuwanie symboli dla {len(schedule_cells)} komórek.")

        for cell_data in schedule_cells:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            nr_kadrowy = cell_data.get('nr_kadrowy')

            if not user_id or not date_str or not nr_kadrowy:
                failed_updates += 1
                error_detail = f"user_id={user_id}, data={date_str}, nr_kadrowy={nr_kadrowy}"
                if not nr_kadrowy:
                    error_messages.append(f"Brak numeru kadrowego dla użytkownika {user_id} w dniu {date_str}.")
                else:
                    error_messages.append(f"Niekompletne dane dla komórki: {error_detail}.")
                log_warning(f"Pominięto komórkę z powodu niekompletnych danych: {error_detail}")
                continue

            try:
                year, month, day = date_str.split('-')
                date_obj = f"{year}-{month}-{day}"

                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy,
                    rok=int(year),
                    miesiac=int(month),
                    data=date_obj,
                    symbol=""  # Pusty symbol oznacza usunięcie
                )

                if result.get('success', False):
                    successful_updates += 1
                    # --- KLUCZOWA POPRAWKA ---
                    # Dodajemy krotkę z 3 elementami, w tym symbolem zwrotnym z procedury.
                    # Dla usuwania, zwrócony symbol powinien być pustym stringiem.
                    affected_pairs.append((user_id, date_str, result.get('returned_symbol')))
                    debug_print(f"Pomyślnie usunięto symbol: Użytkownik {user_id} ({nr_kadrowy}), Data {date_str}")
                else:
                    failed_updates += 1
                    error_msg = result.get('message', 'Nieznany błąd podczas usuwania symbolu.')
                    error_messages.append(f"Pracownik {nr_kadrowy} (dnia {date_str}): {error_msg}")
                    debug_print(f"Błąd usuwania symbolu dla {nr_kadrowy} ({date_str}): {error_msg}")

            except ValueError:
                failed_updates += 1
                error_messages.append(f"{nr_kadrowy} ({date_str}): Nieprawidłowy format daty.")
                log_error(f"Nieprawidłowy format daty dla {nr_kadrowy}, {date_str} przy usuwaniu symbolu.")
            except Exception as e:
                failed_updates += 1
                error_messages.append(f"{nr_kadrowy} ({date_str}): Błąd krytyczny - {str(e)}")
                log_error(f"Krytyczny błąd podczas usuwania symbolu dla {user_id}, {date_str}: {e}", exception=e)

        # Odśwież dane w UI, jeśli były jakieś udane operacje
        if successful_updates > 0 and affected_pairs:
            # Wywołanie metody odświeżającej z poprawnie sformatowanymi danymi
            self._update_cells_with_new_symbols(affected_pairs)
            debug_print(f"Odświeżono {len(affected_pairs)} komórek po usunięciu symboli.")

        # Pokaż wyniki operacji
        self._show_clear_symbols_results(successful_updates, failed_updates, error_messages)

    def _show_clear_symbols_results(self, successful_updates: int, failed_updates: int, error_messages: list):
        """
        Wyświetla użytkownikowi podsumowanie operacji usuwania symboli.
        """
        if successful_updates > 0:
            message = f"Pomyślnie usunięto symbole z {successful_updates} komórek."
            if failed_updates > 0:
                message += f"\n\n⚠️ {failed_updates} operacji usunięcia symbolu nie powiodło się."
                if error_messages:
                    # Formatowanie listy błędów dla lepszej czytelności
                    error_list_str = "\n - " + "\n - ".join(error_messages[:5])
                    message += ":" + error_list_str
                    if len(error_messages) > 5:
                        message += f"\n... i {len(error_messages) - 5} więcej błędów (sprawdź logi aplikacji)."

            QMessageBox.information(self, "Wyniki usuwania symboli", message, QMessageBox.Ok)
        else:  # Tylko jeśli nie było żadnych sukcesów
            message = "Nie udało się usunąć symboli z żadnej zaznaczonej komórki."
            if error_messages:
                error_list_str = "\n - " + "\n - ".join(error_messages[:10])
                message += f"\n\nBłędy ({len(error_messages)}):" + error_list_str
                if len(error_messages) > 10:
                    message += f"\n... i {len(error_messages) - 10} więcej błędów (sprawdź logi aplikacji)."

            QMessageBox.warning(self, "Błąd usuwania symboli", message, QMessageBox.Ok)

  
    def set_cell_data(self, row, col, data_dict):
        """
        Ustawia dane w komórce modelu.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny
            data_dict: Słownik z danymi do zapisania

        Returns:
            bool: True jeśli operacja się powiodła, False w przeciwnym razie
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return False

        if not isinstance(data_dict, dict):
            log_error(f"Błąd: data_dict nie jest słownikiem: {type(data_dict)}")
            return False

        # Utwórz indeks modelu dla podanej pozycji
        index = self.schedule_model.index(row, col)
        if not index.isValid():
            return False

        # Ustaw dane w modelu
        return self.schedule_model.setData(index, data_dict, Qt.UserRole)

    def on_data_changed(self, data_type, year, month):
        """Obsługuje powiadomienie o zmianie danych z DataProvider."""
        current_data = self.date_combo.currentData()
        if not (current_data and current_data == (year, month)):
            return

        if data_type == "schedule":
            self.update_table_content()
        elif data_type == "events":
            # Po prostu odświeżamy tabelę zdarzeń, jeśli coś się w nich zmieniło
            self.on_selection_changed()
            


    def log_time(self, label, start_time):
        """Pomocnicza funkcja do logowania czasu"""
        end_time = time.time()
        elapsed = end_time - start_time
        debug_print(f"[CZAS] {label}: {elapsed:.3f} sekundy")
        return end_time

    def setup_ui(self):
        """Ustawia interfejs użytkownika"""
        # Główny widget i layout
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)

        # WAŻNA ZMIANA: Usunięcie marginesy górnego i dolnego
        main_layout.setContentsMargins(10, 0, 10, 0)  # Lewy, Górny, Prawy, Dolny
        main_layout.setSpacing(0)  # Brak odstępu między elementami

        # Tworzenie poszczególnych części interfejsu
        top_bar = self.setup_top_bar(main_layout)

        # Dodanie górnego paska do głównego layoutu
        main_layout.addWidget(top_bar)

        # Dodanie splittera środkowego
        middle_splitter = self.setup_middle_section(main_layout)
        main_layout.addWidget(middle_splitter, 1)  # Dodaj z rozciąganiem (waga 1)

        # Ustawienie głównego widgetu
        self.setCentralWidget(central_widget)

        # Dodatkowe konfiguracje
        self.setup_table_properties()

        # ZMIANA: Podłącz sygnał selection_changed dopiero po utworzeniu wszystkich komponentów
        if hasattr(self, 'table'):
            # Odłącz poprzednie połączenia jeśli istnieją
            try:
                self.table.selection_changed.disconnect()
            except:
                pass

            # Podłącz nowe połączenie
            self.table.selection_changed.connect(self.on_selection_changed)

    def setup_top_bar(self, main_layout):
        """Tworzy górny pasek z przyciskami i kontrolkami"""
        top_bar_frame = QFrame()
        top_bar_frame.setFrameShape(QFrame.StyledPanel)
        top_bar_frame.setFrameShadow(QFrame.Raised)
        top_bar_frame.setFixedHeight(50)

        top_bar_layout = QHBoxLayout(top_bar_frame)
        top_bar_layout.setContentsMargins(5, 5, 5, 5)
        top_bar_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        self.toggle_menu_button = QPushButton()
        self.toggle_menu_button.setFixedSize(32, 32)
        self.toggle_menu_button.setText("☰")
        self.toggle_menu_button.setToolTip("Pokaż/ukryj panel filtrów (F1)")
        self.toggle_menu_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))  #
        self.toggle_menu_button.clicked.connect(self.toggle_left_panel)
        top_bar_layout.addWidget(self.toggle_menu_button)

        self.settings_button = QPushButton("Ustawienia")  # NOWY PRZYCISK
        self.settings_button.clicked.connect(self.show_settings_dialog)  # NOWA METODA
        self.settings_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light")) #

        date_label = QLabel("Miesiąc:")
        self.date_combo = QComboBox()
        self.date_combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        self.setup_date_combo()
        # self.date_combo.currentIndexChanged.connect(self.on_date_combo_changed)

        self.refresh_button = QPushButton("Odśwież dane")
        self.refresh_button.clicked.connect(self.refresh_data)
        self.refresh_button.setToolTip("Odśwież dane (używa async loading dla lepszej wydajności)")
        self.refresh_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light")) #

        self.show_audit_button = QPushButton("Historia Zmian")
        self.show_audit_button.clicked.connect(self.show_audit_log_window)
        self.show_audit_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.show_audit_button.setToolTip("Pokaż historię modyfikacji grafiku dla wybranego miesiąca i filtrów")

        self.staffing_details_button = QPushButton("Obsada") # Możesz wybrać inną nazwę
        self.staffing_details_button.clicked.connect(self.show_staffing_details_window) # Połącz z nową metodą
        self.staffing_details_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light")) #
        self.staffing_details_button.setToolTip("Pokaż szczegóły obsady godzinowej")

        top_bar_layout.addWidget(self.settings_button)
        top_bar_layout.addWidget(date_label)
        top_bar_layout.addWidget(self.date_combo)
        top_bar_layout.addWidget(self.refresh_button)
        top_bar_layout.addWidget(self.show_audit_button)
        top_bar_layout.addWidget(self.staffing_details_button) # Dodaj nowy przycisk do layoutu
        self.schedule_control_button = QPushButton("Zarządzaj Grafikiem")
        self.schedule_control_button.clicked.connect(self.show_schedule_control_dialog)
        self.schedule_control_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.schedule_control_button.setToolTip("Otwiera panel zarządzania statusami, publikacją i blokadami grafiku")
        top_bar_layout.addWidget(self.schedule_control_button)
        top_bar_layout.addStretch()

        # Nie dodawaj top_bar_frame do main_layout tutaj, jeśli setup_ui robi to globalnie
        # main_layout.addWidget(top_bar_frame) # Zakładając, że setup_ui dodaje top_bar_frame

        return top_bar_frame

    def setup_date_combo(self):
        """Konfiguruje combobox z datami, uwzględniając uprawnienia."""
        current_date = datetime.now()
        months_to_show = []
        year, month = current_date.year, current_date.month

        # Generowanie 3 miesięcy wstecz
        for i in range(3, 0, -1):
            prev_month, prev_year = (month - i, year)
            while prev_month <= 0:
                prev_month += 12
                prev_year -= 1
            months_to_show.append((prev_year, prev_month))

        # Dodaj bieżący miesiąc
        months_to_show.append((year, month))

        # --- ZMIANA: Warunkowe dodawanie przyszłego miesiąca ---
        if self.can_see_next_month:
            next_month, next_year = (month + 1, year)
            if next_month > 12:
                next_month = 1
                next_year += 1
            months_to_show.append((next_year, next_month))
            debug_print("Dodano przyszły miesiąc do listy wyboru.")

        # Zapisujemy aktualnie wybrany indeks, aby go przywrócić
        current_index = self.date_combo.currentIndex()
        if current_index == -1: # Jeśli to pierwsze uruchomienie
            current_index = 3 # Domyślnie bieżący miesiąc

        self.date_combo.clear()
        for y, m in months_to_show:
            self.date_combo.addItem(f"{y}-{m:02d}", (y, m))

        # Przywracamy indeks, upewniając się, że jest w zakresie
        if current_index < self.date_combo.count():
            self.date_combo.setCurrentIndex(current_index)
        else:
            # Jeśli usunęliśmy przyszły miesiąc, ustawiamy na ostatni dostępny
            self.date_combo.setCurrentIndex(self.date_combo.count() - 1)

    def setup_middle_section(self, main_layout):
        """Tworzy środkową sekcję z filtrem i tabelami"""
        # Główny kontener na środkową część (filtry po lewej, tabela po prawej)
        main_splitter = QSplitter(Qt.Horizontal)

        # Ustaw politykę rozmiaru - aby element wypełniał dostępną przestrzeń
        main_splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Tworzenie lewego panelu filtrów
        self.setup_left_panel()
        # Zapamiętaj standardową szerokość lewego panelu
        self.left_panel_width = 280  # Domyślna szerokość panelu

        # Tworzenie prawego panelu z tabelami
        right_panel = self.setup_right_panel()

        # Dodaj panele do głównego splittera
        main_splitter.addWidget(self._left_panel)
        main_splitter.addWidget(right_panel)

        # Ustaw początkowe proporcje dla głównego splittera (np. 25% lewy panel, 75% prawy panel)
        main_splitter.setSizes([280, 720])

        # Zapisz referencję do splittera
        self.main_splitter = main_splitter

        self.main_splitter.setStretchFactor(0, 0)  # Lewy panel (employees_view) nie jest rozciągany
        self.main_splitter.setStretchFactor(1, 1)  # Prawy panel (schedule_view) jest rozciągany

        # NIE dodawaj main_splitter do main_layout - zwróć go tylko
        return main_splitter

    def setup_left_panel(self):
        """Tworzy lewy panel z filtrami"""
        self._left_panel = QWidget()
        self._left_panel.setStyleSheet(AppStyles.get_left_panel_style("dark" if self.is_dark_theme else "light"))
        self._left_panel.setMinimumWidth(280)  # Zwiększamy minimalną szerokość panelu
        self._left_panel.setMaximumWidth(280)  # Zwiększamy maksymalną szerokość panelu

        filters_layout = QVBoxLayout(self._left_panel)
        filters_layout.setContentsMargins(10, 10, 10, 10)
        filters_layout.setSpacing(6)  # Zmniejsz odstępy między elementami

        # Tytuł filtrów
        filters_title = QLabel("Filtry")
        filters_title.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light", is_title=True))
        filters_layout.addWidget(filters_title)

        # Kolejność zgodnie z oznaczeniami na zdjęciu
        # 1. Wydział
        self.add_horizontal_filter("Wydział:", "wydzial_combo", filters_layout)

        # 2. Przełożony - pole tekstowe i lista w układzie pionowym
        self.add_horizontal_search_filter("Przełożony:", "przelozony_filter", filters_layout)
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)

        # Lista przełożonych
        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_list.setFixedHeight(150)
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.przelozony_list)

        # 3. Użytkownik
        self.add_horizontal_search_filter("Użytkownik:", "uzytkownik_filter", filters_layout)
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)

        # Lista użytkowników
        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_list.setFixedHeight(200)
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.uzytkownik_list)

        # 4. DTN
        self.add_horizontal_filter("DTN:", "dtn_combo", filters_layout)

        # 5. Etat
        self.add_horizontal_filter("Etat:", "etat_combo", filters_layout)

        # 6. Rola
        self.add_horizontal_filter("Rola:", "rola_combo", filters_layout)

        # 7. Język
        self.add_horizontal_filter("Język:", "jezyk_combo", filters_layout)

        # 8. System Czasu Pracy
        self.add_horizontal_filter("System Pracy:", "system_czasu_pracy_combo", filters_layout)

        # Przycisk wyczyść filtry
        self.clear_filters_button = QPushButton("Wyczyść filtry")
        self.clear_filters_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.clear_filters_button.clicked.connect(self.clear_filters)
        filters_layout.addStretch()
        filters_layout.addWidget(self.clear_filters_button)

    def add_horizontal_filter(self, label_text, combo_name, parent_layout):
        """Dodaje filtr w układzie poziomym (etykieta + kontrolka w jednej linii)"""
        # Układ poziomy dla filtru
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)  # Minimalne marginesy
        filter_layout.setSpacing(4)  # Mniejszy odstęp

        # Etykieta
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        filter_label.setFixedWidth(80)  # Ustaw stałą szerokość etykiet
        filter_layout.addWidget(filter_label)

        # Kontrolka ComboBox
        combo = CustomMultiComboBox()
        combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        combo.setFixedHeight(24)  # Ustaw wysokość podobną do pól tekstowych
        combo.view().setMaximumWidth(250)  # Ograniczenie szerokości rozwijanej listy
        # combo.activated.connect(self.filter_data)  # Podłącz sygnał filtrowania
        combo.selection_changed.connect(self.filter_data)

        # Zapisz referencję do kontrolki
        setattr(self, combo_name, combo)

        filter_layout.addWidget(combo, 1)  # Dodaj z rozciąganiem
        parent_layout.addLayout(filter_layout)

    def add_horizontal_search_filter(self, label_text, filter_name, parent_layout):
        """Dodaje filtr wyszukiwania w układzie poziomym (etykieta + pole tekstowe w jednej linii)"""
        # Układ poziomy dla filtru
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)  # Minimalne marginesy
        filter_layout.setSpacing(4)  # Mniejszy odstęp

        # Etykieta
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        filter_label.setFixedWidth(80)  # Ustaw stałą szerokość etykiet
        filter_layout.addWidget(filter_label)

        # Pole tekstowe
        text_edit = QLineEdit()
        text_edit.setPlaceholderText(f"Filtruj {label_text.lower()[:-1]}...")
        text_edit.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        text_edit.setFixedHeight(24)  # Ustaw stałą wysokość

        # Zapisz referencję do kontrolki
        setattr(self, filter_name, text_edit)

        filter_layout.addWidget(text_edit, 1)  # Dodaj z rozciąganiem
        parent_layout.addLayout(filter_layout)

    def setup_filter_combo(self, label_text, combo_name, parent_layout):
        """Konfiguruje filtr jako ComboBox z wielokrotnym wyborem"""
        # Etykieta filtru
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(filter_label)

        # ComboBox z wielokrotnym wyborem
        combo = CustomMultiComboBox()
        combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        combo.view().setMinimumWidth(200)  # Ustaw minimalną szerokość listy rozwijanej

        # Dodaj sygnał zmiany stanu ComboBoxa
        combo.view().pressed.connect(self.filter_data)

        # Zapisz referencję do ComboBoxa
        setattr(self, combo_name, combo)

        parent_layout.addWidget(combo)
        parent_layout.addSpacing(10)  # Dodaj odstęp między filtrami

    # Te metody pozostają bez zmian, tylko przenosimy je do oddzielnych funkcji
    def setup_filter_przelozony(self, parent_layout):
        """Konfiguruje filtr przełożonego"""
        # Filtr przełożonego
        przelozony_label = QLabel("Przełożony:")
        przelozony_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(przelozony_label)

        # Lista przełożonych
        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_list.setFixedHeight(120)

        # Dodaj pole wyszukiwania dla przełożonych
        self.przelozony_filter = QLineEdit()
        self.przelozony_filter.setPlaceholderText("Filtruj przełożonych...")
        self.przelozony_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)

        parent_layout.addWidget(self.przelozony_filter)
        parent_layout.addWidget(self.przelozony_list)

        # Podłącz sygnał zmiany filtru
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)

    def setup_filter_uzytkownik(self, parent_layout):
        """Konfiguruje filtr użytkownika"""
        # Filtr użytkownika
        uzytkownik_label = QLabel("Użytkownik:")
        uzytkownik_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(uzytkownik_label)

        # Lista użytkowników
        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_list.setFixedHeight(120)

        # Dodaj pole wyszukiwania dla użytkowników
        self.uzytkownik_filter = QLineEdit()
        self.uzytkownik_filter.setPlaceholderText("Filtruj użytkowników...")
        self.uzytkownik_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)

        parent_layout.addWidget(self.uzytkownik_filter)
        parent_layout.addWidget(self.uzytkownik_list)

        # Podłącz sygnał zmiany filtru
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)

    def setup_right_panel(self):
        """Tworzy prawy panel z tabelami"""
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)

        # Splitter pionowy dla prawego panelu (grafik | zdarzenia)
        right_splitter = QSplitter(Qt.Vertical)

        # Dodaj sekcje
        schedule_frame = self.setup_schedule_section()
        events_frame = self.setup_events_section()

        # Dodaj panele do pionowego splittera
        right_splitter.addWidget(schedule_frame)
        right_splitter.addWidget(events_frame)

        # Ustaw początkowe proporcje dla pionowego splittera (np. 60% grafik, 40% zdarzenia)
        right_splitter.setSizes([600, 400])

        # Dodaj pionowy splitter do layoutu prawego panelu
        right_layout.addWidget(right_splitter)

        return right_panel

    # W pliku main.py - klasa WorkScheduleWindow, metoda setup_schedule_section

    def setup_schedule_section(self):
        """
        Tworzy sekcję grafiku (górna część prawego panelu) używając SplitTableView
        """
        schedule_frame = QFrame()
        schedule_layout = QVBoxLayout(schedule_frame)
        schedule_layout.setContentsMargins(5, 5, 5, 5)

        # NIE INICJALIZUJ employee_columns tutaj, użyj wartości z inicjalizacji klasy

        # Tworzenie i konfiguracja SplitTableView
        self.table = SplitTableView()

        # Ustaw style dla obu tabel
        self.table.employees_view.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))
        self.table.schedule_view.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))

        # Dodaj przycisk zarządzania kolumnami do przycisków akcji
        self.manage_columns_button = QPushButton("Zarządzaj kolumnami")
        self.manage_columns_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.manage_columns_button.clicked.connect(self.show_column_select_dialog)

        # Podłącz sygnał zmiany zaznaczenia do aktualizacji zdarzeń
        self.table.selection_changed.connect(self.on_selection_changed)

        # Dodaj tabelę do layoutu
        schedule_layout.addWidget(self.table)

        # Dodaj przyciski akcji
        button_frame = self.setup_schedule_buttons()
        button_layout = button_frame.layout()

        # NOWE: Ustaw, aby panel z przyciskami zajmował tylko tyle miejsca, ile potrzebuje
        schedule_layout.addWidget(button_frame, 0)  # 0 = minimum stretch factor

        # Dodaj przycisk zarządzania kolumnami do przycisków akcji
        if isinstance(button_layout, QHBoxLayout):
            button_layout.insertWidget(0, self.manage_columns_button)

        schedule_layout.addWidget(button_frame)

        return schedule_frame

    def setup_schedule_buttons(self):
        """Tworzy przyciski akcji dla sekcji grafiku"""
        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setContentsMargins(0, 0, 0, 0)

        # NOWE: Ustaw stałą wysokość ramki przycisków
        button_frame.setFixedHeight(40)  # Możesz dostosować wysokość według potrzeb

        # NOWE: Ustaw politykę rozmiaru, aby zapobiec rozciąganiu
        button_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        # NOWOŚĆ: Dodajemy przycisk do ukrywania/pokazywania panelu zdarzeń (po lewej stronie)
        self.toggle_events_panel_button = QPushButton("Ukryj zdarzenia↓")
        self.toggle_events_panel_button.setToolTip(
            "Ukryj panel zdarzeń (dla większego widoku grafiku) (F2)")  # Dodano (F2)
        self.toggle_events_panel_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.toggle_events_panel_button.clicked.connect(self.toggle_events_panel)

        # Dodaj przycisk po lewej stronie
        button_layout.addWidget(self.toggle_events_panel_button)

        # Dodaj elastyczny odstęp, aby rozdzielić przyciski
        button_layout.addStretch()

        # Przycisk "Wstaw zmianę"
        self.insert_change_button = QPushButton("Wstaw zmianę")
        self.insert_change_button.setToolTip("Wstaw zmianę grafiku (F3)")
        self.insert_change_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.insert_change_button.clicked.connect(self.show_insert_change_dialog)
        button_layout.addWidget(self.insert_change_button)

        # Przycisk "Wstaw nieobecność"
        self.insert_symbol_button = QPushButton("Wstaw nieobecność")
        self.insert_symbol_button.setToolTip("Wstaw nieobecność (F4)")
        self.insert_symbol_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.insert_symbol_button.clicked.connect(self.show_insert_symbol_dialog)
        button_layout.addWidget(self.insert_symbol_button)

        # Przycisk "Odwołaj delegacje"
        self.cancel_delegation_button = QPushButton("Odwołaj delegacje")
        self.cancel_delegation_button.setToolTip("Odwołaj delegacje dla zaznaczonych komórek (F5)")
        self.cancel_delegation_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.cancel_delegation_button.clicked.connect(self.cancel_delegations)
        button_layout.addWidget(self.cancel_delegation_button)

        # Przycisk "Dodaj nadgodziny"
        self.add_overtime_button = QPushButton("Dodaj nadgodziny")
        self.add_overtime_button.setShortcut("Insert")  # Skrót klawiszowy Insert
        self.add_overtime_button.setToolTip("Dodaj nadgodziny dla zaznaczonych komórek (Insert)")
        self.add_overtime_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.add_overtime_button.clicked.connect(self.show_add_overtime_dialog)

        # ZMODYFIKOWANA LINIA: Zawsze dodawaj przycisk do layoutu
        button_layout.addWidget(self.add_overtime_button)

        # Ewentualnie ustaw widoczność przycisku na podstawie roli
        # Można to zrobić po inicjalizacji wszystkich komponentów
        if hasattr(self, 'current_user_role'):
            self.add_overtime_button.setVisible(self.current_user_role == "Pracownik WPR")
        else:
            # Domyślnie widoczny, możemy to zmienić później
            self.add_overtime_button.setVisible(True)

        return button_frame

    def setup_events_section(self):
        """
        Tworzy sekcję zdarzeń używając QTableView zamiast QTableWidget
        """
        events_frame = QFrame()
        events_frame.setFrameShape(QFrame.StyledPanel)
        events_frame.setFrameShadow(QFrame.Raised)
        events_layout = QVBoxLayout(events_frame)
        events_layout.setContentsMargins(5, 5, 5, 5)

        # Dodaj kontrolki filtrów
        filters_frame = self.setup_events_filters()
        events_layout.addWidget(filters_frame)

        # Tworzenie tabeli zdarzeń jako QTableView
        self.events_table = QTableView()
        self.events_table.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.events_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.events_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.events_table.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))

        # Dodaj tabelę zdarzeń do panelu
        events_layout.addWidget(self.events_table)

        return events_frame

    def setup_events_filters(self):
        """Konfiguruje filtry dla tabeli zdarzeń"""
        events_filter_frame = QFrame()
        events_filter_layout = QHBoxLayout(events_filter_frame)
        events_filter_layout.setContentsMargins(0, 0, 0, 0)

        # Filtry daty od-do
        date_from_label = QLabel("Data od:")
        self.date_from = QDateEdit()
        self.date_from.setDisplayFormat("dd.MM.yyyy")
        self.date_from.setDate(QDate.currentDate().addDays(-30))
        self.date_from.setCalendarPopup(True)
        self.date_from.setStyleSheet(AppStyles.get_date_edit_style("dark" if self.is_dark_theme else "light"))

        date_to_label = QLabel("Data do:")
        self.date_to = QDateEdit()
        self.date_to.setDisplayFormat("dd.MM.yyyy")
        self.date_to.setDate(QDate.currentDate())
        self.date_to.setCalendarPopup(True)
        self.date_to.setStyleSheet(AppStyles.get_date_edit_style("dark" if self.is_dark_theme else "light"))

        # Filtr tematu
        topic_label = QLabel("Temat:")
        self.topic_filter = QLineEdit()
        self.topic_filter.setPlaceholderText("Filtruj po temacie...")
        self.topic_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))

        # Filtr nazwy
        name_label = QLabel("Nazwa:")
        self.name_filter = QLineEdit()
        self.name_filter.setPlaceholderText("Filtruj po nazwie...")
        self.name_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))

        # Checkboxy do filtrowania typów zdarzeń
        self.meetings_checkbox = QCheckBox("Spotkania")
        self.meetings_checkbox.setChecked(True)
        self.meetings_checkbox.stateChanged.connect(self.filter_events_table)

        self.trainings_checkbox = QCheckBox("Szkolenia")
        self.trainings_checkbox.setChecked(True)
        self.trainings_checkbox.stateChanged.connect(self.filter_events_table)

        self.overtime_checkbox = QCheckBox("Nadgodziny")
        self.overtime_checkbox.setChecked(True)
        self.overtime_checkbox.stateChanged.connect(self.filter_events_table)

        # Podłącz sygnały zmiany daty bezpośrednio do filtrowania
        self.date_from.dateChanged.connect(self.filter_events_table)
        self.date_to.dateChanged.connect(self.filter_events_table)
        self.topic_filter.textChanged.connect(self.filter_events_table)
        self.name_filter.textChanged.connect(self.filter_events_table)

        # Dodaj kontrolki do layoutu filtrów zdarzeń
        events_filter_layout.addWidget(date_from_label)
        events_filter_layout.addWidget(self.date_from)
        events_filter_layout.addWidget(date_to_label)
        events_filter_layout.addWidget(self.date_to)
        events_filter_layout.addWidget(topic_label)
        events_filter_layout.addWidget(self.topic_filter)
        events_filter_layout.addWidget(name_label)
        events_filter_layout.addWidget(self.name_filter)
        events_filter_layout.addWidget(self.meetings_checkbox)
        events_filter_layout.addWidget(self.trainings_checkbox)
        events_filter_layout.addWidget(self.overtime_checkbox)
        events_filter_layout.addStretch()

        return events_filter_frame

    def setup_events_table_columns(self):
        """Konfiguruje kolumny dla tabeli zdarzeń"""
        self.events_table.setColumnCount(10)
        self.events_table.setHorizontalHeaderLabels([
            "Id", "Typ", "Temat", "Nazwa", "Użytkownik", "Data", "Od", "Do", "Status", "Akcje"
        ])

        # Ustaw szerokość kolumn
        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Użytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

    def setup_table_properties(self):
        """Konfiguruje właściwości tabel"""
        # Sortowanie
        self.events_table.setSortingEnabled(True)
        self.events_table.sortByColumn(0, Qt.AscendingOrder)

        # Dostosuj dla nowej klasy SplitTableView
        if hasattr(self.table, 'employees_view'):
            self.table.employees_view.setSortingEnabled(True)
            self.table.employees_view.sortByColumn(0, Qt.AscendingOrder)

        # Możemy także zachować informację o ostatnim sortowaniu
        self.last_sort_column = 0
        self.last_sort_order = Qt.AscendingOrder

        # Podłącz sygnały sortowania - POPRAWKA: odwołuj się do konkretnego widoku
        if hasattr(self.table, 'employees_view') and hasattr(self.table.employees_view, 'horizontalHeader'):
            self.table.employees_view.horizontalHeader().sortIndicatorChanged.connect(self.on_sort_changed)

        if hasattr(self.events_table, 'horizontalHeader'):
            self.events_table.horizontalHeader().sortIndicatorChanged.connect(self.on_events_sort_changed)

        # Dodaj delegata do tabeli aby obsługiwał niestandardowe rysowanie
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            # Dla nowej klasy SplitTableView
            self.table.schedule_view.setItemDelegate(OvertimeItemDelegate())
        elif hasattr(self, 'table'):
            # Dla starej klasy SplitTableWidget
            self.table.setItemDelegate(OvertimeItemDelegate())

    def toggle_left_panel(self):
        """Przełącza widoczność lewego panelu filtrów"""
        if self.left_panel_visible:
            # Ukryj panel
            self.left_panel_width = self._left_panel.width()  # Zapamiętaj bieżącą szerokość
            self._left_panel.setFixedWidth(0)
            self._left_panel.setVisible(False)  # WAŻNE: Ukryj panel całkowicie
            self.left_panel_visible = False
            self.toggle_menu_button.setText("☲")  # Zmień ikonę na "pokaż menu"
            self.toggle_menu_button.setToolTip("Pokaż panel filtrów")
        else:
            # Pokaż panel
            self._left_panel.setVisible(True)  # WAŻNE: Najpierw pokaż panel
            self._left_panel.setMinimumWidth(200)
            self._left_panel.setMaximumWidth(250)

            # Sprawdź czy mamy zapamiętaną szerokość
            if hasattr(self, 'left_panel_width'):
                self._left_panel.setFixedWidth(self.left_panel_width)
            else:
                self._left_panel.setFixedWidth(200)  # Domyślna szerokość

            self.left_panel_visible = True
            self.toggle_menu_button.setText("☰")  # Przywróć ikonę "burger menu"
            self.toggle_menu_button.setToolTip("Pokaż/ukryj panel filtrów (F1)")

        # DODANE: Wymuś ponowne rozłożenie splittera
        current_sizes = self.main_splitter.sizes()
        if not self.left_panel_visible:
            # Gdy ukrywamy panel, dajemy całą przestrzeń prawemu panelowi
            self.main_splitter.setSizes([0, sum(current_sizes)])
        else:
            # Gdy pokazujemy panel, przywracamy proporcje
            if hasattr(self, 'left_panel_width'):
                right_size = sum(current_sizes) - self.left_panel_width
                self.main_splitter.setSizes([self.left_panel_width, right_size])
            else:
                # Domyślnie 20% - 80%
                total = sum(current_sizes)
                self.main_splitter.setSizes([int(total * 0.2), int(total * 0.8)])

        # Wymuś aktualizację widoku
        self.main_splitter.update()

        # DODANE: Odśwież układ całego okna
        QApplication.processEvents()
        self.update()

    def toggle_events_panel(self):
        """Przełącza widoczność panelu zdarzeń (dolny panel)"""
        # Znajdź splitter, który organizuje układ prawy (grafik | zdarzenia)
        right_splitter = None

        # Szukamy w rodzicu prawego panelu, który zawiera splitter
        for widget in self.findChildren(QSplitter):
            # Sprawdź, czy to pionowy splitter zawierający panel zdarzeń
            if widget.orientation() == Qt.Vertical and widget.count() > 1:
                right_splitter = widget
                break

        if right_splitter:
            # Pobierz rozmiary paneli
            sizes = right_splitter.sizes()

            # Jeśli panel zdarzeń jest widoczny, ukryj go
            if sizes[1] > 0:
                # Zapisz obecny rozmiar panelu zdarzeń przed ukryciem
                self.events_panel_size = sizes[1]

                # Ustaw nowe rozmiary - cała przestrzeń dla grafiku, 0 dla zdarzeń
                right_splitter.setSizes([sizes[0] + sizes[1], 0])

                # Zmień tekst przycisku
                self.toggle_events_panel_button.setText("Pokaż zdarzenia↑")
                self.toggle_events_panel_button.setToolTip("Pokaż panel zdarzeń↑ (F2)")
            else:
                # Jeśli panel zdarzeń jest ukryty, pokaż go
                # Użyj zapisanego wcześniej rozmiaru lub domyślnego (300)
                events_size = getattr(self, 'events_panel_size', 300)

                # Oblicz nowy rozmiar dla panelu grafiku
                schedule_size = sizes[0] - events_size
                if schedule_size < 200:  # Minimalny rozmiar dla grafiku
                    schedule_size = 200
                    events_size = sizes[0] - schedule_size

                # Ustaw nowe rozmiary
                right_splitter.setSizes([schedule_size, events_size])

                # Zmień tekst przycisku
                self.toggle_events_panel_button.setText("Ukryj zdarzenia↓")
                self.toggle_events_panel_button.setToolTip("Ukryj panel zdarzeń (dla większego widoku grafiku)")

    def show_column_select_dialog(self):
        """Wyświetla dialog wyboru kolumn, obsługując nową opcję komentarza."""
        try:
            if not hasattr(self, 'schedule_model'):
                QMessageBox.warning(self, "Błąd", "Model danych nie jest zainicjalizowany.", QMessageBox.Ok)
                return

            dialog = ColumnSelectDialog(
                self,
                self.employee_columns,
                self.visible_columns,
                self.default_visible_columns,
                user_role=self.current_user_role,
                is_comment_column_checked=self.show_comment_column
            )

            if dialog.exec() == QDialog.Accepted:
                selected_columns = dialog.get_selected_columns()

                # Używamy nowej, poprawnej nazwy metody
                self.show_comment_column = dialog.get_comment_column_state()

                self.schedule_model.set_visible_columns(selected_columns)
                self.schedule_model.set_show_comment_column(self.show_comment_column)

                self.visible_columns = selected_columns

                # Zapisujemy wszystkie ustawienia do bazy
                self.settings_db.save_settings(
                    "dark" if self.is_dark_theme else "light",
                    self.current_font,
                    self.current_font_size,
                    getattr(self, 'load_all_events', True),
                    selected_columns,
                    self.show_comment_column
                )
                debug_print(
                    f"Zapisano ustawienia: widoczne kolumny={selected_columns}, pokaż komentarz={self.show_comment_column}")

                self.refresh_column_configuration()
                if hasattr(self, 'table'):
                    self.table.set_model(self.schedule_model)
                    self.table.adjust_employees_table_width()
                    self._set_schedule_columns_width()

        except Exception as e:
            log_error(f"Błąd w show_column_select_dialog: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas zmiany kolumn: {str(e)}", QMessageBox.Ok)

    def _set_schedule_columns_width(self):
        """
        OSTATECZNA, POPRAWIONA WERSJA: Ustawia szerokość i widoczność kolumn w widoku grafiku,
        używając prawidłowego API QHeaderView.
        """
        if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view') or not self.schedule_model:
            return

        header = self.table.schedule_view.horizontalHeader()
        model = self.schedule_model

        # Pokaż wszystkie sekcje przed ustawieniem rozmiarów/ukryciem
        for i in range(model.columnCount()):
            if not header.isSectionHidden(i):
                header.showSection(i)

        # Mapa definiująca niestandardowe szerokości dla konkretnych nagłówków
        special_widths = {
            "Suma\nRBH": 45,
            "Bilans\nRBH": 45,
            "Komentarz": 300
        }

        # Pętla po wszystkich kolumnach w modelu danych
        for logical_index in range(model.columnCount()):
            # Pobieramy tekst nagłówka z modelu dla danego indeksu logicznego
            header_text = model.headerData(logical_index, Qt.Horizontal, Qt.DisplayRole)

            width_to_set = 65  # Domyślna szerokość dla kolumn dni

            if header_text in special_widths:
                # Jeśli nagłówek jest w naszej mapie, użyj jego specjalnej szerokości
                width_to_set = special_widths[header_text]

            # Ustaw szerokość dla kolumny o danym indeksie logicznym
            header.resizeSection(logical_index, width_to_set)

        # Ukrywanie niepotrzebnych kolumn dla krótszych miesięcy
        days_in_month = model._days_in_month
        employee_cols_count = len(model.get_visible_columns())

        # Pętla od pierwszego nieistniejącego dnia do końca 31-dniowej siatki
        for day_offset in range(days_in_month, 31):
            # Obliczamy indeks logiczny kolumny w pełnym modelu
            model_col_to_hide = employee_cols_count + day_offset
            # Używamy poprawnej metody do ukrywania sekcji wg indeksu logicznego
            header.setSectionHidden(model_col_to_hide, True)

    def delete_event_from_row(self, row):
        """
        POPRAWIONA WERSJA: Usuwa zdarzenie na podstawie indeksu wiersza w tabeli zdarzeń
        z pełnym odświeżaniem ikon
        """
        # Sprawdź czy model istnieje
        if not hasattr(self, 'events_model') or not self.events_model:
            return

        # Pobierz zdarzenie z modelu
        event = self.events_model.get_event(row)
        if not event:
            debug_print(f"Nie znaleziono zdarzenia w wierszu {row}")
            return

        # Pobierz dane zdarzenia
        event_id = event.get('id')
        event_type = event.get('type')
        
        debug_print(f"Usuwanie zdarzenia z wiersza {row}: ID={event_id}, typ={event_type}")

        if not event_id or not event_type:
            debug_print(f"Niepełne dane zdarzenia: ID={event_id}, typ={event_type}")
            return

        # KLUCZOWA ZMIANA: Użyj metody delete_event która już ma pełną logikę odświeżania
        self.delete_event(event_id, event_type)

    def on_sort_changed(self, logical_index, order):
        """Obsługuje zmianę sortowania w tabeli grafiku"""
        self.last_sort_column = logical_index
        self.last_sort_order = order
        debug_print(
            f"Tabela grafiku: Sortowanie po kolumnie {logical_index}, kolejność: {'rosnąco' if order == Qt.AscendingOrder else 'malejąco'}")

    def on_events_sort_changed(self, logical_index, order):
        """Obsługuje zmianę sortowania w tabeli zdarzeń"""
        debug_print(f"Tabela zdarzeń: Sortowanie po kolumnie {logical_index}, kolejność: {'rosnąco' if order == Qt.AscendingOrder else 'malejąco'}")

    def update_buttons_visibility(self):
        """Aktualizuje widoczność przycisków na podstawie roli użytkownika"""
        is_next_month_selected = False
        current_data = self.date_combo.currentData()
        if current_data:
            selected_year, selected_month = current_data

            today = QDate.currentDate()
            # Oblicz datę dla następnego miesiąca
            next_month_date = today.addMonths(1)

            # Sprawdź, czy wybrany rok i miesiąc zgadzają się z następnym miesiącem
            if selected_year == next_month_date.year() and selected_month == next_month_date.month():
                is_next_month_selected = True

        if hasattr(self, 'add_overtime_button') and hasattr(self, 'current_user_role'):
            self.add_overtime_button.setVisible(self.current_user_role == "Pracownik WPR")

        # Ustaw widoczność przycisku "Obsada" tylko dla roli "Pracownik WPR"
        if hasattr(self, 'staffing_details_button') and hasattr(self, 'current_user_role'):
            self.staffing_details_button.setVisible(self.current_user_role == "Pracownik WPR")

        if hasattr(self, 'current_user_role') and self.current_user_role == "Pracownik WPR":
            debug_print("Edycja klawiatury włączona: cyfry 0-9 = godzina start, Delete/Backspace = usuń symbol")

        if hasattr(self, 'show_audit_button') and hasattr(self, 'current_user_role'):
            self.show_audit_button.setVisible(self.current_user_role == "Pracownik WPR")

        if hasattr(self, 'schedule_control_button') and hasattr(self, 'current_user_role'):
            allowed_roles = ["Pracownik WPR", "Lider OUT"]
            # Przycisk jest widoczny TYLKO, gdy rola się zgadza ORAZ wybrany jest następny miesiąc
            is_visible = self.current_user_role in allowed_roles and is_next_month_selected
            self.schedule_control_button.setVisible(is_visible)

    def show_audit_log_window(self):
        """
        Tworzy i pokazuje okno historii zmian, obsługując jego niezależne odświeżanie.
        """
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Proszę najpierw wybrać miesiąc.")
            return

        year, month = current_data

        # Helper do pobierania i filtrowania danych, aby uniknąć powtarzania kodu
        def _get_filtered_audit_data():
            full_data = self.data_provider.get_schedule_audit_data(year, month)
            selected_cells = self.table.get_data_for_selected_cells()

            if selected_cells:
                allowed_users_dates = set()
                for cell in selected_cells:
                    if (user_id := cell.get('uzytkownik_id')) and (date_str := cell.get('date_str')):
                        date_obj = QDate.fromString(date_str, "yyyy-MM-dd").toPython()
                        allowed_users_dates.add((user_id, date_obj))

                return [row for row in full_data if
                        row.get('Data') and (int(row.get('Uzytkownik')), row.get('Data').date()) in allowed_users_dates]
            else:
                visible_user_ids = {key[3] for key in self.schedule_model._keys}
                return [row for row in full_data if
                        row.get('Uzytkownik') is not None and int(row.get('Uzytkownik')) in visible_user_ids]

        # Pobierz dane początkowe
        initial_filtered_data = _get_filtered_audit_data()
        if not initial_filtered_data:
            QMessageBox.information(self, "Informacja", "Brak historii zmian dla wybranych filtrów / zaznaczenia.")
            return

        # Utwórz okno dialogowe
        from audit_log_window import AuditLogWindow
        dialog = AuditLogWindow(initial_filtered_data, self.is_dark_theme, self)

        # Zdefiniuj slot do obsługi odświeżania
        def on_refresh_requested():
            debug_print("Otrzymano żądanie odświeżenia historii zmian.")
            # Wyczyść cache, aby pobrać świeże dane z bazy
            self.data_provider.clear_audit_cache(year, month)
            # Pobierz i przefiltruj dane na nowo
            fresh_filtered_data = _get_filtered_audit_data()
            # Zaktualizuj widok w oknie dialogowym
            dialog.update_model_data(fresh_filtered_data)
            QMessageBox.information(dialog, "Odświeżono", "Historia zmian została zaktualizowana.")

        # Podłącz sygnał z dialogu do nowo utworzonego slotu
        dialog.refresh_requested.connect(on_refresh_requested)

        # Pokaż okno
        dialog.exec()

    def check_user_permissions(self):
        """Sprawdza uprawnienia użytkownika i zapisuje je w atrybutach klasy."""
        # Pobieramy 5 wartości, w tym wydział użytkownika
        user_id, user_app_id, user_app_role, visible_next_month, user_department = get_modifier_id()

        self.current_user_id = user_id
        self.current_user_app_id = user_app_id
        self.current_user_role = user_app_role
        self.can_see_next_month = visible_next_month
        self.current_user_department = user_department  # NOWY ATRYBUT

        self.update_buttons_visibility()

        # Reszta logiki bez zmian...
        allowed_roles = ["Pracownik WPR", "Lider", "Menadżer", "Lider OUT"]
        if user_app_role not in allowed_roles:
            QMessageBox.critical(
                self, "Brak uprawnień",
                f"Nie masz uprawnień do korzystania z tej aplikacji.\n\nTwoja rola: {user_app_role}",
                QMessageBox.Ok
            )
            return False

        debug_print(f"Zalogowano jako: {user_app_id} ({user_app_role}), Wydział: {self.current_user_department}")
        return True

    def _can_modify_cells(self, selected_cells_data: list) -> bool:
        """
        Sprawdza, czy bieżący użytkownik (Lider) ma uprawnienia do modyfikacji
        grafiku dla pracowników w zaznaczonych komórkach.
        """
        # Reguła dotyczy tylko ról Lider IN i Lider OUT
        leader_roles = ["Lider", "Lider OUT"]  # Założyłem, że "Lider IN" to po prostu "Lider"
        if self.current_user_role not in leader_roles:
            return True  # Inne role nie mają tego ograniczenia

        if not self.current_user_department:
            QMessageBox.warning(self, "Błąd konfiguracji",
                                "Nie można zweryfikować Twojego wydziału. Edycja niemożliwa.")
            return False

        unauthorized_employees = set()
        leader_dept = self.current_user_department

        for cell_data in selected_cells_data:
            employee_dept = cell_data.get('wydzial')
            if not employee_dept:
                continue  # Pomiń komórki bez informacji o wydziale

            # Sprawdź, czy wydział lidera zawiera się w wydziale pracownika
            if leader_dept not in employee_dept:
                unauthorized_employees.add(cell_data.get('uzytkownik_dane', 'Nieznany'))

        if unauthorized_employees:
            QMessageBox.warning(
                self,
                "Brak uprawnień",
                "Nie posiadasz uprawnień do edycji grafiku tej osoby.\n\n"
                f"Twoja jednostka: '{leader_dept}'\n"
                "Problem dotyczy pracowników:\n - " + "\n - ".join(sorted(list(unauthorized_employees)))
            )
            return False

        return True  # Walidacja pomyślna

    def show_insert_symbol_dialog(self):
        """
        Pokazuje okno dialogowe do wstawiania symbolu nieobecności.
        NOWA WERSJA z procedurą p_P_ZZ_ImportZmianyNaSerwer_v3
        """
        dialog = InsertSymbolDialog(self)
        if dialog.exec():
            selected_symbol = dialog.get_selected_symbol()

            # Pobierz zaznaczone komórki z modelu
            selected_cells_data = self.get_selected_cells_data()

            if not self._can_modify_cells(selected_cells_data):
                return

            if not selected_cells_data:
                QMessageBox.warning(
                    self,
                    "Brak zaznaczenia",
                    "Nie zaznaczono żadnych komórek do edycji.",
                    QMessageBox.Ok
                )
                return

            # Filtruj tylko komórki grafiku (nie kolumny pracowników) i pomijaj puste komórki
            schedule_cells = []
            for cell_data in selected_cells_data:
                if isinstance(cell_data, dict) and 'date_str' in cell_data and 'uzytkownik_id' in cell_data:
                    # NOWE: Sprawdź czy komórka nie jest pusta
                    current_symbol = cell_data.get('symbol', '').strip()
                    if current_symbol:  # Pomijaj puste komórki
                        schedule_cells.append(cell_data)

            if not schedule_cells:
                QMessageBox.warning(
                    self,
                    "Brak komórek do edycji",
                    "Nie zaznaczono żadnych komórek grafiku z symbolami do edycji.\n\n" +
                    "Uwaga: Puste komórki są pomijane.",
                    QMessageBox.Ok
                )
                return

            # Pogrupuj komórki dla lepszego komunikatu
            grouped_changes = self._group_cells_for_symbol_changes(schedule_cells)

            # Przygotuj komunikat potwierdzenia
            changes_info = self._prepare_symbol_changes_description(grouped_changes, selected_symbol)

            # Sprawdź czy są zdarzenia do odwołania
            user_date_pairs = set()
            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    user_date_pairs.add((user_id, date_str))

            events_to_cancel = self._find_events_to_cancel(user_date_pairs)
            delegations_info = ""
            if events_to_cancel:
                grouped_events = self._group_events_by_user_date(events_to_cancel)
                delegations_info = self._prepare_delegations_description(grouped_events)

            # Pokaż komunikat potwierdzenia
            complete_info = f"Czy na pewno chcesz wprowadzić następujące zmiany?\n\n{changes_info}"
            if delegations_info:
                complete_info += f"\n{delegations_info}"
            complete_info += f"\nŁącznie: {len(schedule_cells)} komórek zmieni symbol"
            if events_to_cancel:
                complete_info += f", {len(events_to_cancel)} delegacji zostanie odwołanych"

            reply = QMessageBox.question(
                self,
                "Potwierdzenie wstawienia nieobecności",
                complete_info,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )

            if reply == QMessageBox.Yes:
                self._apply_absence_symbol_changes(schedule_cells, selected_symbol, events_to_cancel)

    def _group_cells_for_symbol_changes(self, schedule_cells):
        """
        Grupuje komórki według użytkownika i daty dla komunikatu potwierdzenia

        Args:
            schedule_cells (list): Lista komórek do modyfikacji

        Returns:
            dict: Pogrupowane zmiany
        """
        grouped_changes = {}
        for cell_data in schedule_cells:
            user_id = cell_data.get('uzytkownik_id')
            user_name = cell_data.get('uzytkownik_dane', '')
            date_str = cell_data.get('date_str')
            current_symbol = cell_data.get('symbol', '')

            # Formatuj datę
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            user_key = (user_id, user_name)
            if user_key not in grouped_changes:
                grouped_changes[user_key] = {}

            if formatted_date not in grouped_changes[user_key]:
                grouped_changes[user_key][formatted_date] = []

            grouped_changes[user_key][formatted_date].append({
                'current_symbol': current_symbol,
                'cell_data': cell_data
            })

        return grouped_changes

    def _prepare_symbol_changes_description(self, grouped_changes, new_special_symbol):
        """
        Przygotowuje opis zmian symboli do komunikatu potwierdzenia

        Args:
            grouped_changes (dict): Pogrupowane zmiany
            new_special_symbol (str): Nowy symbol specjalny

        Returns:
            str: Opis zmian
        """
        changes_info = ""
        for (user_id, user_name), dates in grouped_changes.items():
            changes_info += f"\n👤 {user_name}:\n"

            for date, cells in dates.items():
                changes_info += f"   📅 {date}: "

                # Pokaż przykład jak będzie wyglądał nowy symbol
                example_cell = cells[0]['cell_data']
                current_symbol = cells[0]['current_symbol']

                # Przewiduj jak będzie wyglądał nowy symbol
                predicted_symbol = self._predict_new_symbol(current_symbol, new_special_symbol, example_cell)

                if len(cells) == 1:
                    changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                else:
                    # Jeśli wiele komórek w tym dniu
                    current_symbols = [cell['current_symbol'] for cell in cells]
                    unique_symbols = set(current_symbols)
                    if len(unique_symbols) == 1:
                        changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                    else:
                        symbols_str = ", ".join([f"{s}" for s in unique_symbols])
                        changes_info += f"[{symbols_str}] -> {predicted_symbol}\n"

        return changes_info

    def _predict_new_symbol(self, current_symbol, special_symbol, cell_data):
        """
        Przewiduje jak będzie wyglądał nowy symbol po modyfikacji

        Args:
            current_symbol (str): Obecny symbol (nigdy pusty - puste są filtrowane)
            special_symbol (str): Nowy symbol specjalny
            cell_data (dict): Dane komórki

        Returns:
            str: Przewidywany nowy symbol
        """
        from symbol_parser import parse_symbol, build_symbol

        # Sprawdź czy symbol istnieje (zabezpieczenie dodatkowe)
        if not current_symbol or current_symbol.strip() == '':
            debug_print("Ostrzeżenie: _predict_new_symbol otrzymał pusty symbol")
            return special_symbol

        # Parsuj obecny symbol
        parsed = parse_symbol(current_symbol)

        # Zachowaj lokalizację i godziny, zmień tylko symbol specjalny
        new_symbol = build_symbol(
            location=parsed.get('location'),
            start_hour=parsed.get('start_hour'),
            work_hours=parsed.get('work_hours'),
            special_symbol=special_symbol
        )

        return new_symbol if new_symbol else special_symbol

    def _find_events_to_cancel(self, user_date_pairs):
        """
        Znajduje zdarzenia do odwołania dla podanych par użytkownik-data

        Args:
            user_date_pairs (set): Pary (user_id, date_str)

        Returns:
            list: Lista zdarzeń do odwołania
        """
        events_to_cancel = []

        for user_id, date_str in user_date_pairs:
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

            for event in user_events:
                event_type = event.get('type', '')
                event_id = event.get('id')
                event_status = event.get('status')

                if not event_type or event_id is None:
                    continue

                if event_status is not None:
                    event_status = str(event_status)

                # Dodaj zdarzenia do odwołania (spotkania, szkolenia, nadgodziny)
                if event_type in ['Spotkanie', 'Szkolenie', 'Nadgodziny'] and event_status != '0':
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),
                    })

        return events_to_cancel

    def _group_events_by_user_date(self, events_to_cancel):
        """
        Grupuje zdarzenia według użytkownika i daty

        Args:
            events_to_cancel (list): Lista zdarzeń do odwołania

        Returns:
            dict: Pogrupowane zdarzenia
        """
        grouped_events = {}
        for event in events_to_cancel:
            key = (event['user_id'], event['date'])
            if key not in grouped_events:
                grouped_events[key] = []
            grouped_events[key].append(event)

        return grouped_events

    def _apply_absence_symbol_changes(self, schedule_cells, special_symbol, events_to_cancel):
        try:
            canceled_count = 0
            if events_to_cancel:
                canceled_count = self._cancel_delegations(events_to_cancel)
                debug_print(f"Odwołano {canceled_count} delegacji przed wstawieniem nieobecności.")

            successful_symbol_updates = 0
            failed_symbol_updates = 0
            error_messages_symbol = []
            # Ta lista musi zawierać krotki 3-elementowe
            affected_pairs_for_symbol_change = []

            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                nr_kadrowy = cell_data.get('nr_kadrowy')
                current_symbol = cell_data.get('symbol', '')

                if not user_id or not date_str or not nr_kadrowy:
                    failed_symbol_updates += 1
                    error_messages_symbol.append(f"Brak danych dla komórki: U:{user_id} D:{date_str} NRK:{nr_kadrowy}")
                    continue

                new_symbol = self._build_new_symbol_with_absence_fixed(current_symbol, special_symbol, cell_data)

                try:
                    year_val, month_val, day_val = map(int, date_str.split('-'))

                    result = self._call_import_changes_procedure(
                        nr_kadrowy=nr_kadrowy,
                        rok=year_val,
                        miesiac=month_val,
                        data=date_str,
                        symbol=new_symbol
                    )

                    if result['success']:
                        successful_symbol_updates += 1
                        # --- KLUCZOWA POPRAWKA ---
                        # Upewniamy się, że zawsze dodajemy 3 elementy do krotki
                        affected_pairs_for_symbol_change.append(
                            (user_id, date_str, result.get('returned_symbol'))
                        )
                        debug_print(f"Sukces wstawienia symbolu nieobecności: {user_id}, {date_str}, symbol: {result.get('returned_symbol', new_symbol)}")
                    else:
                        failed_symbol_updates += 1
                        error_msg = result.get('message', 'Nieznany błąd')
                        error_messages_symbol.append(f"{nr_kadrowy} ({date_str}): {error_msg}")
                except Exception as e_proc:
                    failed_symbol_updates += 1
                    error_messages_symbol.append(f"{nr_kadrowy} ({date_str}): {str(e_proc)}")
                    log_error(f"Błąd procedury importu dla {user_id}, {date_str}: {e_proc}", exception=e_proc)

            # Odśwież symbole w grafiku, przekazując listę z poprawnymi danymi
            if successful_symbol_updates > 0:
                self._update_cells_with_new_symbols(affected_pairs_for_symbol_change)

            # Pokaż wyniki operacji
            self._show_symbol_change_results(successful_symbol_updates, failed_symbol_updates, error_messages_symbol,
                                             events_to_cancel if canceled_count > 0 else [])

        except Exception as e:
            log_error(f"Błąd podczas wstawiania nieobecności: {e}", exception=e)
            QMessageBox.critical(
                self, "Błąd", f"Wystąpił błąd podczas wstawiania nieobecności: {str(e)}", QMessageBox.Ok
            )

    def clear_special_symbol_from_selected_cells(self):
        """
        POPRAWIONA WERSJA: Usuwa tylko symbol specjalny z zaznaczonych komórek,
        używając nowego, niezawodnego mechanizmu odświeżania UI.
        """
        # 1. Sprawdzenie uprawnień
        if self.current_user_role != "Pracownik WPR":
            self.statusBar().showMessage("Brak uprawnień do wykonania tej operacji.", 3000)
            return

        # 2. Pobranie i walidacja zaznaczonych komórek
        selected_cells_data = self.table.get_data_for_selected_cells()

        if not self._can_modify_cells(selected_cells_data):
            return

        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono komórek do modyfikacji.")
            return

        cells_to_modify = [
            cell for cell in selected_cells_data
            if cell.get('symbol') and parse_symbol(cell.get('symbol')).get('special_symbol')
        ]

        if not cells_to_modify:
            QMessageBox.information(self, "Brak zmian",
                                    "W zaznaczonych komórkach nie ma symboli specjalnych do usunięcia.")
            return

        # 3. Dialog potwierdzenia
        changes_info = f"Czy na pewno chcesz usunąć symbole specjalne z {len(cells_to_modify)} komórek?\n(Godziny pracy i lokalizacja zostaną zachowane)"
        reply = QMessageBox.question(self, "Potwierdzenie operacji", changes_info,
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

        if reply != QMessageBox.Yes:
            return

        # 4. Logika modyfikacji i zapisu z nowym odświeżaniem
        updated_info = []

        for cell_data in cells_to_modify:
            current_symbol = cell_data.get('symbol', '')
            parsed = parse_symbol(current_symbol)

            # Budowa nowego symbolu bez części specjalnej
            new_symbol = build_symbol(
                location=parsed.get('location'),
                start_hour=parsed.get('start_hour'),
                work_hours=parsed.get('work_hours'),
                special_symbol=None
            )

            try:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                nr_kadrowy = cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')

                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy,
                    rok=int(year),
                    miesiac=int(month),
                    data=date_str,
                    symbol=new_symbol
                )

                if result.get('success'):
                    # Zbieramy informacje zwrotne do jednej, zbiorczej aktualizacji UI
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
            except Exception as e:
                log_error(f"Błąd wywołania procedury w clear_special_symbol_from_selected_cells: {e}")

        # 5. Wywołanie nowej, niezawodnej metody odświeżającej UI
        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Pomyślnie zmodyfikowano {len(updated_info)} komórek.", 3000)

    def _build_new_symbol_with_absence_fixed(self, current_symbol, special_symbol, cell_data):
        """
        POPRAWIONA WERSJA: Buduje nowy symbol z absencją, poprawnie obsługując
        zarówno puste, jak i wypełnione komórki.
        """
        from symbol_parser import parse_symbol, build_symbol

        # Inicjalizacja zmiennych
        location = None
        start_hour = None
        work_hours = None

        if current_symbol and current_symbol.strip():
            # Komórka NIE JEST pusta: parsujemy istniejący symbol
            debug_print(f"Komórka niepusta. Parsowanie symbolu: '{current_symbol}'")
            parsed = parse_symbol(current_symbol)
            location = parsed.get('location')
            start_hour = parsed.get('start_hour')
            work_hours = parsed.get('work_hours')
        else:
            # --- NOWA, POPRAWNA LOGIKA DLA PUSTEJ KOMÓRKI ---
            debug_print("Komórka pusta. Używam danych domyślnych.")
            # Pobierz domyślną lokalizację i godziny z etatu
            location = cell_data.get('lokalizacja_domyslna')
            work_hours = cell_data.get('etat')
            # Dla absencji w dzień wolny, domyślna godzina rozpoczęcia to 8
            start_hour = 8

        # Budujemy nowy symbol z nowym symbolem specjalnym, ale zachowując godziny/lokalizację
        new_symbol = build_symbol(
            location=location,
            start_hour=start_hour,
            work_hours=work_hours,
            special_symbol=special_symbol
        )

        debug_print(f"Zbudowano nowy symbol: '{new_symbol}'")
        return new_symbol

    def _call_import_changes_procedure(self, nr_kadrowy, rok, miesiac, data, symbol):
        """
        POPRAWIONA WERSJA: Wywołuje procedurę i bardziej niezawodnie interpretuje jej wyniki.
        Każdy komunikat tekstowy, który nie jest nowym symbolem, jest traktowany jako błąd.
        """
        try:
            from db_connector import DatabaseConnector

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            debug_print(
                f"Wywołanie procedury: nr_kadrowy={nr_kadrowy}, rok={rok}, miesiac={miesiac}, data={data}, symbol={symbol}")

            cursor.execute("""
                EXEC [dbo].[p_P_ZZ_ImportZmianyNaSerwer_v3] 
                    @NumerKadrowy = ?, @Rok = ?, @Miesiac = ?, @Data = ?, @Symbol = ?, @CzyPobieranieSugestii = ?
            """, (nr_kadrowy, rok, miesiac, data, symbol, None))

            all_results = []
            while True:
                try:
                    rows = cursor.fetchall()
                    if rows:
                        all_results.extend(rows)
                    if not cursor.nextset():
                        break
                except Exception:
                    break

            conn.commit()
            conn.close()

            returned_symbol = symbol
            success = True
            message = "Operacja zakończona pomyślnie"

            for row in all_results:
                if row and len(row) > 0 and row[0] is not None:
                    raw_value = row[0]

                    # --- NOWA, KLUCZOWA ZMIANA ---
                    # Sprawdzamy, czy procedura nie zwróciła numerycznego 0,
                    # które traktujemy jako sygnał sukcesu i ignorujemy.
                    if isinstance(raw_value, int) and raw_value == 0:
                        continue  # Przejdź do następnego wyniku

                    value_str = str(raw_value).strip()
                    if not value_str:
                        continue

                    # Sprawdzamy również dla tekstowego "0"
                    if value_str == "0":
                        continue
                    # --- KONIEC KLUCZOWEJ ZMIANY ---

                    is_likely_a_symbol = ' ' not in value_str and len(value_str) <= 50

                    if is_likely_a_symbol:
                        returned_symbol = value_str
                        debug_print(f"Procedura zwróciła nowy symbol: {value_str}")
                    else:
                        success = False
                        message = value_str
                        debug_print(f"Procedura zwróciła komunikat (traktowany jako błąd): {value_str}")
                        break

            if success:
                self._update_modification_date()

            return {
                "success": success,
                "message": message,
                "returned_symbol": returned_symbol
            }

        except Exception as e:
            log_error(f"Błąd procedury p_P_ZZ_ImportZmianNaSerwer_v4: {e}")
            return {
                "success": False,
                "message": f"Błąd bazy danych: {str(e)}",
                "returned_symbol": symbol
            }

    def _update_cells_with_new_symbols(self, updated_cells_info: list):
        """
        Aktualizuje komórki w modelu na podstawie danych zwróconych przez procedurę,
        bez ponownego odpytywania bazy danych.

        Args:
            updated_cells_info: Lista krotek (user_id, date_str, new_symbol)
        """
        if not updated_cells_info or not hasattr(self, 'schedule_model'):
            return

        for user_id, date_str, new_symbol in updated_cells_info:
            if new_symbol is not None:
                self._update_single_cell_in_model(user_id, date_str, new_symbol, self.year, self.month)

        debug_print(f"Zaktualizowano {len(updated_cells_info)} komórek w modelu na podstawie danych zwrotnych.")

    def _update_single_cell_in_model(self, user_id, date_str, new_symbol, year, month):
        """
        NOWA PROSTA METODA: Aktualizuje jedną komórkę w modelu i wymusza jej odświeżenie
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return False

            # Znajdź pozycję komórki
            row_index = -1
            for idx, key in enumerate(self.schedule_model._keys):
                if str(key[3]) == str(user_id):
                    row_index = idx
                    break

            if row_index == -1:
                debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                return False

            # Oblicz kolumnę
            try:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)
                if int(year_str) != year or int(month_str) != month:
                    return False
            except:
                return False

            visible_columns_count = len(self.schedule_model.get_visible_columns())
            col_index = visible_columns_count + day - 1

            # KLUCZOWE: Użyj setData aby model wiedział o zmianie
            model_index = self.schedule_model.index(row_index, col_index)
            if model_index.isValid():
                # Ustaw nowy symbol przez model - to wywoła automatyczne odświeżenie
                success = self.schedule_model.setData(model_index, new_symbol, Qt.EditRole)

                if success:
                    debug_print(f"SUKCES: Zaktualizowano komórkę [{row_index},{col_index}] = '{new_symbol}'")
                    return True
                else:
                    debug_print(f"BŁĄD: Nie udało się zaktualizować komórki [{row_index},{col_index}]")

            return False

        except Exception as e:
            log_error(f"Błąd aktualizacji komórki {user_id}/{date_str}: {e}")
            return False

    def _update_model_with_new_symbols(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje symbole bezpośrednio w modelu
        """
        try:
            if not updated_symbols or not hasattr(self, 'schedule_model'):
                return

            processed_data = self.schedule_model.get_processed_data()
            if not processed_data:
                return

            updated_count = 0
            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Znajdź klucz użytkownika w processed_data
                target_key = None
                for key in processed_data.keys():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        target_key = key
                        break

                if not target_key:
                    debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                    continue

                # Oblicz dzień z daty
                try:
                    year_str, month_str, day_str = date_str.split('-')
                    day = int(day_str)

                    if int(year_str) != year or int(month_str) != month:
                        continue

                except ValueError:
                    continue

                # Aktualizuj symbol w processed_data
                user_data = processed_data[target_key]
                days_data = user_data.setdefault('days', {})
                day_data = days_data.setdefault(day, {})

                old_symbol = day_data.get('symbol', '')
                day_data['symbol'] = new_symbol

                # Przelicz godziny na podstawie nowego symbolu
                from symbol_parser import parse_symbol
                parsed = parse_symbol(new_symbol)
                day_data['hours'] = parsed.get('work_hours', 0) or 0
                day_data['start_hour'] = parsed.get('start_hour')

                # Aktualizuj total_hours użytkownika
                old_hours = 0
                if old_symbol:
                    old_parsed = parse_symbol(old_symbol)
                    old_hours = old_parsed.get('work_hours', 0) or 0

                new_hours = day_data['hours']
                user_data['total_hours'] = (user_data.get('total_hours', 0) or 0) - old_hours + new_hours

                updated_count += 1
                debug_print(
                    f"Model: Zaktualizowano {user_id}/{day}: '{old_symbol}' -> '{new_symbol}' ({old_hours}h -> {new_hours}h)")

            debug_print(f"Zaktualizowano {updated_count} komórek w modelu")

        except Exception as e:
            log_error(f"Błąd aktualizacji modelu: {e}")

    def _fetch_single_cell_symbol(self, user_id, date_str, year, month):
        """
        NOWA METODA: Pobiera aktualny symbol dla pojedynczej komórki z bazy danych

        Args:
            user_id (int): ID użytkownika
            date_str (str): Data w formacie YYYY-MM-DD
            year (int): Rok
            month (int): Miesiąc

        Returns:
            str|None: Aktualny symbol lub None jeśli nie znaleziono
        """
        try:
            from db_connector import DatabaseConnector

            # Zapytanie do pobrania symbolu dla konkretnej komórki
            query = """
            SELECT Symbol 
            FROM [dbo].[fn_GetScheduleData](?, ?) 
            WHERE Uzytkownik = ? AND Data = ?
            """

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query, (year, month, user_id, date_str))
            result = cursor.fetchone()
            conn.close()

            if result and result[0] is not None:
                return str(result[0])

            return None

        except Exception as e:
            log_error(f"Błąd podczas pobierania symbolu dla komórki {user_id}/{date_str}: {e}")
            return None

    def _update_data_provider_cache(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje cache w DataProvider
        """
        try:
            if not updated_symbols or not hasattr(self.data_provider, 'monthly_cache'):
                return

            month_key = (year, month)
            if month_key not in self.data_provider.monthly_cache:
                return

            container = self.data_provider.monthly_cache[month_key]

            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Aktualizuj processed_data w kontenerze
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):
                        try:
                            year_str, month_str, day_str = date_str.split('-')
                            day = int(day_str)

                            if int(year_str) == year and int(month_str) == month:
                                days_data = user_data.setdefault('days', {})
                                day_data = days_data.setdefault(day, {})
                                day_data['symbol'] = new_symbol

                                # Przelicz godziny
                                from symbol_parser import parse_symbol
                                parsed = parse_symbol(new_symbol)
                                day_data['hours'] = parsed.get('work_hours', 0) or 0
                                day_data['start_hour'] = parsed.get('start_hour')

                                debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")
                                break
                        except:
                            continue

        except Exception as e:
            log_error(f"Błąd aktualizacji DataProvider cache: {e}")

    def _force_full_refresh(self):
        """Fallback - pełne odświeżenie danych"""
        try:
            current_data = self.date_combo.currentData()
            if current_data:
                year, month = current_data
                self.data_provider.refresh_data(year, month)
                self.update_table_content()
        except Exception as e:
            log_error(f"Błąd pełnego odświeżenia: {e}")

    def _force_refresh_specific_cells(self, affected_pairs, year, month):
        """
        POPRAWIONA METODA: Wymusza odświeżenie konkretnych komórek w widoku
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycję komórki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajdź wiersz użytkownika w modelu
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnę dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymusza odświeżenie komórki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej komórki
                        self.schedule_model.dataChanged.emit(model_index, model_index,
                                                             [Qt.DisplayRole, Qt.BackgroundRole])

                        # Metoda 2: Wymuś update widoku dla tej komórki
                        self.table.schedule_view.update(model_index)

                        refreshed_cells += 1
                        debug_print(f"Odświeżono komórkę tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"Błąd odświeżania komórki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymuś całościowy update viewport jeśli zmieniono jakieś komórki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po odświeżeniu {refreshed_cells} komórek")

                # DODATKOWE: Wymuś też odświeżenie tabeli pracowników (dla sum RBH)
                if hasattr(self.table, 'employees_view'):
                    self.table.employees_view.viewport().update()

        except Exception as e:
            log_error(f"Błąd podczas wymuszania odświeżenia komórek tabeli: {e}")

    def _update_model_cells_directly(self, updated_symbols, year, month):
        """
        Aktualizuje symbole bezpośrednio w modelu i DataProvider

        Args:
            updated_symbols (dict): Słownik {(user_id, date_str): symbol}
            year (int): Rok
            month (int): Miesiąc
        """
        try:
            if not updated_symbols:
                return

            updated_count = 0

            # AKTUALIZACJA 1: Schedule Model processed_data
            if hasattr(self, 'schedule_model') and self.schedule_model:
                processed_data = self.schedule_model.get_processed_data()

                if processed_data:
                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        if self._update_single_cell_in_processed_data(processed_data, user_id, date_str, new_symbol,
                                                                      year, month):
                            updated_count += 1

            # AKTUALIZACJA 2: DataProvider cache (jeśli istnieje)
            if hasattr(self.data_provider, 'monthly_cache'):
                month_key = (year, month)
                if month_key in self.data_provider.monthly_cache:
                    container = self.data_provider.monthly_cache[month_key]

                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        self._update_single_cell_in_data_provider(container, user_id, date_str, new_symbol, year, month)

            debug_print(f"Zaktualizowano {updated_count} komórek w modelu")

        except Exception as e:
            log_error(f"Błąd bezpośredniej aktualizacji modelu: {e}")

    def _update_single_cell_in_processed_data(self, processed_data, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczą komórkę w processed_data

        Returns:
            bool: True jeśli zaktualizowano
        """
        try:
            # Znajdź klucz użytkownika
            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if not target_key:
                debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                return False

            # Oblicz dzień
            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)

            if int(year_str) != year or int(month_str) != month:
                return False

            # Aktualizuj symbol
            user_data = processed_data[target_key]
            days_data = user_data.setdefault('days', {})
            day_data = days_data.setdefault(day, {})

            old_symbol = day_data.get('symbol', '')
            day_data['symbol'] = new_symbol

            # Przelicz godziny i inne parametry
            from symbol_parser import parse_symbol
            parsed = parse_symbol(new_symbol)
            day_data['hours'] = parsed.get('work_hours', 0) or 0
            day_data['start_hour'] = parsed.get('start_hour')

            debug_print(f"Model: {user_id}/{day} '{old_symbol}' -> '{new_symbol}'")
            return True

        except Exception as e:
            log_error(f"Błąd aktualizacji komórki processed_data {user_id}/{date_str}: {e}")
            return False

    def _update_single_cell_in_data_provider(self, container, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczą komórkę w DataProvider cache
        """
        try:
            if not hasattr(container, 'processed_data') or not container.processed_data:
                return

            # Podobna logika jak dla processed_data w modelu
            processed_data = container.processed_data

            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if target_key:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)

                if int(year_str) == year and int(month_str) == month:
                    user_data = processed_data[target_key]
                    days_data = user_data.setdefault('days', {})
                    day_data = days_data.setdefault(day, {})
                    day_data['symbol'] = new_symbol

                    # Przelicz godziny
                    from symbol_parser import parse_symbol
                    parsed = parse_symbol(new_symbol)
                    day_data['hours'] = parsed.get('work_hours', 0) or 0
                    day_data['start_hour'] = parsed.get('start_hour')

                    debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")

        except Exception as e:
            log_error(f"Błąd aktualizacji DataProvider cache: {e}")

    def _force_refresh_table_cells(self, affected_pairs, year, month):
        """
        WYMUSZA odświeżenie konkretnych komórek w widoku tabeli

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
            year (int): Rok
            month (int): Miesiąc
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycję komórki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajdź wiersz użytkownika
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnę dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymuś odświeżenie komórki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej komórki
                        self.schedule_model.dataChanged.emit(model_index, model_index, [])

                        # Metoda 2: Wymuś update widoku (backup)
                        self.table.schedule_view.update(model_index)

                        # Metoda 3: Invalidate item (backup)
                        if hasattr(self.table.schedule_view, 'setDirtyRegion'):
                            rect = self.table.schedule_view.visualRect(model_index)
                            if not rect.isEmpty():
                                self.table.schedule_view.viewport().update(rect)

                        refreshed_cells += 1
                        debug_print(f"Odświeżono komórkę tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"Błąd odświeżania komórki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymuś całościowy update viewport jeśli zmieniono jakieś komórki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po odświeżeniu {refreshed_cells} komórek")

        except Exception as e:
            log_error(f"Błąd podczas wymuszania odświeżenia komórek tabeli: {e}")

    def _find_user_row_in_model(self, user_id):
        """
        POPRAWIONA METODA: Znajduje indeks wiersza dla danego użytkownika w modelu
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return -1

            # Pobierz klucze z modelu
            if hasattr(self.schedule_model, '_keys'):
                keys = self.schedule_model._keys
            else:
                return -1

            user_id_str = str(user_id)

            for row_index, key in enumerate(keys):
                if len(key) > 3 and str(key[3]) == user_id_str:
                    return row_index

            return -1

        except Exception as e:
            log_error(f"Błąd podczas szukania wiersza użytkownika {user_id}: {e}")
            return -1

    def _update_local_events_for_cells(self, affected_pairs):
        """
        Aktualizuje lokalny events_data tylko dla zmienionych komórek

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
        """
        try:
            if not hasattr(self, 'events_data'):
                return

            # Sprawdź czy jakieś z zmienionych komórek są obecnie zaznaczone
            if not hasattr(self, 'table'):
                return

            current_selection = self.table.get_data_for_selected_cells()
            selected_pairs = set()

            for cell_data in current_selection:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    selected_pairs.add((user_id, date_str))

            # Sprawdź czy któraś ze zmienionych komórek jest zaznaczona
            intersection = set(affected_pairs) & selected_pairs

            if intersection:
                debug_print(f"Zaktualizowano {len(intersection)} zmienionych komórek w events_data")
                # Jeśli tak, odśwież events_data tylko dla zaznaczonych komórek
                self.on_selection_changed()

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji lokalnych events: {e}")

    def _show_symbol_change_results(self, successful_updates, failed_updates, error_messages, events_to_cancel):
        """
        Pokazuje wyniki operacji wstawiania symboli

        Args:
            successful_updates (int): Liczba udanych aktualizacji
            failed_updates (int): Liczba nieudanych aktualizacji
            error_messages (list): Lista komunikatów błędów
            events_to_cancel (list): Lista odwołanych zdarzeń
        """
        if successful_updates > 0:
            message = f"Pomyślnie zaktualizowano {successful_updates} komórek"

            if events_to_cancel:
                message += f" i odwołano {len(events_to_cancel)} delegacji"

            if failed_updates > 0:
                message += f"\n\n⚠️ {failed_updates} aktualizacji nie powiodło się"
                if error_messages:
                    message += ":\n" + "\n".join(error_messages[:5])
                    if len(error_messages) > 5:
                        message += f"\n... i {len(error_messages) - 5} więcej błędów"

            if failed_updates == 0:
                QMessageBox.information(
                    self, "Sukces", message, QMessageBox.Ok
                )
            else:
                QMessageBox.warning(
                    self, "Częściowy sukces", message, QMessageBox.Ok
                )
        else:
            message = f"Nie udało się zaktualizować żadnej komórki"
            if error_messages:
                message += f"\n\nBłędy ({len(error_messages)}):\n"
                message += "\n".join(error_messages[:10])
                if len(error_messages) > 10:
                    message += f"\n... i {len(error_messages) - 10} więcej błędów"

            QMessageBox.critical(
                self, "Błąd aktualizacji", message, QMessageBox.Ok
            )

    def _prepare_delegations_description(self, grouped_events, max_groups=10):
        """
        Przygotowuje opis delegacji do odwołania.

        Args:
            grouped_events: Słownik zdarzeń pogrupowanych według użytkownika i daty
            max_groups: Maksymalna liczba grup do wyświetlenia

        Returns:
            str: Opis delegacji do odwołania
        """
        delegations_info = ""

        if not grouped_events:
            return delegations_info

        delegations_info += "\nNastępujące delegacje zostaną automatycznie odwołane:\n"

        # Licznik dla ograniczenia liczby wyświetlanych grup
        group_count = 0

        for (user_id, date_str), events in grouped_events.items():
            # Ograniczenie liczby wyświetlanych grup
            if group_count >= max_groups:
                delegations_info += f"\n...oraz więcej zdarzeń dla innych użytkowników/dni ({len(grouped_events) - max_groups} więcej grup)...\n"
                break

            # Pobierz nazwę użytkownika z pierwszego zdarzenia
            user_name = events[0].get('user_name', f"ID: {user_id}")

            # Przygotuj datę w ładniejszym formacie (DD.MM.YYYY)
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            delegations_info += f"   👤 {user_name} - 📅 {formatted_date}:\n"

            # Wyświetl zdarzenia dla tego użytkownika i daty
            for i, event in enumerate(events):
                delegations_info += f"      {i + 1}. {event['type']}: {event['name']}\n"

            group_count += 1

        return delegations_info

    def filter_processed_data(self):
        """
        Filtruje przetworzone dane na podstawie bieżących filtrów.
        Zwraca przefiltrowane dane w formacie słownikowym.

        Returns:
            dict: Przefiltrowane dane
        """
        # Pobierz wszystkie dane z processed_data
        all_data = self.processed_data.copy() if hasattr(self, 'processed_data') else {}

        # Jeśli nie ma danych do filtrowania, zwróć pusty słownik
        if not all_data:
            return {}

        # Pobierz wybrane filtry
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self,
                                                                                            'przelozony_list') else []
        selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list) if hasattr(self,
                                                                                             'uzytkownik_list') else []
        selected_dtn = self.dtn_combo.get_selected_items() if hasattr(self, 'dtn_combo') else []
        selected_role = self.rola_combo.get_selected_items() if hasattr(self, 'rola_combo') else []
        selected_jezyki = self.jezyk_combo.get_selected_items() if hasattr(self, 'jezyk_combo') else []
        selected_etaty = self.etat_combo.get_selected_items() if hasattr(self, 'etat_combo') else []
        selected_scp = self.system_czasu_pracy_combo.get_selected_items() if hasattr(self,
                                                                                     'system_czasu_pracy_combo') else []

        # Filtruj dane
        filtered_data = {}
        for key, data in all_data.items():
            wydzial, przelozony, uzytkownik_dane, uzytkownik = key

            # Pobierz wartości pól do filtrowania
            dtn = str(data.get('dtn', ''))
            rola_nazwa = data.get('rola_nazwa', '')
            jezyk = data.get('jezyk', '')
            etat = str(data.get('etat', '')) if data.get('etat') is not None else ''
            system_czasu_pracy = data.get('system_czasu_pracy', '')
            # Sprawdź, czy dane spełniają kryteria filtrowania
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni) and \
                    (not selected_uzytkownicy or str(uzytkownik_dane) in selected_uzytkownicy) and \
                    (not selected_dtn or dtn in selected_dtn) and \
                    (not selected_role or rola_nazwa in selected_role) and \
                    (not selected_jezyki or jezyk in selected_jezyki) and \
                    (not selected_etaty or etat in selected_etaty):
                # Dodaj dane do przefiltrowanych wyników
                filtered_data[key] = data

        return filtered_data

    def _cancel_delegations(self, events_to_cancel_input: List[Dict]):
        debug_print(f"Rozpoczynam _cancel_delegations dla {len(events_to_cancel_input)} zdarzeń.")
        if not events_to_cancel_input:
            return 0

        successful_db_updates = 0
        # Lista par (user_id, date_key) dla zdarzeń, które zostały pomyślnie zaktualizowane w DB
        affected_user_date_pairs_for_refresh = set()

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            _, user_app_id, _, _, _ = get_modifier_id()

            for event_details in events_to_cancel_input:
                event_id = event_details.get('id')
                event_type = event_details.get('type')
                user_id_for_event = event_details.get('user_id')  # Użyj user_id z event_details
                date_key_for_event = event_details.get('date_key', event_details.get('date'))

                if not event_id or not event_type or not user_id_for_event or not date_key_for_event:
                    log_warning(f"Pominięto zdarzenie z niepełnymi danymi w _cancel_delegations: {event_details}")
                    continue

                table_name = ""
                if event_type == "Spotkanie":
                    table_name = "p_t_zz_Spotkania"
                elif event_type == "Szkolenie":
                    table_name = "p_t_zz_Szkolenia"
                elif event_type == "Nadgodziny":
                    table_name = "p_t_zz_Nadgodziny"

                if not table_name:
                    log_warning(f"Nieznany typ zdarzenia w _cancel_delegations: {event_type}")
                    continue

                try:
                    if event_type in ["Spotkanie", "Szkolenie"]:
                        update_query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                        cursor.execute(update_query, (user_app_id, event_id))
                    else:  # Nadgodziny
                        delete_query = f"DELETE FROM {table_name} WHERE Id = ?"
                        cursor.execute(delete_query, (event_id,))

                    if cursor.rowcount > 0:
                        successful_db_updates += 1
                        affected_user_date_pairs_for_refresh.add((user_id_for_event, date_key_for_event))
                        debug_print(f"DB: Pomyślnie zaktualizowano/usunięto {event_type} ID {event_id}")
                    else:
                        log_warning(f"DB: Nie znaleziono {event_type} ID {event_id} do aktualizacji/usunięcia.")

                except Exception as db_err:
                    log_error(f"Błąd DB podczas odwoływania {event_type} ID {event_id}: {db_err}", exception=db_err)

            if successful_db_updates > 0:
                conn.commit()
                debug_print(f"DB: Zatwierdzono {successful_db_updates} zmian.")
                # Rejestrujemy, że to my dokonaliśmy zmiany w bazie danych
                self._update_modification_date()
            conn.close()

        except Exception as e:
            log_error(f"Generalny błąd w _cancel_delegations podczas operacji DB: {e}", exception=e)
            return 0  # Zwróć 0 jeśli wystąpił błąd przed aktualizacją UI

        # Jeśli były jakiekolwiek udane aktualizacje w DB
        if affected_user_date_pairs_for_refresh:
            debug_print(
                f"_cancel_delegations: Uruchamiam odświeżanie DataProvider dla {len(affected_user_date_pairs_for_refresh)} par.")
            # Krok 1: Unieważnij i odśwież cache DataProvider dla dotkniętych zdarzeń/miesięcy
            self.data_provider.invalidate_complete_cache_for_pairs(list(affected_user_date_pairs_for_refresh))

            # Krok 2: Odśwież tabelę zdarzeń - on_selection_changed użyje świeżych danych z DataProvider
            # Ta metoda zaktualizuje self.events_data i self.events_model
            debug_print(f"_cancel_delegations: Uruchamiam on_selection_changed() w celu odświeżenia tabeli zdarzeń.")
            selected_cells_data = self.table.get_data_for_selected_cells()  # Pobierz aktualnie zaznaczone komórki
            if selected_cells_data:
                self.on_selection_changed()  # To powinno teraz poprawnie wyczyścić zdarzenia
            else:  # Jeśli nic nie jest zaznaczone, wyczyść tabelę zdarzeń ręcznie
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])
                debug_print("_cancel_delegations: Brak zaznaczenia, wyczyszczono tabelę zdarzeń.")

            # Krok 3: Zaktualizuj ikony w tabeli grafiku na podstawie świeżych danych z DataProvider
            if hasattr(self, 'schedule_model'):
                debug_print(
                    f"_cancel_delegations: Uruchamiam aktualizację ikon grafiku dla {len(affected_user_date_pairs_for_refresh)} par.")
                for user_id, date_str in affected_user_date_pairs_for_refresh:
                    # Pobierz aktualne aktywne zdarzenia dla tej komórki z DataProvider
                    # DataProvider powinien teraz mieć świeże dane po invalidate_complete_cache_for_pairs
                    remaining_active_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                    has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_active_events)
                    has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_active_events)
                    has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_active_events)

                    self.schedule_model.update_cell_icons_directly(
                        user_id, date_str, has_meetings, has_trainings, has_overtime
                    )

            # Wymuś odświeżenie widoków tabel, jeśli to konieczne
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        debug_print(f"_cancel_delegations: Zakończono, pomyślnie przetworzono w DB: {successful_db_updates} zdarzeń.")
        return successful_db_updates

    def update_filter_dates(self):
        """Aktualizuje daty filtrowania do pierwszego i ostatniego dnia wybranego miesiąca"""
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # KLUCZOWA POPRAWKA: Blokuj sygnały przed zmianą dat
        self.date_from.blockSignals(True)
        self.date_to.blockSignals(True)
        
        try:
            # Pierwszy dzień miesiąca
            first_day = QDate(year, month, 1)
            self.date_from.setDate(first_day)

            # Ostatni dzień miesiąca
            if month == 12:
                next_month = QDate(year + 1, 1, 1)
            else:
                next_month = QDate(year, month + 1, 1)

            last_day = next_month.addDays(-1)
            self.date_to.setDate(last_day)
            
        finally:
            # ZAWSZE odblokuj sygnały
            self.date_from.blockSignals(False)
            self.date_to.blockSignals(False)

        # Wywołaj filtrowanie tylko RAZ po wszystkich zmianach
        self.filter_events_table()

    def on_date_combo_changed(self):
        """
        ZMODYFIKOWANA: Zmiana miesiąca z async loading
        """
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            if self.staffing_details_win and not self.staffing_details_win.isHidden():
                self.staffing_details_win.update_for_new_month_or_filters(year, month)

            if hasattr(self.data_provider, 'on_month_change'):
                self.data_provider.on_month_change(year, month)

            self.update_data(year, month, use_async=True)
            self.update_filter_dates()

            # --- DODAJ TĘ LINIĘ ---
            self.update_buttons_visibility()

    def update_data(self, year, month, use_async=True):
        """
        NOWA WERSJA: Ładowanie danych z opcją async

        Args:
            year: Rok
            month: Miesiąc
            use_async: Czy użyć asynchronicznego ładowania (domyślnie True)
        """
        debug_print(f"Rozpoczynam ładowanie danych dla {year}-{month} (async={use_async})")

        self.year = year
        self.month = month

        # Sprawdź czy modele zostały zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            debug_print("Tworzę nowy model grafiku")
            self.schedule_model = ScheduleTableModel(self)
            self.schedule_model.set_theme(self.is_dark_theme)

            ui_columns = self.column_definitions.get_ui_display_columns()
            visible_cols = self.visible_columns
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

        if not hasattr(self, 'events_model') or not self.events_model:
            debug_print("Tworzę nowy model zdarzeń")
            self.events_model = EventsTableModel(self)
            self.events_model.set_theme(self.is_dark_theme)

        # KLUCZOWA ZMIANA: Użyj async loading dla dużych zbiorów danych
        if use_async:
            self._load_data_async(year, month)
        else:
            self._load_data_sync(year, month)

    def _load_data_sync(self, year, month):
        """
        Synchroniczne ładowanie danych (fallback), teraz spójne z logiką asynchroniczną.
        """
        debug_print(f"Ładowanie synchroniczne dla {year}-{month}")

        try:
            if hasattr(self, 'statusBar'):
                self.statusBar().showMessage(f"Ładowanie danych {year}-{month}...")

            # Krok 1: Pobierz kontener z danymi bazowymi
            container = self.data_provider._get_or_load_monthly_data(
                year, month, self.import_grupa, self.import_funkcja, use_cache=False
            )

            if container:
                # Krok 2: Pobierz przetworzone dane z nałożonymi ikonami
                processed_data_with_icons = self.data_provider.get_processed_data(
                    year, month, self.import_grupa, self.import_funkcja
                )

                # Krok 3: Zastosuj wszystkie dane
                self._apply_loaded_data({
                    'schedule_data': container.schedule_data,
                    'events_data': container.events_data,
                    'processed_data': processed_data_with_icons,  # Używamy danych z ikonami
                    'year': year,
                    'month': month
                })
            else:
                log_error("Nie udało się pobrać danych z DataProvider w trybie synchronicznym.")

        except Exception as e:
            log_error(f"Błąd podczas synchronicznego ładowania: {e}", exception=e)

        finally:
            if hasattr(self, 'statusBar'):
                self.statusBar().clearMessage()

    def _load_data_async(self, year, month):
        """
        NOWA METODA: Asynchroniczne ładowanie danych z progress dialog
        """
        debug_print(f"Uruchamiam async ładowanie dla {year}-{month}")

        # Pokaż dialog ładowania
        self.loading_dialog = LoadingProgressDialog(
            self, self.data_provider, year, month, self.import_grupa, self.import_funkcja
        )

        # Podłącz sygnały
        self.loading_dialog.loading_completed.connect(self._on_async_data_loaded)
        self.loading_dialog.loading_cancelled.connect(self._on_async_loading_cancelled)
        self.loading_dialog.loading_failed.connect(self._on_async_loading_failed)

        # Pokaż dialog
        result = self.loading_dialog.exec()

        # Sprzątanie
        if hasattr(self, 'loading_dialog'):
            self.loading_dialog.deleteLater()
            delattr(self, 'loading_dialog')

    def _on_async_data_loaded(self, data):
        """
        NOWA METODA: Obsługuje pomyślne załadowanie danych async
        """
        debug_print("Otrzymano dane z async loading")

        try:
            self._apply_loaded_data(data)
            debug_print("Pomyślnie zastosowano dane z async loading")
        except Exception as e:
            log_error(f"Błąd podczas stosowania załadowanych danych: {e}")

    def _on_async_loading_cancelled(self):
        """
        NOWA METODA: Obsługuje anulowanie ładowania
        """
        debug_print("Async loading został anulowany przez użytkownika")
        # Można dodać logikę powrotu do poprzedniego stanu

    def _on_async_loading_failed(self, error_message):
        """
        NOWA METODA: Obsługuje błędy async loading
        """
        debug_print(f"Async loading failed: {error_message}")

        # Pokaż komunikat błędu użytkownikowi
        from PySide6.QtWidgets import QMessageBox
        QMessageBox.critical(
            self,
            "Błąd ładowania danych",
            f"Nie udało się załadować danych:\n{error_message}\n\nSpróbuj ponownie lub skontaktuj się z administratorem.",
            QMessageBox.Ok
        )

        # Fallback - spróbuj załadować synchronicznie
        try:
            debug_print("Próbuję fallback do synchronicznego ładowania")
            self._load_data_sync(self.year, self.month)
        except Exception as e:
            log_error(f"Fallback loading też nie powiódł się: {e}")

    def _apply_loaded_data(self, data):
        """
        NOWA METODA: Aplikuje załadowane dane do modeli i UI
        """
        schedule_data = data['schedule_data']
        events_data = data['events_data']
        processed_data = data['processed_data']
        year = data['year']
        month = data['month']

        debug_print(f"Aplikuję dane: {len(schedule_data)} wierszy grafiku, "
                    f"{len(events_data)} zdarzeń, {len(processed_data)} użytkowników")

        # Aktualizuj model grafiku
        self.schedule_model.update_data(self.data_provider, year, month, self.import_grupa, self.import_funkcja)

        # Wyczyść model zdarzeń
        debug_print("Model zdarzeń pozostaje pusty - oczekuje na zaznaczenie komórek")
        if not hasattr(self, 'events_data'):
            self.events_data = []
        if hasattr(self, 'events_model'):
            self.events_model.update_data([])  # Pusta tabela zdarzeń

        # Zachowaj dane dla kompatybilności
        self.raw_data = schedule_data
        self.all_events_data = events_data
        self.processed_data = processed_data

        # Filtruj dane grafiku
        debug_print("Filtruję dane grafiku...")
        filtered_data = self.filter_processed_data()
        self.schedule_model.update_filtered_data(filtered_data)

        # Aktualizuj widoki
        if hasattr(self, 'table') and self.table:
            debug_print("Aktualizuję widok grafiku...")
            self.table.set_model(self.schedule_model)

        if hasattr(self, 'events_table') and self.events_table:
            debug_print("Aktualizuję widok zdarzeń (pusty)...")
            self.events_table.setModel(self.events_model)
            self.setup_event_table_columns()

        # Aktualizuj filtry
        debug_print("Aktualizuję filtry...")
        self.update_filters()

        # Ustaw daty filtrowania BEZ emitowania sygnałów
        if hasattr(self, 'date_from') and hasattr(self, 'date_to'):
            # Oblicz pierwszy i ostatni dzień miesiąca
            first_day = QDate(year, month, 1)

            # Ostatni dzień miesiąca
            if month == 12:
                next_month = QDate(year + 1, 1, 1)
            else:
                next_month = QDate(year, month + 1, 1)
            last_day = next_month.addDays(-1)

            # Blokuj sygnały przed zmianą dat
            self.date_from.blockSignals(True)
            self.date_to.blockSignals(True)

            try:
                self.date_from.setDate(first_day)
                self.date_to.setDate(last_day)
            finally:
                # ZAWSZE odblokuj sygnały
                self.date_from.blockSignals(False)
                self.date_to.blockSignals(False)

        # Odśwież widoki
        if hasattr(self, 'table'):
            if hasattr(self.table, 'employees_view'):
                self.table.employees_view.viewport().update()
            if hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

        debug_print("Zakończono aplikowanie danych")
        self._set_schedule_columns_width()

    def clear_events_cache(self, year, month):
        """
        Czyści cache zdarzeń dla danego miesiąca - UPROSZCZONA WERSJA
        
        Args:
            year: Rok
            month: Miesiąc
        """
        # POPRAWKA: Deleguj TYLKO do DataProvider, bez dodatkowych akcji
        if hasattr(self.data_provider, 'invalidate_icons_cache'):
            self.data_provider.invalidate_icons_cache(year, month)
            debug_print(f"Wyczyszczono cache zdarzeń dla {year}-{month}")
        else:
            debug_print(f"DataProvider nie ma metody invalidate_icons_cache")

    def get_events_for_user_date(self, user_id, date_str):
        """
        UPROSZCZONA METODA: Deleguje do DataProvider
        """
        return self.data_provider.get_events_for_user_date(user_id, date_str)

    def refresh_column_configuration(self):
        """Odświeża konfigurację kolumn z ColumnDefinitions"""
        # ZMODYFIKOWANE: Używaj self.column_definitions zamiast column_manager
        # Pobierz zaktualizowane dane kolumn
        ui_columns = self.column_definitions.get_ui_display_columns()
        visible_cols = self.visible_columns

        # Aktualizuj referencje w głównej klasie
        self.employee_columns = ui_columns

        # Aktualizuj model
        if hasattr(self, 'schedule_model') and self.schedule_model:
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

            # Jeśli tabela już istnieje, zaktualizuj widok
            if hasattr(self, 'table') and self.table:
                self.table.set_model(self.schedule_model)
                # Dostosuj szerokość tabeli pracowników
                self.table.adjust_employees_table_width()

    def setup_event_table_columns(self):
        """
        Konfiguruje szerokości kolumn tabeli zdarzeń.
        Wyodrębnione z metody update_data dla lepszej czytelności.
        """
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Użytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje


    def show_loading_indicator(self, message="Ładowanie..."):
        """
        Pokazuje wskaźnik ładowania w UI
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().showMessage(message)

        # Wyłącz niektóre kontrolki podczas ładowania
        self.date_combo.setEnabled(False)
        self.refresh_button.setEnabled(False)

        if hasattr(self, 'left_panel_visible') and self.left_panel_visible:
            self._left_panel.setEnabled(False)

    def hide_loading_indicator(self):
        """
        Ukrywa wskaźnik ładowania
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().clearMessage()

        # Włącz z powrotem kontrolki
        self.date_combo.setEnabled(True)
        self.refresh_button.setEnabled(True)

        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(True)

    def get_loading_preferences(self):
        """
        Zwraca preferencje użytkownika dotyczące ładowania
        """
        # Można dodać ustawienia w settings_db dla kontroli async loading
        # Na razie zawsze async dla dużych zbiorów danych
        return {
            'use_async_threshold': 1000,  # Użyj async dla >1000 wierszy
            'show_progress_dialog': True,
            'auto_fallback_to_sync': True
        }

    def check_for_new_data(self):
        """
        Sprawdza, czy w bazie pojawiły się nowe dane grafiku lub zdarzeń,
        i tworzy szczegółowe powiadomienie.
        """
        try:
            current_date_data = self.date_combo.currentData()
            if not current_date_data:
                return

            year, month = current_date_data

            if not hasattr(self, 'last_modification_date') or not self.last_modification_date:
                self._update_modification_date()
                debug_print(f"Zainicjowano datę ostatniej modyfikacji: {self.last_modification_date}")
                return

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # 1. Sprawdź najnowszą modyfikację w grafiku
            cursor.execute("SELECT MAX(DataModyfikacji) FROM [dbo].[p_T_ZZ_GrafikiPracy] WHERE Rok = ? AND Miesiac = ?", (year, month))
            schedule_max_date = cursor.fetchone()[0]

            # 2. Sprawdź najnowszą modyfikację w zdarzeniach
            cursor.execute("SELECT MAX(DataModyfikacji) FROM [dbo].[fn_GetEventsData](?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]

            conn.close()

            # --- NOWA LOGIKA: Oddzielna analiza obu źródeł ---

            new_data_types = []

            # Sprawdź, czy dane grafiku są nowsze
            if schedule_max_date and schedule_max_date > self.last_modification_date:
                new_data_types.append("grafiku")

            # Sprawdź, czy dane zdarzeń są nowsze
            if events_max_date and events_max_date > self.last_modification_date:
                new_data_types.append("zdarzeń")

            # Jeśli wykryto jakiekolwiek zmiany, sprawdź, czy nie są to zmiany własne
            if new_data_types:
                latest_overall_modification = max(d for d in [schedule_max_date, events_max_date] if d)

                is_self_change = False
                if hasattr(self, 'last_self_modification_date') and self.last_self_modification_date:
                    time_diff = abs(latest_overall_modification - self.last_self_modification_date)
                    if time_diff < timedelta(seconds=2):
                        is_self_change = True

                # Jeśli zmiana nie jest naszą własną, wyświetl szczegółowe powiadomienie
                if not is_self_change:
                    change_type_text = " i ".join(new_data_types)

                    debug_print(f"Wykryto nowe dane w sekcji: {change_type_text}.")
                    self.refresh_button.setText(f"Nowe dane {change_type_text}!")
                    self.refresh_button.setToolTip(
                        f"Wykryto zmiany w sekcji: {change_type_text}. Kliknij, aby załadować.")

                    new_data_style = """
                        QPushButton {
                            background-color: #f39c12; color: white; font-weight: bold;
                            border: 1px solid #e67e22;
                        }
                        QPushButton:hover { background-color: #e67e22; }
                    """
                    self.refresh_button.setStyleSheet(new_data_style)
                    self.check_timer.stop()
                else:
                    # To nasza własna zmiana, więc tylko aktualizujemy datę w tle
                    self.last_modification_date = latest_overall_modification
                    debug_print("Wykryto własną zmianę, powiadomienie zignorowane.")

        except Exception as e:
            log_error(f"Błąd podczas sprawdzania nowych danych: {e}", exception=e)

    def refresh_data(self):
        """
        Pełne odświeżenie danych z async loading i aktualizacja daty ostatniej modyfikacji.
        """
        button_style = AppStyles.get_button_style("dark" if self.is_dark_theme else "light")
        self.refresh_button.setText("Odśwież dane")
        self.refresh_button.setStyleSheet(button_style)
        self.refresh_button.setToolTip("Odśwież dane")

        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            self.data_provider.refresh_data(year, month)
            self.update_data(year, month, use_async=True)

            # --- KLUCZOWA ZMIANA: Zaktualizuj bazową datę po odświeżeniu ---
            # To sprawi, że kolejne sprawdzanie będzie się odnosić do nowej, aktualnej daty.
            self._update_modification_date()

            if hasattr(self, 'check_timer'):
                self.check_timer.start(60000)
                debug_print("Dane odświeżone przez użytkownika, wznowiono automatyczne sprawdzanie.")

    def _update_modification_date(self):
        """
        Aktualizuje datę ostatniej modyfikacji po dokonaniu zmian,
        sprawdzając oba źródła danych (grafik i zdarzenia).
        """
        try:
            current_date_data = self.date_combo.currentData()
            if not current_date_data:
                return

            year, month = current_date_data

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # 1. Sprawdź najnowszą modyfikację w grafiku
            cursor.execute("SELECT MAX(DataModyfikacji) FROM [dbo].[p_T_ZZ_GrafikiPracy] WHERE Rok = ? AND Miesiac = ?", (year, month))
            schedule_max_date = cursor.fetchone()[0]

            # 2. Sprawdź najnowszą modyfikację w zdarzeniach
            cursor.execute("SELECT MAX(DataModyfikacji) FROM [dbo].[fn_GetEventsData](?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]

            conn.close()

            all_dates = [d for d in [schedule_max_date, events_max_date] if d is not None]
            if not all_dates:
                return

            latest_modification = max(all_dates)

            # Zapisz jako ostatnią modyfikację własną ORAZ jako ogólną ostatnią znaną modyfikację
            self.last_self_modification_date = latest_modification
            self.last_modification_date = latest_modification
            debug_print(f"Zarejestrowano własną modyfikację z datą: {self.last_self_modification_date}")

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji daty modyfikacji: {e}", exception=e)

    def filter_data(self):
        """
        Filtruje dane grafiku i aktualizuje widok.
        ZMIENIONA WERSJA z wzajemnym filtrowaniem.
        """
        # Sprawdź czy model istnieje
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # POPRAWKA: Sprawdź czy nie jesteśmy już w trakcie filtrowania
        if getattr(self, '_updating_filters', False):
            return
            
        self._updating_filters = True
        
        try:
            # NOWE: Najpierw aktualizuj cross-filtry
            self.update_cross_filters()

            # Pobierz przefiltrowane dane
            filtered_data = self.filter_processed_data()

            # Aktualizuj model z przefiltrowanymi danymi
            self.schedule_model.update_filtered_data(filtered_data)
            
        finally:
            self._updating_filters = False
            current_data = self.date_combo.currentData()
            if current_data and self.staffing_details_win and not self.staffing_details_win.isHidden():
                year, month = current_data
                self.staffing_details_win.update_for_new_month_or_filters(year, month)

    def update_cross_filters(self):
        """
        NOWA METODA: Aktualizuje filtry wzajemnie na podstawie aktualnych wyborów
        """
        # Sprawdź czy cross-filtering jest włączone
        if not getattr(self, '_cross_filtering_enabled', True):
            return
            
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return
        
        # KLUCZOWA POPRAWKA: Sprawdź czy już jesteśmy w trakcie aktualizacji
        if getattr(self, '_updating_cross_filters', False):
            return
            
        # Ustaw flagę blokującą
        self._updating_cross_filters = True

        try:
            # Pobierz aktualne wybory
            selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self, 'przelozony_list') else []
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list) if hasattr(self, 'uzytkownik_list') else []

            debug_print(f"Cross-filter: Wydziały={len(selected_wydzialy)}, Przełożeni={len(selected_przelozeni)}, Użytkownicy={len(selected_uzytkownicy)}")

            # === AKTUALIZACJA WYDZIAŁÓW na podstawie przełożonych/użytkowników ===
            if hasattr(self, 'wydzial_combo'):
                available_wydzialy = set()
                
                # Jeśli wybrano przełożonych, pokaż tylko ich wydziały
                if selected_przelozeni:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        if przelozony in selected_przelozeni and wydzial:
                            available_wydzialy.add(wydzial)
                
                # Jeśli wybrano użytkowników, pokaż tylko ich wydziały
                elif selected_uzytkownicy:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        if str(uzytkownik_dane) in selected_uzytkownicy and wydzial:
                            available_wydzialy.add(wydzial)
                
                # Jeśli nic nie wybrano, pokaż wszystkie wydziały
                else:
                    for key in self.processed_data.keys():
                        wydzial = key[0]
                        if wydzial:
                            available_wydzialy.add(wydzial)
                
                # Zachowaj wybrane wydziały które są dostępne
                valid_selected_wydzialy = [w for w in selected_wydzialy if w in available_wydzialy]
                
                # Aktualizuj combo wydziałów
                self.wydzial_combo.clear()
                self.wydzial_combo.add_items(sorted(available_wydzialy))
                self.wydzial_combo.select_items(valid_selected_wydzialy)

            # === AKTUALIZACJA PRZEŁOŻONYCH na podstawie wydziałów/użytkowników ===
            if hasattr(self, 'przelozony_list'):
                available_przelozeni = set()
                
                # Jeśli wybrano wydziały, pokaż tylko przełożonych z tych wydziałów
                if selected_wydzialy:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        if wydzial in selected_wydzialy and przelozony:
                            available_przelozeni.add(przelozony)
                
                # Jeśli wybrano użytkowników, pokaż tylko ich przełożonych
                elif selected_uzytkownicy:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        if str(uzytkownik_dane) in selected_uzytkownicy and przelozony:
                            available_przelozeni.add(przelozony)
                
                # Jeśli nic nie wybrano, pokaż wszystkich przełożonych
                else:
                    for key in self.processed_data.keys():
                        przelozony = key[1]
                        if przelozony:
                            available_przelozeni.add(przelozony)
                
                # Zachowaj wybranych przełożonych którzy są dostępni
                valid_selected_przelozeni = [p for p in selected_przelozeni if p in available_przelozeni]
                
                # Aktualizuj listę przełożonych BEZPIECZNIE
                self.update_list_safely(self.przelozony_list, available_przelozeni, valid_selected_przelozeni)

            # === AKTUALIZACJA UŻYTKOWNIKÓW na podstawie wydziałów/przełożonych ===
            if hasattr(self, 'uzytkownik_list'):
                available_uzytkownicy = set()
                
                # Jeśli wybrano wydziały i/lub przełożonych
                if selected_wydzialy or selected_przelozeni:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        
                        # Sprawdź czy pasuje do filtrów wydziału i przełożonego
                        wydzial_match = not selected_wydzialy or wydzial in selected_wydzialy
                        przelozony_match = not selected_przelozeni or przelozony in selected_przelozeni
                        
                        if wydzial_match and przelozony_match and uzytkownik_dane:
                            available_uzytkownicy.add(str(uzytkownik_dane))
                
                # Jeśli nic nie wybrano, pokaż wszystkich użytkowników
                else:
                    for key in self.processed_data.keys():
                        uzytkownik_dane = key[2]
                        if uzytkownik_dane:
                            available_uzytkownicy.add(str(uzytkownik_dane))
                
                # Zachowaj wybranych użytkowników którzy są dostępni
                valid_selected_uzytkownicy = [u for u in selected_uzytkownicy if u in available_uzytkownicy]
                
                # Aktualizuj listę użytkowników BEZPIECZNIE
                self.update_list_safely(self.uzytkownik_list, available_uzytkownicy, valid_selected_uzytkownicy)

            debug_print("Cross-filter zakończone")

        except Exception as e:
            log_error(f"Błąd podczas cross-filtrowania: {e}")
            import traceback
            traceback.print_exc()
        finally:
            # KLUCZOWA POPRAWKA: Zawsze odblokuj flagę
            self._updating_cross_filters = False

    def update_list_safely(self, list_widget, items, selected_items):
        """
        NOWA METODA: Bezpiecznie aktualizuje listę bez wywołania sygnałów
        """
        if not list_widget:
            return
            
        # Blokuj sygnały podczas aktualizacji
        list_widget.blockSignals(True)
        
        try:
            list_widget.clear()
            for item_text in sorted(items):
                item = QListWidgetItem(item_text)
                list_widget.addItem(item)
                if item_text in selected_items:
                    item.setSelected(True)
        finally:
            # Zawsze odblokuj sygnały
            list_widget.blockSignals(False)

    def clear_filters(self):
        """
        Czyści wszystkie filtry i aktualizuje model.
        ZMIENIONA WERSJA z pełnym resetem cross-filtrów.
        """
        # NOWE: Tymczasowo wyłącz cross-filtering podczas czyszczenia
        self._cross_filtering_enabled = False
        
        try:
            # Wyczyść filtry ComboBox z wielokrotnym wyborem
            for combo_name in ['wydzial_combo', 'dtn_combo', 'rola_combo', 'jezyk_combo', 'etat_combo']:
                if hasattr(self, combo_name):
                    combo = getattr(self, combo_name)
                    combo.clear_selection()

            # Wyczyść filtry list BEZPIECZNIE
            if hasattr(self, 'przelozony_list'):
                self.przelozony_list.blockSignals(True)
                self.przelozony_list.clearSelection()
                self.przelozony_list.blockSignals(False)

            if hasattr(self, 'uzytkownik_list'):
                self.uzytkownik_list.blockSignals(True)
                self.uzytkownik_list.clearSelection()
                self.uzytkownik_list.blockSignals(False)

            # Wyczyść pola filtrowania
            if hasattr(self, 'przelozony_filter'):
                self.przelozony_filter.clear()

            if hasattr(self, 'uzytkownik_filter'):
                self.uzytkownik_filter.clear()

            # Pokaż wszystkie elementy list
            if hasattr(self, 'przelozony_list'):
                for i in range(self.przelozony_list.count()):
                    self.przelozony_list.item(i).setHidden(False)

            if hasattr(self, 'uzytkownik_list'):
                for i in range(self.uzytkownik_list.count()):
                    self.uzytkownik_list.item(i).setHidden(False)

            # Resetuj zmienne śledzące filtry
            self._last_selected_wydzialy = []
            self._last_selected_przelozeni = []

            # NOWE: Włącz z powrotem cross-filtering
            self._cross_filtering_enabled = True

            # Flaga zabezpieczająca przed pętlą w cross-filtering
            self._updating_cross_filters = False
            # Flaga zabezpieczająca przed pętlą w filter_data
            self._updating_filters = False
            
            # Pełne odświeżenie filtrów po wyczyszczeniu
            self.update_filters()  # Przeładuj wszystkie dostępne opcje
            
            # Aktualizuj dane
            self.filter_data()
        
        finally:
            # Upewnij się że cross-filtering jest włączone
            self._cross_filtering_enabled = True

    def filter_przelozony_list(self, text):
        """
        Filtruje listę przełożonych na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'przelozony_list'):
            return

        text = text.lower()
        for i in range(self.przelozony_list.count()):
            item = self.przelozony_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_uzytkownik_list(self, text):
        """
        Filtruje listę użytkowników na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'uzytkownik_list'):
            return

        text = text.lower()
        for i in range(self.uzytkownik_list.count()):
            item = self.uzytkownik_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def update_filtered_table(self):
        """
        Aktualizuje widok tabeli na podstawie zaznaczonych filtrów
        """
        # Bezpośrednio aktualizuj całą tabelę z przefiltrowanymi danymi
        self.update_table_content()

    def get_list_selected_items(self, list_widget):
        """
        Zwraca teksty zaznaczonych elementów z listy.
        POPRAWKA: Zmieniono nazwę metody z get_selected_items na get_list_selected_items,
        aby uniknąć konfliktu z metodą get_selected_items w CustomMultiComboBox.

        Args:
            list_widget: QListWidget do pobrania zaznaczonych elementów

        Returns:
            list: Lista zaznaczonych tekstów
        """
        if not list_widget:
            return []

        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item and item.isSelected():
                selected.append(item.text())
        return selected

    def update_filters(self):
        """
        LEKKO ZMODYFIKOWANA: processed_data przychodzi gotowe
        """
        try:
            debug_print("Rozpoczynam aktualizację filtrów...")

            # Sprawdź czy mamy processed_data (już gotowe z DataProvider)
            if not hasattr(self, 'processed_data') or not self.processed_data:
                debug_print("Brak processed_data - pomijam aktualizację filtrów")
                return

            # Zapamiętaj bieżące zaznaczenia
            selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
            selected_dtn = self.dtn_combo.get_selected_items() if hasattr(self, 'dtn_combo') else []
            selected_role = self.rola_combo.get_selected_items() if hasattr(self, 'rola_combo') else []
            selected_jezyki = self.jezyk_combo.get_selected_items() if hasattr(self, 'jezyk_combo') else []
            selected_etaty = self.etat_combo.get_selected_items() if hasattr(self, 'etat_combo') else []
            selected_scp = self.system_czasu_pracy_combo.get_selected_items() if hasattr(self, 'system_czasu_pracy_combo') else []
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

            # ZMIANA: Korzystaj z gotowego processed_data zamiast budować je od nowa
            if hasattr(self, 'wydzial_combo'):
                wydzialy = set()
                for key in self.processed_data.keys():
                    wydzial = key[0]
                    if wydzial:
                        wydzialy.add(wydzial)
                self.wydzial_combo.add_items(sorted(wydzialy))
                self.wydzial_combo.select_items(selected_wydzialy)
                debug_print(f"Dodano {len(wydzialy)} wydziałów")

            # Reszta logiki bez zmian - wszystkie pozostałe filtry
            if hasattr(self, 'dtn_combo'):
                dtn_values = set()
                for _, data in self.processed_data.items():
                    dtn = str(data.get('dtn', ''))
                    if dtn:
                        dtn_values.add(dtn)
                self.dtn_combo.add_items(sorted(dtn_values))
                self.dtn_combo.select_items(selected_dtn)

            if hasattr(self, 'rola_combo'):
                role = set()
                for _, data in self.processed_data.items():
                    rola = data.get('rola_nazwa', '')
                    if rola:
                        role.add(rola)
                self.rola_combo.add_items(sorted(role))
                self.rola_combo.select_items(selected_role)

            if hasattr(self, 'jezyk_combo'):
                jezyki = set()
                for _, data in self.processed_data.items():
                    jezyk = data.get('jezyk', '')
                    if jezyk:
                        jezyki.add(jezyk)
                self.jezyk_combo.add_items(sorted(jezyki))
                self.jezyk_combo.select_items(selected_jezyki)

            if hasattr(self, 'etat_combo'):
                etaty = set()
                for _, data in self.processed_data.items():
                    etat = str(data.get('etat', '')) if data.get('etat') is not None else ''
                    if etat:
                        etaty.add(etat)
                sorted_etaty = sorted(etaty, key=lambda x: float(x) if x.replace('.', '', 1).isdigit() else 0)
                self.etat_combo.add_items(sorted_etaty)
                self.etat_combo.select_items(selected_etaty)

            if hasattr(self, 'system_czasu_pracy_combo'):
                scp_values = set()
                for _, data in self.processed_data.items():
                    scp = data.get('system_czasu_pracy', '')
                    if scp:
                        scp_values.add(scp)
                self.system_czasu_pracy_combo.add_items(sorted(scp_values))
                self.system_czasu_pracy_combo.select_items(selected_scp)  # selected_scp zdefiniujemy w kolejnym kroku

            # Aktualizacja przełożonych i użytkowników
            self.update_przelozony_filter(selected_przelozeni)
            self.update_uzytkownik_filter(selected_uzytkownicy)

            debug_print("Zakończono aktualizację filtrów")

        except Exception as e:
            import traceback
            log_error(f"Błąd podczas aktualizacji filtrów: {e}")
            traceback.print_exc()

    def update_przelozony_filter(self, selected_przelozeni=None):
        """
        Aktualizuje listę przełożonych na podstawie wybranych wydziałów.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_przelozeni: Lista zaznaczonych przełożonych (opcjonalnie)
        """
        if not hasattr(self, 'przelozony_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiętaj bieżącą selekcję jeśli nie podano
        if selected_przelozeni is None:
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)

        self.przelozony_list.clear()

        # Pobierz wybrane wydziały
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []

        # Zbiór unikalnych przełożonych
        przelozeni = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, _, _ = key

            # Jeśli nie wybrano wydziałów lub wydział pasuje do filtra
            if not selected_wydzialy or wydzial in selected_wydzialy:
                # Dodaj przełożonego do zbioru (tylko niepuste wartości)
                if przelozony:
                    przelozeni.add(przelozony)

        # Dodaj posortowanych przełożonych do listy
        for przelozony in sorted(przelozeni):
            item = QListWidgetItem(przelozony)
            self.przelozony_list.addItem(item)

            # Przywróć zaznaczenie jeśli było
            if przelozony in selected_przelozeni:
                item.setSelected(True)

    def update_uzytkownik_filter(self, selected_uzytkownicy=None):
        """
        Aktualizuje listę użytkowników na podstawie wybranych wydziałów i przełożonych.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_uzytkownicy: Lista zaznaczonych użytkowników (opcjonalnie)
        """
        if not hasattr(self, 'uzytkownik_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiętaj bieżącą selekcję jeśli nie podano
        if selected_uzytkownicy is None:
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

        self.uzytkownik_list.clear()

        # Pobierz wybrane wydziały i przełożonych
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self,
                                                                                            'przelozony_list') else []

        # Zbiór unikalnych użytkowników (użyj stringa jako tekstowej reprezentacji)
        uzytkownicy = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, uzytkownik_dane, _ = key

            # Sprawdź czy dane pasują do filtrów
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni):
                # Dodaj użytkownika do zbioru (tylko niepuste wartości)
                if uzytkownik_dane:
                    # Konwertuj do stringa dla spójności
                    uzytkownicy.add(str(uzytkownik_dane))

        # Dodaj posortowanych użytkowników do listy
        for uzytkownik in sorted(uzytkownicy):
            item = QListWidgetItem(uzytkownik)
            self.uzytkownik_list.addItem(item)

            # Przywróć zaznaczenie jeśli było
            if uzytkownik in selected_uzytkownicy:
                item.setSelected(True)

    def update_table_content(self):
        """
        Aktualizuje zawartość tabeli grafiku używając modelu danych.
        Zoptymalizowana wersja wykorzystująca precyzyjne aktualizacje.
        """
        # Sprawdź czy modele zostały zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # Ustaw rok i miesiąc w modelu (jeśli jeszcze nie są ustawione)
        if self.schedule_model._year != year or self.schedule_model._month != month:
            # Pobierz dane dla wybranego roku i miesiąca
            schedule_data = self.data_provider.get_schedule_data(year, month, self.import_grupa, self.import_funkcja)

            # Aktualizuj model - to wywoła zoptymalizowaną metodę update_data
            self.schedule_model.update_data(schedule_data, year, month)
            self._set_schedule_columns_width()
        else:
            # Jeśli rok i miesiąc nie uległy zmianie, tylko zastosuj filtry
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

    

    def get_cell_color_by_time(self, hour):
        """
        Zwraca kolor tła komórki na podstawie godziny rozpoczęcia.
        Godziny są mapowane na kolory w bardziej czytelnej palecie.

        Args:
            hour (int): Godzina rozpoczęcia zmiany (0-23)

        Returns:
            QColor: Kolor tła komórki
        """
        # Domyślny kolor (przezroczysty) gdy godzina nie jest zdefiniowana
        if hour is None or hour < 0 or hour > 23:
            return QColor(255, 255, 255, 0)  # Przezroczysty

        # Mapowanie godzin na kolory - zharmonizowana paleta
        if hour == 5:
            return QColor(204, 255, 255)  # Jasny błękit (bardzo jasny cyjan)
        elif hour == 6:
            return QColor(204, 255, 255)  # Jasny błękit (bardzo jasny cyjan)
        elif hour == 7:
            return QColor(0, 255, 255)  # Cyjan (akwamaryna)
        elif hour == 8:
            return QColor(0, 204, 255)  # Jasny błękit (niebieskozielony)
        elif hour == 9:
            return QColor(0, 255, 0)  # Limonkowy (czysty zielony)
        elif hour == 10:
            return QColor(153, 204, 0)  # Oliwkowy (żółtozielony)
        elif hour == 11:
            return QColor(204, 255, 204)  # Bardzo jasny zielony (miętowy)
        elif hour == 12:
            return QColor(255, 255, 153)  # Bardzo jasny żółty (kremowy)
        elif hour == 13:
            return QColor(255, 204, 153)  # Jasny łososiowy (brzoskwiniowy)
        elif hour == 14:
            return QColor(255, 153, 0)  # Ciemny pomarańczowy
        elif hour == 15:
            return QColor(255, 0, 255)  # Magenta (fuksja)
        elif hour == 16:
            return QColor(204, 0, 0)  # Ciemnoczerwony
        elif hour == 17:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 18:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 19:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 20:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 21:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 22:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 23:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 0:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour in [1, 2, 3, 4]:
            return QColor(51, 51, 51)  # Ciemny szary

        # Domyślny kolor dla innych wartości
        return QColor(255, 255, 255, 0)  # Przezroczysty

    def on_selection_changed(self):
        """
        POPRAWIONA WERSJA: Debounced selection handling
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # DODANE: Sprawdź czy nie jesteśmy w trakcie aktualizacji
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        # NOWE: Zastop poprzedni timer i uruchom nowy (debouncing)
        if hasattr(self, '_selection_timer'):
            self._selection_timer.stop()
            self._selection_timer.start(self._selection_debounce_delay)

    def _handle_selection_change(self):
        """
        NOWA METODA: Faktyczna obsługa zmiany zaznaczenia (wywoływana po debounce)
        """
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        self._updating_selection = True

        try:
            debug_print("Zmiana zaznaczenia - aktualizuję tabelę zdarzeń...")

            # Pobierz dane dla zaznaczonych komórek
            selected_cells_data = self.table.get_data_for_selected_cells()
            debug_print(f"Zaznaczono {len(selected_cells_data)} komórek")

            if selected_cells_data and len(selected_cells_data) > 0:
                # MAMY ZAZNACZONE KOMÓRKI - pokaż zdarzenia
                events = []

                for cell_data in selected_cells_data:
                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')

                    if user_id and date_str:
                        # Pobierz aktualne zdarzenia z DataProvider
                        user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                        # Filtruj tylko aktywne zdarzenia (status != '0')
                        active_events = []
                        for event in user_events:
                            status = str(event.get('status', '1'))  # Domyślnie aktywne
                            if status != '0':  # Tylko aktywne zdarzenia
                                # DODANE: Skonwertuj format na lokalny format UI
                                local_event = self._convert_dp_event_to_local(event)
                                active_events.append(local_event)

                        events.extend(active_events)

                debug_print(f"Pobrano {len(events)} aktywnych zdarzeń dla zaznaczonych komórek")

                # Zaktualizuj events_data
                self.events_data = events

                # Aktualizuj model zdarzeń
                if hasattr(self, 'events_model'):
                    self.events_model.update_data(self.events_data)

                    # WAŻNE: Zastosuj filtry po aktualizacji danych
                    self.filter_events_table()
            else:
                # BRAK ZAZNACZENIA - wyczyść tabelę zdarzeń
                debug_print("Brak zaznaczenia - czyszczę tabelę zdarzeń")
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])

            # DODANE: Wymuś odświeżenie widoku tabeli zdarzeń
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        finally:
            self._updating_selection = False

    def clear_events_on_startup(self):
        """
        NOWA METODA: Czyści tabelę zdarzeń przy starcie aplikacji
        """
        debug_print("Czyszczę tabelę zdarzeń przy starcie aplikacji")

        # Wyczyść dane zdarzeń
        self.events_data = []

        # Wyczyść model zdarzeń jeśli istnieje
        if hasattr(self, 'events_model') and self.events_model:
            self.events_model.update_data([])

        # Odśwież widok tabeli zdarzeń
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

    def _convert_dp_event_to_local(self, dp_event):
        """
        NOWA METODA: Konwertuje format zdarzenia z DataProvider na lokalny format UI
        """
        try:
            # Skonwertuj datę z YYYY-MM-DD na DD.MM.YYYY
            date_key = dp_event.get('date_key', dp_event.get('date', ''))
            if date_key and '-' in date_key:
                year, month, day = date_key.split('-')
                display_date = f"{day}.{month}.{year}"
            else:
                display_date = dp_event.get('date_display', date_key)

            # Skonwertuj czas z formatu bazy na HH:MM
            time_from = dp_event.get('time_from', '')
            time_to = dp_event.get('time_to', '')
            
            if time_from and 'T' in time_from:
                time_from = time_from.split('T')[1].split(':')[0] + ':' + time_from.split('T')[1].split(':')[1]
            elif time_from and ' ' in time_from:
                time_from = time_from.split(' ')[1][:5]
                
            if time_to and 'T' in time_to:
                time_to = time_to.split('T')[1].split(':')[0] + ':' + time_to.split('T')[1].split(':')[1]
            elif time_to and ' ' in time_to:
                time_to = time_to.split(' ')[1][:5]

            # Pobierz nazwę użytkownika
            user_name = dp_event.get('user_name', '')
            if not user_name:
                user_id = dp_event.get('user_id')
                if user_id and hasattr(self, 'user_info_map') and user_id in self.user_info_map:
                    user_name = self.user_info_map[user_id].get('uzytkownik_dane', f"ID: {user_id}")
                else:
                    user_name = f"ID: {user_id}"

            # Utwórz zdarzenie w lokalnym formacie
            local_event = {
                'type': dp_event.get('event_type', dp_event.get('type', '')),
                'topic': dp_event.get('topic', ''),
                'name': dp_event.get('name', ''),
                'user_id': dp_event.get('user_id'),
                'user_name': user_name,
                'date': display_date,
                'date_key': date_key,
                'time_from': time_from,
                'time_to': time_to,
                'status': dp_event.get('status', ''),
                'id': dp_event.get('event_id', dp_event.get('id'))
            }

            return local_event

        except Exception as e:
            log_error(f"Błąd konwersji zdarzenia: {e}")
            # Zwróć zdarzenie w oryginalnym formacie w przypadku błędu
            return dp_event
    
    def temporarily_disable_filters(self):
        """Tymczasowo wyłącza filtry zdarzeń aby zapewnić wyświetlenie wszystkich danych"""
        # Zapamiętaj obecny stan filtrów
        self._saved_filters = {
            'meetings': self.meetings_checkbox.isChecked() if hasattr(self, 'meetings_checkbox') else True,
            'trainings': self.trainings_checkbox.isChecked() if hasattr(self, 'trainings_checkbox') else True,
            'overtime': self.overtime_checkbox.isChecked() if hasattr(self, 'overtime_checkbox') else True,
            'topic': self.topic_filter.text() if hasattr(self, 'topic_filter') else "",
            'name': self.name_filter.text() if hasattr(self, 'name_filter') else "",
            'date_from': self.date_from.date() if hasattr(self, 'date_from') else None,
            'date_to': self.date_to.date() if hasattr(self, 'date_to') else None
        }

        # Ustaw wszystkie filtry na wartości, które pokazują wszystkie dane
        if hasattr(self, 'meetings_checkbox'):
            self.meetings_checkbox.setChecked(True)
        if hasattr(self, 'trainings_checkbox'):
            self.trainings_checkbox.setChecked(True)
        if hasattr(self, 'overtime_checkbox'):
            self.overtime_checkbox.setChecked(True)
        if hasattr(self, 'topic_filter'):
            self.topic_filter.setText("")
        if hasattr(self, 'name_filter'):
            self.name_filter.setText("")

        # Daty zostawiamy bez zmian, filtrowanie będzie nadpisane przez model

        debug_print("Tymczasowo wyłączono filtry zdarzeń")

    def restore_filters(self):
        """Przywraca filtry zdarzeń do ich poprzedniego stanu"""
        if not hasattr(self, '_saved_filters'):
            return

        # Przywróć filtry do ich poprzedniego stanu
        if hasattr(self, 'meetings_checkbox') and 'meetings' in self._saved_filters:
            self.meetings_checkbox.setChecked(self._saved_filters['meetings'])
        if hasattr(self, 'trainings_checkbox') and 'trainings' in self._saved_filters:
            self.trainings_checkbox.setChecked(self._saved_filters['trainings'])
        if hasattr(self, 'overtime_checkbox') and 'overtime' in self._saved_filters:
            self.overtime_checkbox.setChecked(self._saved_filters['overtime'])
        if hasattr(self, 'topic_filter') and 'topic' in self._saved_filters:
            self.topic_filter.setText(self._saved_filters['topic'])
        if hasattr(self, 'name_filter') and 'name' in self._saved_filters:
            self.name_filter.setText(self._saved_filters['name'])

        # Nie przywracamy dat, aby zapewnić spójność z zaznaczonymi komórkami

        debug_print("Przywrócono filtry zdarzeń")

        # Wymuś odświeżenie z nowymi filtrami
        self.filter_events_table()

    def filter_events_table(self):
        """
        Filtruje tabelę zdarzeń na podstawie zaznaczonych filtrów i zakresów dat.
        Zoptymalizowana wersja wykorzystująca model danych.
        """
        try:
            # Sprawdź czy model istnieje
            if not hasattr(self, 'events_model') or not self.events_model:
                return

            # KLUCZOWA ZMIANA: Najpierw sprawdź, czy w ogóle mamy dane do filtrowania
            if not hasattr(self, 'events_data') or not self.events_data:
                # Jeśli nie ma danych, po prostu wyczyść model
                self.events_model.update_data([])
                return

            # NAJWAŻNIEJSZE: Użyj lokalnych danych events_data zamiast wszystkich zdarzeń
            # To zapewni, że filtrujemy tylko zdarzenia dla zaznaczonych komórek
            base_data = self.events_data.copy()
            filtered_data = base_data.copy()

            # Przygotuj parametry filtrowania
            allowed_types = []
            if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
                allowed_types.append('Spotkanie')
            if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
                allowed_types.append('Szkolenie')
            if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
                allowed_types.append('Nadgodziny')

            # Filtruj po typach zdarzeń
            if allowed_types:
                filtered_data = [e for e in filtered_data if e.get('type') in allowed_types]

            # Filtruj po temacie
            topic_filter = self.topic_filter.text().lower() if hasattr(self, 'topic_filter') else ""
            if topic_filter:
                filtered_data = [e for e in filtered_data if topic_filter in str(e.get('topic', '')).lower()]

            # Filtruj po nazwie
            name_filter = self.name_filter.text().lower() if hasattr(self, 'name_filter') else ""
            if name_filter:
                filtered_data = [e for e in filtered_data if name_filter in str(e.get('name', '')).lower()]

            # Filtruj po datach (tylko jeśli nie są ustawione na zakres wybranego miesiąca)
            date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
            date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

            if date_from_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') >= date_from_str]
            if date_to_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') <= date_to_str]

            # Aktualizuj model po filtrowaniu
            debug_print(f"Filtrowanie lokalne: z {len(base_data)} zdarzeń po filtrach zostało {len(filtered_data)}")
            self.events_model.filtered_update(filtered_data)

        except Exception as e:
            log_error(f"Błąd podczas filtrowania zdarzeń: {str(e)}")
            import traceback
            traceback.print_exc()

    def diagnose_events_table(self):
        """Metoda diagnostyczna do sprawdzenia stanu tabeli zdarzeń"""
        debug_print("\n=== DIAGNOSTYKA TABELI ZDARZEŃ ===")

        if not hasattr(self, 'events_table') or not self.events_table:
            log_error("ERROR: Brak obiektu events_table!")
            return

        if not hasattr(self, 'events_model') or not self.events_model:
            log_error("ERROR: Brak obiektu events_model!")
            return

        # Sprawdź model
        debug_print(f"events_model ma {self.events_model.rowCount()} wierszy i {self.events_model.columnCount()} kolumn")
        debug_print(f"Dane w events_model: {len(self.events_model._data)} zdarzeń")
        debug_print(f"Przefiltrowane dane w events_model: {len(self.events_model._filtered_data)} zdarzeń")

        # Sprawdź filtry
        debug_print("\nAktualne filtry:")
        if hasattr(self, 'meetings_checkbox'):
            debug_print(f"Spotkania: {self.meetings_checkbox.isChecked()}")
        if hasattr(self, 'trainings_checkbox'):
            debug_print(f"Szkolenia: {self.trainings_checkbox.isChecked()}")
        if hasattr(self, 'overtime_checkbox'):
            debug_print(f"Nadgodziny: {self.overtime_checkbox.isChecked()}")
        if hasattr(self, 'topic_filter'):
            debug_print(f"Filtr tematu: '{self.topic_filter.text()}'")
        if hasattr(self, 'name_filter'):
            debug_print(f"Filtr nazwy: '{self.name_filter.text()}'")

        # Sprawdź przykładowe dane
        if self.events_model._data:
            debug_print("\nPrzykładowe zdarzenie z danych (przed filtrowaniem):")
            debug_print(self.events_model._data[0])

        if self.events_model._filtered_data:
            debug_print("\nPrzykładowe zdarzenie z danych po filtrowaniu:")
            debug_print(self.events_model._filtered_data[0])

        # Sprawdź widok
        debug_print(f"\nWidok events_table: {self.events_table.model().rowCount()} wierszy")

        debug_print("=== KONIEC DIAGNOSTYKI TABELI ZDARZEŃ ===\n")

    def standardize_date(self, date_obj):
        """
        Standaryzuje format daty do 'YYYY-MM-DD' dla porównań
        """
        if not date_obj:
            return ''

        # Jeśli to już string, wyciągnij tylko datę
        if isinstance(date_obj, str):
            # Obsługa różnych formatów
            if 'T' in date_obj:  # Format ISO 'YYYY-MM-DDThh:mm:ss'
                return date_obj.split('T')[0]
            elif ' ' in date_obj:  # Format 'YYYY-MM-DD hh:mm:ss'
                return date_obj.split(' ')[0]
            elif len(date_obj) == 10 and date_obj.count('-') == 2:  # Format 'YYYY-MM-DD'
                return date_obj
            # Jeśli nie dopasowano do żadnego formatu, zwróć oryginalny string
            return date_obj

        # Jeśli to obiekt datetime, skonwertuj na string
        if hasattr(date_obj, 'strftime'):
            return date_obj.strftime('%Y-%m-%d')

        # W przypadku nieznanego typu, zwróć pusty string
        return ''

    def diagnose_table_view(self):
        """Metoda diagnostyczna do sprawdzenia stanu SplitTableView"""
        if not hasattr(self, 'table') or not self.table:
            log_error("ERROR: Brak obiektu table!")
            return

        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            log_error("ERROR: Brak obiektu schedule_model!")
            return

        debug_print("\n=== DIAGNOSTYKA TABELI ===")

        # Sprawdź model
        debug_print(f"Model ma {self.schedule_model.rowCount()} wierszy i {self.schedule_model.columnCount()} kolumn")
        debug_print(f"Widoczne kolumny: {self.schedule_model.get_visible_columns()}")

        # Sprawdź widoki
        debug_print(
            f"Employees view ma {self.table.employees_view.model().rowCount()} wierszy i {self.table.employees_view.model().columnCount()} kolumn")
        debug_print(
            f"Schedule view ma {self.table.schedule_view.model().rowCount()} wierszy i {self.table.schedule_view.model().columnCount()} kolumn")

        # Sprawdź kolumny w employees_view
        for col in range(self.table.employees_view.model().columnCount()):
            hidden = self.table.employees_view.isColumnHidden(col)
            width = self.table.employees_view.columnWidth(col)
            debug_print(f"Kolumna {col} w employees_view: ukryta={hidden}, szerokość={width}px")

        # Sprawdź przykładowe dane w pierwszym wierszu
        if self.schedule_model.rowCount() > 0:
            debug_print("\nPrzykładowe dane z pierwszego wiersza:")
            for col in range(len(self.schedule_model.get_visible_columns())):
                index = self.schedule_model.index(0, col)
                text = self.schedule_model.data(index, Qt.DisplayRole)
                debug_print(f"Kolumna {col}: '{text}'")

        debug_print("=== KONIEC DIAGNOSTYKI ===\n")

    def diagnose_application_state(self):
        """Wykonuje pełną diagnostykę stanu aplikacji i wyświetla szczegółowe informacje"""
        try:
            debug_print("\n===== DIAGNOSTYKA STANU APLIKACJI =====")

            # 1. Sprawdź tabele i dane
            debug_print("\n--- TABELA GRAFIKU ---")
            debug_print(f"Liczba wierszy: {self.table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.table.columnCount()}")

            # Sprawdź pierwsze 3 wiersze i kolumny dla przykładu
            debug_print("\nPrzykładowe komórki z tabeli grafiku:")
            for row in range(min(3, self.table.rowCount())):
                for col in range(min(6, self.table.columnCount())):
                    item = self.table.item(row, col)
                    if item:
                        debug_print(f"[{row},{col}] Tekst: {item.text()}")
                        user_role_data = item.data(Qt.UserRole)
                        user_role_2 = item.data(Qt.UserRole + 2)
                        user_role_3 = item.data(Qt.UserRole + 3)
                        debug_print(
                            f"  UserRole: {type(user_role_data)}, UserRole+2: {user_role_2}, UserRole+3: {user_role_3}")
                        if isinstance(user_role_data, dict):
                            debug_print(f"  Zawartość: {user_role_data}")
                    else:
                        debug_print(f"[{row},{col}] Brak elementu")

            debug_print("\n--- TABELA ZDARZEŃ ---")
            debug_print(f"Liczba wierszy: {self.events_table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.events_table.columnCount()}")

            # Sprawdź zawartość events_data
            debug_print(
                f"\nLiczba zdarzeń w events_data: {len(self.events_data) if hasattr(self, 'events_data') else 'Brak'}")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print("Pierwsze zdarzenie:")
                for key, value in self.events_data[0].items():
                    debug_print(f"  {key}: {value}")

            # Sprawdź pierwsze 3 wiersze tabeli zdarzeń
            debug_print("\nPrzykładowe wiersze z tabeli zdarzeń:")
            for row in range(min(3, self.events_table.rowCount())):
                row_data = []
                for col in range(self.events_table.columnCount() - 1):  # Pomijamy ostatnią kolumnę z przyciskami
                    item = self.events_table.item(row, col)
                    if item:
                        row_data.append(f"{col}:{item.text()}")
                debug_print(f"Wiersz {row}: {', '.join(row_data)}")

            # 2. Sprawdź delegaty i style
            debug_print("\n--- DELEGATY I STYLE ---")
            item_delegate = self.table.itemDelegate()
            debug_print(f"Delegat tabeli grafiku: {item_delegate.__class__.__name__}")
            if isinstance(item_delegate, OvertimeItemDelegate):
                debug_print("  Delegat OvertimeItemDelegate poprawnie przypisany")
            else:
                debug_print("  UWAGA: Delegat OvertimeItemDelegate nie jest przypisany!")

            # 3. Sprawdź filtrowanie danych
            debug_print("\n--- FILTROWANIE DANYCH ---")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print(f"Liczba zdarzeń przed filtrowaniem: {len(self.events_data)}")
                # Sprawdź, czy metoda filter_events_table jest wywoływana
                debug_print("Spróbuj wykonać filter_events_table:")
                try:
                    self.filter_events_table()
                    debug_print("  Metoda filter_events_table wykonana bez błędów")
                except Exception as e:
                    debug_print(f"  BŁĄD podczas wykonywania filter_events_table: {e}")

            debug_print("\n===== KONIEC DIAGNOSTYKI =====\n")

        except Exception as e:
            debug_print(f"BŁĄD podczas diagnostyki: {e}")
            import traceback
            traceback.print_exc()

    def show_schedule_control_dialog(self):
        """Pokazuje odpowiednie okno dialogowe w zależności od roli użytkownika."""
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Proszę najpierw wybrać miesiąc.")
            return

        year, month = current_data

        # Importuj klasy dialogowe
        from schedule_control_dialog import ScheduleControlDialog, SuggestionsOutDialog

        # Sprawdź rolę i otwórz odpowiednie okno
        if self.current_user_role == "Pracownik WPR":
            dialog = ScheduleControlDialog(self, year, month)
            dialog.data_refresh_needed.connect(self.refresh_data)
            dialog.exec()
        elif self.current_user_role == "Lider OUT":
            dialog = SuggestionsOutDialog(self, year, month)
            dialog.data_refresh_needed.connect(self.refresh_data)
            dialog.exec()
        else:
            QMessageBox.information(self, "Brak uprawnień", "Twoja rola nie ma dostępu do tej funkcji.")

    def _get_current_event_filter_params(self):
        """
        Pobiera bieżące parametry filtrowania zdarzeń.

        Returns:
            dict: Parametry filtrowania
        """
        filter_params = {}

        # Dodaj filtr typów zdarzeń
        allowed_types = []
        if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
            allowed_types.append('Spotkanie')
        if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
            allowed_types.append('Szkolenie')
        if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
            allowed_types.append('Nadgodziny')

        if allowed_types:
            filter_params['allowed_types'] = allowed_types

        # Dodaj filtry tematu i nazwy
        topic_filter = self.topic_filter.text().lower() if hasattr(self,
                                                                   'topic_filter') and self.topic_filter.text() else None
        name_filter = self.name_filter.text().lower() if hasattr(self,
                                                                 'name_filter') and self.name_filter.text() else None

        if topic_filter:
            filter_params['topic'] = topic_filter
        if name_filter:
            filter_params['name'] = name_filter

        # Dodaj filtry zakresu dat
        date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
        date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

        if date_from_str:
            filter_params['date_from'] = date_from_str
        if date_to_str:
            filter_params['date_to'] = date_to_str

        return filter_params

    def find_cell_position(self, user_id, date_str):
        """
        Znajduje pozycję komórki dla podanego użytkownika i daty, korzystając z modelu.

        Args:
            user_id: ID użytkownika
            date_str: Data w formacie YYYY-MM-DD

        Returns:
            tuple: (wiersz, dzień) lub (-1, -1) jeśli nie znaleziono
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return -1, -1

        # Pobierz dzień z daty
        try:
            year, month, day_str = date_str.split('-')
            day = int(day_str)
        except:
            return -1, -1

        # Pobierz liczbę wierszy w modelu
        row_count = self.schedule_model.rowCount()

        # Dla każdego wiersza sprawdź, czy odpowiada szukanemu użytkownikowi
        for row in range(row_count):
            # Pobierz ID użytkownika z pierwszej kolumny
            index = self.schedule_model.index(row, 0)
            user_data = self.schedule_model.data(index, Qt.UserRole)

            if isinstance(user_data, dict) and str(user_data.get('uzytkownik_id', '')) == str(user_id):
                return row, day

        return -1, -1

    def _get_cell_data_for_user_date_pairs(self, user_date_pairs: list) -> list:
        """
        Na podstawie listy par (user_id, date_str) odnajduje i zwraca
        pełne dane komórek z modelu grafiku.
        """
        if not self.schedule_model or not user_date_pairs:
            return []

        cells_data_to_return = []
        # Stwórz mapę dla szybszego wyszukiwania wierszy
        user_row_map = {str(key[3]): idx for idx, key in enumerate(self.schedule_model._keys)}

        for user_id, date_str in user_date_pairs:
            row = user_row_map.get(str(user_id))
            if row is not None:
                try:
                    # Oblicz indeks kolumny na podstawie daty
                    day = int(date_str.split('-')[2])
                    col_offset = len(self.schedule_model.get_visible_columns())
                    col = col_offset + day - 1

                    # Pobierz pełne dane komórki z modelu
                    index = self.schedule_model.index(row, col)
                    cell_data = self.schedule_model.data(index, self.schedule_model.ROLE_DATA)
                    if isinstance(cell_data, dict):
                        cells_data_to_return.append(cell_data)
                except (ValueError, IndexError) as e:
                    log_warning(f"Nie udało się znaleźć danych dla komórki ({user_id}, {date_str}): {e}")

        return cells_data_to_return

    def cancel_delegations(self):
        """
        POPRAWIONA WERSJA: Odwołuje delegacje z pełnym odświeżaniem ikon i tabeli zdarzeń
        """
        debug_print("\n=== ROZPOCZYNAM OPERACJĘ ODWOŁYWANIA DELEGACJI ===")

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Brak danych",
                "Nie wybrano miesiąca lub brak dostępnych danych do wyświetlenia.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone komórki
        selected_cells_data = self.get_selected_cells_data()

        if not self._can_modify_cells(selected_cells_data):
            return  # Zatrzymaj operację, jeśli użytkownik nie ma uprawnień

        if not selected_cells_data:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono żadnych komórek. Zaznacz komórki, dla których chcesz odwołać delegacje.",
                QMessageBox.Ok
            )
            return

        # Zbierz pary (user_id, date_str) z zaznaczonych komórek
        user_date_pairs = []
        for cell_data in selected_cells_data:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if user_id and date_str:
                user_date_pairs.append((user_id, date_str))

        if not user_date_pairs:
            QMessageBox.information(
                self,
                "Brak danych",
                "Nie znaleziono danych dla zaznaczonych komórek.",
                QMessageBox.Ok
            )
            return

        debug_print(f"Sprawdzam delegacje dla {len(user_date_pairs)} par (użytkownik, data)")

        # Znajdź delegacje do odwołania
        events_to_cancel = []
        grouped_events = {}

        for user_id, date_str in user_date_pairs:
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)
            
            for event in user_events:
                event_type = event.get('type', '')
                event_id = event.get('id')
                event_status = event.get('status')

                if not event_type or event_id is None:
                    continue

                if event_status is not None:
                    event_status = str(event_status)

                if event_type in ['Spotkanie', 'Szkolenie', 'Nadgodziny'] and event_status != '0':
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),
                    })

                    key = (user_id, date_str)
                    if key not in grouped_events:
                        grouped_events[key] = []
                    grouped_events[key].append(event)

        debug_print(f"Znaleziono {len(events_to_cancel)} delegacji do odwołania")

        if not events_to_cancel:
            QMessageBox.information(
                self,
                "Brak delegacji",
                "Nie znaleziono delegacji do odwołania dla zaznaczonych komórek.",
                QMessageBox.Ok
            )
            return

        # Pokaż potwierdzenie
        delegations_info = self._prepare_delegations_description(grouped_events)
        confirm_message = f"Czy na pewno chcesz odwołać następujące delegacje?\n\n{delegations_info}\n"
        confirm_message += f"Łącznie: {len(events_to_cancel)} delegacji dla {len(user_date_pairs)} komórek"

        reply = QMessageBox.question(
            self,
            "Potwierdzenie odwołania delegacji",
            confirm_message,
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply != QMessageBox.Yes:
            debug_print("=== OPERACJA ANULOWANA PRZEZ UŻYTKOWNIKA ===")
            return

        try:
            # Odwołaj delegacje w bazie danych
            canceled_count = self._cancel_delegations(events_to_cancel)

            if canceled_count > 0:
                # KLUCZOWA ZMIANA 1: Usuń zdarzenia z lokalnych danych
                affected_pairs = []
                for event in events_to_cancel:
                    user_id = event.get('user_id')
                    date_str = event.get('date_key', event.get('date'))
                    if user_id and date_str:
                        affected_pairs.append((user_id, date_str))
                        
                    # Usuń z events_data (tabela zdarzeń)
                    if hasattr(self, 'events_data'):
                        self.events_data = [e for e in self.events_data 
                                        if not (e.get('id') == event.get('id') and 
                                                e.get('type') == event.get('type'))]
                    
                    # Usuń z all_events_data
                    if hasattr(self, 'all_events_data'):
                        self.all_events_data = [e for e in self.all_events_data 
                                            if not (e.get('id') == event.get('id') and 
                                                    e.get('type') == event.get('type'))]

                # KLUCZOWA ZMIANA 2: Odśwież model zdarzeń
                if hasattr(self, 'events_model') and hasattr(self, 'events_data'):
                    self.events_model.update_data(self.events_data)
                    debug_print(f"Zaktualizowano model zdarzeń - pozostało {len(self.events_data)} zdarzeń")

                # KLUCZOWA ZMIANA 3: Wyczyść cache i odśwież ikony
                affected_pairs = list(set(affected_pairs))  # Usuń duplikaty
                
                # Wyczyść cache zdarzeń w DataProvider
                self.data_provider.invalidate_icons_cache(year, month)
                
                # Odśwież konkretne ikony
                self.data_provider.invalidate_specific_icons(affected_pairs)
                debug_print(f"Odświeżono ikony dla {len(affected_pairs)} zmienionych komórek")

                # KLUCZOWA ZMIANA 4: Odśwież model grafiku dla zmienionych komórek
                if hasattr(self, 'schedule_model'):
                    for user_id, date_str in affected_pairs:
                        # Aktualizuj wskaźniki zdarzeń w modelu
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', False)
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', False)
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', False)

                # KLUCZOWA ZMIANA 5: Wymuś odświeżenie widoków
                if hasattr(self, 'table'):
                    if hasattr(self.table, 'schedule_view'):
                        self.table.schedule_view.viewport().update()
                    if hasattr(self.table, 'employees_view'):
                        self.table.employees_view.viewport().update()

                if hasattr(self, 'events_table'):
                    self.events_table.viewport().update()

                # KLUCZOWA ZMIANA 6: Kompleksowe odświeżenie po odwołaniu delegacji
                # 1. Kompletne czyszczenie cache
                if hasattr(self.data_provider, 'invalidate_complete_cache_for_pairs'):
                    self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)

                # 2. Aktualizuj ikony w modelu grafiku
                if hasattr(self, 'schedule_model'):
                    for user_id, date_str in affected_pairs:
                        # Sprawdź pozostałe zdarzenia w lokalnych danych
                        remaining_events = [e for e in self.events_data 
                                        if e.get('user_id') == user_id and e.get('date_key') == date_str]
                        
                        # Oblicz ikony na podstawie pozostałych zdarzeń  
                        has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                        has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                        has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)
                        
                        # Aktualizuj ikony w modelu
                        self.schedule_model.update_cell_icons_directly(
                            user_id, date_str, has_meetings, has_trainings, has_overtime
                        )

                # 3. Odśwież tabelę zdarzeń dla zaznaczonych komórek
                selected_cells = self.table.get_data_for_selected_cells()
                if selected_cells:
                    self.on_selection_changed()
                else:
                    self.events_data = []
                    if hasattr(self, 'events_model'):
                        self.events_model.update_data([])

                QMessageBox.information(
                    self,
                    "Sukces",
                    f"Pomyślnie odwołano {canceled_count} delegacji z {len(events_to_cancel)} znalezionych.",
                    QMessageBox.Ok
                )

                debug_print(f"=== ZAKOŃCZONO POMYŚLNIE - ODWOŁANO {canceled_count} DELEGACJI ===")
            else:
                QMessageBox.warning(
                    self,
                    "Brak zmian",
                    "Nie udało się odwołać żadnej delegacji. Sprawdź logi aplikacji.",
                    QMessageBox.Ok
                )

        except Exception as e:
            log_error(f"Błąd podczas odwoływania delegacji: {e}")
            QMessageBox.critical(
                self,
                "Błąd",
                f"Wystąpił błąd podczas odwoływania delegacji: {str(e)}",
                QMessageBox.Ok
            )

    def get_data_from_model(self, row, col):
        """
        Pobiera dane z komórki modelu na podstawie wierszy i kolumn.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny

        Returns:
            dict: Dane komórki lub pusty słownik
        """
        if not hasattr(self, 'schedule_model'):
            return {}

        # Pobierz dane z modelu
        index = self.schedule_model.index(row, col)
        cell_data = self.schedule_model.data(index, Qt.UserRole)

        # Upewnij się, że dane są słownikiem
        if not isinstance(cell_data, dict):
            return {}

        return cell_data

    def get_selected_cells_data(self):
        """
        Pobiera dane dla zaznaczonych komórek z modelu.

        Returns:
            list: Lista danych zaznaczonych komórek
        """
        if not hasattr(self, 'table') or not self.table:
            return []

        # Deleguj do metody w SplitTableView, która już obsługuje model
        return self.table.get_data_for_selected_cells()

    def update_model_after_data_change(self, user_id, date_str):
        """
        Aktualizuje dane w modelu po zmianach w bazie danych.

        Args:
            user_id: ID użytkownika
            date_str: Data w formacie YYYY-MM-DD
        """
        if not user_id or not date_str:
            return

        # Pobierz rok i miesiąc z daty
        if date_str.count('-') != 2:
            return

        year, month, _ = date_str.split('-')
        try:
            year = int(year)
            month = int(month)
        except ValueError:
            return

        # Pobierz aktualne dane z DataProvider - wymuś odświeżenie cache
        self.data_provider.clear_cache()
        schedule_data = self.data_provider.get_schedule_data(year, month, use_cache=False)

        # Aktualizuj model
        if schedule_data and hasattr(self, 'schedule_model'):
            # Aktualizuj model bezpośrednio
            self.schedule_model.update_data(schedule_data, year, month)

            # Zaktualizuj przefiltrowane dane
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

            # Odśwież widok
            if hasattr(self, 'table'):
                self.table.update()

    def setup_model_connections(self):
        """
        Łączy sygnały modeli z obsługą interfejsu użytkownika.
        """
        # Połącz zmiany w modelach z aktualizacją interfejsu
        if hasattr(self, 'schedule_model'):
            self.schedule_model.dataChanged.connect(self.on_schedule_data_changed)

        if hasattr(self, 'events_model'):
            self.events_model.dataChanged.connect(self.on_events_data_changed)

    def on_schedule_data_changed(self, topLeft, bottomRight):
        """
        Obsługuje zmianę danych w modelu grafiku.

        Args:
            topLeft: Indeks górnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Odśwież widok
        if hasattr(self, 'table'):
            self.table.update()

        # Jeśli zmieniło się zaznaczenie, zaktualizuj tabelę zdarzeń
        if self.table.selection_changed.receivers() > 0:
            selected_rows = self.table.get_selected_rows()
            if selected_rows:
                self.on_selection_changed()

    def on_events_data_changed(self, topLeft, bottomRight):
        """
        Obsługuje zmianę danych w modelu zdarzeń.

        Args:
            topLeft: Indeks górnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Odśwież tabelę zdarzeń
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

  
    def show_insert_change_dialog(self):
        """Pokazuje okno dialogowe do wstawiania zmian w grafiku"""
        # Pobierz aktualną datę z tabeli grafiku
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Błąd",
                "Nie wybrano miesiąca. Nie można dodać zmiany grafiku.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # ZMIANA: Użyj metody get_data_for_selected_cells z SplitTableView
        selected_cells = self.table.get_data_for_selected_cells()

        if not self._can_modify_cells(selected_cells):
            return

        if not selected_cells:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono żadnych komórek do edycji.",
                QMessageBox.Ok
            )
            return

        # Grupuj komórki według użytkownika i dnia dla łatwiejszej edycji
        grouped_cells = self.group_cells_by_user_and_day(selected_cells)

        # Utwórz dialog
        dialog = ScheduleChangeDialog(self, grouped_cells, year, month)
        dialog.exec()

    def get_selected_schedule_cells(self):
        """Zwraca listę zaznaczonych komórek z siatki grafiku"""
        selected_cells = []
        selected_ranges = self.table.selectedRanges()

        for range_item in selected_ranges:
            for row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawdź czy to komórka z grafikiem
                    if col >= 3:
                        # Pobierz element tabeli
                        cell_item = self.table.item(row, col)
                        if not cell_item:
                            continue

                        # Pobierz dane z komórki
                        cell_data = self.get_cell_data(cell_item)
                        if not cell_data:
                            continue

                        # Dodaj dane do listy wybranych komórek
                        selected_cells.append(cell_data)

        return selected_cells

    def group_cells_by_user_and_day(self, cells):
        """Grupuje komórki według użytkownika i dnia dla łatwiejszej edycji"""
        grouped = {}
        for cell in cells:
            # ZMIANA: Dostosuj do nowej struktury danych z modelu
            user_id = cell.get('uzytkownik_id')  # Zmieniono z 'user_id'
            date_str = cell.get('date_str')      # Zmieniono z 'date'

            if not user_id or not date_str:
                continue

            if user_id not in grouped:
                grouped[user_id] = {}

            if date_str not in grouped[user_id]:
                grouped[user_id][date_str] = []

            grouped[user_id][date_str].append(cell)

        return grouped

    def delete_event(self, event_id, event_type):
        """Wersja z weryfikacją uprawnień przed usunięciem."""
        # Krok 1: Znajdź komórki, których dotyczy zmiana
        affected_pairs = []
        event_to_delete = None
        # Przeszukujemy dane zdarzeń (te aktualnie wyświetlane w tabeli)
        for event in (self.events_data or []):
            if event.get('id') == event_id and event.get('type') == event_type:
                user_id = event.get('user_id')
                date_key = event.get('date_key')
                if user_id and date_key:
                    affected_pairs.append((user_id, date_key))
                    event_to_delete = event
                    break  # Zakładamy unikalne ID, więc możemy przerwać

        if not event_to_delete:
            QMessageBox.warning(self, "Błąd", "Nie można odnaleźć zdarzenia do usunięcia.")
            return

        # Krok 2: Pobierz pełne dane komórek i przeprowadź walidację uprawnień
        cells_to_check = self._get_cell_data_for_user_date_pairs(affected_pairs)
        if not self._can_modify_cells(cells_to_check):
            return  # Zatrzymaj, jeśli brak uprawnień

        # Krok 3: Poproś o potwierdzenie (jeśli walidacja przeszła pomyślnie)
        reply = QMessageBox.question(
            self, "Potwierdzenie",
            f"Czy na pewno chcesz usunąć {event_type.lower()} o ID {event_id}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.Yes
        )

        if reply != QMessageBox.StandardButton.Yes:
            return

        # Krok 4: Wykonaj operację usunięcia (istniejąca logika)
        try:
            _, user_app_id, _, _, _ = get_modifier_id()
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            table_name = ""
            if event_type == "Spotkanie":
                table_name = "p_t_zz_Spotkania"
            elif event_type == "Szkolenie":
                table_name = "p_t_zz_Szkolenia"
            elif event_type == "Nadgodziny":
                table_name = "p_t_zz_Nadgodziny"
            else:
                return

            if event_type in ["Spotkanie", "Szkolenie"]:
                query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                cursor.execute(query, (user_app_id, event_id))
            else:
                query = f"DELETE FROM {table_name} WHERE Id = ?"
                cursor.execute(query, (event_id,))

            conn.commit()
            conn.close()
            self._update_modification_date()

            self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)

            if hasattr(self, 'schedule_model'):
                for user_id, date_str in affected_pairs:
                    remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                    has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                    has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                    has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)
                    self.schedule_model.update_cell_icons_directly(
                        user_id, date_str, has_meetings, has_trainings, has_overtime
                    )

            self.on_selection_changed()

            QMessageBox.information(self, "Sukces", f"{event_type} o ID {event_id} zostało pomyślnie usunięte.",
                                    QMessageBox.StandardButton.Ok)

        except Exception as e:
            log_error(f"Błąd podczas usuwania zdarzenia: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas usuwania zdarzenia: {str(e)}",
                                 QMessageBox.StandardButton.Ok)

    def show_add_overtime_dialog(self):
        """
        Pokazuje okno dialogowe do dodawania nadgodzin.
        POPRAWIONA WERSJA - bez duplikacji zdarzeń i z prawidłowym ustawianiem ikon.
        """
        # Pobierz bieżącą datę z tabeli grafiku
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Błąd",
                "Nie wybrano miesiąca. Nie można dodać nadgodzin.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone komórki z modelu
        selected_cells_data = self.table.get_data_for_selected_cells()

        if not self._can_modify_cells(selected_cells_data):
            return

        # Sprawdź liczbę zaznaczonych komórek
        if not selected_cells_data:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono żadnej komórki. Zaznacz dokładnie jedną komórkę, aby dodać nadgodziny.",
                QMessageBox.Ok
            )
            return

        # Jeśli zaznaczono więcej niż jedną komórkę, wyświetl komunikat i zakończ
        if len(selected_cells_data) > 1:
            QMessageBox.warning(
                self,
                "Zbyt wiele zaznaczonych komórek",
                "Zaznaczono zbyt wiele komórek. Zaznacz dokładnie jedną komórkę, aby dodać nadgodziny.",
                QMessageBox.Ok
            )
            return

        # Pobierz dane pierwszej (i jedynej) zaznaczonej komórki
        cell_data = selected_cells_data[0]

        # Pobierz podstawowe informacje o komórce
        selected_user_id = cell_data.get('uzytkownik_id')
        selected_user_name = cell_data.get('uzytkownik_dane')
        day = cell_data.get('day')
        date_str = cell_data.get('date_str')
        nr_kadrowy = cell_data.get('nr_kadrowy')
        start_hour = cell_data.get('start_hour')
        current_symbol = cell_data.get('symbol', '')
        
        # NOWE: Pobierz lokalizację domyślną z danych użytkownika
        lokalizacja_domyslna = cell_data.get('lokalizacja_domyslna', 'h')

        if not selected_user_id or not day or not date_str:
            QMessageBox.warning(
                self,
                "Błąd",
                "Brak wymaganych danych w zaznaczonej komórce.",
                QMessageBox.Ok
            )
            return

        # Utwórz datę QDate
        selected_date = QDate.fromString(date_str, "yyyy-MM-dd")

        # Flaga określająca, czy to dzień wolny (brak danych lub pusty symbol)
        is_day_off = not current_symbol or current_symbol.strip() == ''

        # Jeśli nr_kadrowy jest None, spróbuj znaleźć go w danych użytkownika
        if nr_kadrowy is None and selected_user_id in self.user_info_map:
            nr_kadrowy = self.user_info_map[selected_user_id].get('nr_kadrowy')

        # Ustaw domyślną godzinę rozpoczęcia
        if start_hour is None:
            start_hour = 9 if is_day_off else 8

        # POPRAWIONE: Pobierz lokalizację z symbolu lub użyj domyślnej
        current_location = lokalizacja_domyslna  # Domyślna z danych użytkownika
        
        if current_symbol and ';' in current_symbol:
            from symbol_parser import parse_symbol
            parsed_symbol = parse_symbol(current_symbol)
            if parsed_symbol['location']:
                current_location = parsed_symbol['location']

        # Utwórz okno dialogowe
        dialog = QDialog(self)

        # Nazwy miesięcy po polsku
        polish_months = [
            "stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca",
            "lipca", "sierpnia", "września", "października", "listopada", "grudnia"
        ]

        month_name = polish_months[selected_date.month() - 1]
        dialog.setWindowTitle(f"Dodaj nadgodziny w dniu {selected_date.day()} {month_name} {selected_date.year()}")
        dialog.setMinimumWidth(300)

        layout = QVBoxLayout(dialog)

        # Informacja o pracowniku
        user_info_label = QLabel(f"Pracownik: {selected_user_name}")
        user_info_label.setStyleSheet("font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(user_info_label)

        # Informacja o numerze kadrowym
        if nr_kadrowy:
            kadrowy_info_label = QLabel(f"Numer kadrowy: {nr_kadrowy}")
            kadrowy_info_label.setStyleSheet("margin-bottom: 10px;")
            layout.addWidget(kadrowy_info_label)

        # Informacja o miesiącu rozliczenia
        settlement_month = month
        settlement_year = year
        settlement_info = QLabel(f"Miesiąc rozliczenia: {settlement_month:02d}.{settlement_year}")
        settlement_info.setStyleSheet("margin-bottom: 10px;")
        layout.addWidget(settlement_info)

        # Informacja o dniu wolnym (jeśli to dzień wolny)
        if is_day_off:
            day_off_info = QLabel("Zaznaczony dzień jest dniem wolnym pracownika.")
            day_off_info.setStyleSheet("color: blue; font-weight: bold; margin-bottom: 10px;")
            layout.addWidget(day_off_info)

        # Formularz wprowadzania
        form_frame = QFrame()
        form_frame.setFrameShape(QFrame.StyledPanel)
        form_frame.setFrameShadow(QFrame.Raised)
        form_layout = QGridLayout(form_frame)

        # Etykiety
        od_label = QLabel("od kiedy")
        ile_label = QLabel("ile godzin")
        typ_label = QLabel("typ")
        ld_label = QLabel("LD")
        zalegle_label = QLabel("czy zaległe")

        # Kontrolki wprowadzania
        time_combo = QComboBox()
        time_combo.setMinimumWidth(60)

        # Ustal domyślny czas
        if is_day_off:
            default_time = "09:00"  # Dla dnia wolnego
        else:
            # Oblicz koniec zmiany (godzina rozpoczęcia + 8 godzin)
            end_hour = (start_hour + 8) % 24
            default_time = f"{end_hour:02d}:00"

        # Dodaj opcje czasu
        for hour in range(0, 24):
            for minute in [0, 30]:
                time_combo.addItem(f"{hour:02d}:{minute:02d}", f"{hour:02d}:{minute:02d}")

        # Ustaw domyślny czas
        index = time_combo.findText(default_time)
        if index != -1:
            time_combo.setCurrentIndex(index)
        else:
            time_combo.setCurrentText(default_time)

        # Combo z liczbą godzin do 13.0
        hours_combo = QComboBox()
        hours_combo.setMinimumWidth(50)
        for hours in [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5,
                    10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0]:
            hours_combo.addItem(f"{hours:.1f}", hours)
        hours_combo.setCurrentIndex(1)  # Domyślnie 1.0

        # Typ: wypłata, odbiór, odpracowanie
        type_combo = QComboBox()
        type_combo.addItem("wypłata", "wypłata")
        type_combo.addItem("odbiór", "odbiór")
        type_combo.addItem("odpracowanie", "odpracowanie")

        # LD (lokalizacja): h, p, s
        ld_combo = QComboBox()
        ld_combo.addItem("h", "h")  # Hybrydowa
        ld_combo.addItem("p", "p")  # Praca zdalna
        ld_combo.addItem("s", "s")  # Stacjonarna

        # POPRAWIONE: Ustaw domyślną lokalizację na podstawie symbolu lub domyślnej użytkownika
        if current_location == 'h':
            ld_combo.setCurrentIndex(0)
        elif current_location == 'p':
            ld_combo.setCurrentIndex(1)
        elif current_location == 's':
            ld_combo.setCurrentIndex(2)
        else:
            ld_combo.setCurrentIndex(0)  # Domyślnie 'h'

        # Czy zaległe
        overdue_combo = QComboBox()
        overdue_combo.addItem("nie", 0)
        overdue_combo.addItem("tak", 1)

        # Przycisk dodawania
        add_button = QPushButton("Dodaj")
        add_button.setStyleSheet("background-color: #333; color: white; font-weight: bold;")

        # Dodaj kontrolki do layoutu
        form_layout.addWidget(od_label, 0, 0)
        form_layout.addWidget(time_combo, 0, 1)
        form_layout.addWidget(ile_label, 0, 2)
        form_layout.addWidget(hours_combo, 0, 3)
        form_layout.addWidget(typ_label, 0, 4)
        form_layout.addWidget(type_combo, 0, 5)
        form_layout.addWidget(ld_label, 0, 6)
        form_layout.addWidget(ld_combo, 0, 7)
        form_layout.addWidget(zalegle_label, 0, 8)
        form_layout.addWidget(overdue_combo, 0, 9)
        form_layout.addWidget(add_button, 0, 10)

        # Dodaj formularz do głównego layoutu
        layout.addWidget(form_frame)

        # POPRAWIONA funkcja dodawania nadgodzin - BEZ _update_after_adding_overtime
        def add_overtime():
            try:
                # Pobierz dane z formularza
                start_time = time_combo.currentText()
                hours = float(hours_combo.currentData())
                overtime_type = type_combo.currentData()
                location = ld_combo.currentData()
                is_overdue = overdue_combo.currentData()

                # Data rozliczenia to pierwszy dzień bieżącego miesiąca
                settlement_date_str = f"{settlement_year}-{settlement_month:02d}-01"

                # UPROSZCZONE WYWOŁANIE - bez user_name
                result = self.call_add_overtime_procedure_fixed(
                    selected_user_id,
                    selected_date.year(),
                    selected_date.month(),
                    selected_date.toString("yyyy-MM-dd"),
                    start_time,
                    hours,
                    settlement_date_str,
                    is_overdue,
                    overtime_type,
                    location,
                    nr_kadrowy
                )

                if result["success"]:
                    QMessageBox.information(dialog, "Sukces", result["message"], QMessageBox.Ok)
                    dialog.accept()
                else:
                    QMessageBox.warning(dialog, "Błąd", result["message"], QMessageBox.Ok)

            except Exception as e:
                QMessageBox.critical(dialog, "Błąd", f"Wystąpił błąd: {str(e)}", QMessageBox.Ok)

        # Podłącz funkcję do przycisku
        add_button.clicked.connect(add_overtime)

        # Pokaż dialog
        dialog.exec()

   
        
    def _update_overtime_icon_single(self, user_id, date_str, year, month):
        """
        NOWA METODA: Aktualizuje ikonę nadgodzin bez wpływania na cache innych danych.
        """
        try:
            # 1. Aktualizuj bezpośrednio w modelu grafiku
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonę nadgodzin w modelu dla ({user_id}, {date_str})")

            # 2. Wyczyść tylko cache ikon dla tej konkretnej komórki w DataProvider
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla komórki ({user_id}, {date_str})")

            # 3. Odśwież widok grafiku
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji ikony nadgodzin: {e}")

    

    def connect_model_signals(self):
        """Podłącz sygnały modelu - DODAJ TO DO METODY setup_ui lub __init__"""
        if hasattr(self, 'data_provider'):
            self.data_provider.data_changed.connect(self.on_data_changed)
            
            # NOWE: Podłącz sygnał odświeżania konkretnych ikon
            if hasattr(self.data_provider, 'data_changed'):
                self.data_provider.data_changed.connect(self._handle_specific_icons_refresh)

    def _handle_specific_icons_refresh(self, data_type, year, month):
        """NOWA METODA: Obsługuje sygnał odświeżenia konkretnych ikon"""
        if data_type == "icons" and hasattr(self, 'schedule_model') and self.schedule_model:
            # Model sam odświeży ikony przy następnym dostępie - nie rób nic więcej
            debug_print(f"Otrzymano sygnał odświeżenia ikon dla {year}-{month}")

    def call_add_overtime_procedure_fixed(self, user_id, year, month, date_str, start_time, hours,
                                          settlement_date, is_overdue, overtime_type, location,
                                          nr_kadrowy):
        """
        Dodaje nadgodziny i zapewnia natychmiastową, niezawodną aktualizację
        tabeli zdarzeń oraz ikony w grafiku.
        """
        try:
            # Krok 1: Dodanie rekordu do bazy danych
            location_map = {'h': 1, 'p': 2, 's': 3}
            location_value = location_map.get(location, 1)
            param_value = 1 if overtime_type == 'odpracowanie' else None
            odebrane_value = 1 if overtime_type == 'odbiór' else 0

            from datetime import datetime, timedelta
            start_datetime = datetime.strptime(f"{date_str} {start_time}", "%Y-%m-%d %H:%M")
            end_datetime = start_datetime + timedelta(hours=float(hours))
            end_time = end_datetime.strftime("%H:%M")

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            params = [
                nr_kadrowy, year, month, date_str, start_time, end_time,
                settlement_date, is_overdue, odebrane_value, location_value,
                param_value
            ]
            sql = f"{{CALL [dbo].[p_P_ZZ_NadgodzinyWstawienie_v3] ({', '.join(['?'] * len(params))})}}"
            cursor.execute(sql, params)
            conn.commit()
            conn.close()

            # Krok 2: Rejestracja własnej zmiany i unieważnienie cache
            self._update_modification_date()
            self.data_provider.invalidate_complete_cache_for_pairs([(user_id, date_str)])

            # --- NOWA, KLUCZOWA LOGIKA (skopiowana z `delete_event`) ---
            # Krok 3: Bezpośrednia aktualizacja ikony w modelu
            if hasattr(self, 'schedule_model'):
                # Sprawdzamy, jakie zdarzenia istnieją dla komórki PO dodaniu nowego
                remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)

                # Bezpośrednio aktualizujemy stan ikon w modelu
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_meetings, has_trainings, has_overtime
                )

            # Krok 4: Odświeżenie dolnej tabeli zdarzeń
            self.on_selection_changed()

            # Zwracamy sukces
            return {
                "success": True,
                "message": "Nadgodziny zostały pomyślnie dodane."
            }

        except Exception as e:
            log_error(f"Błąd podczas dodawania nadgodzin: {e}", exception=e)
            return {
                "success": False,
                "message": f"Wystąpił błąd podczas dodawania nadgodzin: {str(e)}"
            }

    def _refresh_data_after_overtime_addition(self, new_id, user_id, date_str, year, month):
        """
        NOWA METODA: Odświeża dane z bazy po dodaniu nadgodzin
        """
        try:
            debug_print(f"Odświeżam dane po dodaniu nadgodzin ID={new_id}")
            
            # Upewnij się, że column_mapper jest dostępny
            if not hasattr(self, 'column_mapper'):
                from column_mapper import ColumnMapper
                self.column_mapper = ColumnMapper()
            
            # 1. POBIERZ NOWE ZDARZENIE Z BAZY DANYCH
            new_event = self._fetch_specific_event_from_db(year, month, new_id, 'Nadgodziny')
            
            if not new_event:
                log_error(f"Nie znaleziono dodanych nadgodzin o ID {new_id} w bazie danych")
                return
            
            debug_print(f"Pobrano nowe zdarzenie z bazy: {new_event}")
            
            # 2. AKTUALIZUJ CACHE DATAPROVIDER
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]
                
                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data")
                
                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []
                
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache")
                
                # Aktualizuj processed_data - ustaw ikonę nadgodzin
                try:
                    day = int(date_str.split('-')[2])
                    for key, user_data in container.processed_data.items():
                        if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonę nadgodzin w processed_data")
                            break
                except Exception as e:
                    log_error(f"Błąd aktualizacji processed_data: {e}")
            
            # 3. AKTUALIZUJ LOKALNE DANE
            # Konwertuj na lokalny format
            local_event = self._convert_dp_event_to_local(new_event)
            
            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(local_event)
                    debug_print(f"Dodano nadgodziny do all_events_data")
            
            # 4. AKTUALIZUJ events_data TYLKO JEŚLI KOMÓRKA JEST ZAZNACZONA
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )
                
                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(local_event)
                        debug_print(f"Dodano nadgodziny do events_data")
                        
                        # Aktualizuj model zdarzeń
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()
            
            # 5. AKTUALIZUJ MODEL GRAFIKU
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_overtime=True
                )
                debug_print(f"Zaktualizowano ikony w schedule_model")
            
            # 6. WYCZYŚĆ CACHE IKON
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon")
            
            # 7. ODŚWIEŻ WIDOKI
            if hasattr(self, 'table'):
                if hasattr(self.table, 'schedule_view'):
                    self.table.schedule_view.viewport().update()
            
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()
            
            debug_print(f"=== ODŚWIEŻENIE DANYCH ZAKOŃCZONE ===")
            
        except Exception as e:
            log_error(f"Błąd podczas odświeżania danych: {e}")
            import traceback
            traceback.print_exc()

    def _fetch_specific_event_from_db(self, year, month, event_id, event_type):
        """
        NOWA METODA: Pobiera konkretne zdarzenie z bazy danych
        """
        try:
            # Zapytanie do pobrania konkretnego zdarzenia
            query = """
            SELECT * FROM [dbo].[fn_GetEventsData](?, ?) 
            WHERE EventType = ? AND ID = ?
            """
            
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query, (year, month, event_type, event_id))
            result = cursor.fetchone()
            conn.close()
            
            if not result:
                return None
            
            # Konwertuj na format DataProvider używając column_mapper
            event_dict = self.column_mapper.map_events_row_to_dict(result)
            
            # Dodaj pola wymagane przez DataProvider
            if 'event_type' in event_dict:
                event_dict['type'] = event_dict['event_type']
            if 'event_id' in event_dict:
                event_dict['id'] = event_dict['event_id']
            
            # Formatuj daty
            raw_date = event_dict.get('date', '')
            if hasattr(raw_date, 'strftime'):
                event_dict['date_display'] = raw_date.strftime('%d.%m.%Y')
                event_dict['date_key'] = raw_date.strftime('%Y-%m-%d')
            elif isinstance(raw_date, str) and raw_date:
                event_dict['date_display'] = self.data_provider._format_date_display(raw_date)
                event_dict['date_key'] = self.data_provider._standardize_date(raw_date)
            
            # Formatuj czasy
            time_from = event_dict.get('time_from')
            time_to = event_dict.get('time_to')
            
            if hasattr(time_from, 'strftime'):
                event_dict['time_from'] = time_from.strftime('%H:%M')
            elif isinstance(time_from, str) and 'T' in time_from:
                event_dict['time_from'] = time_from.split(' ')[1][:5]
            
            if hasattr(time_to, 'strftime'):
                event_dict['time_to'] = time_to.strftime('%H:%M')
            elif isinstance(time_to, str) and 'T' in time_to:
                event_dict['time_to'] = time_to.split(' ')[1][:5]
            
            debug_print(f"Skonwertowano zdarzenie z bazy: {event_dict}")
            return event_dict
            
        except Exception as e:
            log_error(f"Błąd podczas pobierania zdarzenia z bazy: {e}")
            return None
        
             
    def _add_event_to_data_provider(self, new_id, user_id, user_name, date_str, start_time, 
                               end_time, overtime_type, is_overdue, year, month):
        """
        NOWA METODA: Dodaje zdarzenie bezpośrednio do DataProvider i wszystkich cache'y
        """
        try:
            # Utwórz obiekt zdarzenia w formacie DataProvider
            display_date = ".".join(reversed(date_str.split("-")))
            
            # Status na podstawie typu i flagi zaległości
            if overtime_type == 'wypłata':
                status = "Wypłata - zaległe" if is_overdue else "Wypłata"
            elif overtime_type == 'odbiór':
                status = "Odbiór"
            elif overtime_type == 'odpracowanie':
                status = "Odpracowanie"
            else:
                status = "Aktywne"

            # Utwórz zdarzenie w formacie zgodnym z DataProvider
            new_event_dp_format = {
                'event_type': 'Nadgodziny',
                'event_id': new_id,
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'date': date_str,  # DataProvider oczekuje YYYY-MM-DD
                'time_from': f"1900-01-01 {start_time}:00",  # Format z bazy
                'time_to': f"1900-01-01 {end_time}:00",
                'status': 'Wstawione',  # Status w formacie bazy
                'type': 'Nadgodziny',
                'id': new_id,
                'date_display': display_date,
                'date_key': date_str
            }

            # Utwórz zdarzenie w formacie lokalnym
            new_event_local_format = {
                'type': 'Nadgodziny',
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'user_name': user_name,
                'date': display_date,
                'date_key': date_str,
                'time_from': start_time,
                'time_to': end_time,
                'status': status,
                'id': new_id
            }

            # KLUCZOWA ZMIANA 1: Dodaj do cache DataProvider
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]
                
                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data (ID: {new_id})")
                
                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []
                
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache (ID: {new_id})")
                
                # Aktualizuj processed_data - dodaj ikonę nadgodzin
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        try:
                            day = int(date_str.split('-')[2])
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonę nadgodzin w processed_data dla {user_id}, dzień {day}")
                            break
                        except:
                            pass

            # KLUCZOWA ZMIANA 2: Dodaj do lokalnych danych
            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(new_event_local_format)
                    debug_print(f"Dodano nadgodziny do all_events_data (ID: {new_id})")

            # KLUCZOWA ZMIANA 3: Dodaj do events_data tylko jeśli komórka jest zaznaczona
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )
                
                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(new_event_local_format)
                        debug_print(f"Dodano nadgodziny do events_data (ID: {new_id})")
                        
                        # Aktualizuj model zdarzeń
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # KLUCZOWA ZMIANA 4: Aktualizuj ikonę w modelu
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonę nadgodzin w modelu dla ({user_id}, {date_str})")

            # KLUCZOWA ZMIANA 5: Wyczyść tylko cache ikon dla tej komórki (nie cały cache)
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla komórki ({user_id}, {date_str})")

            # Odśwież widok
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"Błąd podczas dodawania zdarzenia do DataProvider: {e}")

    def debug_check_event_in_index(self, event_id, event_type='Nadgodziny'):
        """
        Sprawdza, czy zdarzenie o podanym ID istnieje w indeksie zdarzeń
        i wyświetla informacje diagnostyczne.

        Args:
            event_id: ID zdarzenia
            event_type: Typ zdarzenia (domyślnie 'Nadgodziny')

        Returns:
            bool: True jeśli znaleziono zdarzenie, False w przeciwnym wypadku
        """
        debug_print(f"\n--- DIAGNOSTYKA INDEKSU ZDARZEŃ ---")
        debug_print(f"Szukam zdarzenia o ID {event_id} i typie {event_type}")

        # Sprawdź w indeksie zdarzeń DataProvider
        if hasattr(self.data_provider, 'events_index'):
            # Sprawdź bezpośrednio przez indeks ID
            event = self.data_provider.events_index.get_event_by_id(event_id)
            if event:
                debug_print(f"ZNALEZIONO w indeksie ID: {event}")
                return True

            # Alternatywnie, przeszukaj wszystkie zdarzenia
            found_in_all = False
            for e in self.data_provider.events_index.all_events:
                if e.get('id') == event_id and e.get('type') == event_type:
                    debug_print(f"ZNALEZIONO w all_events: {e}")
                    found_in_all = True

            # Przeszukaj indeks typów
            found_in_type_index = False
            type_events = self.data_provider.events_index.type_index.get(event_type, [])
            for e in type_events:
                if e.get('id') == event_id:
                    debug_print(f"ZNALEZIONO w type_index: {e}")
                    found_in_type_index = True

            if not found_in_all and not found_in_type_index:
                debug_print("NIE ZNALEZIONO w indeksie zdarzeń")
                return False

            return found_in_all or found_in_type_index
        else:
            debug_print("BRAK indeksu zdarzeń w data_provider")
            return False

    def show_settings_dialog(self):
        """Otwiera nowe, kompleksowe okno ustawień."""
        current_settings = {
            'theme': 'dark' if self.is_dark_theme else 'light',
            'font_family': self.current_font,
            'font_size': self.current_font_size,
            'import_grupa': self.import_grupa,
            'import_funkcja': self.import_funkcja
        }

        dialog = AppSettingsDialog(self, settings=current_settings)

        if dialog.exec() == QDialog.Accepted:
            new_settings = dialog.get_current_settings()

            # Zastosuj i zapisz ustawienia
            self.is_dark_theme = new_settings['theme'] == 'dark'
            self.current_font = new_settings['font_family']
            self.current_font_size = new_settings['font_size']
            self.import_grupa = new_settings['import_grupa']
            self.import_funkcja = new_settings['import_funkcja']

            self.apply_theme_settings(new_settings['theme'], new_settings['font_family'], new_settings['font_size'])

            if new_settings['save_to_db']:
                self.settings_db.save_settings(
                    theme=new_settings['theme'],
                    font_family=new_settings['font_family'],
                    font_size=new_settings['font_size'],
                    visible_columns=self.visible_columns,
                    show_schedule_comment=self.show_comment_column,
                    import_grupa=self.import_grupa,
                    import_funkcja=self.import_funkcja
                )

            # Wymuś odświeżenie danych z nowymi parametrami importu
            self.refresh_data()

    def update_cell_data(self, user_id, date_str, event_type=None, action="update"):
        """
        Aktualizuje dane komórki i ikony po różnych operacjach.
        Zoptymalizowana wersja wykorzystująca precyzyjne aktualizacje.

        Args:
            user_id: ID użytkownika
            date_str: Data w formacie 'YYYY-MM-DD'
            event_type: Typ zdarzenia (Spotkanie, Szkolenie, Nadgodziny lub None)
            action: Rodzaj operacji - "update", "add", "delete"

        Returns:
            bool: True jeśli operacja się powiodła, False w przeciwnym wypadku
        """
        if not user_id or not date_str:
            return False

        # Standardyzuj format daty
        date_str = self.data_provider._standardize_date(date_str)

        # Wyczyść cache dla miesiąca tej daty
        if date_str and date_str.count('-') == 2:
            year, month, _ = date_str.split('-')
            self.clear_events_cache(int(year), int(month))

        # Pobierz zdarzenia dla tej pary (użytkownik, data)
        events = self.data_provider.get_events_for_user_date(user_id, date_str)

        # Sprawdź typy zdarzeń
        has_meeting = any(
            e.get('type') == 'Spotkanie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_training = any(
            e.get('type') == 'Szkolenie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_overtime = any(e.get('type') == 'Nadgodziny' for e in events)

        # Aktualizuj wskaźniki w modelu - używając zoptymalizowanej metody
        if hasattr(self, 'schedule_model'):
            if event_type == 'Spotkanie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Szkolenie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Nadgodziny':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny',
                                                                  is_active=(action != "delete"))
            else:
                # Aktualizuj wszystkie wskaźniki
                result1 = self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', has_meeting)
                result2 = self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', has_training)
                result3 = self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', has_overtime)
                return result1 or result2 or result3

        return False

    def get_all_valid_symbols(self) -> set:
        """Zwraca zbiór wszystkich prawidłowych symboli specjalnych."""
        # Definicje skopiowane z InsertSymbolDialog dla centralizacji
        symbol_lists = [
            ("U", "Urlop wypoczynkowy"), ("UZ", "Urlop na żądanie"), ("CO", "Zwolnienie lekarskie"),
            ("CR", "Zwolnienie lekarskie na inną osobę"), ("UB", "Urlop bezpłatny"),
            ("UD", "Urlop dodatkowy z tytułu niepełnosprawności"), ("UM", "Urlop macierzyński"),
            ("UO", "Urlop okolicznościowy"), ("UOD", "Opieka nad dzieckiem"),
            ("US", "Urlop szkolny"), ("UT", "Urlop ojcowski"), ("UW", "Urlop wychowawczy"),
            ("UOP", "Urlop opiekuńczy (5 dni)"), ("CRW", "Zwolnienie na opiekę (wyjątkowe)"),
            ("CSR", "Świadczenie rehabilitacyjne"), ("ZO", "Zwolnienie z obowiązku świadczenia pracy"),
            ("ZS", "Zwolnienie z obowiązku świadczenia pracy (wyjątkowe)"),
            ("DK", "Delegacja krajowa"), ("DZ", "Delegacja zagraniczna"),
            ("HO", "Home Office"), ("P", "Czasowe oddelegowanie"), ("PD", "Prace dodatkowe"),
            ("BC", "Backup"), ("BK", "Badanie kontrolne"), ("BO", "Badanie okresowe"),
            ("CW", "Ćwiczenia wojskowe"), ("DYS", "Dyspozycja"), ("MW", "mWolne"),
            ("NN", "Nieobecność nieusprawiedliwiona"), ("NU", "Nieobecność usprawiedliwiona"),
            ("NW", "Nieobecność do wyjaśnienia"), ("O", "Odbiór godzin"),
            ("OS", "Odbiór dnia wolnego za święto"), ("S", "Szkolenie"), ("T", "Testy"),
            ("USW", "Zwolnienie z powodu siły wyższej (2 dni)"), ("Z", "Rozwiązanie umowy")
        ]
        return {symbol for symbol, desc in symbol_lists}

    def apply_symbol_from_keyboard(self, special_symbol: str):
        """
        Stosuje podany symbol specjalny, budując nowy symbol zgodnie z nowymi zasadami.
        """
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono komórek do edycji.")
            return

        # Dialog potwierdzenia (bez zmian)
        user_dates = defaultdict(list)
        for cell in selected_cells_data:
            user_dates[cell.get('uzytkownik_dane', 'Nieznany')].append(cell.get('date_str'))
        changes_info = f"Czy na pewno chcesz wstawić symbol '{special_symbol}' dla:\n\n"
        for user, dates in user_dates.items():
            dates_str = ", ".join(sorted(dates))
            changes_info += f"👤 {user}: {dates_str}\n"

        reply = QMessageBox.question(self, "Potwierdzenie zmiany symbolu", changes_info,
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

        if reply != QMessageBox.Yes:
            return

        # Nowa logika budowania symbolu i zapisu
        updated_info = []
        error_messages = []  # Nowa lista do zbierania błędów
        for cell_data in selected_cells_data:
            current_symbol = cell_data.get('symbol', '')

            location = None
            start_hour = None
            work_hours = None

            if current_symbol and current_symbol.strip():
                # Komórka NIE JEST pusta: pobieramy godziny z istniejącego symbolu
                parsed = parse_symbol(current_symbol)
                start_hour = parsed.get('start_hour')
                work_hours = parsed.get('work_hours')
            else:
                # Komórka JEST pusta: używamy wartości domyślnych
                start_hour = 11
                work_hours = cell_data.get('etat')

            # Budujemy nowy symbol
            new_symbol = build_symbol(
                location=location,
                start_hour=start_hour,
                work_hours=work_hours,
                special_symbol=special_symbol
            )

            # Wywołujemy procedurę
            try:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                nr_kadrowy = cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                user_name = cell_data.get('uzytkownik_dane')

                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy,
                    rok=int(year),
                    miesiac=int(month),
                    data=date_str,
                    symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    # Zbierz komunikat o błędzie do późniejszego wyświetlenia
                    error_message = result.get('message', 'Nieznany błąd')
                    error_messages.append(f"👤 {user_name} ({date_str}): {error_message}")
            except Exception as e:
                log_error(f"Błąd wywołania procedury w apply_symbol_from_keyboard: {e}")
                error_messages.append(f"Błąd aplikacji: {e}")

        # Po przetworzeniu wszystkich komórek, najpierw zaktualizuj te, które się udały
        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Pomyślnie zaktualizowano {len(updated_info)} komórek.", 4000)

        # A następnie, jeśli wystąpiły błędy, wyświetl je w jednym oknie
        if error_messages:
            QMessageBox.warning(
                self,
                "Błędy podczas zapisu",
                "Wystąpiły następujące błędy i niektóre zmiany nie zostały zapisane:\n\n" + "\n".join(
                    error_messages),
                QMessageBox.Ok
                    )

    def apply_theme_settings(self, theme, font_family, font_size):
        """Stosuje wybrane ustawienia motywu z wykorzystaniem centralnych stylów"""
        # Zapamiętaj wybrane ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Zastosuj czcionkę do całej aplikacji
        font = QFont(font_family, font_size)
        QApplication.setFont(font)

        # Zastosuj główny styl dla całego okna aplikacji
        self.setStyleSheet(AppStyles.get_main_window_style(theme))

        # Bezpieczne ustawianie stylów z sprawdzaniem istnienia atrybutów

        # Przyciski w górnym pasku
        if hasattr(self, 'theme_button'): self.theme_button.setStyleSheet(AppStyles.get_button_style(theme))
        if hasattr(self, 'refresh_button'): self.refresh_button.setStyleSheet(AppStyles.get_button_style(theme))
        if hasattr(self, 'toggle_menu_button'): self.toggle_menu_button.setStyleSheet(AppStyles.get_button_style(theme))
        if hasattr(self, 'date_combo'): self.date_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'staffing_details_button'): self.staffing_details_button.setStyleSheet(AppStyles.get_button_style(theme))
        if hasattr(self, 'show_audit_button'): self.show_audit_button.setStyleSheet(AppStyles.get_button_style(theme))
        # Lewy panel i jego elementy
        if hasattr(self, '_left_panel'): self._left_panel.setStyleSheet(AppStyles.get_left_panel_style(theme))
        if hasattr(self, 'wydzial_combo'): self.wydzial_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'dtn_combo'): self.dtn_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'rola_combo'): self.rola_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'jezyk_combo'): self.jezyk_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'etat_combo'): self.etat_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'system_czasu_pracy_combo'): self.system_czasu_pracy_combo.setStyleSheet(AppStyles.get_combobox_style(theme))

        if hasattr(self, 'przelozony_filter'): self.przelozony_filter.setStyleSheet(
            AppStyles.get_line_edit_style(theme))
        if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.setStyleSheet(
            AppStyles.get_line_edit_style(theme))
        if hasattr(self, 'przelozony_list'): self.przelozony_list.setStyleSheet(AppStyles.get_list_style(theme))
        if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style(theme))
        if hasattr(self, 'clear_filters_button'): self.clear_filters_button.setStyleSheet(
            AppStyles.get_button_style(theme))

        # Przyciski w dolnym panelu
        if hasattr(self, 'manage_columns_button'): self.manage_columns_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'toggle_events_panel_button'): self.toggle_events_panel_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'insert_change_button'): self.insert_change_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'insert_symbol_button'): self.insert_symbol_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'cancel_delegation_button'): self.cancel_delegation_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'add_overtime_button'): self.add_overtime_button.setStyleSheet(
            AppStyles.get_button_style(theme))

        # Elementy panelu zdarzeń
        if hasattr(self, 'date_from'): self.date_from.setStyleSheet(AppStyles.get_date_edit_style(theme))
        if hasattr(self, 'date_to'): self.date_to.setStyleSheet(AppStyles.get_date_edit_style(theme))
        if hasattr(self, 'topic_filter'): self.topic_filter.setStyleSheet(AppStyles.get_line_edit_style(theme))
        if hasattr(self, 'name_filter'): self.name_filter.setStyleSheet(AppStyles.get_line_edit_style(theme))
        if hasattr(self, 'meetings_checkbox'): self.meetings_checkbox.setStyleSheet(AppStyles.get_checkbox_style(theme))
        if hasattr(self, 'trainings_checkbox'): self.trainings_checkbox.setStyleSheet(
            AppStyles.get_checkbox_style(theme))
        if hasattr(self, 'overtime_checkbox'): self.overtime_checkbox.setStyleSheet(AppStyles.get_checkbox_style(theme))

        # Aktualizacja modeli
        if hasattr(self, 'schedule_model'): self.schedule_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'events_model'): self.events_model.set_theme(self.is_dark_theme)

        # Aktualizacja widoków tabel
        if hasattr(self, 'table'):
            if hasattr(self.table, 'employees_view'):
                self.table.employees_view.setStyleSheet(AppStyles.get_table_style(theme))
                self.table.employees_view.viewport().update()
            if hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.setStyleSheet(AppStyles.get_table_style(theme))
                self.table.schedule_view.viewport().update()

        if hasattr(self, 'events_table'):
            self.events_table.setStyleSheet(AppStyles.get_table_style(theme))
            self.events_table.viewport().update()

        # Jeśli okno szczegółów obsady jest otwarte, zaktualizuj również jego motyw.
        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            is_dark = (theme == "dark")
            self.staffing_details_win.set_current_theme(is_dark)

    def closeEvent(self, event):
        """Obsługuje zamknięcie aplikacji"""
        try:
            debug_print("=== ZAMYKANIE APLIKACJI TEAMFLOW ===")
            debug_print(f"Sesja trwała od uruchomienia aplikacji")

            # NOWE: Wyczyść filtr klawiatury
            self.cleanup_keyboard_filter()

            close_log_file()
        except:
            pass  # Ignoruj błędy podczas zamykania
        finally:
            event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = WorkScheduleWindow()
    window.show()
    sys.exit(app.exec())
