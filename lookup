Ten b≈ÇƒÖd: ORA-01439: column to be modified must be empty to change datatype oznacza, ≈ºe Tw√≥j skrypt pr√≥buje zmieniƒá typ danych kolumny INITIATEDDATETIME (na NVARCHAR2(22)), ale w tabeli w bazie danych sƒÖ ju≈º dane, a Oracle na to nie pozwala (chyba ≈ºe tabela jest pusta).
Dlaczego to siƒô dzieje?
 * W bazie danych kolumna INITIATEDDATETIME ma prawdopodobnie typ DATE lub TIMESTAMP.
 * Tw√≥j DataFrame w Pythonie traktuje tƒô kolumnƒô jako string (napis) o d≈Çugo≈õci 22 znak√≥w.
 * Funkcja check_column_size wykrywa r√≥≈ºnicƒô i pr√≥buje wykonaƒá ALTER TABLE ... MODIFY ... NVARCHAR2(22).
 * Oracle blokuje tƒô operacjƒô, bo zmiana typu DATE -> NVARCHAR2 na niepustej kolumnie jest zabroniona.
üõ†Ô∏è RozwiƒÖzanie
Musimy zmodyfikowaƒá funkcjƒô check_column_size w klasie DatabaseManager. Musimy dodaƒá obs≈Çugƒô b≈Çƒôdu (try-except), aby zignorowaƒá ten b≈ÇƒÖd w przypadku Oracle. Je≈õli nie mo≈ºemy zmieniƒá typu kolumny, powinni≈õmy po prostu zostawiƒá jƒÖ takƒÖ, jaka jest, i spr√≥bowaƒá wstawiƒá dane (Oracle czƒôsto poradzi sobie z niejawnƒÖ konwersjƒÖ string->date przy insercie).
Oto poprawiona funkcja check_column_size. Podmie≈Ñ jƒÖ w swoim pliku.
    def check_column_size(self, engine, df: pd.DataFrame, table_name: str, schema: str, target_db: str):
        """
        Sprawdza i ewentualnie zwiƒôksza rozmiar kolumn w bazie danych.
        Ignoruje b≈Çƒôdy zmiany typu danych (ORA-01439) dla niepustych tabel.
        """
        if df.empty:
            return

        # Mapowanie typ√≥w dla sprawdzenia d≈Çugo≈õci
        # U≈ºywamy uproszczonego mapowania, bo interesuje nas g≈Ç√≥wnie VARCHAR/NVARCHAR
        column_types = self.map_data_types(df, target_db)
        
        try:
            with engine.connect() as connection:
                # Pobranie informacji o kolumnach z bazy (dla Oracle)
                if target_db.lower() == 'oracle':
                    # Pobieramy obecne definicje kolumn z Oracle
                    # Uwaga: user_tab_columns przechowuje nazwy wielkimi literami
                    sql_check = f"""
                        SELECT COLUMN_NAME, DATA_TYPE, DATA_LENGTH, CHAR_LENGTH 
                        FROM ALL_TAB_COLUMNS 
                        WHERE TABLE_NAME = '{table_name.upper()}' 
                          AND OWNER = '{schema.upper()}'
                    """
                    existing_cols = connection.execute(text(sql_check)).fetchall()
                    existing_cols_dict = {row[0]: {'type': row[1], 'len': row[3] if row[3] else row[2]} for row in existing_cols}

                    for col_name in df.columns:
                        col_upper = col_name.upper()
                        
                        # Je≈õli kolumny nie ma w bazie, zostanie dodana przy insercie (lub mo≈ºna tu dodaƒá ALTER ADD)
                        if col_upper not in existing_cols_dict:
                            continue

                        current_type_info = existing_cols_dict[col_upper]
                        current_len = current_type_info['len']
                        
                        # Sprawdzamy typ w Pythonie
                        # Je≈õli w Pythonie mamy string/object, a w bazie jest VARCHAR/CHAR, sprawdzamy d≈Çugo≈õƒá
                        col_type_obj = column_types.get(col_name)
                        
                        # Interesuje nas tylko zwiƒôkszanie VARCHAR-√≥w
                        is_varchar_in_python = 'VARCHAR' in str(col_type_obj).upper() or 'STRING' in str(col_type_obj).upper() or 'CLOB' in str(col_type_obj).upper()
                        
                        if is_varchar_in_python:
                            # Obliczamy wymaganƒÖ d≈Çugo≈õƒá
                            max_len_in_df = df[col_name].astype(str).map(len).max()
                            if pd.isna(max_len_in_df): max_len_in_df = 0
                            required_len = int(max_len_in_df * 1.2) # Margines

                            # Je≈õli wymagana d≈Çugo≈õƒá jest wiƒôksza ni≈º obecna (i obecna to nie CLOB)
                            if required_len > current_len and current_type_info['type'] not in ['CLOB', 'NCLOB', 'LONG']:
                                
                                try:
                                    alter_sql = ""
                                    if required_len > 4000:
                                        self.logger.info(f"Zmiana typu kolumny {col_name} na CLOB")
                                        alter_sql = f'ALTER TABLE "{schema}"."{table_name}" MODIFY ("{col_name}" CLOB)'
                                    else:
                                        self.logger.info(f"Zwiƒôkszanie kolumny {col_name} z {current_len} na {required_len}")
                                        alter_sql = f'ALTER TABLE "{schema}"."{table_name}" MODIFY ("{col_name}" VARCHAR2({required_len}))'
                                    
                                    connection.execute(text(alter_sql))
                                    
                                except Exception as e:
                                    # üí• TUTAJ JEST NAPRAWA TWOJEGO B≈ÅƒòDU üí•
                                    error_str = str(e)
                                    if "ORA-01439" in error_str:
                                        self.logger.warning(f"Nie mo≈ºna zmieniƒá typu kolumny '{col_name}' (ORA-01439). "
                                                            f"Kolumna nie jest pusta, a typy sƒÖ niekompatybilne. "
                                                            f"Ignorujƒô zmianƒô i pr√≥bujƒô wstawiƒá dane.")
                                    else:
                                        self.logger.error(f"B≈ÇƒÖd podczas zmiany rozmiaru kolumny {col_name}: {e}")
                                        # Nie podnosimy raise, pr√≥bujemy wstawiaƒá dalej

                elif target_db.lower() == 'sqlserver':
                    # (Tutaj Twoja istniejƒÖca logika dla SQL Server lub uproszczona wersja)
                    pass

        except Exception as e:
            self.logger.error(f"B≈ÇƒÖd w check_column_size: {e}")
            # Nie przerywamy procesu, bo insert mo≈ºe siƒô udaƒá mimo to

Co zmieniƒá w kodzie?
Musisz dodaƒá import text z sqlalchemy na g√≥rze pliku, je≈õli go nie masz:
from sqlalchemy import text
Kluczowa zmiana to blok except, kt√≥ry wy≈Çapuje ORA-01439. Dziƒôki temu skrypt:
 * Spr√≥buje zmieniƒá kolumnƒô.
 * Oracle rzuci b≈ÇƒÖd "nie mogƒô, bo sƒÖ dane".
 * Python z≈Çapie b≈ÇƒÖd, wypisze ostrze≈ºenie (warning) zamiast b≈Çƒôdu (error).
 * Proces p√≥jdzie dalej do insert_data i spr√≥buje wstawiƒá dane. Je≈õli INITIATEDDATETIME to data w formacie stringowym pasujƒÖcym do formatu Oracle, wstawienie siƒô uda.

Oto pe≈Çny, naprawiony kod funkcji check_column_size.
Zosta≈Ç on wzbogacony o blok try-except, kt√≥ry specyficznie wy≈Çapuje b≈ÇƒÖd ORA-01439. Dziƒôki temu, gdy skrypt spr√≥buje zmieniƒá typ kolumny (np. z DATE na VARCHAR), a Oracle odm√≥wi, skrypt tylko zaloguje ostrze≈ºenie i p√≥jdzie dalej, zamiast przerywaƒá ca≈Çe zadanie.
üìÑ Pe≈Çny kod check_column_size
Upewnij siƒô, ≈ºe na g√≥rze pliku masz import: from sqlalchemy import text.
    def check_column_size(self, engine, df: pd.DataFrame, table_name: str, schema: str, target_db: str) -> None:
        """
        Sprawdza i dostosowuje rozmiar kolumn w tabeli (Oracle i SQL Server).
        Obs≈Çuguje b≈ÇƒÖd ORA-01439 (blokada zmiany typu dla niepustych kolumn).
        """
        if df.empty:
            return

        # U≈ºywamy text() do surowych zapyta≈Ñ SQL
        from sqlalchemy import text

        # Pobieramy mapowanie typ√≥w, aby wiedzieƒá, kt√≥re kolumny sƒÖ tekstowe w Pythonie
        # U≈ºywamy tutaj Twojej funkcji mapujƒÖcej
        column_types = self.map_data_types(df, target_db)

        try:
            with engine.connect() as connection:
                
                # --- LOGIKA DLA ORACLE ---
                if target_db.lower() == 'oracle':
                    # 1. Pobieramy informacje o obecnych kolumnach w bazie
                    # ALL_TAB_COLUMNS zawiera nazwy, typy i d≈Çugo≈õci
                    sql_check = f"""
                        SELECT COLUMN_NAME, DATA_TYPE, DATA_LENGTH, CHAR_LENGTH 
                        FROM ALL_TAB_COLUMNS 
                        WHERE TABLE_NAME = '{table_name.upper()}' 
                          AND OWNER = '{schema.upper()}'
                    """
                    existing_cols = connection.execute(text(sql_check)).fetchall()
                    
                    # Tworzymy s≈Çownik: { 'NAZWA_KOLUMNY': {'type': 'VARCHAR2', 'len': 100} }
                    # CHAR_LENGTH jest lepsze dla VARCHAR2, DATA_LENGTH dla innych
                    existing_cols_dict = {
                        row[0].upper(): {'type': row[1], 'len': row[3] if row[3] else row[2]} 
                        for row in existing_cols
                    }

                    for col_name in df.columns:
                        col_upper = col_name.upper()
                        
                        # Je≈õli kolumny nie ma w bazie, pomijamy (zostanie dodana lub wyrzuci b≈ÇƒÖd przy insercie)
                        if col_upper not in existing_cols_dict:
                            continue

                        current_info = existing_cols_dict[col_upper]
                        current_len = current_info['len']
                        current_type = current_info['type']
                        
                        # Sprawdzamy typ w Pythonie (z mapowania)
                        col_type_obj = column_types.get(col_name)
                        col_type_str = str(col_type_obj).upper()

                        # Interesuje nas tylko weryfikacja kolumn tekstowych (VARCHAR, STRING, CLOB)
                        # Ignorujemy liczby i daty, bo ich "d≈Çugo≈õƒá" dzia≈Ça inaczej
                        is_text_col = 'VARCHAR' in col_type_str or 'STRING' in col_type_str or 'CLOB' in col_type_str
                        
                        if is_text_col:
                            # Obliczamy faktycznƒÖ d≈Çugo≈õƒá danych w DataFrame + margines 20%
                            max_len_in_df = df[col_name].astype(str).map(len).max()
                            if pd.isna(max_len_in_df): 
                                max_len_in_df = 0
                            
                            required_len = int(max_len_in_df * 1.2)
                            
                            # Je≈õli wymagana d≈Çugo≈õƒá jest wiƒôksza ni≈º obecna w bazie
                            # I obecna kolumna to nie jest ju≈º CLOB (kt√≥ry jest ogromny)
                            if required_len > current_len and current_type not in ['CLOB', 'NCLOB', 'LONG', 'BLOB']:
                                
                                alter_sql = ""
                                try:
                                    if required_len > 4000:
                                        self.logger.info(f"Wykryto potrzebƒô zmiany kolumny {col_name} na CLOB (wymagane: {required_len})")
                                        alter_sql = f'ALTER TABLE "{schema}"."{table_name}" MODIFY ("{col_name}" CLOB)'
                                    else:
                                        self.logger.info(f"Zwiƒôkszanie kolumny {col_name} z {current_len} na {required_len}")
                                        alter_sql = f'ALTER TABLE "{schema}"."{table_name}" MODIFY ("{col_name}" VARCHAR2({required_len}))'
                                    
                                    # Wykonanie zmiany
                                    connection.execute(text(alter_sql))
                                    self.logger.info(f"Pomy≈õlnie zmieniono rozmiar kolumny {col_name}.")
                                    
                                except Exception as e:
                                    # üí• KLUCZOWA POPRAWKA DLA ORA-01439 üí•
                                    error_str = str(e)
                                    if "ORA-01439" in error_str:
                                        self.logger.warning(
                                            f"Ignorujƒô zmianƒô typu/rozmiaru dla '{col_name}' (B≈ÇƒÖd ORA-01439). "
                                            f"Baza zawiera dane, a typy sƒÖ niekompatybilne (np. DATE vs VARCHAR). "
                                            f"Pr√≥ba wstawienia danych nastƒÖpi bez zmian w strukturze."
                                        )
                                    elif "ORA-01441" in error_str:
                                        self.logger.warning(f"Nie mo≈ºna zmniejszyƒá d≈Çugo≈õci kolumny {col_name}, poniewa≈º zawiera ona dane.")
                                    else:
                                        # Inne b≈Çƒôdy logujemy jako Warning, ≈ºeby nie przerywaƒá procesu
                                        self.logger.warning(f"Nie uda≈Ço siƒô zmieniƒá rozmiaru kolumny {col_name}: {e}")

                # --- LOGIKA DLA SQL SERVER ---
                elif target_db.lower() == 'sqlserver':
                    
                    sql_check = f"""
                        SELECT COLUMN_NAME, CHARACTER_MAXIMUM_LENGTH 
                        FROM INFORMATION_SCHEMA.COLUMNS 
                        WHERE TABLE_SCHEMA = '{schema}' 
                          AND TABLE_NAME = '{table_name}'
                    """
                    existing_cols = connection.execute(text(sql_check)).fetchall()
                    existing_cols_dict = {row[0]: row[1] for row in existing_cols}

                    for col_name in df.columns:
                        if col_name not in existing_cols_dict:
                            continue
                            
                        current_len = existing_cols_dict[col_name]
                        # W SQL Server -1 oznacza MAX
                        if current_len == -1: 
                            continue

                        # Sprawdzamy czy to kolumna tekstowa w Pythonie
                        col_type_obj = column_types.get(col_name)
                        if 'VARCHAR' in str(col_type_obj).upper() or 'NVARCHAR' in str(col_type_obj).upper():
                            
                            max_len_in_df = df[col_name].astype(str).map(len).max()
                            if pd.isna(max_len_in_df): max_len_in_df = 0
                            required_len = int(max_len_in_df * 1.2)

                            # Je≈õli obecna d≈Çugo≈õƒá to nie None (czyli nie MAX) i wymagana jest wiƒôksza
                            if current_len is not None and required_len > current_len:
                                try:
                                    alter_sql = ""
                                    if required_len > 4000:
                                        alter_sql = f'ALTER TABLE [{schema}].[{table_name}] ALTER COLUMN [{col_name}] NVARCHAR(MAX)'
                                    else:
                                        alter_sql = f'ALTER TABLE [{schema}].[{table_name}] ALTER COLUMN [{col_name}] NVARCHAR({required_len})'
                                    
                                    self.logger.info(f"SQL Server: Zwiƒôkszanie kolumny {col_name} na {required_len}")
                                    connection.execute(text(alter_sql))
                                except Exception as e:
                                    self.logger.warning(f"B≈ÇƒÖd zmiany kolumny SQL Server {col_name}: {e}")

        except Exception as e:
            # Globalny catch dla funkcji - nie chcemy, ≈ºeby sprawdzanie rozmiaru wywali≈Ço ca≈Çy import
            self.logger.error(f"Og√≥lny b≈ÇƒÖd podczas sprawdzania rozmiaru kolumn: {e}")

Co robi ten kod?
 * Iteruje po kolumnach: Sprawdza ka≈ºdƒÖ kolumnƒô z DataFrame.
 * Por√≥wnuje: Sprawdza, czy w DataFrame jest tekst d≈Çu≈ºszy ni≈º limit ustawiony w bazie danych.
 * Pr√≥buje zmieniƒá: Je≈õli w DataFrame jest d≈Çu≈ºszy tekst, pr√≥buje wykonaƒá ALTER TABLE.
 * Chwyta ORA-01439: Je≈õli Oracle rzuci b≈ÇƒÖd "nie mogƒô zmieniƒá typu, bo sƒÖ dane", Python to wy≈Çapie, wypisze ≈º√≥≈Çte ostrze≈ºenie w logach i pozwoli programowi dzia≈Çaƒá dalej.
Po wklejeniu tej funkcji Tw√≥j proces insert_data powinien przej≈õƒá ten etap bez b≈Çƒôdu krytycznego.

