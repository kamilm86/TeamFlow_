# W pliku db_m.py, w klasie DatabaseManager

def fetch_data(self, source_db: str, sql: str, params: Optional[Dict] = None) -> pd.DataFrame:
    """
    Pobiera dane, poprawnie obsługując parametry SQL i zarządzając pamięcią.
    Jest to ostateczna, zunifikowana wersja metody.
    """
    engine = None
    self.logger.info(f"Rozpoczynam pobieranie danych z bazy '{source_db}'...")
    try:
        # Krok 1: Przygotuj zapytanie, podstawiając parametry (np. daty)
        # Zakładamy, że `prepare_queries` zwraca listę gotowych do wykonania zapytań
        # i że dla `fetch_data` interesuje nas tylko ostatnie zapytanie SELECT.
        # split_by_semicolon=False jest ważne dla zapytań CTE.
        final_queries = self.prepare_queries(sql, params, split_by_semicolon=False)
        
        if not final_queries:
            self.logger.warning("Brak zapytań do wykonania po przygotowaniu.")
            return pd.DataFrame()

        # Zakładamy, że interesuje nas ostatnie zapytanie z listy (jeśli jest ich więcej)
        sql_to_execute = final_queries[-1]

        self.logger.info("--- ROZPOCZYNAM WYKONYWANIE ZAPYTANIA SQL ---")
        self.logger.info(f"Ostateczna treść zapytania:\n{sql_to_execute}")
        self.logger.info("--- KONIEC TREŚCI ZAPYTANIA SQL ---")

        # Krok 2: Pobierz silnik z puli połączeń
        engine = self.get_engine(source_db)

        # Krok 3: Wczytaj dane w bezpieczny sposób (porcjami)
        chunk_size = 50000
        df_list = []
        self.logger.info(f"Pobieranie danych w porcjach (rozmiar: {chunk_size} wierszy)...")

        for chunk_df in pd.read_sql(sql_to_execute, engine, chunksize=chunk_size):
            self.logger.info(f"Pobrano porcję {len(chunk_df)} wierszy.")
            df_list.append(chunk_df)

        if not df_list:
            self.logger.warning("Zapytanie nie zwróciło żadnych danych.")
            return pd.DataFrame()

        final_df = pd.concat(df_list, ignore_index=True)
        self.logger.info(f"Pobrano łącznie {len(final_df)} wierszy.")
        return final_df

    except Exception as e:
        self.logger.error(f"Błąd podczas pobierania danych z {source_db}.", exc_info=True)
        raise
    finally:
        if engine:
            engine.dispose()
            self.logger.info(f"Zwolniono pulę połączeń dla silnika {source_db}.")
