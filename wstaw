Cześć. Jako Senior Developer widzę tutaj klasyczny problem "wyścigu" (race condition) pomiędzy procesem inicjalizacji interfejsu a asynchronicznym nasłuchem zdarzeń. Nawet jeśli czyścisz kolejkę, moment startu listenera i moment zakończenia ładowania danych mogą się nałożyć, lub Service Broker może odebrać wiadomość "resztkową" tuż po czyszczeniu, zanim UI będzie gotowe.

Rozwiązaniem w duchu "best practices" jest wprowadzenie **flagi stanu aplikacji**, która jawnie ignoruje powiadomienia zewnętrzne dopóki pierwsze, pełne ładowanie danych nie zakończy się sukcesem. Jest to bardziej niezawodne niż manipulacja czasem startu wątków.

Oto rozwiązanie implementowane w pliku `main.py`.

### Plan zmian w `main.py`

1.  **`__init__`**: Dodanie flagi `self._is_startup_phase = True`.
2.  **`on_db_notification`**: Dodanie warunku strażnika (guard clause), który przerywa działanie funkcji, jeśli flaga startowa jest aktywna.
3.  **`_on_async_data_loaded`**: Wyłączenie flagi (`self._is_startup_phase = False`) w momencie, gdy dane zostały poprawnie wyświetlone użytkownikowi.

Oto kompletny kod zmienionych metod dla klasy `WorkScheduleWindow`:

```python
# Zmiany w pliku main.py w klasie WorkScheduleWindow

    def __init__(self):
        super().__init__()

        # --- POCZĄTEK ZMIANY: Flaga fazy startowej ---
        # Zapobiega wyświetlaniu alertów "Nowe dane" podczas inicjalizacji aplikacji,
        # kiedy dane i tak są ładowane najświeższe.
        self._is_startup_phase = True
        # --- KONIEC ZMIANY ---

        self._is_updating_layout = False
        self.user_hidden_days = set()
        self.schedule_control_win = None
        self._state_to_restore = None

        # ... (reszta inicjalizacji bez zmian) ...
        
        self.setWindowTitle("TeamFlowApp")

        # ... (reszta kodu __init__) ...

    def on_db_notification(self, table_name: str, year: int, month: int, modifier: str):
        """
        Slot wywoływany, gdy nadejdzie powiadomienie z bazy danych.
        Zmieniony, aby ignorować powiadomienia podczas fazy startowej.
        """
        # --- POCZĄTEK ZMIANY: Ignorowanie powiadomień na starcie ---
        if self._is_startup_phase:
            from debug_utils import debug_print
            debug_print(f"[SB Listener] Ignoruję powiadomienie (Faza startowa): Tabela={table_name}")
            return
        # --- KONIEC ZMIANY ---

        # 1. Sprawdzenie daty (dla powiadomień specyficznych dla miesiąca - grafik, zdarzenia)
        # Tabela 'appsettings' jest globalna, więc pomijamy dla niej sprawdzanie daty.
        if table_name != 'appsettings':
            current_data = self.date_combo.currentData()
            if not current_data: return
            current_year, current_month = current_data

            # Jeśli powiadomienie dotyczy innego miesiąca niż oglądany -> Ignoruj logikę odświeżania widoku
            if year != current_year or month != current_month:
                return

        # 2. IGNOROWANIE WŁASNYCH ZMIAN
        # Używamy metody pomocniczej do obcięcia domeny (np. 'FIRMA\Jan' -> 'jan')
        db_user_normalized = self._normalize_db_login(modifier)
        app_user_normalized = self.current_user_app_login_windows.lower()

        if db_user_normalized == app_user_normalized:
            # Wyjątek dla zmian administracyjnych (appsettings)
            if table_name == 'appsettings':
                debug_print(f"Wymuszam przetworzenie własnej zmiany w '{table_name}' (Administrator).")
            else:
                debug_print(f"Powiadomienie zignorowane - autorem zmian jest bieżący użytkownik ({modifier}).")
                return

        debug_print(f"Przetwarzanie powiadomienia zewnętrznego: Tabela={table_name}, Kto={modifier}")

        # ... (reszta logiki powiadomień: Centrum Powiadomień, Logika Odświeżania) ...
        # (Tutaj następuje dalsza część oryginalnej metody on_db_notification - bez zmian)
        
        # --- Poniżej fragmenty oryginalnej metody dla kontekstu (nie trzeba ich zmieniać, o ile są takie same) ---
        if hasattr(self, 'notification_drawer') and self.notification_drawer:
             # ... logika drawer ...
             pass
        
        if table_name == 'appsettings':
             # ... logika appsettings ...
             pass
        elif table_name in ['spotkania', 'szkolenia', 'nadgodziny']:
             # ... logika zdarzeń ...
             pass
        elif table_name == 'grafikipracy':
             # ... logika grafiku (alert button) ...
             self.refresh_button.setText(f"Nowe dane grafiku!")
             self.refresh_button.setToolTip(
                f"Użytkownik {modifier} wprowadził zmiany w grafiku. Kliknij, aby załadować.")
             
             alert_style = AppStyles.get_alert_button_style(
                'dark' if self.is_dark_theme else 'light',
                self.current_font,
                self.current_font_size
             )
             self.refresh_button.setStyleSheet(alert_style)
             QApplication.alert(self)


    def _on_async_data_loaded(self, data, filters_to_restore=None):
        """Obsługuje pomyślne załadowanie danych async."""
        from debug_utils import debug_print
        debug_print("Otrzymano dane z async loading")
        try:
            # ... (logika czyszczenia powiadomień i drawer - bez zmian) ...
            if hasattr(self, 'notification_drawer') and self.notification_drawer:
                self.notification_drawer.clear_notifications()
            
            if hasattr(self, 'notification_btn'):
                current_theme = 'dark' if self.is_dark_theme else 'light'
                style = AppStyles.get_icon_button_style(current_theme)
                self.notification_btn.setStyleSheet(style)

            is_initial_load = self.schedule_model.rowCount() == 0

            # Zapisz stan widoku
            view_state = self._save_view_state()

            self._apply_loaded_data(data, filters_to_restore=filters_to_restore)

            if not is_initial_load:
                debug_print("Przywracanie stanu widoku po załadowaniu asynchronicznym...")
                self._restore_view_state(view_state)

            debug_print("Pomyślnie zastosowano dane z async loading")

            # --- POCZĄTEK ZMIANY: Wyłączenie fazy startowej ---
            # Skoro dane zostały załadowane i wyświetlone, możemy zacząć reagować na nowe zmiany z bazy.
            if self._is_startup_phase:
                self._is_startup_phase = False
                debug_print("=== Faza startowa zakończona. Powiadomienia o nowych danych są teraz aktywne. ===")
            # --- KONIEC ZMIANY ---

        except Exception as e:
            from debug_utils import log_error
            log_error(f"Błąd podczas stosowania załadowanych danych: {e}", exception=e)
        finally:
            self._is_refreshing_data = False
            debug_print("Ustawiono flagę _is_refreshing_data = False (w bloku finally)")
```

### Wyjaśnienie Logiki:

1.  **Stan Początkowy (`_is_startup_phase = True`)**: W konstruktorze ustawiamy flagę. Oznacza to: "Aplikacja startuje, właśnie pobieram najświeższe dane z bazy, więc nie informuj mnie, że w bazie są nowe dane, bo zaraz je wyświetlę".
2.  **Filtr Powiadomień (`on_db_notification`)**: Nawet jeśli ServiceBroker wyśle komunikat (ponieważ kolejka nie zdążyła się wyczyścić lub przyszło coś w ułamku sekundy po starcie), metoda `on_db_notification` sprawdzi flagę i cicho zignoruje ten komunikat. Zapobiega to zmianie koloru przycisku "Odśwież" na pomarańczowy.
3.  **Punkt Synchronizacji (`_on_async_data_loaded`)**: To jest jedyne pewne miejsce, w którym wiemy, że dane zostały pobrane z bazy, przetworzone i wstawione do tabeli. Dopiero w tym momencie zdejmujemy flagę (`False`). Od tej chwili każda kolejna zmiana w bazie (wykonana przez kogoś innego) jest faktycznie "nową zmianą" względem tego, co widzi użytkownik, więc alert będzie zasadny.

To podejście jest bezpieczne (fail-safe) i nie wymaga skomplikowanej synchronizacji wątków czyszczących kolejkę.
