Jasne, oczywiście. Oto kompletny, połączony kod ze wszystkich naszych ostatnich rozmów.
Ten skrypt jest gotowy do wklejenia i uruchomienia w jednym bloku w notatniku Jupyter. Zawiera wszystkie omówione elementy:
 * Prawidłowe zliczanie unikalnych rozmów (nunique).
 * Analizę porównawczą YTD (rok do dziś).
 * Szczegółową analizę tematów w ujęciu YTD.
 * Analizę miesiąc do miesiąca (MoM) dla tematów.
 * Analizę miesiąca rok do roku (YoY-M) dla tematów.
 * Wszystkie dodatkowe analizy i solidne podsumowanie biznesowe.
# ==============================================================================
# KROK 1: IMPORT BIBLIOTEK I USTAWIENIA WIZUALIZACJI
# ==============================================================================
import pandas as pd
import sqlalchemy as sa
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from dateutil.relativedelta import relativedelta # Do łatwej manipulacji datami

# Ustawienia dla wykresów, aby były czytelne i estetyczne
sns.set_theme(style="whitegrid")
plt.rcParams['figure.figsize'] = (14, 7)
plt.rcParams['axes.titlesize'] = 18
plt.rcParams['axes.labelsize'] = 14
plt.rcParams['xtick.labelsize'] = 12
plt.rcParams['ytick.labelsize'] = 12
print("✅ Biblioteki załadowane, styl wykresów ustawiony.")


# ==============================================================================
# KROK 2: WCZYTANIE DANYCH Z BAZY MS SQL SERVER
# ==============================================================================
# Wypełnij poniższe zmienne swoimi danymi dostępowymi
server_name = "TWOJ_SERWER"
database_name = "TWOJA_BAZA_DANYCH"
table_name = "NAZWA_TWOJEJ_TABELI_RAW_Z_TEMATAMI"

try:
    # Tworzenie connection stringa dla uwierzytelniania Windows
    connection_string = f"mssql+pyodbc://{server_name}/{database_name}?driver=ODBC+Driver+17+for+SQL+Server&trusted_connection=yes"
    engine = sa.create_engine(connection_string)
    
    query = f"SELECT * FROM {table_name}"
    df_raw = pd.read_sql(query, engine)
    
    print(f"✅ Pomyślnie połączono i wczytano {len(df_raw)} rekordów z tabeli {table_name}.")

except Exception as e:
    print(f"❌ Błąd podczas połączenia z bazą danych: {e}")
    print("⚠️ Tworzę przykładowy, granularny zbiór danych z wieloma tematami na rozmowę.")
    # Generowanie realistycznych danych przykładowych
    date_rng_2025 = pd.to_datetime(pd.date_range(start='2025-01-01', end='2025-09-17', freq='15min'))
    date_rng_2024 = pd.to_datetime(pd.date_range(start='2024-01-01', end='2024-12-31', freq='12min'))
    all_dates = date_rng_2025.union(date_rng_2024)
    
    # Tworzymy bazę unikalnych połączeń
    df_calls = pd.DataFrame({
        'callid': range(len(all_dates)), 'Data': all_dates,
        'Kanal_kontakt': np.random.choice(['voice', 'czat', 'wideo'], len(all_dates), p=[0.7, 0.25, 0.05]),
        'czy_odebrane': np.random.choice([1, 0], len(all_dates), p=[0.85, 0.15]),
        'wejscie': np.random.choice(['ivr', 'bot', 'vendor'], len(all_dates), p=[0.5, 0.4, 0.1]),
        'gdzie_koniec': np.random.choice(['konsultant', 'bot', 'transfer'], len(all_dates), p=[0.7, 0.15, 0.15]),
        'czas_rozmowy': np.random.gamma(2, 150, len(all_dates)).astype(int)
    })
    df_calls.loc[df_calls['czy_odebrane'] == 0, 'czas_rozmowy'] = 0

    # Tworzymy tematy i łączymy je z rozmowami
    tematy = ['Faktury', 'Płatności', 'Problemy techniczne', 'Oferta', 'Reklamacje', 'Zmiana danych']
    df_topics_1 = df_calls[['callid']].copy()
    df_topics_1['Temat'] = np.random.choice(tematy, len(df_calls))
    df_topics_2 = df_calls[['callid']].sample(frac=0.3).copy() # 30% rozmów ma drugi temat
    df_topics_2['Temat'] = np.random.choice(tematy, len(df_topics_2))
    df_with_topics = pd.concat([df_topics_1, df_topics_2])
    
    # Finalne połączenie danych
    df_raw = pd.merge(df_calls, df_with_topics, on='callid')

print("\n--- Próbka danych (wiersze mogą mieć to samo callid) ---")
display(df_raw.head())


# ==============================================================================
# KROK 3: PRZYGOTOWANIE DANYCH I IMPLEMENTACJA LOGIKI YTD
# ==============================================================================
print("\n--- Rozpoczęto przygotowanie danych ---")
df_raw['Data'] = pd.to_datetime(df_raw['Data'])
df_raw['Rok'] = df_raw['Data'].dt.year
df_raw['Miesiac'] = df_raw['Data'].dt.month
df_raw['Dzien_Roku'] = df_raw['Data'].dt.dayofyear
df_raw['Godzina'] = df_raw['Data'].dt.hour

current_year = df_raw['Rok'].max()
previous_year = current_year - 1
latest_date_cy = df_raw[df_raw['Rok'] == current_year]['Data'].max()
latest_day_of_year = latest_date_cy.dayofyear

print(f"Lata w analizie: {current_year}, {previous_year}")
print(f"Dane YTD do dnia: {latest_day_of_year} ({latest_date_cy.strftime('%Y-%m-%d')})")

df_ytd = df_raw[(df_raw['Dzien_Roku'] <= latest_day_of_year) & (df_raw['Rok'].isin([current_year, previous_year]))].copy()
print(f"✅ Dane odfiltrowane. Liczba wierszy w zbiorze YTD: {len(df_ytd)}")


# ==============================================================================
# KROK 4: ANALIZA PORÓWNAWCZA (METRYKI GŁÓWNE)
# ==============================================================================
print("\n--- Rozpoczęto główną analizę porównawczą (YTD) ---")

# --- 4.1. Ogólny Wolumen Interakcji (YTD) ---
total_volume_ytd = df_ytd.groupby('Rok')['callid'].nunique().reset_index().rename(columns={'callid': 'liczba_polaczen'})
vol_cy = total_volume_ytd.loc[total_volume_ytd['Rok'] == current_year, 'liczba_polaczen'].iloc[0]
vol_py = total_volume_ytd.loc[total_volume_ytd['Rok'] == previous_year, 'liczba_polaczen'].iloc[0]
yoy_change = ((vol_cy - vol_py) / vol_py) * 100

plt.figure(figsize=(10, 6))
ax = sns.barplot(data=total_volume_ytd, x='Rok', y='liczba_polaczen', palette='viridis')
ax.set_title(f'Całkowity Wolumen Unikalnych Interakcji (YTD)\nZmiana: {yoy_change:.2f}%', fontsize=20)
for p in ax.patches:
    ax.annotate(f'{int(p.get_height()):,}', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', fontsize=14, color='black', xytext=(0, 10), textcoords='offset points')
plt.ylabel('Liczba Unikalnych Połączeń')
plt.xlabel('Rok')
plt.show()

# --- 4.2. Analiza Średniego Czasu Obsługi (AHT) (YTD) ---
df_calls_unique_ytd = df_ytd.drop_duplicates(subset=['callid']).copy()
df_answered_ytd = df_calls_unique_ytd[df_calls_unique_ytd['czy_odebrane'] == 1]
aht_ytd = df_answered_ytd.groupby('Rok')['czas_rozmowy'].mean().reset_index().rename(columns={'czas_rozmowy': 'Sredni_AHT_s'})

plt.figure(figsize=(10, 6))
ax = sns.barplot(data=aht_ytd, x='Rok', y='Sredni_AHT_s', palette='coolwarm')
ax.set_title('Średni Czas Obsługi - AHT (YTD)')
for p in ax.patches:
    ax.annotate(f'{p.get_height():.1f}s', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', fontsize=14, color='black', xytext=(0, 10), textcoords='offset points')
plt.ylabel('AHT (w sekundach)')
plt.xlabel('Rok')
plt.show()


# ==============================================================================
# KROK 5: ANALIZA ZMIAN W TEMATACH ROZMÓW (YTD)
# ==============================================================================
print("\n--- Rozpoczęto analizę tematów rozmów (YTD) ---")

# --- 5.1. Top Tematy i Ich Zmiana (YTD) ---
topic_counts_ytd = df_ytd.groupby(['Rok', 'Temat'])['callid'].count().reset_index().rename(columns={'callid': 'liczba_wzmianek'})
top_n = 6 # Pokaż top 6 tematów

fig, axes = plt.subplots(1, 2, figsize=(20, 8), sharey=True)
for i, year in enumerate([previous_year, current_year]):
    top_topics = topic_counts_ytd[topic_counts_ytd['Rok'] == year].nlargest(top_n, 'liczba_wzmianek')
    sns.barplot(ax=axes[i], data=top_topics, x='liczba_wzmianek', y='Temat', palette='magma')
    axes[i].set_title(f'Top {top_n} Tematów w {year} (YTD)')
    axes[i].set_xlabel('Liczba Wzmianek')
plt.tight_layout()
plt.show()

# --- 5.2. Największe Wzrosty i Spadki Tematów (YTD) ---
topic_pivot = topic_counts_ytd.pivot_table(index='Temat', columns='Rok', values='liczba_wzmianek', fill_value=0)
topic_pivot['zmiana_proc'] = ((topic_pivot[current_year] - topic_pivot[previous_year]) / topic_pivot[previous_year]) * 100
topic_pivot.replace([np.inf, -np.inf], 0, inplace=True)

top_growth = topic_pivot.nlargest(5, 'zmiana_proc')
top_decline = topic_pivot.nsmallest(5, 'zmiana_proc')

fig, axes = plt.subplots(1, 2, figsize=(20, 8))
sns.barplot(ax=axes[0], x=top_growth['zmiana_proc'], y=top_growth.index, palette='Greens_r')
axes[0].set_title('Top 5 Wzrostów Tematów (YoY %)')
axes[0].set_xlabel('Wzrost Procentowy')
sns.barplot(ax=axes[1], x=top_decline['zmiana_proc'], y=top_decline.index, palette='Reds_r')
axes[1].set_title('Top 5 Spadków Tematów (YoY %)')
axes[1].set_xlabel('Spadek Procentowy')
plt.tight_layout()
plt.show()

# --- 5.3. Miesięczna Mapa Cieplna Tematów (YTD) ---
fig, axes = plt.subplots(2, 1, figsize=(18, 16), sharex=True)
for i, year in enumerate([previous_year, current_year]):
    monthly_topics = df_ytd[df_ytd['Rok'] == year].groupby(['Miesiac', 'Temat'])['callid'].count().unstack(fill_value=0)
    sns.heatmap(ax=axes[i], data=monthly_topics.T, cmap='YlGnBu', annot=True, fmt='d', linewidths=.5)
    axes[i].set_title(f'Miesięczna Mapa Cieplna Tematów w {year} (YTD)')
    axes[i].set_ylabel('Temat')
plt.xlabel('Miesiąc')
plt.tight_layout()
plt.show()


# ==============================================================================
# KROK 6: ANALIZA ZMIAN W TEMATACH (MoM i YoY-M)
# ==============================================================================
print("\n--- Rozpoczęto analizę tematów w ujęciu miesięcznym ---")

# --- 6.1. Przygotowanie - Identyfikacja miesięcy do porównania ---
latest_date_in_data = df_raw['Data'].max()
last_full_month_date = latest_date_in_data - relativedelta(months=1) if latest_date_in_data.day > 5 else latest_date_in_data - relativedelta(months=2)
lfm_year, lfm_month = last_full_month_date.year, last_full_month_date.month

prev_month_date = last_full_month_date - relativedelta(months=1)
pm_year, pm_month = prev_month_date.year, prev_month_date.month

lfm_prev_year_date = last_full_month_date - relativedelta(years=1)
lfm_py_year, lfm_py_month = lfm_prev_year_date.year, lfm_prev_year_date.month

print(f"Ostatni pełny miesiąc: {lfm_year}-{lfm_month:02d}")
print(f"Poprzedni miesiąc (do MoM): {pm_year}-{pm_month:02d}")
print(f"Ten sam miesiąc, rok wcześniej (do YoY-M): {lfm_py_year}-{lfm_py_month:02d}")

# --- 6.2. Analiza Miesiąc do Miesiąca (MoM) ---
df_mom = df_raw[((df_raw['Rok'] == lfm_year) & (df_raw['Miesiac'] == lfm_month)) | ((df_raw['Rok'] == pm_year) & (df_raw['Miesiac'] == pm_month))].copy()

if not df_mom.empty and len(df_mom['Rok'].unique()) > 1:
    mom_counts = df_mom.groupby(['Rok', 'Miesiac', 'Temat'])['callid'].count().unstack(level=[0, 1], fill_value=0)
    col_lfm = (lfm_year, lfm_month)
    col_pm = (pm_year, pm_month)
    if col_lfm in mom_counts.columns and col_pm in mom_counts.columns:
        mom_counts['zmiana_proc'] = ((mom_counts[col_lfm] - mom_counts[col_pm]) / mom_counts[col_pm]) * 100
        mom_counts.replace([np.inf, -np.inf], 0, inplace=True)
        
        fig, axes = plt.subplots(1, 2, figsize=(20, 8))
        sns.barplot(ax=axes[0], x=mom_counts.nlargest(5, 'zmiana_proc')['zmiana_proc'], y=mom_counts.nlargest(5, 'zmiana_proc').index, palette='Greens_r')
        axes[0].set_title(f'Wzrosty Tematów (MoM): {lfm_month:02d}-{lfm_year} vs {pm_month:02d}-{pm_year}')
        sns.barplot(ax=axes[1], x=mom_counts.nsmallest(5, 'zmiana_proc')['zmiana_proc'], y=mom_counts.nsmallest(5, 'zmiana_proc').index, palette='Reds_r')
        axes[1].set_title(f'Spadki Tematów (MoM)')
        plt.tight_layout()
        plt.show()
    else: print("⚠️ Brak wystarczających danych do porównania MoM.")
else: print("⚠️ Brak danych dla wybranych miesięcy do analizy MoM.")

# --- 6.3. Analiza Miesiąca Rok do Roku (YoY-M) ---
df_yoy_m = df_raw[((df_raw['Rok'] == lfm_year) & (df_raw['Miesiac'] == lfm_month)) | ((df_raw['Rok'] == lfm_py_year) & (df_raw['Miesiac'] == lfm_py_month))].copy()

if not df_yoy_m.empty and len(df_yoy_m['Rok'].unique()) > 1:
    yoy_m_pivot = df_yoy_m.groupby(['Rok', 'Temat'])['callid'].count().unstack(level=0, fill_value=0)
    if lfm_year in yoy_m_pivot.columns and lfm_py_year in yoy_m_pivot.columns:
        yoy_m_pivot['zmiana_proc'] = ((yoy_m_pivot[lfm_year] - yoy_m_pivot[lfm_py_year]) / yoy_m_pivot[lfm_py_year]) * 100
        yoy_m_pivot.replace([np.inf, -np.inf], 0, inplace=True)
        
        fig, axes = plt.subplots(1, 2, figsize=(20, 8))
        sns.barplot(ax=axes[0], x=yoy_m_pivot.nlargest(5, 'zmiana_proc')['zmiana_proc'], y=yoy_m_pivot.nlargest(5, 'zmiana_proc').index, palette='Blues_r')
        axes[0].set_title(f'Wzrosty Tematów (YoY): {lfm_month:02d}-{lfm_year} vs {lfm_month:02d}-{lfm_py_year}')
        sns.barplot(ax=axes[1], x=yoy_m_pivot.nsmallest(5, 'zmiana_proc')['zmiana_proc'], y=yoy_m_pivot.nsmallest(5, 'zmiana_proc').index, palette='Oranges_r')
        axes[1].set_title(f'Spadki Tematów (YoY)')
        plt.tight_layout()
        plt.show()
    else: print("⚠️ Brak wystarczających danych do porównania YoY dla wybranego miesiąca.")
else: print("⚠️ Brak danych dla wybranych miesięcy do analizy YoY-M.")


# ==============================================================================
# KROK 7: GŁĘBSZA ANALIZA (BONUS)
# ==============================================================================
print("\n--- Rozpoczęto analizy dodatkowe (bonus) ---")

# --- 7.1. Dystrybucja Czasu Trwania Rozmów ---
fig, axes = plt.subplots(1, 2, figsize=(20, 8), sharey=True)
sns.histplot(ax=axes[0], data=df_answered_ytd[df_answered_ytd['Rok'] == previous_year], x='czas_rozmowy', bins=50, kde=True)
axes[0].set_title(f'Dystrybucja Czasu Rozmów w {previous_year} (YTD)')
axes[0].axvline(aht_ytd.loc[aht_ytd['Rok'] == previous_year, 'Sredni_AHT_s'].iloc[0], color='red', linestyle='--', label='Średnia (AHT)')
axes[0].legend()

sns.histplot(ax=axes[1], data=df_answered_ytd[df_answered_ytd['Rok'] == current_year], x='czas_rozmowy', bins=50, kde=True, color='orange')
axes[1].set_title(f'Dystrybucja Czasu Rozmów w {current_year} (YTD)')
axes[1].axvline(aht_ytd.loc[aht_ytd['Rok'] == current_year, 'Sredni_AHT_s'].iloc[0], color='red', linestyle='--', label='Średnia (AHT)')
axes[1].legend()
plt.suptitle('Porównanie Dystrybucji Czasu Rozmów (YTD)', fontsize=22)
plt.show()

# --- 7.2. Analiza obciążenia w ciągu dnia ---
hourly_volume_ytd = df_ytd.groupby(['Rok', 'Godzina'])['callid'].nunique().reset_index()
g = sns.FacetGrid(hourly_volume_ytd, col="Rok", height=6, aspect=1.5)
g.map(sns.barplot, "Godzina", "callid", order=range(24), palette=['skyblue', 'lightcoral'])
g.set_axis_labels("Godzina Dnia", "Liczba Połączeń")
g.set_titles(col_template="Rok {col_name}")
g.fig.suptitle('Rozkład Połączeń w Ciągu Dnia (YTD)', y=1.03, fontsize=20)
plt.show()


# ==============================================================================
# KROK 8: PODSUMOWANIE I REKOMENDACJE BIZNESOWE
# ==============================================================================
print("\n\n" + "="*80)
print("💡 KOMPLEKSOWE PODSUMOWANIE WNIOSKÓW I REKOMENDACJE BIZNESOWE 💡")
print("="*80)
print(f"""
Analiza porównawcza dla okresu YTD oraz w ujęciu miesięcznym dostarcza wielowymiarowego obrazu działania infolinii:

### Perspektywa Strategiczna (Analiza YTD)

1.  **Ogólny Wolumen:** Zaobserwowaliśmy {'wzrost' if yoy_change > 0 else 'spadek'} całkowitego wolumenu unikalnych interakcji o **{yoy_change:.2f}%**. Jest to kluczowy wskaźnik ogólnego zapotrzebowania na wsparcie.
2.  **Efektywność Operacyjna (AHT):** Średni czas obsługi zmienił się z **{aht_ytd.loc[aht_ytd['Rok'] == previous_year, 'Sredni_AHT_s'].iloc[0]:.1f}s** na **{aht_ytd.loc[aht_ytd['Rok'] == current_year, 'Sredni_AHT_s'].iloc[0]:.1f}s**. Należy to skorelować ze zmianami w tematyce - czy rozmowy stają się bardziej skomplikowane?
3.  **Długofalowe Trendy w Tematach:** Analiza YTD pokazuje, że tematy takie jak **[wpisz temat z największym wzrostem YTD]** systematycznie zyskują na znaczeniu. Może to być sygnał do strategicznych zmian w produkcie, komunikacji lub procesach, aby zredukować liczbę tych zapytań w przyszłości.

### Perspektywa Taktyczna i Sezonowa (Analiza Miesiąca Rok do Roku - YoY-M)

4.  **Weryfikacja Sezonowości:** Porównanie miesiąca {lfm_month:02d}-{lfm_year} z {lfm_month:02d}-{lfm_py_year} pozwala ocenić, czy obecne trendy są anomalią, czy powtarzalnym wzorcem.
    - **Rekomendacja:** Jeśli np. temat 'Oferta' rośnie co roku w tym samym miesiącu, można proaktywnie przygotować zespół i kampanie. Jeśli wzrost jest w tym roku wyjątkowo wysoki, należy zbadać przyczynę (np. skuteczność nowej kampanii marketingowej).

### Perspektywa Operacyjna (Analiza Miesiąc do Miesiąca - MoM)

5.  **System Wczesnego Ostrzegania:** Porównanie miesiąca {lfm_month:02d}-{lfm_year} z {pm_month:02d}-{pm_year} to najlepszy barometr bieżących problemów.
    - **Rekomendacja:** Nagły wzrost tematu **[wpisz temat z największym wzrostem MoM]** powinien być natychmiastowym sygnałem dla odpowiedniego działu (np. IT w przypadku 'Problemów technicznych', Finansów dla 'Faktur'). Regularne monitorowanie tego wskaźnika pozwala na błyskawiczne gaszenie "pożarów".

### Wnioski Ogólne:

- **Od Ogółu do Szczegółu:** Analizę należy rozpoczynać od ogólnego wolumenu (YTD), a następnie zagłębiać się w przyczyny zmian, analizując tematy w różnych horyzontach czasowych.
- **Klucz to Tematy:** Zrozumienie, **DLACZEGO** klienci się kontaktują (tematy), jest ważniejsze niż wiedza, **JAK CZĘSTO** to robią (wolumen).
- **Proaktywność:** Połączenie tych trzech perspektyw analitycznych pozwala przejść od reaktywnego odpowiadania na problemy do proaktywnego zarządzania doświadczeniem klienta.
""")
print("="*80)

