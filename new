To typowy niuans biblioteki Qt. Przycisk "Zamknij" w Twoim kodzie był podłączony do metody self.accept (standardowe zachowanie dla dialogów), która zamyka okno, ale nie zawsze wyzwala zdarzenie closeEvent (gdzie umieściliśmy logikę zapisu), zwłaszcza jeśli okno nie jest modalne.
Aby to naprawić, musimy zmienić akcję przycisku "Zamknij" tak, aby wywoływał metodę self.close(). To zadziała tak samo jak kliknięcie "X" w rogu okna i zagwarantuje uruchomienie logiki zapisu.
Oto poprawka w pliku staffing_details_window.py.
Plik: staffing_details_window.py
Znajdź metodę setup_ui i popraw linię łączącą przycisk close_button.
    def setup_ui(self):
        main_layout = QVBoxLayout(self)
        self.info_label = QLabel(f"Analiza obsady i zdarzeń dla miesiąca: {self._month:02}.{self._year}")
        main_layout.addWidget(self.info_label)
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)

        self._create_hourly_staffing_tab()
        self._create_daily_staffing_tab()
        self._create_forecast_tab()
        self._create_overtime_tab()
        self._create_symbols_tab()
        self._create_absence_analysis_tab()
        self._create_flexibility_analysis_tab()

        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()
        self.refresh_button = QPushButton("Odśwież")
        self.refresh_button.clicked.connect(self.load_and_display_data)
        
        self.close_button = QPushButton("Zamknij")
        
        # --- POPRAWKA: Zmiana z self.accept na self.close ---
        # self.close() wymusza wywołanie closeEvent, gdzie jest logika zapisu.
        self.close_button.clicked.connect(self.close)
        # ----------------------------------------------------
        
        buttons_layout.addWidget(self.refresh_button)
        buttons_layout.addWidget(self.close_button)
        main_layout.addLayout(buttons_layout)

Dla pewności upewnij się, że metoda closeEvent (którą podałem w poprzedniej odpowiedzi) jest nadal w klasie StaffingDetailsWindow:
    def closeEvent(self, event):
        """Zapisuje aktualne wymiary okna do ustawień i wymusza zapis do bazy."""
        if self.parent_widget and hasattr(self.parent_widget, 'user_app_settings'):
            # 1. Zapisz wymiary do słownika ustawień w pamięci głównego okna
            current_size = (self.width(), self.height())
            self.parent_widget.user_app_settings['staffing_window_size'] = current_size
            
            # 2. Wymuś natychmiastowy zapis do bazy danych SQL
            if hasattr(self.parent_widget, 'settings_db'):
                self.parent_widget.settings_db.save_settings(
                    self.parent_widget.user_app_settings
                )
            
        event.accept()

Teraz zarówno krzyżyk ("X"), jak i przycisk "Zamknij" wywołają ten sam kod i zapiszą rozmiar okna.


Rozumiem. Problem wynika z tego, że obecna logika w _predict_new_symbol automatycznie zakłada, że jeśli wstawiamy absencję w dzień wolny (pusty), to system powinien pobrać etat i wstawić np. "8;U" (szczególnie w systemie równoważnym).
Dla roli Lider musimy zablokować to zachowanie na etapie filtrowania komórek, zanim trafią one do przetwarzania.
Należy zmodyfikować metodę _apply_special_symbol_to_selection w pliku main.py.
Plik: main.py
Zastąp metodę _apply_special_symbol_to_selection poniższą wersją. Dodałem w niej nową listę skipped_day_off oraz warunek sprawdzający, czy komórka jest pusta.
    def _apply_special_symbol_to_selection(self, special_symbol: str):
        """
        Aplikuje symbol specjalny do zaznaczonych komórek z uwzględnieniem logiki Lidera:
        1. Blokada wstawiania U/OS nie-Liderom.
        2. Blokada wstawiania absencji w dni wolne (puste).
        """
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not selected_cells_data:
            self.statusBar().showMessage("Nie zaznaczono żadnych komórek do edycji.", 3000)
            return

        if not self._can_modify_cells(selected_cells_data):
            return

        special_symbol_upper = special_symbol.upper()
        user_role = self.current_user_app_role
        
        # Czy to jest symbol absencji? (np. U, L4, ale nie HO, DYS)
        is_absence = special_symbol_upper in app_settings.get_absence_symbols()

        show_vacation_plan_warning = False
        cells_to_process = []
        
        # Listy pominiętych
        skipped_restricted_symbol = [] 
        skipped_day_off = [] # <--- NOWA LISTA

        for cell_data in selected_cells_data:
            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_edit_symbol']:
                continue

            target_role = cell_data.get('rola_nazwa', '')
            current_symbol_str = cell_data.get('symbol', '')
            parsed_current = parse_symbol(current_symbol_str)
            current_special = (parsed_current.get('special_symbol') or '').upper()
            
            # Sprawdź czy dzień jest wolny (brak godzin pracy)
            is_day_off = parsed_current.get('work_hours') is None

            # --- NOWA LOGIKA: LIDER + DZIEŃ WOLNY + ABSENCJA ---
            if user_role == 'Lider' and is_day_off and is_absence:
                skipped_day_off.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue
            # ---------------------------------------------------

            # Logika: Lider może wstawić "U" lub "OS" TYLKO osobie w roli Lider.
            if user_role == 'Lider':
                if special_symbol_upper in ['U', 'OS']:
                    if target_role != 'Lider':
                        skipped_restricted_symbol.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                        continue
            
            # Ostrzeżenie przy zmianie 'U' na co innego
            if current_special in ['U', 'UZ'] and special_symbol_upper not in ['U', 'UZ'] and special_symbol_upper:
                show_vacation_plan_warning = True

            cells_to_process.append(cell_data)

        # --- KOMUNIKATY O POMINIĘCIACH ---
        
        if skipped_restricted_symbol:
            QMessageBox.warning(self, "Ograniczenia uprawnień",
                                f"Symbol '{special_symbol_upper}' może być wstawiony przez Lidera TYLKO innemu Liderowi.<br>"
                                f"Pominięto zmiany dla:<br>- {', '.join(set(skipped_restricted_symbol))}")

        # Nowy komunikat dla dni wolnych
        if skipped_day_off:
             # Opcjonalnie: pokaż komunikat, lub po prostu statusbar, żeby nie spamować oknami
             # Tutaj wersja z Info, bo to ważna reguła biznesowa
             if len(skipped_day_off) > 5:
                 msg_users = f"{len(skipped_day_off)} komórek"
             else:
                 msg_users = "<br>- ".join(set(skipped_day_off))
                 
             self.statusBar().showMessage(f"Pominięto wstawianie absencji w dni wolne dla: {msg_users}", 5000)
             # Jeśli wolisz okno dialogowe, odkomentuj poniższe:
             # QMessageBox.information(self, "Pominięto dni wolne", 
             #                        f"Jako Lider nie możesz wstawiać absencji w dni wolne od pracy.<br>"
             #                        f"Pominięto: {msg_users}")

        if not cells_to_process:
            return

        # --- RESZTA BEZ ZMIAN ---
        
        events_to_cancel = []
        if is_absence:
            user_date_pairs = {(c.get('uzytkownik_id'), c.get('date_str')) for c in cells_to_process}
            events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        reply = QMessageBox.Yes
        if self._should_ask_for_confirmation():
            grouped_changes = self._group_cells_for_symbol_changes(cells_to_process)
            changes_info = self._prepare_symbol_changes_description(grouped_changes, special_symbol)
            complete_info = f"Czy na pewno chcesz wprowadzić następujące zmiany?{changes_info}"
            
            if show_vacation_plan_warning:
                complete_info += "<br><br><b><font color='orange'>UWAGA:</font> Zmieniasz 'U' na inny symbol. Pamiętaj o usunięciu urlopu z planów urlopowych!</b>"

            if events_to_cancel:
                grouped_events = self._group_events_by_user_date(events_to_cancel)
                delegations_info = self._prepare_delegations_description(grouped_events)
                complete_info += f"<br>{delegations_info}"
            
            reply = show_confirmation_dialog(self, "Potwierdzenie wstawienia symbolu", complete_info)

        if reply != QMessageBox.Yes:
            return

        if events_to_cancel:
            self.cancel_delegations(ask_for_confirmation=False)

        change_requests = []
        for cell_data in cells_to_process:
            new_symbol = self._predict_new_symbol(cell_data.get('symbol', ''), special_symbol, cell_data)
            change_requests.append((ChangeType.APPLY_SPECIAL_SYMBOL, cell_data, special_symbol))

        if change_requests:
            self.schedule_change_processor.start_changes(change_requests)
            if show_vacation_plan_warning and not self._should_ask_for_confirmation():
                 QMessageBox.information(self, "Przypomnienie", "Zmieniono symbol urlopu. Pamiętaj o usunięciu go z planów urlopowych.")

Co się zmieniło?
 * Definicja Dnia Wolnego: Dodano is_day_off = parsed_current.get('work_hours') is None.
 * Nowy Warunek: W pętli dodano blok:
   if user_role == 'Lider' and is_day_off and is_absence:
    # pomiń

   Dzięki temu, jeśli Lider wybierze pustą komórkę i spróbuje wstawić "U" lub "L4" (lub cokolwiek ze zbioru absencji), kod po prostu pominie tę komórkę, nie próbując jej wypełniać domyślnymi godzinami.
 * Kompatybilność: To działa zarówno przy wyborze z klawiatury (wpisanie "U"), jak i przez okno dialogowe (wybranie przycisku "U"), ponieważ obie metody korzystają z tej samej funkcji _apply_special_symbol_to_selection.



Problem wynika z tego, że metoda _predict_new_symbol domyślnie pobiera godziny i lokalizację z istniejącego symbolu. W przypadku dnia wolnego (pustego), tych danych nie ma (None), a logika "Lidera OUT" była zaimplementowana wcześniej w pętli, a nie w samym predyktorze.
Przeniesiemy logikę "wypełniania pustego dnia" dla Lidera OUT bezpośrednio do metody obliczającej nowy symbol.
Oto poprawiona metoda _predict_new_symbol. Wklej ją do pliku main.py.
Plik: main.py
Zastąp istniejącą metodę _predict_new_symbol tą wersją:
    def _predict_new_symbol(self, current_symbol: str, special_symbol: str, cell_data: dict) -> str:
        """
        Przewiduje nowy symbol.
        Dla Lidera OUT w dzień wolny automatycznie ustawia start na 9:00 i godziny z etatu.
        """
        parsed_current = parse_symbol(current_symbol)

        final_start_hour = parsed_current.get('start_hour')
        final_work_hours = parsed_current.get('work_hours')
        
        # Sprawdź czy to dzień wolny (brak godzin pracy)
        is_day_off = final_work_hours is None

        # --- NOWA LOGIKA DLA LIDERA OUT W DZIEŃ WOLNY ---
        if self.current_user_app_role == 'Lider OUT' and is_day_off:
            # 1. Sztywna godzina rozpoczęcia
            final_start_hour = 9
            
            # 2. Pobranie godzin z etatu
            try:
                etat_val = float(cell_data.get('etat', 0) or 0)
                # Jeśli etat jest zapisany jako ułamek (np. 1.0, 0.5) -> przelicz na godziny standardowe (x8)
                # Jeśli etat jest zapisany w godzinach (np. 7, 8) -> użyj wprost
                if 0 < etat_val <= 1.0:
                    final_work_hours = int(etat_val * 8)
                elif etat_val > 1.0:
                    final_work_hours = int(etat_val)
                else:
                    final_work_hours = 8 # Fallback
            except (ValueError, TypeError):
                final_work_hours = 8
            
            # 3. Wstępne ustawienie lokalizacji domyślnej w "sparsowanym" obiekcie, 
            # aby logika poniżej mogła z niej skorzystać
            parsed_current['location'] = cell_data.get('lokalizacja_domyslna')
        # ------------------------------------------------

        # Logika dla systemu równoważnego i absencji (zachowana z poprzedniej wersji)
        system_pracy = cell_data.get('system_czasu_pracy', '').strip().lower()
        is_equivalent_system = (system_pracy == 'równoważny')
        is_absence_symbol = special_symbol and special_symbol.upper() in app_settings.get_absence_symbols()

        if is_equivalent_system and is_absence_symbol and final_work_hours is None:
             # Jeśli system równoważny i brak godzin (a nie wpadło w logikę Lider OUT), spróbuj pobrać etat
             try:
                 etat_val = float(cell_data.get('etat', 0) or 0)
                 final_work_hours = int(etat_val) if etat_val > 1 else 8
             except:
                 final_work_hours = 8

        # --- USTALANIE LOKALIZACJI ---
        final_location = None
        
        # Lokalizację dodajemy TYLKO gdy:
        # 1. Symbol jest "pracujący" (np. HO, DYS, T, PR)
        # 2. LUB brak symbolu specjalnego (zwykła zmiana)
        is_work_like = (special_symbol and special_symbol.upper() in app_settings.WORK_LIKE_SYMBOLS)
        
        if is_work_like or not special_symbol:
            # Priorytet: 1. Lokalizacja z obecnego symbolu, 2. Domyślna lokalizacja pracownika (lub ta ustawiona dla Lidera OUT wyżej)
            current_loc = parsed_current.get('location')
            
            # Jeśli Lider OUT wstawia w dzień wolny, parsed_current['location'] został ustawiony w bloku wyżej
            # Jeśli to edycja istniejącego dnia, bierzemy to co było.
            if current_loc:
                final_location = current_loc
            else:
                # Fallback do funkcji SQL (determine_correct_location)
                final_location = self.determine_correct_location(cell_data)
        
        # Budowanie symbolu
        new_symbol = build_symbol(
            location=final_location,
            start_hour=final_start_hour,
            work_hours=final_work_hours,
            special_symbol=special_symbol
        )

        if not new_symbol.strip() and special_symbol and special_symbol.strip():
            return special_symbol.strip()

        return new_symbol.strip() if new_symbol else ""

Co naprawiono?
 * Start 9:00: Dodano blok if Lider OUT and day_off, który na sztywno ustawia final_start_hour = 9.
 * Godziny z etatu: Dodano przeliczanie etatu. Jeśli etat to 1.0, system wstawi 8 godzin. Jeśli 0.5, wstawi 4 godziny.
 * Lokalizacja:
   * Jeśli wstawiany symbol to np. HO (pracujący) -> system wstawi lokalizację domyślną (np. h) i powstanie h;9;8;HO.
   * Jeśli wstawiany symbol to U (absencja) -> system wstawi godziny, ale pominie lokalizację, tworząc 9;8;U (zgodnie z tym, że absencje zazwyczaj nie mają lokalizacji, ale Lider OUT chce mieć godziny).
