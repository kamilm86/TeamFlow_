Jasne, rozumiem. Chodzi o to, aby caÅ‚a logika wyjÄ…tkÃ³w lokalizacyjnych nie dotyczyÅ‚a pracownikÃ³w z wydziaÅ‚Ã³w, ktÃ³rych nazwa zawiera "WZP". To waÅ¼na reguÅ‚a biznesowa.
WprowadziÅ‚em dwuetapowe rozwiÄ…zanie, ktÃ³re w peÅ‚ni realizuje to zaÅ‚oÅ¼enie.
## Plan Zmian
 * Logika w Oknie "Wstaw zmianÄ™": Metoda zapisujÄ…ca zmiany w tym oknie zostanie zmodyfikowana. JeÅ›li wykryje, Å¼e edytowany pracownik naleÅ¼y do wydziaÅ‚u z "WZP" w nazwie, ominie caÅ‚Ä… logikÄ™ sprawdzania, dodawania czy usuwania wyjÄ…tkÃ³w i po prostu zapisze zmianÄ™ w grafiku.
 * Przycisk "WyjÄ…tki lokalizacyjne": Ten przycisk w gÅ‚Ã³wnym oknie aplikacji bÄ™dzie automatycznie nieaktywny, gdy zaznaczysz pracownika z wydziaÅ‚u "WZP", uniemoÅ¼liwiajÄ…c rÄ™czne zarzÄ…dzanie wyjÄ…tkami dla tej grupy.
## Zmiany w kodzie
### 1. Plik: schedule_edit_dialogs.py
ProszÄ™, zastÄ…p caÅ‚Ä… metodÄ™ _apply_change_for_row w klasie ScheduleChangeDialog poniÅ¼szÄ…, zaktualizowanÄ… wersjÄ….
# W pliku schedule_edit_dialogs.py, wewnÄ…trz klasy ScheduleChangeDialog

def _apply_change_for_row(self, visual_row_index):
    """Stosuje zmianÄ™ dla konkretnego wiersza, z logikÄ… wyjÄ…tkÃ³w i pominiÄ™ciem dla WZP."""
    button = self.cells_table.cellWidget(visual_row_index, 7)
    if not button or not button.isEnabled(): return

    status_item = self.cells_table.item(visual_row_index, 8)
    
    try:
        item = self.cells_table.item(visual_row_index, 0)
        if not item: raise ValueError("Nie moÅ¼na odnaleÅºÄ‡ elementu w wierszu.")
        original_data_index = item.data(Qt.UserRole)
        cell_data = self.flattened_cells[original_data_index]

        user_id = cell_data.get('uzytkownik_id')
        nr_kadrowy = cell_data.get('nr_kadrowy')
        user_name = cell_data.get('uzytkownik_dane')
        date_str = cell_data.get('date_str')
        q_date = QDate.fromString(date_str, "yyyy-MM-dd")
        _, modyfikujacy_id, _, _, _ = get_modifier_id()
        location_map = {'h': 1, 's': 3, 'p': 2}
        default_location_code = cell_data.get('lokalizacja_domyslna', 'h')
        target_dept = cell_data.get('wydzial', '') # Pobierz wydziaÅ‚ pracownika

        location_combo = self.cells_table.cellWidget(visual_row_index, 4)
        time_button = self.cells_table.cellWidget(visual_row_index, 5)
        hours_button = self.cells_table.cellWidget(visual_row_index, 6)
        
        from symbol_parser import parse_symbol, build_symbol
        original_parsed_symbol = parse_symbol(cell_data.get('symbol', ''))
        
        new_location_code = location_combo.currentData()
        new_start_hour = int(time_button.text())
        new_work_hours = int(hours_button.text())
        
        original_location_code = original_parsed_symbol.get('location') or default_location_code
        loc_changed = new_location_code != original_location_code
        is_reverting_to_default = loc_changed and (new_location_code == default_location_code)
        
        button.setEnabled(False)
        button.setText("Przetwarzanie...")
        QApplication.processEvents()

        result = {}
        new_symbol = build_symbol(
            location=new_location_code, start_hour=new_start_hour, work_hours=new_work_hours,
            special_symbol=original_parsed_symbol.get('special_symbol')
        )
        
        # --- POCZÄ„TEK NOWEJ LOGIKI ---
        # SprawdÅº, czy wydziaÅ‚ to WZP. JeÅ›li tak, omiÅ„ caÅ‚Ä… logikÄ™ wyjÄ…tkÃ³w.
        if 'wzp' in target_dept.lower():
            debug_print(f"-> Wykryto wydziaÅ‚ WZP ({target_dept}). Omijam logikÄ™ wyjÄ…tkÃ³w lokalizacyjnych.")
            result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year, self.month, date_str, new_symbol)
        # --- KONIEC NOWEJ LOGIKI ---
        elif loc_changed:
            # Tutaj znajduje siÄ™ caÅ‚a poprzednia, zÅ‚oÅ¼ona logika wyjÄ…tkÃ³w dla innych wydziaÅ‚Ã³w
            exact_exception, range_exception = self.parent_widget._check_location_exception(user_id, q_date)
            # ... (reszta logiki wyjÄ…tkÃ³w bez zmian)
        else:
            # JeÅ›li lokalizacja siÄ™ nie zmieniÅ‚a, zapisz normalnie
            result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year, self.month, date_str, new_symbol)
        
        # PozostaÅ‚a czÄ™Å›Ä‡ metody do wyÅ›wietlania wyniku jest bez zmian, dla pewnoÅ›ci wklejam caÅ‚oÅ›Ä‡
        if result.get("success", False):
            status_item.setText("Sukces âœ…"); status_item.setForeground(QColor("green"))
            returned_symbol = result.get('returned_symbol', new_symbol)
            self.cells_table.item(visual_row_index, 3).setText(returned_symbol)
            self.parent_widget._update_cells_with_new_symbols([(user_id, date_str, returned_symbol)])
            self.parent_widget.schedule_model.layoutChanged.emit()
            self.flattened_cells[original_data_index]['symbol'] = returned_symbol
        else:
            status_item.setText("PoraÅ¼ka âŒ"); status_item.setForeground(QColor("red"))
            error_msg = result.get("message", "Nieznany bÅ‚Ä…d.")
            QMessageBox.warning(self, "BÅ‚Ä…d", f"ğŸ‘¤ {user_name} ({self.format_date(date_str)}):\n{error_msg}", QMessageBox.Ok)
    
    except Exception as e:
        if status_item: status_item.setText("PoraÅ¼ka âŒ"); status_item.setForeground(QColor("red"))
        log_error(f"BÅ‚Ä…d krytyczny w _apply_change_for_row: {e}", exception=e)
        QMessageBox.critical(self, "BÅ‚Ä…d krytyczny", f"WystÄ…piÅ‚ nieoczekiwany bÅ‚Ä…d: {str(e)}", QMessageBox.Ok)
    finally:
        QTimer.singleShot(1000, lambda b=button: self._reset_button_state(b))

### 2. Plik: main.py
Zaktualizuj metodÄ™ _handle_selection_change, aby dynamicznie blokowaÅ‚a przycisk "WyjÄ…tki lokalizacyjne".
# W pliku main.py, wewnÄ…trz klasy WorkScheduleWindow

def _handle_selection_change(self):
    """Faktyczna obsÅ‚uga zmiany zaznaczenia (wywoÅ‚ywana po debounce)."""
    if hasattr(self, '_updating_selection') and self._updating_selection:
        return

    self._updating_selection = True
    try:
        selected_cells_data = self.table.get_data_for_selected_cells()

        # --- POCZÄ„TEK POPRAWKI: WÅ‚Ä…czanie/wyÅ‚Ä…czanie przycisku wyjÄ…tkÃ³w ---
        enable_exception_button = False
        if selected_cells_data:
            user_ids = {cell['uzytkownik_id'] for cell in selected_cells_data}
            if len(user_ids) == 1: # Przycisk aktywny tylko dla jednego zaznaczonego pracownika
                first_cell = selected_cells_data[0]
                department = first_cell.get('wydzial', '').lower()
                if 'wzp' not in department:
                    enable_exception_button = True
        
        if hasattr(self, 'location_exception_button'):
            self.location_exception_button.setEnabled(enable_exception_button)
        # --- KONIEC POPRAWKI ---

        if selected_cells_data:
            events = []
            for cell_data in selected_cells_data:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    user_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                    for event in user_events:
                        local_event = self._convert_dp_event_to_local(event)
                        events.append(local_event)
            self.events_data = events
            if hasattr(self, 'events_model'):
                self.events_model.update_data(self.events_data)
                self.filter_events_table()
        else:
            self.events_data = []
            if hasattr(self, 'events_model'):
                self.events_model.update_data([])
    finally:
        self._updating_selection = False

Po tych zmianach aplikacja bÄ™dzie poprawnie ignorowaÄ‡ caÅ‚Ä… logikÄ™ wyjÄ…tkÃ³w lokalizacyjnych dla wszystkich wydziaÅ‚Ã³w zawierajÄ…cych w nazwie "WZP".
