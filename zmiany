# W metodzie _setup_connections w klasie DatabaseManager

# ... (pętla for section in config.sections():)

        if clean_section == 'impala':
            try:
                host = config.get(section, 'HOST')
                port = config.get(section, 'PORT')
                
                # Budujemy podstawowy connection string
                connection_string = (
                    f"impala://{host}:{port}/default"
                    "?auth_mechanism=GSSAPI"
                    "&kerberos_service_name=impala"
                )
                
                # --- NOWA, POPRAWIONA LOGIKA OBSŁUGI SSL ---
                # Sprawdzamy, czy SSL jest włączony w konfiguracji
                use_ssl = config.getboolean(section, 'SSL', fallback=False)

                if use_ssl:
                    self.logger.info(f"Wykryto konfigurację SSL dla '{section}'.")
                    # Pobieramy ścieżkę do certyfikatu
                    ca_certs_path = config.get(section, 'TrustedCerts', fallback=None)
                    if not ca_certs_path:
                        raise ValueError(f"SSL jest włączony dla '{section}', ale brakuje klucza 'TrustedCerts' w pliku .ini")
                    
                    # Dodajemy parametry SSL do connection stringa
                    # Ważne: W SQLAlchemy używa się `ssl=true` a nie `SSL=1`
                    connection_string += f"&ssl=true&ssl_ca_cert={ca_certs_path}"
                
                self.connections[section] = connection_string
                self.logger.info(f"Utworzono SQLAlchemy connection string dla '{section}'.")

            except (configparser.NoOptionError, configparser.NoSectionError, ValueError) as e:
                self.logger.error(f"Błąd konfiguracji w odbc.ini dla sekcji '{section}': {e}")
                raise # Rzucamy błąd, aby zatrzymać program

# ... (reszta metody)
