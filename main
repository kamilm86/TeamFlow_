# -*- coding: utf-8 -*-
import sys
import time
import getpass
from datetime import datetime, timedelta
from typing import List, Dict
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill
from openpyxl.utils import get_column_letter
import functools

from PySide6.QtWidgets import (QApplication, QMainWindow, QTableView,
                               QVBoxLayout, QHBoxLayout, QWidget, QLabel, QComboBox,
                               QPushButton, QHeaderView, QAbstractItemView, QListWidget,
                               QListWidgetItem, QLineEdit, QDialog, QCheckBox, QFrame, QDateEdit,
                               QMessageBox, QSplitter, QStyledItemDelegate, QFileDialog,
                               QGridLayout, QSizePolicy, QScrollArea, QGroupBox, QStyle, QProgressDialog,
                               QStyleOptionViewItem)

from PySide6.QtCore import (Qt, Signal, QDate, QTimer, QEvent, QObject,
                            QItemSelection, QItemSelectionModel, QRect, QPoint, QSize)
from packaging.version import parse as parse_version
from PySide6.QtGui import QShortcut, QKeySequence, QFont, QColor, QStandardItem, QStandardItemModel, QPixmap, QPainter, \
    QPen, QIcon, QBrush, QPolygon, QPainterPath, QValidator

from data_provider import DataProvider
from db_connector import DatabaseConnector, get_modifier_id, load_all_app_settings
from config import APP_VERSION, SQL_OBJECTS, resource_path
from app_settings import app_settings
from settings_db import SettingsDatabase
from styles import AppStyles
from column_definitions import ColumnDefinitions
from schedule_model import (ScheduleTableModel, ROLE_DATA, ROLE_HAS_MEETING, ROLE_HAS_OVERTIME,
                            ROLE_SPECIAL_SYMBOL, ROLE_LOCATION_SYMBOL, ROLE_IS_SUGGESTED_OFF)  # Dodano importy r√≥l
from events_model import EventsTableModel
from split_table_view import SplitTableView
from schedule_edit_dialogs import ScheduleChangeDialog, ReasonDialog, OvertimeLocationDialog
from debug_utils import debug_print, log_warning, log_error, setup_logging, close_log_file
from symbol_parser import parse_symbol, build_symbol, get_symbol_description
from outlook_connector import create_outlook_email, create_email_from_template
from teams_connector import open_teams_chat
from async_operations import DelegationCanceler, LocationExceptionManager
from ui_utils import show_confirmation_dialog
from overtime_manager import OvertimeManager
from schedule_change_processor import ScheduleChangeProcessor, ChangeType
from preparation_thread import PreparationThread
from loading_indicator import ModernLoadingIndicator
from filter_select_dialog import FilterSelectDialog

class OvertimeItemDelegate(QStyledItemDelegate):
    """Delegat dla kom√≥rek tabeli grafiku."""

    def __init__(self, settings=None, parent=None):
        super().__init__(parent)
        self.settings = settings or {}

    def paint(self, painter: QPainter, option: QStyleOptionViewItem, index):
        try:
            painter.save()
            clip_path = QPainterPath()
            clip_path.addRoundedRect(option.rect, 4.0, 4.0)
            painter.setClipPath(clip_path)
            super().paint(painter, option, index)
            painter.restore()

            special_symbol = index.data(ROLE_SPECIAL_SYMBOL)
            location_symbol = index.data(ROLE_LOCATION_SYMBOL)
            has_meeting = index.data(ROLE_HAS_MEETING)
            has_overtime = index.data(ROLE_HAS_OVERTIME)
            is_suggested_off = index.data(ROLE_IS_SUGGESTED_OFF)

            painter.save()
            painter.setRenderHint(QPainter.Antialiasing)

            if has_meeting:
                marker_size = 7
                rect = QRect(option.rect.left() + 2, option.rect.bottom() - marker_size - 1, marker_size, marker_size)
                painter.setBrush(QBrush(QColor(255, 255, 255, 240)))
                painter.setPen(QPen(QColor(0, 0, 0, 220), 1.0))
                painter.drawEllipse(rect)

            if has_overtime:
                marker_size = 7
                x = option.rect.right() - marker_size - 1
                y = option.rect.bottom() - marker_size - 1
                triangle = QPolygon(
                    [QPoint(x, y + marker_size), QPoint(x + marker_size, y + marker_size), QPoint(x + marker_size, y)])
                painter.setBrush(QBrush(QColor(220, 0, 0, 220)))
                painter.setPen(QPen(Qt.black, 1.0))
                painter.drawPolygon(triangle)

            if is_suggested_off:
                # Nak≈Çadamy p√≥≈Çprzezroczysty zielony kolor na t≈Ço
                user_name = index.model().data(index.siblingAtColumn(2), Qt.DisplayRole)
                # debug_print(f"Delegate: Rysujƒô zielone t≈Ço dla {user_name} w kolumnie {index.column()}")
                painter.fillRect(option.rect, QColor(0, 100, 0, 100))

            show_special = self.settings.get('show_special_symbol', True)
            show_location = self.settings.get('show_location_symbol', True)
            special_pos = self.settings.get('special_symbol_position', 'top_left')
            location_pos = self.settings.get('location_symbol_position', 'top_right')

            if special_symbol and show_special:
                self._draw_text_with_background(painter, option, special_symbol, special_pos)
            if location_symbol and show_location:
                self._draw_text_with_background(painter, option, location_symbol, location_pos)

            painter.restore()
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas rysowania delegata: {e}")

    def _draw_text_with_background(self, painter: QPainter, option: QStyleOptionViewItem, text: str, position: str):
        icon_font = QFont(option.font)
        font_size_map = {7: 6, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10}
        icon_font_size = font_size_map.get(option.font.pointSize(), 7)
        icon_font.setPointSize(icon_font_size)
        painter.setFont(icon_font)
        metrics = painter.fontMetrics()
        text_width = metrics.horizontalAdvance(text)
        text_height = metrics.ascent() + metrics.descent()

        bg_rect = QRect(0, 0, text_width, text_height)
        bg_rect.adjust(0, 1, 0, -1)
        bg_rect.adjust(-1, 0, 1, 0)

        if position == 'top_left':
            bg_rect.moveTo(option.rect.topLeft() + QPoint(1, 1))
        elif position == 'top_right':
            bg_rect.moveTo(option.rect.topRight() - QPoint(bg_rect.width() - 1, -1))

        painter.setBrush(QColor(Qt.white))
        painter.setPen(Qt.NoPen)
        painter.drawRoundedRect(bg_rect, 3, 3)
        painter.setPen(QColor(Qt.black))
        painter.drawText(bg_rect, Qt.AlignCenter, text)


class ButtonDelegate(QStyledItemDelegate):
    button_clicked = Signal(int)

    def __init__(self, parent=None, button_text="Odwo≈Çaj", is_dark_theme=False):
        super().__init__(parent)
        self.button_text = button_text
        self.is_dark_theme = is_dark_theme
        self._pressed_row = -1

    def paint(self, painter, option, index):
        event_data = index.model().data(index, Qt.UserRole)
        status = event_data.get('status', '')
        is_disabled = status in ["Do delegacji", "Usuniƒôty"]
        button_rect = QRect(option.rect).adjusted(4, 4, -4, -4)
        painter.save()
        painter.setRenderHint(QPainter.Antialiasing)
        if is_disabled:
            bg_color = QColor("#5a5a5a") if self.is_dark_theme else QColor("#d3d3d3")
            text_color = QColor("#888888") if self.is_dark_theme else QColor("#a0a0a0")
        elif self._pressed_row == index.row():
            bg_color = QColor("#c0392b")
        else:
            bg_color = QColor("#e74c3c")
        painter.setBrush(bg_color)
        painter.setPen(Qt.NoPen)
        painter.drawRoundedRect(button_rect, 3, 3)
        painter.setPen(text_color if is_disabled else QColor("white"))
        painter.drawText(button_rect, Qt.AlignCenter, self.button_text)
        painter.restore()

    def editorEvent(self, event, model, option, index):
        event_data = index.data(Qt.UserRole)
        status = event_data.get('status', '')
        if status in ["Do delegacji", "Usuniƒôty"]: return False
        if event.type() == QEvent.MouseButtonPress and option.rect.contains(event.position().toPoint()):
            self._pressed_row = index.row()
            return True
        elif event.type() == QEvent.MouseButtonRelease and self._pressed_row == index.row():
            self._pressed_row = -1
            self.button_clicked.emit(index.row())
            return True
        elif event.type() == QEvent.Leave:
            self._pressed_row = -1
        return False


class ScheduleKeyboardFilter(QObject):
    """
    Dedykowany filtr zdarze≈Ñ klawiatury dla tabeli grafiku z obs≈Çuga:
    - dwucyfrowych godzin i wieloznakowych symboli (z buforowaniem)
    - modyfikacji liczby godzin (+/-/=) z poprawnym od≈õwie≈ºaniem bilansu.
    """

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self._digit_buffer = ""
        self._buffer_timer = QTimer()
        self._buffer_timer.setSingleShot(True)
        self._buffer_timer.timeout.connect(self._process_digit_buffer_on_timeout)
        self._buffer_timeout = 1200
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1200

        # Bufor i timer dla wieloznakowych symboli
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1200

    def eventFilter(self, obj, event):
        """G≈Ç√≥wna metoda filtrujƒÖca zdarzenia klawiatury."""
        if not (hasattr(self.main_window, 'table') and
                hasattr(self.main_window.table, 'schedule_view') and
                obj == self.main_window.table.schedule_view and
                event.type() == QEvent.KeyPress):
            return False

        key = event.key()
        role = self.main_window.current_user_app_role

        if key in (Qt.Key_Plus, Qt.Key_Equal, Qt.Key_Minus):
            self._clear_digit_buffer()
            self._clear_char_buffer()
            # ZMIANA: Odwo≈Çanie do app_settings
            if app_settings.has_permission(role, 'schedule_keyboard_edit'):
                self._handle_hour_modification(key)
            return True

        # ZMIANA: Odwo≈Çanie do app_settings
        can_edit_hours_symbols = app_settings.has_permission(role, 'schedule_keyboard_edit')

        is_digit_key = (Qt.Key_0 <= key <= Qt.Key_9)
        is_char_key = (Qt.Key_A <= key <= Qt.Key_Z)
        is_delete_key = key in [Qt.Key_Delete, Qt.Key_Backspace]
        is_escape_key = key == Qt.Key_Escape

        if not can_edit_hours_symbols and (is_digit_key or is_char_key or is_delete_key):
            return True

        if is_digit_key or is_char_key or is_delete_key:
            if not self._validate_selected_cells():
                return True

        if is_digit_key:
            self._handle_digit_input(key - Qt.Key_0)
            return True

        if is_char_key:
            self._handle_char_input(event.text())
            return True

        if is_delete_key:
            # ZMIANA: Odwo≈Çanie do app_settings
            if app_settings.has_permission(role, 'action_delete_symbol'):
                self.main_window.clear_selected_cells()
            self._clear_digit_buffer()
            self._clear_char_buffer()
            return True

        if is_escape_key:
            self._clear_digit_buffer()
            self._clear_char_buffer()
            self.main_window.table.schedule_view.clearSelection()
            return True

        if key in [Qt.Key_Space, Qt.Key_Enter, Qt.Key_Return, Qt.Key_Tab]:
            return True

        return False

    def _handle_hour_modification(self, key):
        """Obs≈Çuguje zwiƒôkszanie/zmniejszanie liczby godzin (+/-/=) z uwzglƒôdnieniem uprawnie≈Ñ."""
        selected_cells_data = self.main_window.table.get_data_for_selected_cells()
        if not selected_cells_data: return

        updated_info = []
        error_messages = []
        skipped_count = 0
        permission_denied_count = 0
        current_user_role = self.main_window.current_user_app_role  # Pobierz rolƒô bie≈ºƒÖcego u≈ºytkownika

        for cell_data in selected_cells_data:
            permissions = self.main_window._get_permission_for_cell(cell_data)
            if not permissions['can_edit_hours']:
                permission_denied_count += 1
                continue

            system_pracy = cell_data.get('system_czasu_pracy', '')

            # --- POCZƒÑTEK ZMIANY ---
            # Sprawd≈∫ system pracy, ale zezw√≥l na edycjƒô dla roli 'Pracownik WPR'
            is_equivalent_system = system_pracy.strip().lower() == 'r√≥wnowa≈ºny'
            if not is_equivalent_system and current_user_role != 'Pracownik WPR':
                skipped_count += 1
                continue
            # --- KONIEC ZMIANY ---

            current_symbol = cell_data.get('symbol', '')
            if not current_symbol: continue

            try:
                parsed = parse_symbol(current_symbol)
                if parsed.get('work_hours') is None: continue

                current_hours = int(parsed['work_hours'])
                new_hours = min(12, current_hours + 1) if key in (Qt.Key_Plus, Qt.Key_Equal) else max(1,
                                                                                                      current_hours - 1)
                if new_hours == current_hours: continue

                new_symbol = build_symbol(
                    location=parsed.get('location'), start_hour=parsed.get('start_hour'),
                    work_hours=new_hours, special_symbol=parsed.get('special_symbol')
                )

                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self.main_window._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )

                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"‚ë≠ {cell_data.get('uzytkownik_dane')}: {result.get('message', 'B≈ÇƒÖd zapisu.')}")
            except (ValueError, TypeError) as e:
                log_warning(f"B≈ÇƒÖd modyfikacji godzin dla symbolu '{current_symbol}': {e}")
                error_messages.append(f"‚ë≠ {cell_data.get('uzytkownik_dane')}: B≈ÇƒÖd aplikacji: {e}")

        if permission_denied_count > 0:
            self.main_window.statusBar().showMessage(
                f"Pominiƒôto {permission_denied_count} kom√≥rek z powodu braku uprawnie≈Ñ do zmiany godzin.", 4000)

        if updated_info:
            self.main_window._update_cells_with_new_symbols(updated_info)
            self.main_window.statusBar().showMessage(f"Zmieniono liczbƒô godzin dla {len(updated_info)} kom√≥rek.", 4000)

        if error_messages:
            QMessageBox.warning(self.main_window, "B≈Çƒôdy podczas zapisu",
                                "WystƒÖpi≈Çy nastƒôpujƒÖce b≈Çƒôdy:<br><br>" + "<br>".join(error_messages))
        elif not updated_info and skipped_count > 0 and skipped_count == len(selected_cells_data):
            self.main_window.statusBar().showMessage("Operacja dozwolona tylko dla R√≥wnowa≈ºnego Systemu Czasu Pracy.",
                                                     5000)

    def _handle_char_input(self, char: str):
        self._clear_digit_buffer()
        self._char_buffer += char.upper()
        self.main_window.statusBar().showMessage(f"Wpisywanie symbolu: {self._char_buffer}", self._char_buffer_timeout)
        if len(self._char_buffer) >= 3:
            self._char_buffer_timer.stop()
            self._process_char_buffer()
        else:
            self._char_buffer_timer.start(self._char_buffer_timeout)

    def _process_char_buffer(self):
        symbol = self._char_buffer
        self._clear_char_buffer()
        if not symbol: return

        # Krok 1: Sprawd≈∫, czy symbol jest w og√≥le poprawny
        if symbol in self.main_window.get_all_valid_symbols():

            # --- POCZƒÑTEK POPRAWKI ---
            # Krok 2: Sprawd≈∫, czy bie≈ºƒÖca rola ma uprawnienia do tego symbolu
            current_role = self.main_window.current_user_app_role
            if app_settings.has_symbol_permission(current_role, symbol):
                self.main_window.apply_symbol_from_keyboard(symbol)
            else:
                # Symbol jest poprawny, ale u≈ºytkownik nie ma uprawnie≈Ñ
                self.main_window.statusBar().showMessage(
                    f"Brak uprawnie≈Ñ do u≈ºycia symbolu '{symbol}' dla Twojej roli.", 4000)
            # --- KONIEC POPRAWKI ---

        else:
            # Symbol jest nieprawid≈Çowy
            self.main_window.statusBar().showMessage(f"B≈ÇƒÖd: Symbol '{symbol}' jest nieprawid≈Çowy!", 4000)

    def _handle_digit_input(self, digit: int):
        self._clear_char_buffer()
        self._digit_buffer += str(digit)
        self.main_window.statusBar().showMessage(f"Wpisywanie godziny: {self._digit_buffer}", self._buffer_timeout)

        if len(self._digit_buffer) == 1:
            if int(self._digit_buffer) >= 3:
                self.main_window.quick_edit_selected_cells(int(self._digit_buffer))
                self._clear_digit_buffer()
            else:
                self._buffer_timer.start(self._buffer_timeout)
        elif len(self._digit_buffer) == 2:
            self._buffer_timer.stop()
            potential_hour = int(self._digit_buffer)
            hour = potential_hour if 0 <= potential_hour <= 23 else int(self._digit_buffer[0])
            self.main_window.quick_edit_selected_cells(hour)
            self._clear_digit_buffer()
        else:
            self._buffer_timer.stop()
            self.main_window.quick_edit_selected_cells(digit)
            self._clear_digit_buffer()

    def _process_digit_buffer_on_timeout(self):
        if self._digit_buffer:
            self.main_window.quick_edit_selected_cells(int(self._digit_buffer))
            self._clear_digit_buffer()

    def _clear_digit_buffer(self):
        self._digit_buffer = ""
        if self._buffer_timer.isActive(): self._buffer_timer.stop()
        if self.main_window.statusBar().currentMessage().startswith("Wpisywanie godziny:"):
            self.main_window.statusBar().clearMessage()

    def _clear_char_buffer(self):
        self._char_buffer = ""
        if self._char_buffer_timer.isActive(): self._char_buffer_timer.stop()
        if self.main_window.statusBar().currentMessage().startswith("Wpisywanie symbolu:"):
            self.main_window.statusBar().clearMessage()

    def _validate_selected_cells(self) -> bool:
        selected_cells_data = self.main_window.table.get_data_for_selected_cells()
        if not selected_cells_data: return False
        return self.main_window._can_modify_cells(selected_cells_data)


class CustomMultiComboBox(QComboBox):
    """Niestandardowy ComboBox z obs≈Çuga wielokrotnego wyboru (wersja poprawiona)."""
    selection_changed = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)

        self._selected_items = set()
        self._select_all_text = "-Wszystkie-"

        # Konfiguracja modelu
        self.setModel(QStandardItemModel(self))

        # Konfiguracja wyglƒÖdu
        self.setEditable(True)
        self.lineEdit().setReadOnly(True)
        self.setEditText("-Wszystkie-")
        self.setSizeAdjustPolicy(QComboBox.AdjustToContents)

        # U≈ºywamy filtra zdarze≈Ñ do przechwytywania klikniƒôƒá, co zapobiega zamykaniu listy
        self.view().viewport().installEventFilter(self)
        self.lineEdit().installEventFilter(self)

        # Delegat jest potrzebny do poprawnego renderowania
        self.setItemDelegate(QStyledItemDelegate(self))

    def eventFilter(self, obj, event):
        # Przechwytujemy klikniƒôcie myszƒÖ w polu tekstowym, aby pokazaƒá listƒô
        if obj == self.lineEdit() and event.type() == QEvent.MouseButtonPress:
            self.showPopup()
            return True

        # Przechwytujemy zwolnienie przycisku myszy na li≈õcie (widoku)
        if obj == self.view().viewport() and event.type() == QEvent.MouseButtonRelease:
            index = self.view().indexAt(event.position().toPoint())  # U≈ºyj .position().toPoint() zamiast .pos()
            if index.isValid():
                self.handle_item_pressed(index)
            return True

        return False

    def handle_item_pressed(self, index):
        """Logika zaznaczania/odznaczania elementu."""
        item = self.model().itemFromIndex(index)
        if not item:
            return

        if item.text() == self._select_all_text:
            # Logika dla przycisku "Zaznacz wszystkie"
            is_checked = (item.checkState() == Qt.Checked)
            new_state = Qt.Unchecked if is_checked else Qt.Checked
            for i in range(1, self.model().rowCount()):
                self.model().item(i).setCheckState(new_state)
        else:
            # Logika dla zwyk≈Çego elementu
            current_state = item.checkState()
            item.setCheckState(Qt.Checked if current_state == Qt.Unchecked else Qt.Unchecked)

        self._rebuild_selected_items()
        self.update_display_text()

        self.selection_changed.emit()

    def _rebuild_selected_items(self):
        """Przebudowuje zbi√≥r zaznaczonych element√≥w na podstawie stanu modelu."""
        self._selected_items.clear()
        all_selected = True
        # Pƒôtla od 1, aby pominƒÖƒá element "Zaznacz wszystkie"
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.checkState() == Qt.Checked:
                self._selected_items.add(item.text())
            else:
                all_selected = False

        # Aktualizuj stan checkboxa "Zaznacz wszystkie"
        if self.model().rowCount() > 0:
            select_all_item = self.model().item(0)
            select_all_item.setCheckState(Qt.Checked if all_selected else Qt.Unchecked)

    def hidePopup(self):
        """Aktualizuje tekst po zamkniƒôciu listy."""
        self.update_display_text()
        super().hidePopup()

    def add_items(self, items):
        """Dodaje elementy do ComboBoxa."""
        self.clear()

        select_all_item = QStandardItem(self._select_all_text)
        select_all_item.setCheckable(True)
        self.model().appendRow(select_all_item)

        for item_text in sorted(items):
            item = QStandardItem(item_text)
            item.setCheckable(True)
            self.model().appendRow(item)

        self.update_display_text()

    def showPopup(self):
        """Poka≈º menu rozwijane z dostosowanƒÖ szeroko≈õciƒÖ."""
        super().showPopup()

        width = self.view().sizeHintForColumn(0) + 20
        width = min(width, 450)
        self.view().setMinimumWidth(width)

    def clear(self):
        """Czy≈õci listƒô element√≥w."""
        self.model().clear()
        self._selected_items.clear()
        self.setEditText("-Wszystkie-")

    def clear_selection(self):
        """Czy≈õci zaznaczenie wszystkich element√≥w i emituje sygna≈Ç o zmianie."""
        for i in range(self.model().rowCount()):
            self.model().item(i).setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()
        # ZMIANA: Dodano emisjƒô sygna≈Çu, aby od≈õwie≈ºyƒá filtrowanie
        self.selection_changed.emit()

    def get_selected_items(self):
        """Zwraca listƒô zaznaczonych element√≥w."""
        return list(self._selected_items)

    def select_items(self, items_to_select):
        """Zaznacza programowo okre≈õlone elementy na li≈õcie."""
        lookup = set(items_to_select)
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.text() in lookup:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()

    def update_display_text(self):
        """Aktualizuje tekst wy≈õwietlany w comboboxie."""
        if not self._selected_items or len(self._selected_items) == (self.model().rowCount() - 1):
            self.setEditText("-Wszystkie-")
        else:
            self.setEditText(f"Wybrano {len(self._selected_items)} z {self.model().rowCount() - 1}")


class UpdateRequiredDialog(QDialog):
    """Modalne okno informujƒÖce o konieczno≈õci aktualizacji i wymuszajƒÖce zamkniƒôcie."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Wymagana aktualizacja")
        self.setModal(True)
        self.setWindowFlags(Qt.Dialog | Qt.CustomizeWindowHint | Qt.WindowTitleHint)

        self.countdown = 15

        layout = QVBoxLayout(self)
        info_label = QLabel(
            "<b>Dostƒôpna jest nowa wersja aplikacji.</b><br><br>"
            "Aby zapewniƒá sp√≥jno≈õƒá danych i dostƒôp do nowych funkcji, dalsza praca na tej wersji nie jest mo≈ºliwa.<br>"

        )
        info_label.setTextFormat(Qt.RichText)
        info_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(info_label)

        self.countdown_label = QLabel(f"Aplikacja zostanie zamkniƒôta za {self.countdown} sekund...")
        self.countdown_label.setAlignment(Qt.AlignCenter)
        self.countdown_label.setStyleSheet("font-weight: bold; color: #e74c3c;")
        layout.addWidget(self.countdown_label)

        self.timer = QTimer(self)
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.update_countdown)
        self.timer.start()

    def update_countdown(self):
        self.countdown -= 1
        self.countdown_label.setText(f"Aplikacja zostanie zamkniƒôta za {self.countdown} sekund...")
        if self.countdown <= 0:
            self.timer.stop()
            self.accept()


class WorkScheduleWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # Przechowuje referencjƒô do okna, aby nie zosta≈Ço "zjedzone" przez garbage collector
        self.schedule_control_win = None

        self._state_to_restore = None

        self.settings_db = SettingsDatabase()
        try:
            current_windows_user = getpass.getuser().lower()
        except Exception:
            current_windows_user = "unknown_user"

        self.user_app_settings = self.settings_db.load_settings(login_windows=current_windows_user)
        debug_print(f"ZA≈ÅADOWANE USTAWIENIA U≈ªYTKOWNIKA: {self.user_app_settings}")

        self.clear_icon_dark = self._create_clear_icon(QColor("#d0d0d0"))
        self.clear_icon_light = self._create_clear_icon(QColor("#505050"))
        self.is_dark_theme = self.user_app_settings.get('theme') == 'dark'
        self.current_font = self.user_app_settings.get('font_family', 'Segoe UI')
        self.current_font_size = self.user_app_settings.get('font_size', 9)
        self.import_grupa = self.user_app_settings.get('import_grupa', 3)
        self.import_funkcja = self.user_app_settings.get('import_funkcja', 1)
        self.column_definitions = ColumnDefinitions()
        self.default_visible_columns = self.column_definitions.DEFAULT_VISIBLE_COLUMNS
        saved_columns = self.user_app_settings.get('visible_columns')
        self.visible_columns = saved_columns if saved_columns else self.default_visible_columns.copy()
        self.user_sort_preferences = self.user_app_settings.get('sort_preferences', [])
        self.show_comment_column = self.user_app_settings.get('show_schedule_comment', False)

        # --- NOWA LOGIKA: Definicja wszystkich filtr√≥w ---
        # (filter_id, display_name, is_locked)
        self.ALL_FILTERS = [
            ('presence', "Obecni w pracy w dniu:", False),
            ('separator1', "--------------------", True),  # Separator te≈º jest "filtrem"
            ('grupa', "Grupa:", False),
            ('wydzial', "Wydzia≈Ç:", True),  # ZABLOKOWANY
            ('przelozony', "Prze≈Ço≈ºony:", True),  # ZABLOKOWANY
            ('uzytkownik', "U≈ºytkownik:", True),  # ZABLOKOWANY
            ('default_location', "LD:", False),
            ('system_czasu_pracy', "System Pracy:", False),
            ('rola', "Rola:", False),
            ('podrola', "PodRola:", False),
            ('jezyk', "Jƒôzyk:", False),
            ('etat', "Etat:", False),
            ('dtn', "DTN:", False),
            ('rka', "Rka:", False),
        ]

        # Mapa do szybkiego wyszukiwania widget√≥w po ich ID
        self.filter_widget_map = {}

        # Wczytaj zapisanƒÖ kolejno≈õƒá i widoczno≈õƒá
        saved_visible_filters = self.user_app_settings.get('visible_filters')
        if saved_visible_filters is None:
            # Je≈õli u≈ºytkownik nigdy nie zapisywa≈Ç, utw√≥rz domy≈õlnƒÖ listƒô
            self.visible_filters_list = [f_id for f_id, name, locked in self.ALL_FILTERS]
        else:
            self.visible_filters_list = saved_visible_filters

        # Upewnij siƒô, ≈ºe zablokowane filtry zawsze sƒÖ na li≈õcie (na wypadek uszkodzonych ustawie≈Ñ)
        for f_id, name, is_locked in self.ALL_FILTERS:
            if is_locked and f_id not in self.visible_filters_list:
                # Dodaj na rozsƒÖdnej pozycji (np. po 'grupa')
                try:
                    idx = self.visible_filters_list.index('grupa')
                    self.visible_filters_list.insert(idx + 1, f_id)
                except ValueError:
                    self.visible_filters_list.append(f_id)  # Dodaj na koniec, je≈õli nie ma 'grupa'
        # --- KONIEC NOWEJ LOGIKI ---

        self.staffing_details_win = None
        self.current_user_app_role = None
        self.data_provider = DataProvider()
        self.data_provider.data_changed.connect(self._handle_specific_icons_refresh)
        self.employee_columns = self.column_definitions.get_ui_display_columns()

        self.setWindowTitle("TeamFlowApp")

        self._selection_timer = QTimer()
        self._selection_timer.setSingleShot(True)
        self._selection_timer.timeout.connect(self._handle_selection_change)
        self._selection_debounce_delay = 50

        font = QFont(self.current_font, self.current_font_size)
        QApplication.setFont(font)

        self.schedule_change_processor = ScheduleChangeProcessor(self)
        self.delegation_canceler = DelegationCanceler(self)
        self.location_exception_manager = LocationExceptionManager(self)
        self.overtime_manager = OvertimeManager(self)

        self.schedule_model = ScheduleTableModel(self)
        self.schedule_model.set_visible_columns(self.visible_columns)
        self.events_model = EventsTableModel(self)

        self._create_central_widget()

        self._update_saved_filters_combo()
        self._update_delete_button_state()

        self.table.set_model(self.schedule_model)
        self.events_table.setModel(self.events_model)
        self.manage_columns_button.clicked.connect(self.show_column_select_dialog)

        if self.table.employees_view.selectionModel():
            self.table.employees_view.selectionModel().selectionChanged.connect(self.on_selection_changed)
        if self.table.schedule_view.selectionModel():
            self.table.schedule_view.selectionModel().selectionChanged.connect(self.on_selection_changed)

        self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font, self.current_font_size)

        self.shortcut_f1 = QShortcut(QKeySequence(Qt.Key_F1), self)
        self.shortcut_f1.activated.connect(self.toggle_left_panel)

        self.shortcut_f2 = QShortcut(QKeySequence(Qt.Key_F2), self)
        self.shortcut_f2.activated.connect(self.toggle_events_panel)

        self.shortcut_f3 = QShortcut(QKeySequence(Qt.Key_F3), self)
        self.shortcut_f3.activated.connect(self.show_insert_change_dialog)

        self.shortcut_f4 = QShortcut(QKeySequence(Qt.Key_F4), self)
        self.shortcut_f4.activated.connect(self.show_insert_symbol_dialog)

        self.shortcut_insert = QShortcut(QKeySequence(Qt.Key_Insert), self)
        self.shortcut_insert.activated.connect(self.show_add_overtime_dialog)
        self.shortcut_insert.setEnabled(False)

        self.shortcut_f12 = QShortcut(QKeySequence(Qt.Key_F12), self)
        self.shortcut_f12.activated.connect(self.clear_special_symbol_from_selected_cells)

        self.shortcut_f6 = QShortcut(QKeySequence(Qt.Key_F6), self)
        self.shortcut_f6.setContext(Qt.ShortcutContext.ApplicationShortcut)
        self.shortcut_f6.activated.connect(self.toggle_staffing_window_visibility)

        self.copy_shortcut = QShortcut(QKeySequence.Copy, self)
        self.copy_shortcut.activated.connect(self.copy_selection_to_clipboard)

        # --- NOWA ZMIANA: Skr√≥ty klawiszowe dla Teams i Outlook ---
        self.shortcut_teams = QShortcut(QKeySequence("Ctrl+T"), self)
        self.shortcut_teams.activated.connect(self.open_teams_chat_for_selection)
        self.shortcut_teams.setEnabled(False)

        self.shortcut_outlook = QShortcut(QKeySequence("Ctrl+O"), self)
        self.shortcut_outlook.activated.connect(self.send_email_to_selection)
        self.shortcut_outlook.setEnabled(False)
        # --- KONIEC ZMIANY ---

        self.start_full_initialization()

        # PRZENIESIONY BLOK: Ustawienie rozmiaru i pokazanie okna na samym ko≈Ñcu
        if self.user_app_settings.get('is_maximized'):
            self.showMaximized()
        else:
            width, height = self.user_app_settings.get('window_size', (1600, 800))
            self.setGeometry(100, 100, width, height)

        debug_print("=== APLIKACJA URUCHOMIONA W TRYBIE AUTOMATYCZNYM ===")

    def _on_schedule_control_closed(self):
        """Callback wywo≈Çywany po zamkniƒôciu okna 'ZarzƒÖdzaj grafikiem'."""
        debug_print("Okno 'ZarzƒÖdzaj grafikiem' zosta≈Ço zamkniƒôte, czyszczƒô referencjƒô.")
        self.schedule_control_win = None

    def manage_ui_state(self, enabled: bool):
        """W≈ÇƒÖcza lub wy≈ÇƒÖcza kluczowe elementy interfejsu u≈ºytkownika."""

        self.add_overtime_dialog_instance = None

        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(enabled)

        action_buttons = [
            self.settings_button, self.refresh_button, self.show_audit_button,
            self.staffing_details_button, self.schedule_control_button,
            self.manage_columns_button, self.toggle_events_panel_button,
            self.insert_change_button, self.insert_symbol_button,
            self.cancel_delegation_button, self.add_overtime_button
        ]
        for button in action_buttons:
            if hasattr(self, button.objectName()):
                button.setEnabled(enabled)

        if hasattr(self, 'date_combo'):
            self.date_combo.setEnabled(enabled)

    def start_full_initialization(self):
        """Uruchamia pe≈ÇnƒÖ inicjalizacjƒô po sprawdzeniu wersji i uprawnie≈Ñ."""
        self.load_data_button.setText("Sprawdzanie uprawnie≈Ñ...")
        self.load_data_button.setEnabled(False)
        QApplication.processEvents()

        if not self.check_user_permissions():
            QTimer.singleShot(10, self.close)
            return

        self.manage_ui_state(enabled=True)
        self.load_data_button.setVisible(False)
        self.refresh_button.setVisible(True)

        self.setup_table_properties()
        self.setup_keyboard_editing()

        self.setup_date_combo()
        self.load_initial_data()

        self.check_timer = QTimer(self)
        self.check_timer.timeout.connect(self.check_for_new_data)
        self.check_timer.start(60000)

    def check_if_update_is_required(self) -> bool:
        """Sprawdza wersjƒô aplikacji na podstawie za≈Çadowanych ustawie≈Ñ."""
        # Por√≥wnujemy wersje. Funkcja zwraca tylko wynik, nie zamyka ju≈º aplikacji.
        return parse_version(APP_VERSION) != parse_version(app_settings.REQUIRED_VERSION)

    def show_staffing_details_window(self):
        """
        Poprawiona wersja: Pokazuje okno 'Obsada'.
        Je≈õli okno istnieje, od≈õwie≈ºa je, przywraca i aktywuje.
        Je≈õli nie istnieje, tworzy je.
        """
        from staffing_details_window import StaffingDetailsWindow  # Leniwy import
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Brak danych", "Proszƒô wybraƒá miesiƒÖc, aby wy≈õwietliƒá szczeg√≥≈Çy obsady.",
                                QMessageBox.Ok)
            return
        year, month = current_data

        # --- POCZƒÑTEK POPRAWKI ---

        # PRZYPADEK 1: Okno nie istnieje (self.staffing_details_win is None)
        if not self.staffing_details_win:
            debug_print("Tworzƒô nowƒÖ instancjƒô okna 'Obsada'...")
            self.staffing_details_win = StaffingDetailsWindow(
                self, self.data_provider, year, month, self.import_grupa, self.import_funkcja
            )
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.show()

        # PRZYPADEK 2: Okno istnieje (by≈Ço ju≈º otwarte, mo≈ºe byƒá ukryte, zminimalizowane lub aktywne)
        else:
            debug_print("Aktywujƒô istniejƒÖce okno 'Obsada'...")

            # Najpierw od≈õwie≈º dane i motyw
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.update_for_new_month_or_filters(year, month)

            # Poka≈º je (je≈õli by≈Ço ukryte) i przywr√≥ƒá (je≈õli by≈Ço zminimalizowane)
            self.staffing_details_win.showNormal()
            self.staffing_details_win.activateWindow()
            self.staffing_details_win.raise_()  # Przenie≈õ na wierzch
        # --- KONIEC POPRAWKI ---

    def toggle_staffing_window_visibility(self):
        """
        Prze≈ÇƒÖcza widoczno≈õƒá okna Obsady (F6). Je≈ºeli jest widoczne, minimalizuje je.
        Je≈ºeli jest zminimalizowane, przywraca je. Je≈ºeli jest zamkniƒôte, otwiera je.
        """
        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            # Okno jest widoczne
            if self.staffing_details_win.isMinimized():
                # Jest zminimalizowane, wiƒôc je przywracamy
                self.staffing_details_win.showNormal()
                self.staffing_details_win.activateWindow()
            else:
                # Jest normalnie widoczne, wiƒôc je minimalizujemy
                self.staffing_details_win.showMinimized()
        else:
            # Okno jest zamkniƒôte lub ukryte, wiƒôc je otwieramy
            self.show_staffing_details_window()

    def setup_keyboard_editing(self):
        """Konfiguruje edycjƒô klawiatury dla kom√≥rek grafiku"""
        if not app_settings.has_permission(self.current_user_app_role, 'schedule_keyboard_edit'):
            debug_print(f"Edycja klawiatury wy≈ÇƒÖczona - rola '{self.current_user_app_role}' nie ma uprawnie≈Ñ.")
            return

        self.keyboard_filter = ScheduleKeyboardFilter(self)
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            self.table.schedule_view.installEventFilter(self.keyboard_filter)
            debug_print(f"W≈ÇƒÖczono edycjƒô klawiatury dla roli: {self.current_user_app_role}")

    def cleanup_keyboard_filter(self):
        """Czy≈õci filtr klawiatury przy zamykaniu aplikacji"""
        if hasattr(self, 'keyboard_filter'):
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.removeEventFilter(self.keyboard_filter)
            del self.keyboard_filter
            debug_print("Wyczyszczono filtr klawiatury")

    def _should_ask_for_confirmation(self) -> bool:
        """
        Sprawdza, czy nale≈ºy wy≈õwietliƒá okno dialogowe z pro≈õbƒÖ o potwierdzenie.
        Zwraca False, je≈õli grafik nie jest opublikowany (praca "na brudno"), True w przeciwnym wypadku.
        """
        current_data = self.date_combo.currentData()
        if not current_data:
            return True  # W razie wƒÖtpliwo≈õci, dla bezpiecze≈Ñstwa pytaj

        year, month = current_data
        is_published = self.data_provider.is_schedule_published(year, month)

        # Pytamy o potwierdzenie tylko wtedy, gdy grafik JEST opublikowany.
        return is_published

    def _get_permission_for_cell(self, cell_data: dict) -> dict:
        permissions = {'can_edit_hours': False, 'can_edit_symbol': False, 'can_edit_location': False,
                       'can_delete': False}
        if not cell_data: return permissions

        user_role, user_dept = self.current_user_app_role, self.current_user_app_department
        target_role, target_dept = cell_data.get('rola_nazwa'), cell_data.get('wydzial')

        # --- POCZƒÑTEK NOWEJ LOGIKI ---
        # Specjalna regu≈Ça: Lider i Lider OUT mogƒÖ wstawiƒá symbol 'CO' osobom z wydzia≈Çu DTN.
        # Przyznajemy im tylko uprawnienie do edycji symbolu w tym konkretnym przypadku.
        if user_role in ['Lider', 'Lider OUT'] and target_dept and target_dept.strip().lower() == 'dtn':
            return {'can_edit_hours': False, 'can_edit_symbol': True, 'can_edit_location': False, 'can_delete': False}
        # --- KONIEC NOWEJ LOGIKI ---

        if user_role == 'Pracownik WPR':
            return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}

        is_in_same_department = False
        if user_dept and target_dept:
            if target_dept.strip().lower().startswith(user_dept.strip().lower()):
                is_in_same_department = True

        if not is_in_same_department: return permissions

        if user_role == 'Lider OUT':
            return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}

        if user_role == 'Lider':
            # --- NOWA LOGIKA DLA "SUPER LIDERA" ---

            # Sprawd≈∫, czy bie≈ºƒÖcy u≈ºytkownik jest na li≈õcie Super Lider√≥w
            is_super_lider = self.current_user_app_login_windows.lower() in app_settings.SUPER_LIDER_LOGINS

            # Super Lider mo≈ºe edytowaƒá godziny wszystkim w swoim wydziale.
            # Zwyk≈Çy Lider mo≈ºe edytowaƒá godziny tylko innym Liderom.
            if is_super_lider or target_role == 'Lider':
                return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}
            else:
                return {'can_edit_hours': False, 'can_edit_symbol': True, 'can_edit_location': True,
                        'can_delete': False}
            # --- KONIEC NOWEJ LOGIKI ---

        return permissions

    def quick_edit_selected_cells(self, start_hour):
        """Szybka edycja zaznaczonych kom√≥rek z klawiatury"""
        try:
            if not app_settings.has_permission(self.current_user_app_role, 'schedule_keyboard_edit'):
                return

            selected_cells_data = self.table.get_data_for_selected_cells()
            if not self._can_modify_cells(selected_cells_data) or not selected_cells_data:
                return

            schedule_cells = [cell for cell in selected_cells_data if
                              isinstance(cell, dict) and 'date_str' in cell and 'uzytkownik_id' in cell]
            if not schedule_cells:
                return

            grouped_changes = {}
            for cell_data in schedule_cells:
                user_id, user_name, date_str = cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane',
                                                                                             ''), cell_data.get(
                    'date_str')
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str
                user_key = (user_id, user_name)
                if user_key not in grouped_changes:
                    grouped_changes[user_key] = []
                grouped_changes[user_key].append(formatted_date)

            # --- POCZƒÑTEK POPRAWKI: Ograniczenie d≈Çugo≈õci komunikatu ---
            changes_info = f"Zmiana godziny rozpoczƒôcia na {start_hour}:00 dla:<br><br>"
            MAX_USERS_TO_SHOW = 15
            user_count = 0
            for (user_id, user_name), dates in grouped_changes.items():
                if user_count >= MAX_USERS_TO_SHOW:
                    break
                changes_info += f"üë§ {user_name}: "
                dates_str = ", ".join(sorted(dates))
                changes_info += f"   üóìÔ∏è {dates_str}<br><br>"
                user_count += 1

            remaining_users = len(grouped_changes) - user_count
            if remaining_users > 0:
                changes_info += f"... i {remaining_users} wiƒôcej pracownik√≥w.<br><br>"

            changes_info += f"≈ÅƒÖcznie: {len(schedule_cells)} kom√≥rek"
            # --- KONIEC POPRAWKI ---

            reply = QMessageBox.Yes
            if self._should_ask_for_confirmation():
                reply = show_confirmation_dialog(self, "Potwierdzenie szybkiej edycji", changes_info)
            if reply == QMessageBox.Yes:
                self._apply_quick_changes(schedule_cells, start_hour)
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas szybkiej edycji: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas edycji: {str(e)}", QMessageBox.Ok)

    def _apply_quick_changes(self, schedule_cells, start_hour):
        """
        Przygotowuje listƒô zmian dla szybkiej edycji i przekazuje jƒÖ do asynchronicznego procesora.
        """
        change_requests = []
        skipped_employees = []

        for cell_data in schedule_cells:
            permissions = self._get_permission_for_cell(cell_data)
            if permissions['can_edit_hours']:
                change_requests.append((ChangeType.QUICK_EDIT_START_HOUR, cell_data, start_hour))
            else:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))

        if skipped_employees:
            QMessageBox.information(self, "Pominiƒôto",
                                    f"Pominiƒôto {len(skipped_employees)} kom√≥rek z powodu braku uprawnie≈Ñ dla:<br>"
                                    f"- {', '.join(set(skipped_employees))}")
        if change_requests:
            self.schedule_change_processor.start_changes(change_requests)

    def _prepare_deletion_summary_message(self, schedule_cells: list, contains_vacation_symbol: bool = False) -> str:
        """
        Przygotowuje sformatowanƒÖ wiadomo≈õƒá podsumowujƒÖcƒÖ usuwanie symboli,
        z limitem wy≈õwietlanych wierszy.
        """
        if not schedule_cells:
            return "Nie wybrano ≈ºadnych kom√≥rek z symbolami do usuniƒôcia."

        grouped_deletions = {}
        for cell_data in schedule_cells:
            user_name = cell_data.get('uzytkownik_dane', 'Nieznany U≈ºytkownik')
            date_str = cell_data.get('date_str', 'Nieznana Data')
            symbol = cell_data.get('symbol', '??')
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except ValueError:
                formatted_date = date_str
            if user_name not in grouped_deletions:
                grouped_deletions[user_name] = []
            grouped_deletions[user_name].append(f"{formatted_date} (symbol: {symbol})")

        summary_lines = ["Czy na pewno chcesz usunƒÖƒá symbole dla nastƒôpujƒÖcych pozycji?<br><br>"]
        line_count = 0
        total_cells = len(schedule_cells)
        cells_shown = 0
        MAX_LINES_TO_SHOW = 15

        for user_name, date_symbol_list in grouped_deletions.items():
            if line_count >= MAX_LINES_TO_SHOW:
                break
            summary_lines.append(f"<b>üßë {user_name}:</b><br>")
            line_count += 1
            for date_with_symbol in sorted(date_symbol_list):
                if line_count >= MAX_LINES_TO_SHOW:
                    break
                summary_lines.append(f"&nbsp;&nbsp;&nbsp;‚Ä¢ {date_with_symbol}<br>")
                line_count += 1
                cells_shown += 1
            summary_lines.append("<br>")  # Dodatkowa przerwa miƒôdzy u≈ºytkownikami

        remaining_cells = total_cells - cells_shown
        if remaining_cells > 0:
            summary_lines.append(f"<br>... i {remaining_cells} wiƒôcej pozycji.")

        summary_lines.append(f"<br>≈ÅƒÖcznie zostanie wyczyszczonych: {total_cells} kom√≥rek.")

        # --- NOWA ZMIANA: Dodanie ostrze≈ºenia o urlopach ---
        if contains_vacation_symbol:
            summary_lines.append(
                "<br><br><b><font color='orange'>UWAGA:</font> Ta operacja spowoduje r√≥wnie≈º usuniƒôcie urlopu z plan√≥w urlopowych.</b>")
        # --- KONIEC ZMIANY ---

        return "".join(summary_lines)

    def clear_selected_cells(self):
        """Asynchronicznie czy≈õci zawarto≈õƒá zaznaczonych kom√≥rek (klawisz Delete)."""
        if hasattr(self, 'keyboard_filter') and hasattr(self.keyboard_filter, '_buffer_timer'):
            self.keyboard_filter._buffer_timer.stop()
            self.keyboard_filter._digit_buffer = ""

        selected_cells_data = self.table.get_data_for_selected_cells()
        if not selected_cells_data:
            return

        schedule_cells = [cell for cell in selected_cells_data if cell.get('symbol', '').strip()]

        # --- NOWA ZMIANA: Sprawdzenie, czy usuwamy urlop ---
        contains_vacation_symbol = any(
            (parse_symbol(cell.get('symbol', '')).get('special_symbol') or '').upper() in ['U', 'UZ']
            for cell in schedule_cells
        )
        # --- KONIEC ZMIANY ---

        if not schedule_cells:
            QMessageBox.information(self, "Brak symboli do usuniƒôcia", "Zaznaczone kom√≥rki sƒÖ ju≈º puste.",
                                    QMessageBox.Ok)
            return

        if not any(self._get_permission_for_cell(c)['can_delete'] for c in schedule_cells):
            QMessageBox.warning(self, "Brak uprawnie≈Ñ",
                                "Nie posiadasz uprawnie≈Ñ do usuniƒôcia symboli dla ≈ºadnej z zaznaczonych os√≥b.")
            return

        user_date_pairs = {(cell.get('uzytkownik_id'), cell.get('date_str')) for cell in schedule_cells}
        events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        # --- ZMIANA: Przekazanie flagi o urlopie do funkcji tworzƒÖcej komunikat ---
        confirmation_message = self._prepare_deletion_summary_message(
            schedule_cells,
            contains_vacation_symbol=contains_vacation_symbol
        )
        # --- KONIEC ZMIANY ---
        if events_to_cancel:
            grouped_events = self._group_events_by_user_date(events_to_cancel)
            delegations_info = self._prepare_delegations_description(grouped_events)
            confirmation_message += f"<br><br>{delegations_info}"

        reply = show_confirmation_dialog(self, "Potwierdzenie usuniƒôcia", confirmation_message)

        if reply == QMessageBox.Yes:
            if events_to_cancel: self.delegation_canceler.start_cancellation(events_to_cancel)
            self._clear_cells_symbols(schedule_cells)

            # --- NOWA ZMIANA: Wymu≈õ od≈õwie≈ºenie ikon po operacji ---
            # Po usuniƒôciu symbolu i odwo≈Çaniu zdarze≈Ñ, musimy jawnie
            # poinformowaƒá DataProvider, ≈ºe dane dla tych kom√≥rek sƒÖ nieaktualne,
            # co spowoduje ponowne przeliczenie i usuniƒôcie ikon.
            current_data = self.date_combo.currentData()
            if current_data:
                year, month = current_data
                self.data_provider.invalidate_complete_cache_for_pairs(list(user_date_pairs))

    def _clear_cells_symbols(self, schedule_cells: list):
        """Przygotowuje ≈ºƒÖdania usuniƒôcia symboli i przekazuje je do ScheduleChangeProcessor."""
        change_requests = []
        skipped_employees = []
        skipped_vacation_employees = []  # Lista os√≥b, gdzie pominiƒôto urlop

        for cell_data in schedule_cells:
            # Sprawd≈∫, czy symbol specjalny to urlop ('U' lub 'UZ')
            parsed_current = parse_symbol(cell_data.get('symbol', ''))
            # --- POPRAWKA: Bezpieczne wywo≈Çanie .upper() na potencjalnie pustym symbolu ---
            special_symbol = (parsed_current.get('special_symbol') or '').upper()
            if special_symbol in ['U', 'UZ']:
                skipped_vacation_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue  # Pomi≈Ñ usuwanie dla urlop√≥w, aby nie usuwaƒá z planu

            # Sprawd≈∫ uprawnienia do usuwania
            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_delete']:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue

            # Dodaj ≈ºƒÖdanie usuniƒôcia do listy
            change_requests.append((ChangeType.CLEAR_CELL, cell_data, None))  # None jako warto≈õƒá dla CLEAR_CELL

        # Wy≈õwietl komunikaty informacyjne o pominiƒôtych kom√≥rkach
        if skipped_vacation_employees:
            QMessageBox.information(self, "Pominiƒôto urlopy",
                                    f"Pominiƒôto usuwanie dla symboli 'U' lub 'UZ', aby zachowaƒá je w planie urlopowym dla:<br>"
                                    f"- {', '.join(set(skipped_vacation_employees))}")

        if skipped_employees:
            QMessageBox.information(self, "Pominiƒôto",
                                    f"Pominiƒôto usuwanie dla nastƒôpujƒÖcych os√≥b z powodu braku uprawnie≈Ñ:<br>"
                                    f"- {', '.join(set(skipped_employees))}")

        # Je≈õli sƒÖ jakiekolwiek ≈ºƒÖdania do wykonania, przeka≈º je do procesora
        if change_requests:
            debug_print(f"Przekazujƒô {len(change_requests)} ≈ºƒÖda≈Ñ CLEAR_CELL do ScheduleChangeProcessor.")
            self.schedule_change_processor.start_changes(change_requests)

    def on_data_changed(self, data_type, year, month):
        """Obs≈Çuguje powiadomienie o zmianie danych z DataProvider."""
        current_data = self.date_combo.currentData()
        if not (current_data and current_data == (year, month)):
            return

        if data_type == "schedule":
            self.update_table_content()
        elif data_type == "events":
            # Po prostu od≈õwie≈ºamy tabelƒô zdarze≈Ñ, je≈õli co≈õ siƒô w nich zmieni≈Ço
            self.on_selection_changed()

    def log_time(self, label, start_time):
        """Pomocnicza funkcja do logowania czasu"""
        end_time = time.time()
        elapsed = end_time - start_time
        debug_print(f"[CZAS] {label}: {elapsed:.3f} sekundy")
        return end_time

    def _create_central_widget(self):
        """Tworzy i ustawia g≈Ç√≥wny widget aplikacji."""
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(10, 0, 10, 0)
        main_layout.setSpacing(0)

        top_bar = self.setup_top_bar(main_layout)
        main_layout.addWidget(top_bar)

        middle_splitter = self.setup_middle_section(main_layout)
        main_layout.addWidget(middle_splitter, 1)

        self.setCentralWidget(central_widget)

    def setup_top_bar(self, main_layout):
        top_bar_frame = QFrame()
        top_bar_frame.setFrameShape(QFrame.StyledPanel)
        top_bar_frame.setFrameShadow(QFrame.Raised)
        top_bar_frame.setFixedHeight(50)
        top_bar_layout = QHBoxLayout(top_bar_frame)
        top_bar_layout.setContentsMargins(5, 5, 5, 5)
        top_bar_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        self.toggle_menu_button = QPushButton("‚ò∞")
        self.toggle_menu_button.setFixedSize(32, 32)
        self.toggle_menu_button.setToolTip("Poka≈º/ukryj panel filtr√≥w (F1)")
        self.toggle_menu_button.clicked.connect(self.toggle_left_panel)
        top_bar_layout.addWidget(self.toggle_menu_button)

        self.settings_button = QPushButton("Ustawienia")
        self.settings_button.clicked.connect(self.show_settings_dialog)
        top_bar_layout.addWidget(self.settings_button)

        top_bar_layout.addWidget(self.create_separator())

        top_bar_layout.addWidget(QLabel("MiesiƒÖc:"))
        self.date_combo = QComboBox()
        self.date_combo.setMinimumWidth(120)
        # --- POCZƒÑTEK POPRAWKI: Pozostawiono tylko jedno, poprawne pod≈ÇƒÖczenie ---
        self.date_combo.currentIndexChanged.connect(self.refresh_data)
        # --- KONIEC POPRAWKI ---
        top_bar_layout.addWidget(self.date_combo)

        self.load_data_button = QPushButton("üöÄ Pobierz Dane")
        self.load_data_button.setToolTip("Kliknij, aby po≈ÇƒÖczyƒá siƒô z bazƒÖ i za≈Çadowaƒá dane.")
        top_bar_layout.addWidget(self.load_data_button)
        self.load_data_button.setVisible(True)

        self.refresh_button = QPushButton("Od≈õwie≈º")
        self.refresh_button.setToolTip("Od≈õwie≈º dane dla bie≈ºƒÖcych filtr√≥w")
        self.refresh_button.clicked.connect(self.refresh_data)
        top_bar_layout.addWidget(self.refresh_button)
        self.refresh_button.setVisible(False)

        self.show_audit_button = QPushButton("Historia Zmian")
        self.show_audit_button.clicked.connect(self.show_audit_log_window)
        top_bar_layout.addWidget(self.show_audit_button)

        self.staffing_details_button = QPushButton("Obsada")
        self.staffing_details_button.clicked.connect(self.show_staffing_details_window)
        top_bar_layout.addWidget(self.staffing_details_button)

        # --- ZMIANA: Przycisk z ikonƒÖ Excel ---
        self.export_button = QPushButton()
        self.export_button.setIcon(QIcon(resource_path("icons/excel.png")))
        self.export_button.setIconSize(QSize(24, 24))
        self.export_button.setFixedSize(32, 32)
        self.export_button.setToolTip("Eksportuj do Excel (.xlsx)")
        self.export_button.clicked.connect(self.export_schedule_to_excel)
        top_bar_layout.addWidget(self.export_button)

        # --- ZMIANA: Przycisk z ikonƒÖ Teams ---
        self.teams_chat_button = QPushButton()
        self.teams_chat_button.setIcon(QIcon(resource_path("icons/teams.png")))
        self.teams_chat_button.setIconSize(QSize(24, 24))
        self.teams_chat_button.setFixedSize(32, 32)
        self.teams_chat_button.setToolTip("Otw√≥rz czat w Teams (Ctrl+T)")
        self.teams_chat_button.clicked.connect(self.open_teams_chat_for_selection)
        self.teams_chat_button.setEnabled(False)
        top_bar_layout.addWidget(self.teams_chat_button)

        # --- ZMIANA: Przycisk z ikonƒÖ Outlook ---
        self.send_email_button = QPushButton()
        self.send_email_button.setIcon(QIcon(resource_path("icons/outlook.png")))
        self.send_email_button.setIconSize(QSize(24, 24))
        self.send_email_button.setFixedSize(32, 32)
        self.send_email_button.setToolTip("Wy≈õlij e-mail (Ctrl+O)")
        self.send_email_button.clicked.connect(self.send_email_to_selection)
        self.send_email_button.setEnabled(False)
        top_bar_layout.addWidget(self.send_email_button)

        self.schedule_control_button = QPushButton("ZarzƒÖdzaj Grafikiem")
        self.schedule_control_button.clicked.connect(self.show_schedule_control_dialog)
        top_bar_layout.addWidget(self.schedule_control_button)

        top_bar_layout.addStretch()

        return top_bar_frame

    def create_separator(self):
        separator = QFrame()
        separator.setFrameShape(QFrame.VLine)
        separator.setFrameShadow(QFrame.Sunken)
        return separator

    def setup_date_combo(self):
        """Konfiguruje combobox z datami, uwzglƒôdniajƒÖc uprawnienia."""
        self.date_combo.blockSignals(True)
        current_date = datetime.now()
        months_to_show = []
        year, month = current_date.year, current_date.month

        for i in range(3, 0, -1):
            prev_month, prev_year = (month - i, year)
            while prev_month <= 0:
                prev_month += 12
                prev_year -= 1
            months_to_show.append((prev_year, prev_month))

        months_to_show.append((year, month))

        if self.can_see_next_month:
            next_month, next_year = (month + 1, year)
            if next_month > 12:
                next_month = 1
                next_year += 1
            months_to_show.append((next_year, next_month))

        current_index = self.date_combo.currentIndex()
        if current_index == -1:
            current_index = 3

        self.date_combo.clear()
        for y, m in months_to_show:
            self.date_combo.addItem(f"{y}-{m:02d}", (y, m))

        self.date_combo.setCurrentIndex(min(current_index, self.date_combo.count() - 1))
        self.date_combo.blockSignals(False)

    def setup_middle_section(self, main_layout):
        """Tworzy ≈õrodkowƒÖ sekcjƒô z filtrem i tabelami"""
        main_splitter = QSplitter(Qt.Horizontal)
        main_splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.setup_left_panel()
        right_panel = self.setup_right_panel()
        main_splitter.addWidget(self._left_panel)
        main_splitter.addWidget(right_panel)

        # Ustawienie rozmiar√≥w poczƒÖtkowych
        main_splitter.setSizes([260, 1200])
        self.main_splitter = main_splitter

        self.main_splitter.setStretchFactor(0, 0)
        self.main_splitter.setStretchFactor(1, 1)

        return main_splitter

    def setup_left_panel(self):
        """Tworzy lewy panel z filtrami w spos√≥b dynamiczny."""
        self._left_panel = QWidget()
        self._left_panel.setMinimumSize(0, 0)
        panel_main_layout = QVBoxLayout(self._left_panel)
        panel_main_layout.setContentsMargins(0, 0, 0, 5)
        panel_main_layout.setSpacing(5)  # Dodano odstƒôp

        # --- 1. SEKCJA G√ìRNA: Zapisane Filtry (Statyczna) ---
        saved_filters_group = QGroupBox("Zapisane Filtry")
        saved_filters_layout = QHBoxLayout(saved_filters_group)
        saved_filters_layout.setContentsMargins(5, 10, 5, 5)

        self.saved_filters_combo = QComboBox()
        self.saved_filters_combo.setPlaceholderText("Wybierz/Zastosuj filtr...")
        self.saved_filters_combo.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.saved_filters_combo.activated.connect(self._load_selected_filter_set_from_combo)
        self.saved_filters_combo.currentIndexChanged.connect(self._update_delete_button_state)
        saved_filters_layout.addWidget(self.saved_filters_combo, 1)

        self.save_filter_button = QPushButton()
        try:
            icon_path = resource_path("icons/save.png")
            save_icon = QIcon(icon_path)
            if save_icon.isNull(): raise FileNotFoundError(f"Nie znaleziono pliku ikony: {icon_path}")
        except Exception as e:
            log_error(f"B≈ÇƒÖd ≈Çadowania ikony zapisu: {e}")
            save_icon = self.style().standardIcon(QStyle.StandardPixmap.SP_DialogSaveButton)
        self.save_filter_button.setIcon(save_icon)
        self.save_filter_button.setFixedSize(28, 28)
        self.save_filter_button.setToolTip("Zapisz bie≈ºƒÖcy zestaw filtr√≥w lub zaktualizuj wybrany...")
        self.save_filter_button.clicked.connect(self._handle_save_button_clicked)
        saved_filters_layout.addWidget(self.save_filter_button, 0)

        self.delete_filter_button = QPushButton()
        try:
            icon_path = resource_path("icons/delete.png")
            delete_icon = QIcon(icon_path)
            if delete_icon.isNull(): raise FileNotFoundError(f"Nie znaleziono pliku ikony: {icon_path}")
        except Exception as e:
            log_error(f"B≈ÇƒÖd ≈Çadowania ikony kosza: {e}")
            delete_icon = self.style().standardIcon(QStyle.StandardPixmap.SP_TrashIcon)
        self.delete_filter_button.setIcon(delete_icon)
        self.delete_filter_button.setFixedSize(28, 28)
        self.delete_filter_button.setToolTip("Usu≈Ñ wybrany zestaw filtr√≥w")
        self.delete_filter_button.clicked.connect(self._delete_selected_filter_set)
        self.delete_filter_button.setEnabled(False)
        saved_filters_layout.addWidget(self.delete_filter_button, 0)

        panel_main_layout.addWidget(saved_filters_group)

        # --- 2. SEKCJA ≈öRODKOWA: Dynamiczne filtry (w ScrollArea) ---
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.NoFrame)

        # Ten kontener bƒôdzie rodzicem dla wszystkich widget√≥w filtr√≥w
        filter_container = QWidget()
        # Ten layout bƒôdzie dynamicznie wype≈Çniany
        self.filters_layout = QVBoxLayout(filter_container)
        self.filters_layout.setContentsMargins(10, 0, 10, 10)
        self.filters_layout.setSpacing(6)
        filter_container.setMinimumWidth(240)

        # Krok 1: Stw√≥rz wszystkie widgety w pamiƒôci (z rodzicem 'filter_container')
        self._create_all_filter_widgets(parent_widget=filter_container)

        # Krok 2: Dodaj do layoutu tylko te, kt√≥re sƒÖ widoczne
        self._apply_filter_visibility_and_order()

        # Krok 3: Ustaw kontener w scroll_area
        scroll_area.setWidget(filter_container)
        panel_main_layout.addWidget(scroll_area)  # Dodaj scroll area do g≈Ç√≥wnego layoutu

        # --- CA≈ÅY STARY KOD TWORZƒÑCY FILTRY ZOSTA≈Å STƒÑD USUNIƒòTY ---

        # --- 3. SEKCJA DOLNA: Przyciski (Statyczna) ---
        bottom_bar = QFrame()
        bottom_bar.setFrameShape(QFrame.NoFrame)
        bottom_bar.setFixedHeight(40)
        bottom_layout = QHBoxLayout(bottom_bar)
        bottom_layout.setContentsMargins(5, 0, 5, 0)

        self.clear_filters_button = QPushButton("Wyczy≈õƒá filtry")
        self.clear_filters_button.clicked.connect(self.clear_filters)

        self.filter_settings_button = QPushButton()
        try:
            # Upewnij siƒô, ≈ºe 'os' jest zaimportowany na g√≥rze pliku main.py
            # (powinien ju≈º byƒá z importu config.py, ale dla pewno≈õci)
            import os

            # Krok 1: Zbuduj ≈õcie≈ºkƒô
            icon_path = resource_path("icons/settings.png")
            debug_print(f"[Filtracja] Pr√≥ba za≈Çadowania ikony ustawie≈Ñ ze ≈õcie≈ºki: {icon_path}")

            # Krok 2: Sprawd≈∫, czy plik fizycznie istnieje
            if not os.path.exists(icon_path):
                debug_print(f"[Filtracja] B≈ÅƒÑD: Plik ikony NIE ISTNIEJE pod ≈õcie≈ºkƒÖ: {icon_path}")
                raise FileNotFoundError(f"Plik ikony nie istnieje: {icon_path}")

            # Krok 3: Spr√≥buj za≈Çadowaƒá ikonƒô
            settings_icon = QIcon(icon_path)
            if settings_icon.isNull():
                debug_print(
                    f"[Filtracja] B≈ÅƒÑD: Plik istnieje, ale QIcon nie mo≈ºe go za≈Çadowaƒá (uszkodzony?): {icon_path}")
                raise Exception(f"Nie mo≈ºna za≈Çadowaƒá pliku ikony (byƒá mo≈ºe uszkodzony): {icon_path}")

            debug_print(f"[Filtracja] Ikona ustawie≈Ñ za≈Çadowana pomy≈õlnie.")

        except Exception as e:
            # Fallback na standardowƒÖ ikonƒô w razie b≈Çƒôdu
            log_error(f"B≈ÇƒÖd ≈Çadowania ikony 'settings.png': {e}")
            settings_icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileDialogDetailedView)
            # --- KONIEC ZMODYFIKOWANEGO BLOKU DIAGNOSTYCZNEGO ---

        self.filter_settings_button.setIcon(settings_icon)
        self.filter_settings_button.setIconSize(QSize(20, 20))
        self.filter_settings_button.setFixedSize(28, 28)
        self.filter_settings_button.setToolTip("Ustawienia widoczno≈õci filtr√≥w")
        self.filter_settings_button.clicked.connect(self.show_filter_select_dialog)

        bottom_layout.addWidget(self.clear_filters_button)
        bottom_layout.addStretch()
        bottom_layout.addWidget(self.filter_settings_button)

        panel_main_layout.addWidget(bottom_bar)

    def _update_saved_filters_combo(self):
        """Aktualizuje listƒô w QComboBox na podstawie zapisanych filtr√≥w."""
        if not hasattr(self, 'saved_filters_combo'):
            return

        self.saved_filters_combo.blockSignals(True)
        current_text = self.saved_filters_combo.currentText()  # Zapamiƒôtaj, co by≈Ço wybrane
        self.saved_filters_combo.clear()
        self.saved_filters_combo.addItem("")  # Dodaj pustƒÖ opcjƒô na poczƒÖtku
        saved_filters_names = sorted(self.user_app_settings.get('saved_filters', {}).keys())
        self.saved_filters_combo.addItems(saved_filters_names)

        # Spr√≥buj przywr√≥ciƒá poprzedni wyb√≥r
        index = self.saved_filters_combo.findText(current_text)
        if index != -1:
            self.saved_filters_combo.setCurrentIndex(index)
        else:
            self.saved_filters_combo.setCurrentIndex(0)  # Wybierz pustƒÖ opcjƒô

        self.saved_filters_combo.blockSignals(False)
        self._update_delete_button_state()

    def _handle_save_button_clicked(self):
        """
        Inteligentnie obs≈Çuguje klikniƒôcie przycisku ZAPISZ.
        - Je≈õli wybrano pustƒÖ pozycjƒô -> tworzy NOWY filtr.
        - Je≈õli wybrano istniejƒÖcy filtr -> pyta o AKTUALIZACJƒò.
        """
        current_index = self.saved_filters_combo.currentIndex()
        filter_name = self.saved_filters_combo.currentText()
        current_state = self.get_current_filters_state()  # Pobierz aktualne ustawienia filtr√≥w

        if current_index == 0 or not filter_name:
            # PRZYPADEK 1: Tworzenie nowego filtra (bo wybrano pustƒÖ pozycjƒô)
            self._create_new_filter_set(current_state)
        else:
            # PRZYPADEK 2: Aktualizacja istniejƒÖcego filtra
            reply = QMessageBox.question(self, "Aktualizacja filtru",
                                         f"Czy na pewno chcesz zaktualizowaƒá (nadpisaƒá)\nfiltr '{filter_name}' bie≈ºƒÖcymi ustawieniami?",
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

            if reply == QMessageBox.Yes:
                self.user_app_settings['saved_filters'][filter_name] = current_state
                self.settings_db.save_settings(self.user_app_settings)  # Zapisz w bazie
                QMessageBox.information(self, "Zaktualizowano",
                                        f"Zestaw filtr√≥w '{filter_name}' zosta≈Ç zaktualizowany.")
                # Nie ma potrzeby od≈õwie≈ºaƒá combo, bo nazwy siƒô nie zmieni≈Çy

    def _create_new_filter_set(self, current_state: dict):
        """
        Pomocnicza funkcja do tworzenia nowego zestawu filtr√≥w.
        (Wydzielona z logiki `_save_current_filter_set` z poprzedniej odpowiedzi)
        """
        from PySide6.QtWidgets import QInputDialog, QLineEdit

        filter_name, ok = QInputDialog.getText(self, "Zapisz nowy zestaw filtr√≥w",
                                               "Podaj nazwƒô dla tego zestawu filtr√≥w:",
                                               QLineEdit.Normal, "")
        if ok and filter_name:
            filter_name = filter_name.strip()
            if not filter_name:
                QMessageBox.warning(self, "B≈Çƒôdna nazwa", "Nazwa filtra nie mo≈ºe byƒá pusta.")
                return

            saved_filters = self.user_app_settings.get('saved_filters', {})

            if filter_name in saved_filters:
                QMessageBox.warning(self, "Nazwa istnieje",
                                    f"Filtr o nazwie '{filter_name}' ju≈º istnieje.\nJe≈õli chcesz go zaktualizowaƒá, wybierz go z listy i kliknij 'Zapisz'.")
                return

            saved_filters[filter_name] = current_state
            self.user_app_settings['saved_filters'] = saved_filters
            self.settings_db.save_settings(self.user_app_settings)
            self._update_saved_filters_combo()  # Od≈õwie≈º listƒô
            self.saved_filters_combo.setCurrentText(filter_name)  # Ustaw nowo zapisanƒÖ nazwƒô
            QMessageBox.information(self, "Zapisano", f"Zestaw filtr√≥w '{filter_name}' zosta≈Ç zapisany.")
        elif ok and not filter_name:
            QMessageBox.warning(self, "B≈Çƒôdna nazwa", "Nazwa filtra nie mo≈ºe byƒá pusta.")

    def _delete_selected_filter_set(self):
        """Usuwa aktualnie wybrany zestaw filtr√≥w."""
        filter_name = self.saved_filters_combo.currentText()

        # Przycisk powinien byƒá nieaktywny, ale to dodatkowe zabezpieczenie
        if not filter_name:
            return

        reply = QMessageBox.question(self, "Usuwanie filtra",
                                     f"Czy na pewno chcesz usunƒÖƒá zapisany filtr:\n'{filter_name}'?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            try:
                del self.user_app_settings['saved_filters'][filter_name]
                self.settings_db.save_settings(self.user_app_settings)  # Zapisz zmiany w bazie
                self._update_saved_filters_combo()  # Od≈õwie≈º listƒô w comboboxie
                QMessageBox.information(self, "Usuniƒôto", f"Zestaw filtr√≥w '{filter_name}' zosta≈Ç usuniƒôty.")
            except KeyError:
                log_error(f"Pr√≥ba usuniƒôcia filtra '{filter_name}', kt√≥ry nie istnieje w 'saved_filters'.")
                QMessageBox.warning(self, "B≈ÇƒÖd", "Nie mo≈ºna by≈Ço usunƒÖƒá wybranego filtra.")
            except Exception as e:
                log_error(f"B≈ÇƒÖd podczas usuwania filtra: {e}", exception=e)
                QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd: {e}")

    def _update_delete_button_state(self):
        """W≈ÇƒÖcza lub wy≈ÇƒÖcza przycisk usuwania w zale≈ºno≈õci od wyboru w ComboBox."""
        if hasattr(self, 'delete_filter_button'):
            # W≈ÇƒÖcz przycisk tylko je≈õli wybrany indeks jest > 0 (czyli nie jest to pusta pozycja)
            is_filter_selected = self.saved_filters_combo.currentIndex() > 0
            self.delete_filter_button.setEnabled(is_filter_selected)

    def _load_selected_filter_set(self):
        """Wczytuje zestaw filtr√≥w wybrany w QComboBox."""
        filter_name = self.saved_filters_combo.currentText()
        if not filter_name:
            QMessageBox.information(self, "Informacja", "Wybierz zapisany zestaw filtr√≥w z listy.")
            return

        saved_filters = self.user_app_settings.get('saved_filters', {})
        filter_state = saved_filters.get(filter_name)

        if filter_state:
            debug_print(f"Wczytywanie zestawu filtr√≥w: '{filter_name}'")
            self.restore_filters_state(filter_state)  # Ta funkcja powinna wywo≈Çaƒá filter_data() na ko≈Ñcu
            QMessageBox.information(self, "Wczytano", f"Zastosowano zapisany zestaw filtr√≥w '{filter_name}'.")
        else:
            QMessageBox.warning(self, "B≈ÇƒÖd", f"Nie znaleziono zapisanego stanu dla filtra '{filter_name}'.")

    def _load_selected_filter_set_from_combo(self, index):
        """Wczytuje zestaw filtr√≥w po wybraniu go z QComboBox (ignoruje index 0)."""
        if index == 0:  # Ignoruj pustƒÖ opcjƒô
            self._update_delete_button_state()
            # Mo≈ºna opcjonalnie wyczy≈õciƒá filtry po wybraniu pustej opcji:
            # self.clear_filters()
            # self.saved_filters_combo.setCurrentIndex(0) # Upewnij siƒô, ≈ºe pusta opcja jest wybrana
            return

        filter_name = self.saved_filters_combo.itemText(index)  # Pobierz tekst wybranego elementu

        saved_filters = self.user_app_settings.get('saved_filters', {})
        filter_state = saved_filters.get(filter_name)

        if filter_state:
            debug_print(f"Automatyczne wczytywanie zestawu filtr√≥w: '{filter_name}'")
            self.restore_filters_state(filter_state)  # Ta funkcja powinna wywo≈Çaƒá filter_data()
            # Nie pokazujemy QMessageBox, bo akcja jest automatyczna
        else:
            # Ten b≈ÇƒÖd nie powinien wystƒÖpiƒá, ale zostawiamy jako zabezpieczenie
            log_error(f"Nie znaleziono zapisanego stanu dla filtra '{filter_name}' wybranego z combo.")
            self.saved_filters_combo.setCurrentIndex(0)  # Wr√≥ƒá do pustej opcji w razie b≈Çƒôdu

    def _create_clear_icon(self, color: QColor) -> QIcon:
        """Tworzy ikonƒô 'X' o zadanym kolorze."""
        pixmap = QPixmap(16, 16)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        pen = QPen(color, 2)
        painter.setPen(pen)
        painter.drawLine(4, 4, 12, 12)
        painter.drawLine(4, 12, 12, 4)
        painter.end()
        return QIcon(pixmap)

    # --- NOWA METODA: Tworzenie ikony ustawie≈Ñ ---
    def _create_settings_icon(self, color: QColor) -> QIcon:
        """Tworzy ikonƒô 'ko≈Ça zƒôbatego' o zadanym kolorze."""
        pixmap = QPixmap(16, 16)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)

        # U≈ºyjemy prostego symbolu, np. trzech kropek lub gwiazdki
        # Pe≈Çne ko≈Ço zƒôbate jest trudne do narysowania w ten spos√≥b
        # Zr√≥bmy prosty kwadrat z kropkƒÖ w ≈õrodku jako "ustawienia"
        pen = QPen(color, 2)
        painter.setPen(pen)
        painter.drawRect(3, 3, 10, 10)  # Ramka
        painter.setBrush(color)
        painter.drawEllipse(6, 6, 4, 4)  # Kropka w ≈õrodku

        painter.end()
        return QIcon(pixmap)

    # --- MODYFIKACJA: Funkcje pomocnicze zwracajƒÖ teraz layout ---

    def add_horizontal_filter(self, label_text, combo_name):
        """
        MODYFIKACJA: Tworzy layout filtra, ale go NIE dodaje.
        Zwraca (QHBoxLayout, QComboBox, QPushButton)
        """
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)
        filter_layout.setSpacing(4)

        filter_label = QLabel(label_text)
        filter_label.setFixedWidth(65)
        filter_layout.addWidget(filter_label)

        combo = CustomMultiComboBox()
        combo.setFixedHeight(24)
        combo.view().setMaximumWidth(240)
        combo.selection_changed.connect(self.filter_data)
        setattr(self, combo_name, combo)

        # ZMIANA: Dodajemy kontrolkƒô z priorytetem rozciƒÖgania (stretch=1)
        filter_layout.addWidget(combo, 1)

        clear_button = QPushButton()
        icon = self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light
        clear_button.setIcon(icon)
        clear_button.setObjectName("FilterClearButton")
        clear_button.setFixedSize(22, 22)
        clear_button.setToolTip(f"Wyczy≈õƒá filtr '{label_text}'")
        clear_button.setFlat(True)
        clear_button.clicked.connect(lambda: combo.clear_selection())

        # ZMIANA: Dodajemy przycisk bez priorytetu rozciƒÖgania (stretch=0)
        filter_layout.addWidget(clear_button, 0)

        return (filter_layout, combo, clear_button)

    def add_horizontal_search_filter(self, label_text, filter_name, list_widget_to_clear=None):
        """
        MODYFIKACJA: Tworzy layout filtra, ale go NIE dodaje.
        Zwraca (QHBoxLayout, QLineEdit, QPushButton)
        """
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)
        filter_layout.setSpacing(4)

        filter_label = QLabel(label_text)
        filter_label.setFixedWidth(65)
        filter_layout.addWidget(filter_label)

        text_edit = QLineEdit()
        text_edit.setPlaceholderText(f"Filtruj {label_text.lower()[:-1]}...")
        text_edit.setFixedHeight(24)
        setattr(self, filter_name, text_edit)

        # ZMIANA: Dodajemy kontrolkƒô z priorytetem rozciƒÖgania (stretch=1)
        filter_layout.addWidget(text_edit, 1)

        clear_button = QPushButton()
        icon = self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light
        clear_button.setIcon(icon)
        clear_button.setObjectName("FilterClearButton")
        clear_button.setFixedSize(22, 22)
        clear_button.setToolTip(f"Wyczy≈õƒá filtr '{label_text}'")
        clear_button.setFlat(True)

        def clear_action():
            text_edit.blockSignals(True)
            if list_widget_to_clear: list_widget_to_clear.blockSignals(True)
            text_edit.clear()
            if list_widget_to_clear: list_widget_to_clear.clearSelection()
            text_edit.blockSignals(False)
            if list_widget_to_clear: list_widget_to_clear.blockSignals(False)
            self.filter_data()

        clear_button.clicked.connect(clear_action)

        # ZMIANA: Dodajemy przycisk bez priorytetu rozciƒÖgania (stretch=0)
        filter_layout.addWidget(clear_button, 0)

        return (filter_layout, text_edit, clear_button)

    def _create_all_filter_widgets(self, parent_widget=None):
        """
        Tworzy instancje wszystkich widget√≥w filtr√≥w i przechowuje je
        w self.filter_widget_map.

        Args:
            parent_widget (QWidget): Widget nadrzƒôdny (filter_container),
                                     kt√≥ry zapobiega "migotaniu" okien.
        """
        self.filter_widget_map = {}

        # --- LOGOWANIE ---
        debug_print(f"[Filtracja] _create_all_filter_widgets otrzyma≈Ç rodzica: {parent_widget}")
        # --- KONIEC LOGOWANIA ---

        # --- Filtr Obecno≈õci ---
        presence_group = QGroupBox("Obecni w pracy w dniu:", parent=parent_widget)
        presence_group.setCheckable(True)
        presence_group.setChecked(False)
        self.filter_by_presence_check = presence_group
        presence_layout = QGridLayout(presence_group)
        presence_layout.setContentsMargins(5, 10, 5, 5)
        self.presence_date_edit = QDateEdit(QDate.currentDate(), parent=presence_group)  # Ustawiamy rodzica
        self.presence_date_edit.setCalendarPopup(True)
        self.presence_date_edit.setDisplayFormat("dd.MM.yyyy")
        self.presence_location_combo = CustomMultiComboBox(parent=presence_group)  # Ustawiamy rodzica
        self.presence_location_combo.add_items(["Home Office (h)", "SBC (s)", "Przystanek (p)", "Bez lokalizacji"])
        self.presence_hour_combo = CustomMultiComboBox(parent=presence_group)  # Ustawiamy rodzica
        self.presence_hour_combo.add_items([f"{h:02d}:00" for h in range(24)])
        presence_layout.addWidget(QLabel("Data:"), 0, 0)
        presence_layout.addWidget(self.presence_date_edit, 0, 1)
        presence_layout.addWidget(QLabel("Lokalizacja:"), 1, 0)
        presence_layout.addWidget(self.presence_location_combo, 1, 1)
        presence_layout.addWidget(QLabel("Godzina:"), 2, 0)
        presence_layout.addWidget(self.presence_hour_combo, 2, 1)
        self.filter_by_presence_check.toggled.connect(self.filter_data)
        self.presence_date_edit.dateChanged.connect(self.filter_data)
        self.presence_location_combo.selection_changed.connect(self.filter_data)
        self.presence_hour_combo.selection_changed.connect(self.filter_data)

        presence_group.setVisible(False)
        self.filter_widget_map['presence'] = presence_group
        debug_print(
            f"[Filtracja] Stworzono widget 'presence'. Rodzic: {presence_group.parent()}, Widoczny: {presence_group.isVisible()}")

        # --- Separator ---
        separator = QFrame(parent=parent_widget)
        separator.setFrameShape(QFrame.HLine)
        separator.setFrameShadow(QFrame.Sunken)

        separator.setVisible(False)
        self.filter_widget_map['separator1'] = separator
        debug_print(
            f"[Filtracja] Stworzono widget 'separator1'. Rodzic: {separator.parent()}, Widoczny: {separator.isVisible()}")

        # --- Pozosta≈Çe filtry ---
        filter_definitions = [
            ("Grupa:", "grupa_main_filter_combo", "grupa"),
            ("Wydzia≈Ç:", "wydzial_combo", "wydzial"),
            ("LD:", "default_location_combo", "default_location"),
            ("System Pracy:", "system_czasu_pracy_combo", "system_czasu_pracy"),
            ("Rola:", "rola_combo", "rola"),
            ("PodRola:", "podrola_combo", "podrola"),
            ("Jƒôzyk:", "jezyk_combo", "jezyk"),
            ("Etat:", "etat_combo", "etat"),
            ("DTN:", "dtn_combo", "dtn"),
            ("Rka:", "rka_combo", "rka")
        ]

        for label, combo_name, f_id in filter_definitions:
            # add_horizontal_filter tworzy layout i widgety.
            # Wa≈ºne, ≈ºeby te widgety (combo, btn) mia≈Çy rodzica.
            layout, combo, btn = self.add_horizontal_filter(label, combo_name)

            # Tworzymy widget-kontener z w≈Ça≈õciwym rodzicem
            container_widget = QWidget(parent=parent_widget)

            # Przypisujemy rodzica (container_widget) do element√≥w layoutu
            # To jest kluczowe, aby combo i btn nie by≈Çy osierocone
            combo.setParent(container_widget)
            btn.setParent(container_widget)
            # Label jest ju≈º w layout, ale jego rodzicem te≈º staje siƒô container_widget
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if item and item.widget():
                    item.widget().setParent(container_widget)

            container_widget.setLayout(layout)
            container_widget.setVisible(False)
            self.filter_widget_map[f_id] = container_widget
            debug_print(
                f"[Filtracja] Stworzono widget '{f_id}'. Rodzic: {container_widget.parent()}, Widoczny: {container_widget.isVisible()}")

        # --- Filtry z≈Ço≈ºone (Wyszukiwanie + Lista) ---

        # Prze≈Ço≈ºony
        przelozony_widget = QWidget(parent=parent_widget)
        przelozony_v_layout = QVBoxLayout(przelozony_widget)
        przelozony_v_layout.setContentsMargins(0, 0, 0, 0)
        przelozony_v_layout.setSpacing(4)

        # Tworzymy listƒô z w≈Ça≈õciwym rodzicem
        self.przelozony_list = QListWidget(parent=przelozony_widget)
        self.przelozony_list.setMaximumHeight(150)

        # Tworzymy elementy wyszukiwania
        search_layout, self.przelozony_filter, clear_btn = self.add_horizontal_search_filter("Prze≈Ço≈ºony:",
                                                                                             "przelozony_filter",
                                                                                             list_widget_to_clear=self.przelozony_list)

        # Ustawiamy rodzic√≥w dla element√≥w z search_layout
        self.przelozony_filter.setParent(przelozony_widget)
        clear_btn.setParent(przelozony_widget)
        for i in range(search_layout.count()):
            item = search_layout.itemAt(i)
            if item and item.widget():
                item.widget().setParent(przelozony_widget)

        przelozony_v_layout.addLayout(search_layout)

        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)
        przelozony_v_layout.addWidget(self.przelozony_list)

        przelozony_widget.setVisible(False)
        self.filter_widget_map['przelozony'] = przelozony_widget
        debug_print(
            f"[Filtracja] Stworzono widget 'przelozony'. Rodzic: {przelozony_widget.parent()}, Widoczny: {przelozony_widget.isVisible()}")

        # U≈ºytkownik
        uzytkownik_widget = QWidget(parent=parent_widget)
        uzytkownik_v_layout = QVBoxLayout(uzytkownik_widget)
        uzytkownik_v_layout.setContentsMargins(0, 0, 0, 0)
        uzytkownik_v_layout.setSpacing(4)

        self.uzytkownik_list = QListWidget(parent=uzytkownik_widget)
        self.uzytkownik_list.setMaximumHeight(150)

        search_layout, self.uzytkownik_filter, clear_btn = self.add_horizontal_search_filter("U≈ºytkownik:",
                                                                                             "uzytkownik_filter",
                                                                                             list_widget_to_clear=self.uzytkownik_list)

        # Ustawiamy rodzic√≥w dla element√≥w z search_layout
        self.uzytkownik_filter.setParent(uzytkownik_widget)
        clear_btn.setParent(uzytkownik_widget)
        for i in range(search_layout.count()):
            item = search_layout.itemAt(i)
            if item and item.widget():
                item.widget().setParent(uzytkownik_widget)

        uzytkownik_v_layout.addLayout(search_layout)

        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)
        uzytkownik_v_layout.addWidget(self.uzytkownik_list)

        uzytkownik_widget.setVisible(False)
        self.filter_widget_map['uzytkownik'] = uzytkownik_widget
        debug_print(
            f"[Filtracja] Stworzono widget 'uzytkownik'. Rodzic: {uzytkownik_widget.parent()}, Widoczny: {uzytkownik_widget.isVisible()}")

    # --- NOWA METODA: Dynamicznie buduje layout filtr√≥w ---
    def _apply_filter_visibility_and_order(self):
        """
        Czy≈õci layout filtr√≥w i buduje go na nowo na podstawie
        self.visible_filters_list, u≈ºywajƒÖc widget√≥w z self.filter_widget_map.
        """
        if not hasattr(self, 'filters_layout') or not hasattr(self, 'filter_widget_map'):
            debug_print("[Filtracja] Przerwano _apply_filter_visibility_and_order: brak layoutu lub mapy.")
            return

        # --- LOGOWANIE ---
        debug_print("[Filtracja] Rozpoczynam przebudowƒô layoutu filtr√≥w...")
        # --- KONIEC LOGOWANIA ---

        # Wyczy≈õƒá stary layout
        while self.filters_layout.count():
            item = self.filters_layout.takeAt(0)
            widget = item.widget()
            if widget:
                # Wa≈ºne: tylko ukrywamy widget, nie usuwamy go!
                widget.setVisible(False)
                # USUWAMY Tƒò LINIƒò:
                # widget.setParent(None) # Ju≈º nie musimy usuwaƒá rodzica

                # --- LOGOWANIE ---
                debug_print(
                    f"[Filtracja] Usuwam z layoutu i ukrywam: {widget.objectName() or widget.__class__.__name__}")
                # --- KONIEC LOGOWANIA ---

        # Dodaj widgety w nowej kolejno≈õci
        for filter_id in self.visible_filters_list:
            widget = self.filter_widget_map.get(filter_id)
            if widget:
                # --- LOGOWANIE ---
                debug_print(f"[Filtracja] Dodajƒô do layoutu: {filter_id} (Rodzic: {widget.parent()})")
                # --- KONIEC LOGOWANIA ---

                # NAJPIERW dodaj do layoutu
                self.filters_layout.addWidget(widget)
                # DOPIERO TERAZ uczy≈Ñ widocznym
                widget.setVisible(True)

        self.filters_layout.addStretch()

        # --- LOGOWANIE ---
        debug_print("[Filtracja] Zako≈Ñczono przebudowƒô layoutu filtr√≥w.")
        # --- KONIEC LOGOWANIA ---

      # --- NOWA METODA: Otwiera dialog ustawie≈Ñ filtr√≥w ---
    def show_filter_select_dialog(self):
        """Wy≈õwietla dialog do zarzƒÖdzania widoczno≈õciƒÖ i kolejno≈õciƒÖ filtr√≥w."""

        # Stw√≥rz listƒô widocznych ID na podstawie aktualnego stanu
        current_visible_ids = self.visible_filters_list

        dialog = FilterSelectDialog(
            self,
            available_filters=self.ALL_FILTERS,
            visible_filters=current_visible_ids
        )

        if dialog.exec() == QDialog.Accepted:
            new_visible_list = dialog.get_visible_filters_ordered()

            # Zapisz zmiany
            self.visible_filters_list = new_visible_list
            self.user_app_settings['visible_filters'] = new_visible_list
            self.settings_db.save_settings(self.user_app_settings)

            # Przebuduj layout
            self._apply_filter_visibility_and_order()

    def load_initial_data(self):
        """Uruchamia proces ≈Çadowania danych i jednorazowo aplikuje zapisane sortowanie."""
        debug_print("Uruchamianie leniwego ≈Çadowania danych poczƒÖtkowych...")
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            # Tworzymy jednorazowƒÖ funkcjƒô obs≈Çugi, aby zastosowaƒá sortowanie po za≈Çadowaniu danych
            def initial_load_handler(data):
                # Najpierw standardowo zastosuj dane
                self._on_async_data_loaded(data)
                # A nastƒôpnie, tylko ten jeden raz, zastosuj zapisane sortowanie
                self.apply_custom_sort()
                # Od≈ÇƒÖcz ten handler, aby nie zosta≈Ç ponownie wywo≈Çany
                if hasattr(self, 'loading_dialog') and self.loading_dialog:
                    try:
                        self.loading_dialog.loading_completed.disconnect(initial_load_handler)
                    except (TypeError, RuntimeError):
                        pass  # Ignoruj b≈ÇƒÖd, je≈õli sygna≈Ç by≈Ç ju≈º od≈ÇƒÖczony

            # Rozpocznij asynchroniczne ≈Çadowanie
            self.update_data(year, month, self.import_grupa, self.import_funkcja, use_async=True)

            # Pod≈ÇƒÖcz nasz jednorazowy handler do sygna≈Çu zako≈Ñczenia ≈Çadowania
            if hasattr(self, 'loading_dialog') and self.loading_dialog:
                self.loading_dialog.loading_completed.connect(initial_load_handler)

            self.update_filter_dates()

    def setup_right_panel(self):
        """Tworzy prawy panel z tabelami"""
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)
        right_splitter = QSplitter(Qt.Vertical)
        schedule_frame = self.setup_schedule_section()
        events_frame = self.setup_events_section()
        right_splitter.addWidget(schedule_frame)
        right_splitter.addWidget(events_frame)
        right_splitter.setSizes([650, 350])
        right_layout.addWidget(right_splitter)
        return right_panel

    def setup_schedule_section(self):
        """Tworzy sekcjƒô grafiku (g√≥rna czƒô≈õƒá prawego panelu) u≈ºywajƒÖc SplitTableView."""
        schedule_frame = QFrame()
        schedule_layout = QVBoxLayout(schedule_frame)
        schedule_layout.setContentsMargins(5, 5, 5, 5)

        self.table = SplitTableView()
        schedule_layout.addWidget(self.table)

        # Tworzymy przycisk i kontener na pozosta≈Çe przyciski
        self.manage_columns_button = QPushButton("Dostosuj widok")
        button_frame = self.setup_schedule_buttons()
        button_layout = button_frame.layout()

        # Wstawiamy przycisk zarzƒÖdzania kolumnami na poczƒÖtek layoutu z przyciskami
        if isinstance(button_layout, QHBoxLayout):
            button_layout.insertWidget(0, self.manage_columns_button)

        # --- POCZƒÑTEK POPRAWKI ---
        # Dodajemy kontener z WSZYSTKIMI przyciskami do layoutu sekcji grafiku - TYLKO RAZ.
        # Usuniƒôto zduplikowanƒÖ liniƒô, kt√≥ra powodowa≈Ça b≈ÇƒÖd.
        schedule_layout.addWidget(button_frame)
        # --- KONIEC POPRAWKI ---

        return schedule_frame

    def setup_schedule_buttons(self):
        """Tworzy przyciski akcji dla sekcji grafiku"""
        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setContentsMargins(0, 0, 0, 0)
        button_frame.setFixedHeight(40)
        button_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.toggle_events_panel_button = QPushButton("Ukryj zdarzenia‚Üì")
        self.toggle_events_panel_button.setToolTip("Ukryj panel zdarze≈Ñ (dla wiƒôkszego widoku grafiku) (F2)")
        self.toggle_events_panel_button.clicked.connect(self.toggle_events_panel)
        self.location_exception_button = QPushButton("WyjƒÖtki lokalizacyjne")
        self.location_exception_button.setToolTip("ZarzƒÖdzaj wyjƒÖtkami od domy≈õlnej lokalizacji pracy")
        self.location_exception_button.clicked.connect(self.show_location_exception_dialog)
        button_layout.addWidget(self.location_exception_button)
        button_layout.addStretch()
        self.insert_change_button = QPushButton("Wstaw zmianƒô")
        self.insert_change_button.setToolTip("Wstaw zmianƒô grafiku (F3)")
        self.insert_change_button.clicked.connect(self.show_insert_change_dialog)
        button_layout.addWidget(self.insert_change_button)
        self.insert_symbol_button = QPushButton("Wstaw nieobecno≈õƒá")
        self.insert_symbol_button.setToolTip("Wstaw nieobecno≈õƒá (F4)")
        self.insert_symbol_button.clicked.connect(self.show_insert_symbol_dialog)
        button_layout.addWidget(self.insert_symbol_button)
        self.cancel_delegation_button = QPushButton("Odwo≈Çaj delegacje")
        self.cancel_delegation_button.setToolTip("Odwo≈Çaj delegacje dla zaznaczonych kom√≥rek (F5)")
        self.cancel_delegation_button.clicked.connect(lambda: self.cancel_delegations())
        button_layout.addWidget(self.cancel_delegation_button)
        self.add_overtime_button = QPushButton("Dodaj nadgodziny")
        # self.add_overtime_button.setShortcut("Insert")
        self.add_overtime_button.setToolTip("Dodaj nadgodziny dla zaznaczonych kom√≥rek (Insert)")
        self.add_overtime_button.clicked.connect(self.show_add_overtime_dialog)
        button_layout.addWidget(self.add_overtime_button)
        # Usuniƒôto redundantny warunek, widoczno≈õƒá jest zarzƒÖdzana przez update_buttons_visibility
        return button_frame

    def setup_events_section(self):
        """Tworzy sekcjƒô zdarze≈Ñ u≈ºywajƒÖc QTableView i od razu konfiguruje jej kolumny."""
        events_frame = QFrame()
        events_frame.setFrameShape(QFrame.Shape.StyledPanel)
        events_frame.setFrameShadow(QFrame.Shadow.Raised)
        events_layout = QVBoxLayout(events_frame)
        events_layout.setContentsMargins(5, 5, 5, 5)

        filters_frame = self.setup_events_filters()
        events_layout.addWidget(filters_frame)

        self.events_table = QTableView()
        self.events_table.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.events_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.events_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)

        events_layout.addWidget(self.events_table)
        return events_frame

    def setup_events_filters(self):
        """Konfiguruje filtry dla tabeli zdarze≈Ñ w jednej linii."""
        events_filter_frame = QFrame()
        # ZMIANA: Powr√≥t do uk≈Çadu poziomego
        events_filter_layout = QHBoxLayout(events_filter_frame)
        events_filter_layout.setContentsMargins(0, 5, 0, 5)

        # Filtry daty od-do z przywr√≥conym kalendarzem
        self.date_from = QDateEdit(QDate.currentDate().addDays(-30))
        self.date_from.setCalendarPopup(True)  # POPRAWKA: Przywr√≥cenie kalendarza
        self.date_to = QDateEdit(QDate.currentDate())
        self.date_to.setCalendarPopup(True)  # POPRAWKA: Przywr√≥cenie kalendarza

        # Filtry tekstowe i statusu
        self.topic_filter = QLineEdit()
        self.topic_filter.setPlaceholderText("Filtruj po temacie...")
        self.name_filter = QLineEdit()
        self.name_filter.setPlaceholderText("Filtruj po nazwie...")
        self.status_filter_combo = CustomMultiComboBox()
        self.status_filter_combo.setMinimumWidth(130)

        # Checkboxy
        self.meetings_checkbox = QCheckBox("Spotkania")
        self.trainings_checkbox = QCheckBox("Szkolenia")
        self.overtime_checkbox = QCheckBox("Nadgodziny")
        self.meetings_checkbox.setChecked(True)
        self.trainings_checkbox.setChecked(True)
        self.overtime_checkbox.setChecked(True)

        # Dodanie wszystkich kontrolek do layoutu w poprawnej kolejno≈õci
        events_filter_layout.addWidget(QLabel("Data od:"))
        events_filter_layout.addWidget(self.date_from)
        events_filter_layout.addWidget(QLabel("Data do:"))
        events_filter_layout.addWidget(self.date_to)
        events_filter_layout.addWidget(QLabel("Temat:"))
        events_filter_layout.addWidget(self.topic_filter)
        events_filter_layout.addWidget(QLabel("Nazwa:"))
        events_filter_layout.addWidget(self.name_filter)
        events_filter_layout.addWidget(QLabel("Status:"))
        events_filter_layout.addWidget(self.status_filter_combo)

        events_filter_layout.addStretch()  # Wype≈Çniacz, aby odsunƒÖƒá checkboxy na prawo

        events_filter_layout.addWidget(self.meetings_checkbox)
        events_filter_layout.addWidget(self.trainings_checkbox)
        events_filter_layout.addWidget(self.overtime_checkbox)

        # Po≈ÇƒÖczenie sygna≈Ç√≥w (bez zmian)
        self.date_from.dateChanged.connect(self.filter_events_table)
        self.date_to.dateChanged.connect(self.filter_events_table)
        self.topic_filter.textChanged.connect(self.filter_events_table)
        self.name_filter.textChanged.connect(self.filter_events_table)
        self.meetings_checkbox.stateChanged.connect(self.filter_events_table)
        self.trainings_checkbox.stateChanged.connect(self.filter_events_table)
        self.overtime_checkbox.stateChanged.connect(self.filter_events_table)
        self.status_filter_combo.selection_changed.connect(self.filter_events_table)

        return events_filter_frame

    def setup_events_table_columns(self):
        """Konfiguruje kolumny dla tabeli zdarze≈Ñ, w tym ich szeroko≈õƒá."""
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        header = self.events_table.horizontalHeader()
        self.events_table.setSortingEnabled(True)

        # ZMIANA: Zaktualizowane indeksy kolumn
        header.setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        header.setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        header.setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        header.setSectionResizeMode(4, QHeaderView.ResizeToContents)  # U≈ºytkownik
        header.setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        header.setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Czas od
        header.setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Czas do
        header.setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        header.setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Data Modyfikacji

        # Ustaw sta≈ÇƒÖ, wiƒôkszƒÖ szeroko≈õƒá dla kolumny Akcje (teraz indeks 10)
        header.setSectionResizeMode(10, QHeaderView.Fixed)
        self.events_table.setColumnWidth(10, 80)

    def setup_table_properties(self):
        """Konfiguruje w≈Ça≈õciwo≈õci tabel i tworzy delegat√≥w z ustawieniami."""
        self.events_table.setSortingEnabled(True)
        # Usuniƒôto liniƒô resetujƒÖcƒÖ sortowanie tabeli zdarze≈Ñ:
        # self.events_table.sortByColumn(0, Qt.AscendingOrder)

        if hasattr(self, 'table') and hasattr(self.table, 'employees_view'):
            self.table.employees_view.setSortingEnabled(True)
            # Usuniƒôto liniƒô, kt√≥ra czy≈õci≈Ça sortowanie tabeli grafiku:
            # self.table.employees_view.sortByColumn(-1, Qt.AscendingOrder)

        if hasattr(self.table, 'employees_view') and hasattr(self.table.employees_view, 'horizontalHeader'):
            self.table.employees_view.horizontalHeader().sortIndicatorChanged.connect(self.on_sort_changed)

        if hasattr(self.events_table, 'horizontalHeader'):
            self.events_table.horizontalHeader().sortIndicatorChanged.connect(self.on_events_sort_changed)
            self.setup_events_table_columns()

        overtime_delegate = OvertimeItemDelegate(settings=self.user_app_settings)
        self.table.schedule_view.setItemDelegate(overtime_delegate)

        button_delegate = ButtonDelegate(parent=self, button_text="Odwo≈Çaj", is_dark_theme=self.is_dark_theme)
        button_delegate.button_clicked.connect(self.delete_event_from_row)
        self.events_table.setItemDelegateForColumn(10, button_delegate)  # "Akcje" to kolumna 10

        self.table.day_sort_requested.connect(self.apply_day_sort)

    def apply_day_sort(self, day: int, order: Qt.SortOrder):
        """
        Wywo≈Çuje sortowanie w modelu danych na podstawie wybranego dnia.
        """
        if hasattr(self, 'schedule_model') and self.schedule_model:
            self.schedule_model.sort_by_day(day, order)

    def toggle_left_panel(self):
        """Prze≈ÇƒÖcza widoczno≈õƒá lewego panelu filtr√≥w z zapamiƒôtywaniem rozmiaru."""
        current_sizes = self.main_splitter.sizes()

        # Sprawd≈∫, czy lewy panel jest zwiniƒôty (jego rozmiar jest bliski zeru)
        if current_sizes[0] < 10:
            # Rozwi≈Ñ panel do ostatniej znanej lub domy≈õlnej szeroko≈õci
            right_width = max(0, sum(current_sizes) - self.last_left_panel_width)
            self.main_splitter.setSizes([self.last_left_panel_width, right_width])
        else:
            # Zwi≈Ñ panel, zapamiƒôtujƒÖc jego aktualnƒÖ szeroko≈õƒá
            self.last_left_panel_width = current_sizes[0]
            self.main_splitter.setSizes([0, sum(current_sizes)])

    def toggle_events_panel(self):
        """Prze≈ÇƒÖcza widoczno≈õƒá panelu zdarze≈Ñ (dolny panel)"""
        right_splitter = self.centralWidget().findChild(QSplitter, self.main_splitter.objectName()).widget(1).findChild(
            QSplitter)
        if not right_splitter: return

        sizes = right_splitter.sizes()
        if sizes[1] > 0:
            self.events_panel_height = sizes[1]
            right_splitter.setSizes([sum(sizes), 0])
            self.toggle_events_panel_button.setText("Poka≈º zdarzenia‚Üë")
        else:
            schedule_height = right_splitter.height() - getattr(self, 'events_panel_height', 300)
            right_splitter.setSizes([schedule_height, getattr(self, 'events_panel_height', 300)])
            self.toggle_events_panel_button.setText("Ukryj zdarzenia‚Üì")

    def export_schedule_to_excel(self):
        """
        Zbiera aktualnie widoczne dane z grafiku i eksportuje je do sformatowanego
        pliku Excel (.xlsx) przy u≈ºyciu biblioteki openpyxl.
        """
        if not self.schedule_model or self.schedule_model.rowCount() == 0:
            QMessageBox.warning(self, "Brak danych", "Brak danych do wyeksportowania.")
            return

        default_filename = f"grafik_{self.year}-{self.month:02d}.xlsx"
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Zapisz plik Excel", default_filename, "Pliki Excel (*.xlsx);;Wszystkie pliki (*)"
        )

        if not file_path:
            return

        try:
            # 1. Przygotowanie danych (logika podobna do poprzedniej)
            headers = self.schedule_model._column_headers[:len(self.visible_columns)]
            days_in_month = self.schedule_model._days_in_month
            day_headers = self.schedule_model._column_headers[
                len(self.visible_columns):len(self.visible_columns) + days_in_month]
            # --- ZMIANA: Tworzymy jeden, po≈ÇƒÖczony nag≈Ç√≥wek dnia (np. "Pn 1") ---
            day_letters = [h.split('<br>')[1] for h in day_headers]
            day_numbers = [h.split('<br>')[0] for h in day_headers]
            visible_keys = self.schedule_model._keys
            data_rows = []
            for key in visible_keys:
                row_data = self.processed_data.get(key, {})
                row_to_write = []
                for col_id in self.visible_columns:
                    # Logika zbierania danych o pracownikach
                    if col_id == 'wydzial':
                        row_to_write.append(key[0])
                    elif col_id == 'przelozony':
                        row_to_write.append(key[1])
                    elif col_id == 'uzytkownik_dane':
                        row_to_write.append(key[2])
                    else:
                        row_to_write.append(str(row_data.get(col_id, '')))

                # Logika zbierania symboli z grafiku
                days_data = row_data.get('days', {})
                for day in range(1, days_in_month + 1):
                    symbol = days_data.get(day, {}).get('symbol', '')
                    row_to_write.append(symbol)
                data_rows.append(row_to_write)

            # 2. Tworzenie pliku Excel i zapis danych
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = f"Grafik {self.year}-{self.month:02d}"

            # 3. Formatowanie i dodawanie nag≈Ç√≥wk√≥w
            header_font = Font(bold=True, color="FFFFFF")
            header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
            weekend_fill = PatternFill(start_color="FFF2F2F2", end_color="FFF2F2F2", fill_type="solid")

            # --- ZMIANA: Dodajemy dwa wiersze nag≈Ç√≥wk√≥w w nowej konfiguracji ---
            ws.append([''] * len(headers) + day_letters)
            ws.append(headers + day_numbers)

            for row in ws.iter_rows(min_row=1, max_row=2, min_col=1, max_col=ws.max_column):
                for cell in row:
                    cell.font = header_font
                    cell.fill = header_fill
                    cell.alignment = Alignment(horizontal='center', vertical='center')

            # 4. Zapis danych
            for row in data_rows:
                ws.append(row)

            # 5. Dodatkowe formatowanie
            employee_cols_count = len(self.visible_columns)

            # Zablokowanie okienek (kolumny pracownicze)
            first_day_column_letter = get_column_letter(employee_cols_count + 1)
            ws.freeze_panes = f"{first_day_column_letter}3"

            # Wyr√≥≈ºnienie weekend√≥w
            weekend_columns = self.schedule_model._weekend_columns
            for weekend_col_idx in weekend_columns:
                col_letter = get_column_letter(employee_cols_count + weekend_col_idx + 1)
                for cell in ws[col_letter]:
                    cell.fill = weekend_fill

            # Automatyczne dopasowanie szeroko≈õci kolumn
            for i, column_cells in enumerate(ws.columns):
                # Dla dni grafiku ustawiamy sta≈ÇƒÖ szeroko≈õƒá
                if i >= employee_cols_count:
                    ws.column_dimensions[get_column_letter(i + 1)].width = 5
                else:  # Dla kolumn pracowniczych dopasowujemy do zawarto≈õci
                    max_length = 0
                    column = get_column_letter(i + 1)
                    for cell in column_cells:
                        try:
                            if len(str(cell.value)) > max_length:
                                max_length = len(cell.value)
                        except:
                            pass
                    adjusted_width = (max_length + 2)
                    ws.column_dimensions[column].width = adjusted_width

            # 6. Zapis pliku
            wb.save(file_path)

            QMessageBox.information(self, "Eksport zako≈Ñczony",
                                    f"Dane zosta≈Çy pomy≈õlnie zapisane w pliku:<br>{file_path}")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas eksportu do Excel (.xlsx): {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd eksportu", f"WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd:<br>{e}")

    def show_column_select_dialog(self):
        """Wy≈õwietla rozbudowany dialog wyboru kolumn i sortowania."""
        from column_select_dialog import ColumnSelectDialog
        try:
            if not hasattr(self, 'schedule_model'):
                QMessageBox.warning(self, "B≈ÇƒÖd", "Model danych nie jest zainicjalizowany.")
                return

            # --- POCZƒÑTEK NOWEJ LOGIKI (KROK 1) ---
            # Zapisz stan PRZED otwarciem dialogu
            old_visible_set = set(self.visible_columns)
            # Pobierz aktualne szeroko≈õci widocznych kolumn
            current_column_widths = self.table.get_column_widths()
            # Pobierz aktualne rozmiary splittera
            current_splitter_sizes = self.table.splitter.sizes()
            current_left_width = current_splitter_sizes[0]
            # --- KONIEC NOWEJ LOGIKI (KROK 1) ---

            dialog = ColumnSelectDialog(
                self, self.employee_columns, self.visible_columns, self.default_visible_columns,
                user_role=self.current_user_app_role,
                is_comment_column_checked=self.show_comment_column,
                sort_preferences=self.user_sort_preferences
            )
            if dialog.exec() == QDialog.Accepted:

                # --- POCZƒÑTEK NOWEJ LOGIKI (KROK 2) ---

                # 2. Pobierz nowy stan z dialogu
                self.visible_columns = dialog.get_selected_columns()
                self.show_comment_column = dialog.get_comment_column_state()
                new_visible_set = set(self.visible_columns)

                # 3. Zapisz ustawienia
                self.user_app_settings['visible_columns'] = self.visible_columns
                self.user_app_settings['show_schedule_comment'] = self.show_comment_column

                self.user_sort_preferences = dialog.get_sort_preferences()
                self.user_app_settings['sort_preferences'] = self.user_sort_preferences

                self.settings_db.save_settings(self.user_app_settings)

                # 4. Oblicz r√≥≈ºnicƒô szeroko≈õci (delta)
                delta_width = 0

                # Kolumny, kt√≥re w≈Ça≈õnie ukryto
                hidden_cols = old_visible_set - new_visible_set
                for col_id in hidden_cols:
                    # Odejmij szeroko≈õƒá ukrytej kolumny
                    delta_width -= current_column_widths.get(col_id, 100)  # 100 jako fallback
                    debug_print(
                        f"Ukryto kolumnƒô: {col_id}, szeroko≈õƒá: {current_column_widths.get(col_id, 100)}, delta: {delta_width}")

                # Kolumny, kt√≥re w≈Ça≈õnie pokazano
                shown_cols = new_visible_set - old_visible_set
                saved_widths = self.user_app_settings.get('column_widths', {})

                for col_id in shown_cols:
                    # Dodaj szeroko≈õƒá nowo pokazanej kolumny
                    if col_id in saved_widths:
                        width_to_add = saved_widths[col_id]
                    else:
                        # Pobierz domy≈õlnƒÖ szeroko≈õƒá z definicji
                        default_width = 100  # fallback
                        for f_id, f_name, f_width in self.employee_columns:
                            if f_id == col_id:
                                default_width = f_width if f_width is not None else 100
                                break
                        width_to_add = default_width

                    delta_width += width_to_add
                    debug_print(f"Pokazano kolumnƒô: {col_id}, szeroko≈õƒá: {width_to_add}, delta: {delta_width}")

                debug_print(f"Splitter adjustment: final delta_width = {delta_width}")

                # 5. Zastosuj zmiany w modelu i UI
                self.schedule_model.set_visible_columns(self.visible_columns)
                self.schedule_model.set_show_comment_column(self.show_comment_column)

                # refresh_column_configuration zaktualizuje model w tabeli (i ukryje/poka≈ºe kolumny)
                self.refresh_column_configuration()

                if hasattr(self, 'table'):
                    # 6. Zastosuj nowe rozmiary splittera
                    new_left_width = current_left_width + delta_width
                    new_left_width = max(50, new_left_width)  # Minimum 50px

                    # Pobierz ca≈ÇkowitƒÖ szeroko≈õƒá splittera, aby obliczyƒá prawƒÖ stronƒô
                    total_width = self.table.splitter.width()
                    new_right_width = total_width - new_left_width - self.table.splitter.handleWidth()
                    new_right_width = max(100, new_right_width)  # Minimum 100px

                    # U≈ºyj setSizes, aby poprawnie ustawiƒá obie strony
                    self.table.splitter.setSizes([new_left_width, new_right_width])
                    debug_print(f"Splitter sizes set to: {[new_left_width, new_right_width]}")

                    # Ta metoda ustawi m.in. wysoko≈õƒá wierszy i szeroko≈õƒá kolumn dni
                    self._apply_dynamic_sizes()

                    # Zastosuj nowe sortowanie
                self.apply_custom_sort()

                # --- KONIEC NOWEJ LOGIKI (KROK 2) ---

        except Exception as e:
            log_error(f"B≈ÇƒÖd w show_column_select_dialog: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd: {str(e)}")

    def apply_custom_sort(self):
        """
        Sortuje dane w modelu na podstawie preferencji u≈ºytkownika, u≈ºywajƒÖc
        dedykowanej, wielopoziomowej funkcji por√≥wnujƒÖcej.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model._processed_data:
            return

        sort_prefs = self.user_sort_preferences
        keys_to_sort = self.schedule_model._keys

        self.schedule_model.layoutAboutToBeChanged.emit()

        if sort_prefs:
            debug_print(f"Aplikowanie sortowania niestandardowego (compare func): {sort_prefs}")

            def compare_rows(key_a, key_b):
                """Funkcja por√≥wnujƒÖca, kt√≥ra analizuje wszystkie kryteria sortowania naraz."""
                for col_id, direction in sort_prefs:
                    val_a = self.schedule_model._get_sort_key(key_a, col_id)
                    val_b = self.schedule_model._get_sort_key(key_b, col_id)

                    # Zabezpieczenie na wypadek por√≥wnywania r√≥≈ºnych typ√≥w (np. None i string)
                    if type(val_a) is not type(val_b):
                        val_a, val_b = str(val_a), str(val_b)

                    result = 0
                    try:
                        if val_a < val_b:
                            result = -1
                        elif val_a > val_b:
                            result = 1
                    except TypeError:  # Dodatkowe zabezpieczenie
                        val_a, val_b = str(val_a), str(val_b)
                        if val_a < val_b:
                            result = -1
                        elif val_a > val_b:
                            result = 1

                    # Je≈õli warto≈õci nie sƒÖ r√≥wne, zwracamy wynik (z uwzglƒôdnieniem kierunku)
                    # i ko≈Ñczymy por√≥wnywanie.
                    if result != 0:
                        return result * -1 if direction == 'desc' else result

                # Je≈õli po sprawdzeniu wszystkich kryteri√≥w wiersze sƒÖ r√≥wne, zwracamy 0.
                return 0

            keys_to_sort.sort(key=functools.cmp_to_key(compare_rows))

        self.schedule_model.layoutChanged.emit()

        # Ustaw wska≈∫nik wizualny w nag≈Ç√≥wku, aby odzwierciedla≈Ç sortowanie
        emp_header = self.table.employees_view.horizontalHeader()
        sched_header = self.table.schedule_view.horizontalHeader()

        emp_header.setSortIndicator(-1, Qt.AscendingOrder)
        sched_header.setSortIndicator(-1, Qt.AscendingOrder)

        if sort_prefs:
            first_col_id, first_direction = sort_prefs[0]
            order = Qt.DescendingOrder if first_direction == 'desc' else Qt.AscendingOrder

            if hasattr(self, 'visible_columns'):
                try:
                    col_index = self.visible_columns.index(first_col_id)
                    emp_header.setSortIndicator(col_index, order)
                except ValueError:
                    pass

        debug_print("Zako≈Ñczono sortowanie niestandardowe (compare func).")

    def _apply_dynamic_sizes(self):
        """Ustawia dynamiczne rozmiary w zale≈ºno≈õci od rozmiaru czcionki ORAZ zapisanych ustawie≈Ñ."""
        if not hasattr(self, 'table') or not self.table.employees_view.model() or self.schedule_model.rowCount() == 0:
            return

        # --- POCZƒÑTEK ZMIANY: Logika szeroko≈õci kolumn ---
        saved_widths = self.user_app_settings.get('column_widths', {})

        # Zastosuj zapisane szeroko≈õci
        visible_columns = self.schedule_model.get_visible_columns()
        for i, col_id in enumerate(visible_columns):
            if col_id in saved_widths:
                self.table.employees_view.setColumnWidth(i, saved_widths[col_id])
        # --- KONIEC ZMIANY ---

        font_size = self.current_font_size
        width_map = {7: 35, 8: 40, 9: 45, 10: 50, 11: 55, 12: 60}
        day_column_width = width_map.get(font_size, 40)
        height_map = {7: 25, 8: 25, 9: 25, 10: 28, 11: 28, 12: 30}
        row_height = height_map.get(font_size, 25)
        header_height_map = {7: 30, 8: 35, 9: 35, 10: 38, 11: 40, 12: 42}
        header_height = header_height_map.get(font_size, 35)

        self.table.set_header_height(header_height)
        header = self.table.schedule_view.horizontalHeader()
        model = self.table.employees_view.model()
        special_widths = {"Suma<br>RBH": 45, "Bilans<br>RBH": 45, "Komentarz": 300}

        for logical_index in range(model.columnCount()):
            header_text = model.headerData(logical_index, Qt.Horizontal, Qt.DisplayRole)
            width_to_set = special_widths.get(header_text, day_column_width)
            header.resizeSection(logical_index, width_to_set)

        days_in_month = model._days_in_month
        employee_cols_count = len(model.get_visible_columns())
        for day in range(1, 32):
            logical_index = employee_cols_count + (day - 1)
            if logical_index < model.columnCount():
                header.setSectionHidden(logical_index, day > days_in_month)

        self.table._force_sync_heights(row_height)

    def showEvent(self, event):
        """Automatycznie wywo≈Çywane przez Qt, gdy okno jest pokazywane po raz pierwszy."""
        super().showEvent(event)

        # Sprawd≈∫, czy inicjalizacja UI zosta≈Ça ju≈º wykonana i czy tabela istnieje
        if not hasattr(self, '_initial_layout_done') and hasattr(self, 'table') and hasattr(self.table, 'splitter'):

            # Pobierz zapisane rozmiary splittera
            saved_sizes = self.user_app_settings.get('schedule_splitter_sizes')

            if saved_sizes and isinstance(saved_sizes, list) and len(saved_sizes) == 2 and sum(saved_sizes) > 100:
                # PRZYPADEK 1: Mamy zapisany i poprawny stan. Przywr√≥ƒá go.
                debug_print(f"Wykryto showEvent - przywracanie szeroko≈õci splittera: {saved_sizes}")
                self.table.splitter.setSizes(saved_sizes)
            else:
                # PRZYPADEK 2: Nie ma zapisanego stanu (lub jest niepoprawny). U≈ºyj logiki domy≈õlnej.
                debug_print("Wykryto showEvent - ustawianie domy≈õlnej szeroko≈õci splittera.")
                self.table.adjust_employees_table_width()

            self._initial_layout_done = True  # Oznacz jako wykonane

    def delete_event_from_row(self, row):
        """Usuwa zdarzenie na podstawie indeksu wiersza w tabeli zdarze≈Ñ."""
        if not hasattr(self, 'events_model') or not self.events_model:
            return
        event = self.events_model.get_event(row)
        if not event:
            return
        event_id = event.get('id')
        event_type = event.get('type')
        if not event_id or not event_type:
            return
        self.delete_event(event_id, event_type)

    def on_sort_changed(self, logical_index, order):
        """Obs≈Çuguje zmianƒô sortowania w tabeli grafiku"""
        self.last_sort_column = logical_index
        self.last_sort_order = order
        debug_print(
            f"Tabela grafiku: Sortowanie po kolumnie {logical_index}, kolejno≈õƒá: {'rosnƒÖco' if order == Qt.AscendingOrder else 'malejƒÖco'}")

    def on_events_sort_changed(self, logical_index, order):
        """Obs≈Çuguje zmianƒô sortowania w tabeli zdarze≈Ñ"""
        debug_print(
            f"Tabela zdarze≈Ñ: Sortowanie po kolumnie {logical_index}, kolejno≈õƒá: {'rosnƒÖco' if order == Qt.AscendingOrder else 'malejƒÖco'}")

    def update_buttons_visibility(self):
        """Aktualizuje widoczno≈õƒá przycisk√≥w na podstawie roli u≈ºytkownika"""
        is_next_month_selected = False
        current_data = self.date_combo.currentData()
        if current_data:
            selected_year, selected_month = current_data
            today = QDate.currentDate()
            next_month_date = today.addMonths(1)
            if selected_year == next_month_date.year() and selected_month == next_month_date.month():
                is_next_month_selected = True

        # U≈ºycie centralnej funkcji do zarzƒÖdzania widoczno≈õciƒÖ przycisk√≥w
        if hasattr(self, 'add_overtime_button'):
            self.add_overtime_button.setVisible(
                app_settings.has_permission(self.current_user_app_role, 'button_add_overtime'))
        if hasattr(self, 'staffing_details_button'):  #
            self.staffing_details_button.setVisible(
                app_settings.has_permission(self.current_user_app_role, 'button_staffing_details'))
        if hasattr(self, 'show_audit_button'):
            self.show_audit_button.setVisible(
                app_settings.has_permission(self.current_user_app_role, 'button_show_audit'))
        if hasattr(self, 'schedule_control_button'):
            can_see_button = app_settings.has_permission(self.current_user_app_role, 'button_schedule_control')
            self.schedule_control_button.setVisible(can_see_button and is_next_month_selected)
        # Ukryj przycisk wyjƒÖtk√≥w lokalizacyjnych dla roli Lider OUT
        if hasattr(self, 'location_exception_button'):
            self.location_exception_button.setVisible(self.current_user_app_role != 'Lider OUT')
        if hasattr(self, 'send_email_button'):
            self.send_email_button.setVisible(
                app_settings.has_permission(self.current_user_app_role, 'button_send_email'))
        # Nowy przycisk jest domy≈õlnie widoczny dla wszystkich, kt√≥rzy majƒÖ dostƒôp do wysy≈Çania e-maili
        if hasattr(self, 'teams_chat_button'):
            self.teams_chat_button.setVisible(
                app_settings.has_permission(self.current_user_app_role, 'button_send_email'))

    def show_audit_log_window(self):
        """Tworzy i pokazuje okno historii zmian."""
        # Leniwe importowanie
        from audit_log_window import AuditLogWindow

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Proszƒô najpierw wybraƒá miesiƒÖc.")
            return

        year, month = current_data

        def _get_filtered_audit_data():
            full_data = self.data_provider.get_schedule_audit_data(year, month)
            selected_cells = self.table.get_data_for_selected_cells()
            if selected_cells:
                allowed_users_dates = set()
                for cell in selected_cells:
                    if (user_id := cell.get('uzytkownik_id')) and (date_str := cell.get('date_str')):
                        date_obj = QDate.fromString(date_str, "yyyy-MM-dd").toPython()
                        allowed_users_dates.add((user_id, date_obj))
                return [row for row in full_data if
                        row.get('Data') and (int(row.get('Uzytkownik')), row.get('Data').date()) in allowed_users_dates]
            else:
                visible_user_ids = {key[3] for key in self.schedule_model._keys}
                filtered_by_visibility = [row for row in full_data if row.get('Uzytkownik') is not None and int(
                    row.get('Uzytkownik')) in visible_user_ids]
                sorted_data = sorted(filtered_by_visibility, key=lambda x: x.get('DataModyfikacji'), reverse=True)
                return sorted_data[:50]

        selected_cells = self.table.get_data_for_selected_cells()
        is_limited = not selected_cells
        limit_count = 50
        initial_filtered_data = _get_filtered_audit_data()
        if not initial_filtered_data:
            QMessageBox.information(self, "Informacja", "Brak historii zmian dla wybranych filtr√≥w / zaznaczenia.")
            return

        dialog = AuditLogWindow(initial_filtered_data, self.is_dark_theme, self, is_limited_view=is_limited, year=year,
                                month=month, limit=limit_count)

        def on_refresh_requested():
            self.data_provider.clear_audit_cache(year, month)
            fresh_filtered_data = _get_filtered_audit_data()
            dialog.update_model_data(fresh_filtered_data)
            QMessageBox.information(dialog, "Od≈õwie≈ºono", "Historia zmian zosta≈Ça zaktualizowana.")

        dialog.refresh_requested.connect(on_refresh_requested)
        dialog.exec()

    def check_user_permissions(self):
        """Sprawdza uprawnienia u≈ºytkownika i zapisuje je w atrybutach klasy."""
        user_app_id, user_app_nr_kadrowy, user_app_role, visible_next_month, user_app_department, user_app_login_windows = get_modifier_id()
        self.current_user_app_id = user_app_id
        self.current_user_app_nr_kadrowy = user_app_nr_kadrowy
        self.current_user_app_login_windows = user_app_login_windows

        # --- POCZƒÑTEK POPRAWKI: Dynamiczna rekonfiguracja po zmianie roli ---
        # Sprawd≈∫, czy rola siƒô zmieni≈Ça od ostatniego sprawdzenia
        if self.current_user_app_role != user_app_role:
            debug_print(f"Wykryto zmianƒô roli u≈ºytkownika z '{self.current_user_app_role}' na '{user_app_role}'.")
            self.current_user_app_role = user_app_role
            # Zrekonfiguruj dostƒôp do edycji z klawiatury
            self.cleanup_keyboard_filter()
            self.setup_keyboard_editing()
        # --- KONIEC POPRAWKI ---

        self.can_see_next_month = visible_next_month
        self.current_user_app_department = user_app_department

        if not app_settings.has_permission(user_app_role, 'app_access'):
            QMessageBox.critical(self, "Brak uprawnie≈Ñ",
                                 f"Nie masz uprawnie≈Ñ do korzystania z tej aplikacji.<br><br>Twoja rola: {user_app_role}",
                                 QMessageBox.Ok)
            return False

        self.update_buttons_visibility()
        debug_print(
            f"Zalogowano jako: {self.current_user_app_login_windows} (ID: {user_app_login_windows}, Rola: {user_app_role}), Wydzia≈Ç: {self.current_user_app_department}")
        return True

    def _can_modify_cells(self, selected_cells_data: list) -> bool:
        """
        Sprawdza, czy u≈ºytkownik ma jakiekolwiek uprawnienia do modyfikacji
        ZAZNACZONYCH kom√≥rek. Zwraca True, je≈õli choƒá jedna kom√≥rka jest edytowalna.
        """
        if not selected_cells_data:
            return False

        # Sprawdzamy, czy istnieje choƒá jedna kom√≥rka, do kt√≥rej u≈ºytkownik ma jakiekolwiek prawo
        can_modify_anything = False
        for cell_data in selected_cells_data:
            permissions = self._get_permission_for_cell(cell_data)
            if any(permissions.values()):
                can_modify_anything = True
                break  # Wystarczy jedna kom√≥rka, przerywamy pƒôtlƒô

        if not can_modify_anything:
            QMessageBox.warning(self, "Brak uprawnie≈Ñ",
                                "Nie posiadasz uprawnie≈Ñ do edycji grafiku dla ≈ºadnej z zaznaczonych os√≥b lub kom√≥rek.")
            return False

        return True

    def show_insert_symbol_dialog(self):
        """
        Uproszczona metoda: Pokazuje okno dialogowe do wstawiania symbolu,
        a nastƒôpnie deleguje logikƒô do scentralizowanej metody.
        """
        if not app_settings.has_permission(self.current_user_app_role, 'schedule_cell_actions'):
            self.statusBar().showMessage("Brak uprawnie≈Ñ do wstawiania symboli.", 3000)
            return

        from schedule_edit_dialogs import InsertSymbolDialog
        selected_cells_data = self.get_selected_cells_data()
        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono ≈ºadnych kom√≥rek do edycji.", QMessageBox.Ok)
            return

        dialog = InsertSymbolDialog(self, selected_cells_data=selected_cells_data)
        if dialog.exec():
            selected_symbol = dialog.get_selected_symbol()
            if selected_symbol:
                self._apply_special_symbol_to_selection(selected_symbol)

    def _group_cells_for_symbol_changes(self, schedule_cells):
        """Grupuje kom√≥rki dla komunikatu potwierdzenia."""
        grouped_changes = {}
        for cell_data in schedule_cells:
            user_id, user_name, date_str, current_symbol = cell_data.get('uzytkownik_id'), cell_data.get(
                'uzytkownik_dane', ''), cell_data.get('date_str'), cell_data.get('symbol', '').strip()
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str
            user_key = (user_id, user_name)
            if user_key not in grouped_changes:
                grouped_changes[user_key] = {}
            if formatted_date not in grouped_changes[user_key]:
                grouped_changes[user_key][formatted_date] = []
            grouped_changes[user_key][formatted_date].append({'current_symbol': current_symbol, 'cell_data': cell_data})
        return grouped_changes

    def _prepare_symbol_changes_description(self, grouped_changes, new_special_symbol):
        """Przygotowuje opis zmian symboli do komunikatu, z limitem wy≈õwietlanych wierszy."""
        changes_info = "<br>"
        line_count = 0
        total_users = len(grouped_changes)
        MAX_LINES_TO_SHOW = 15  # Maksymalna liczba szczeg√≥≈Çowych wierszy do pokazania

        for (user_id, user_name), dates in grouped_changes.items():
            if line_count >= MAX_LINES_TO_SHOW:
                remaining_users = total_users - line_count
                if remaining_users > 0:
                    changes_info += f"<br>>... i {remaining_users} wiƒôcej u≈ºytkownik√≥w."
                break

            changes_info += f"<br>üë§ {user_name}:<br>"
            line_count += 1

            for date, cells in dates.items():
                if line_count >= MAX_LINES_TO_SHOW:
                    break
                changes_info += f"&nbsp;&nbsp;&nbsp;üóìÔ∏è {date}: "
                example_cell = cells[0]['cell_data']
                current_symbol = cells[0]['current_symbol']
                predicted_symbol = self._predict_new_symbol(current_symbol, new_special_symbol, example_cell)
                changes_info += f"{current_symbol or '[puste]'} -> {predicted_symbol}"
                line_count += 1

        return changes_info

    def _predict_new_symbol(self, current_symbol: str, special_symbol: str, cell_data: dict) -> str:
        """
        Przewiduje, jak bƒôdzie wyglƒÖda≈Ç nowy symbol, z uwzglƒôdnieniem
        logiki dla lokalizacji i systemu r√≥wnowa≈ºnego.
        """
        parsed_current = parse_symbol(current_symbol)

        final_start_hour = parsed_current.get('start_hour')
        final_work_hours = parsed_current.get('work_hours')

        system_pracy = cell_data.get('system_czasu_pracy', '').strip().lower()
        is_equivalent_system = (system_pracy == 'r√≥wnowa≈ºny')
        is_absence_symbol = special_symbol.upper() in app_settings.get_absence_symbols()

        if is_equivalent_system and is_absence_symbol:
            try:
                final_work_hours = int(float(cell_data.get('etat')))
            except (ValueError, TypeError):
                final_work_hours = 8

        # --- ZMIANA: Poprawiona logika ustalania lokalizacji ---
        final_location = None
        # Warunek: Lokalizacjƒô przypisujemy tylko, gdy wstawiany jest symbol "pracujƒÖcy"
        # lub gdy nie ma symbolu specjalnego (zwyk≈Ça zmiana robocza).
        if (special_symbol and special_symbol.upper() in app_settings.WORK_LIKE_SYMBOLS) or not special_symbol:
            # Hierarchia:
            # 1. We≈∫ lokalizacjƒô, je≈õli ju≈º istnieje w kom√≥rce.
            # 2. Je≈õli nie, u≈ºyj nowej funkcji, kt√≥ra sprawdzi wyjƒÖtki i domy≈õlne.
            final_location = parsed_current.get('location') or self.determine_correct_location(cell_data)
        # Dla zwyk≈Çych nieobecno≈õci (U, CO) `final_location` pozostanie None.
        # --- KONIEC ZMIANY ---

        new_symbol = build_symbol(
            location=final_location,
            start_hour=final_start_hour,
            work_hours=final_work_hours,
            special_symbol=special_symbol
        )

        if not new_symbol.strip() and special_symbol and special_symbol.strip():
            return special_symbol.strip()

        return new_symbol.strip() if new_symbol else ""

    def determine_correct_location(self, cell_data: dict, cursor=None) -> str | None:
        """
        Okre≈õla prawid≈ÇowƒÖ lokalizacjƒô. Mo≈ºe u≈ºyƒá istniejƒÖcego kursora bazy danych
        lub stworzyƒá w≈Çasne po≈ÇƒÖczenie.
        """
        local_conn = None
        try:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if not user_id or not date_str:
                return None

            if not cursor:
                local_conn = DatabaseConnector.get_connection()
                cursor = local_conn.cursor()

            sql = f"SELECT FinalLocation FROM {SQL_OBJECTS['fn_getcorrectlocation']}(?, ?)"
            cursor.execute(sql, (user_id, date_str))
            result = cursor.fetchone()

            if result and result[0]:
                return result[0]
            return None

        except Exception as e:
            log_error(f"B≈ÇƒÖd w determine_correct_location: {e}", exception=e)
            return None
        finally:
            if local_conn:  # Zamknij po≈ÇƒÖczenie tylko, je≈õli zosta≈Ço stworzone w tej funkcji
                local_conn.close()

    def _find_events_to_cancel(self, user_date_pairs):
        """
        Znajduje zdarzenia do odwo≈Çania dla podanych par u≈ºytkownik-data.
        WERSJA POPRAWIONA: U≈ºywa poprawnej logiki status√≥w ('Usuniƒôty', 'Do delegacji').
        """
        events_to_cancel = []
        for user_id, date_str in user_date_pairs:
            # Pobieramy wszystkie zdarzenia dla kom√≥rki, aby sprawdziƒá ich dok≈Çadny status
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str, active_only=False)

            for event in user_events:
                event_type = event.get('type')
                event_status = event.get('status')
                event_id = event.get('id')

                # Pomi≈Ñ, je≈õli brakuje kluczowych danych
                if not all([event_type, event_id, event_status]):
                    continue

                # --- KLUCZOWA POPRAWKA: Zastosowanie prawid≈Çowej logiki biznesowej ---
                # Aktywne zdarzenie to takie, kt√≥rego status nie jest ani "Usuniƒôty", ani "Do delegacji".
                is_active = event_status not in ["Usuniƒôty", "Do delegacji"]
                # --- KONIEC POPRAWKI ---

                if is_active and event_type in ['Spotkanie', 'Szkolenie', 'Nadgodziny']:
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),
                    })
        return events_to_cancel

    def _group_events_by_user_date(self, events_to_cancel):
        """Grupuje zdarzenia wed≈Çug u≈ºytkownika i daty"""
        grouped_events = {}
        for event in events_to_cancel:
            key = (event['user_id'], event['date'])
            if key not in grouped_events:
                grouped_events[key] = []
            grouped_events[key].append(event)
        return grouped_events

    def clear_special_symbol_from_selected_cells(self):
        """W pe≈Çni asynchronicznie usuwa symbol specjalny (F12) z zaznaczonych kom√≥rek."""
        if not app_settings.has_permission(self.current_user_app_role, 'action_clear_special_symbol'):
            self.statusBar().showMessage("Brak uprawnie≈Ñ do wykonania tej operacji.", 3000)
            return

        selected_cells_data = self.table.get_data_for_selected_cells()
        if not self._can_modify_cells(selected_cells_data):
            return

        cells_to_modify = [cell for cell in selected_cells_data if
                           parse_symbol(cell.get('symbol', '')).get('special_symbol')]

        # --- NOWA ZMIANA: Sprawdzenie, czy usuwamy urlop ---
        contains_vacation_symbol = any(
            (parse_symbol(cell.get('symbol', '')).get('special_symbol') or '').upper() in ['U', 'UZ']
            for cell in cells_to_modify
        )
        # --- KONIEC ZMIANY ---

        if not cells_to_modify:
            QMessageBox.information(self, "Brak zmian",
                                    "W zaznaczonych kom√≥rkach nie ma symboli specjalnych do usuniƒôcia.")
            return

        reply = show_confirmation_dialog(self, "Potwierdzenie operacji",
                                         f"Czy na pewno chcesz usunƒÖƒá symbole specjalne z {len(cells_to_modify)} kom√≥rek?")
        if reply != QMessageBox.Yes:
            return

        # --- POCZƒÑTEK POPRAWKI: U≈ºycie nowego ScheduleChangeProcessor ---
        change_requests = []
        for cell_data in cells_to_modify:
            permissions = self._get_permission_for_cell(cell_data)
            if permissions['can_edit_symbol']:
                # Warto≈õƒá `None` dla symbolu specjalnego oznacza jego usuniƒôcie z zachowaniem godzin
                change_requests.append((ChangeType.APPLY_SPECIAL_SYMBOL, cell_data, None))

        if change_requests:
            self.schedule_change_processor.start_changes(change_requests)
            # Po zako≈Ñczeniu operacji, wy≈õwietl informacjƒô o urlopie, je≈õli to konieczne.
            # U≈ºywamy QTimer, aby daƒá czas na przetworzenie zmian.
            if contains_vacation_symbol:
                QTimer.singleShot(100, lambda: self._show_f12_vacation_info(True, len(change_requests), 0))
        # --- KONIEC POPRAWKI ---

    def _on_preparation_finished(self, contains_vacation_symbol, change_requests):
        """Slot wywo≈Çywany po zako≈Ñczeniu pracy wƒÖtku przygotowawczego."""
        # Ta metoda nie jest ju≈º potrzebna, ale zostawiam jƒÖ pustƒÖ na wypadek,
        # gdyby jakiekolwiek stare po≈ÇƒÖczenia sygna≈Ç√≥w wciƒÖ≈º istnia≈Çy.
        # Docelowo do usuniƒôcia.
        pass

    def _show_f12_vacation_info(self, contains_vacation, successful_updates, failed_updates):
        """Callback do wy≈õwietlania komunikatu po operacji F12."""
        if successful_updates and contains_vacation:
            QMessageBox.information(self, "Informacja o planie urlopowym",
                                    "Usuniƒôcie symbolu urlopu ('U' lub 'UZ') z grafiku nie usuwa go z planu urlopowego.")

    def _show_symbol_change_vacation_info(self, contains_vacation_change, successful_updates, failed_updates):
        """Callback do wy≈õwietlania komunikatu po zmianie symbolu."""
        if successful_updates and contains_vacation_change:
            QMessageBox.information(self, "Informacja o planie urlopowym",
                                    "Zmiana symbolu urlopu ('U' lub 'UZ') na inny nie usuwa go z planu urlopowego.")

    # def _add_location_exception_batch(self, params_list: list):
    #     """Dodaje seriƒô wyjƒÖtk√≥w w jednej transakcji dla wydajno≈õci i bezpiecze≈Ñstwa."""
    #     errors = []
    #     conn = None
    #     try:
    #         # Krok 1: Otw√≥rz po≈ÇƒÖczenie TYLKO RAZ
    #         conn = DatabaseConnector.get_connection()
    #         cursor = conn.cursor()
    #         query = f"EXEC {SQL_OBJECTS['p_lokalizacjewyjatki']} ?, ?, ?, ?, ?, ?, ?, ?"
    #
    #         # Krok 2: Wykonaj wszystkie operacje w pƒôtli
    #         for params in params_list:
    #             try:
    #                 cursor.execute(query, params)
    #             except Exception as e:
    #                 # Zbierz informacje o b≈Çƒôdach, kt√≥re wystƒÖpi≈Çy
    #                 date_str = params[2]  # Data jest na 3. pozycji w krotce
    #                 errors.append(f"Dzie≈Ñ {date_str}: {e}")
    #
    #         # Krok 3: Zatwierd≈∫ wszystkie udane operacje JEDNYM poleceniem
    #         conn.commit()
    #
    #         return {"success": not errors, "errors": errors}
    #
    #     except Exception as e:
    #         log_error(f"B≈ÇƒÖd krytyczny podczas wsadowego dodawania wyjƒÖtk√≥w: {e}", exception=e)
    #         return {"success": False, "errors": [str(e)]}
    #     finally:
    #         # Krok 4: Zamknij po≈ÇƒÖczenie na samym ko≈Ñcu
    #         if conn:
    #             conn.close()

    def _check_location_exception(self, user_id, change_date):
        """Sprawdza wyjƒÖtek lokalizacyjny dla konkretnego dnia u≈ºywajƒÖc nowej funkcji TVF."""
        debug_print(
            f"--- Sprawdzanie wyjƒÖtku (TVF) dla U≈ºytkownika ID: {user_id}, Data: {change_date.toString('yyyy-MM-dd')} ---")
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            date_str = change_date.toString("yyyy-MM-dd")

            fn_name = SQL_OBJECTS.get('fn_getlocationexceptions')
            query = f"SELECT * FROM {fn_name}(?, ?, ?)"
            cursor.execute(query, (user_id, date_str, date_str))

            results = [dict(zip([column[0] for column in cursor.description], row)) for row in cursor.fetchall()]
            conn.close()

            debug_print(f"Znaleziono {len(results)} wpis√≥w w bazie danych przez TVF.")

            exact_match = None
            range_match = None
            py_change_date = change_date.toPython()

            for row_dict in results:
                # --- KLUCZOWA POPRAWKA: Sprawdzaj obie mo≈ºliwe nazwy kolumn ---
                data_od_val = row_dict.get('Dataod', row_dict.get('DataOd'))
                data_do_val = row_dict.get('Datado', row_dict.get('DataDo'))

                if not data_od_val:
                    continue

                data_od = data_od_val.date()
                data_do = data_do_val.date() if data_do_val else None
                # --- KONIEC POPRAWKI ---

                if data_od == py_change_date and data_do and data_do == py_change_date:
                    exact_match = row_dict
                    break
                if data_od <= py_change_date and (not data_do or data_do >= py_change_date):
                    range_match = row_dict

            debug_print(
                f"Zwracam: exact_match={'TAK' if exact_match else 'NIE'}, range_match={'TAK' if range_match else 'NIE'}")
            return exact_match, range_match

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas sprawdzania wyjƒÖtk√≥w lokalizacyjnych (TVF): {e}", exception=e)
            return None, None

    def _manage_location_exception(self, params):
        """ZarzƒÖdza dodawaniem, edycjƒÖ i usuwaniem wyjƒÖtk√≥w lokalizacyjnych."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            query = f"EXEC {SQL_OBJECTS['p_lokalizacjewyjatki']} ?, ?, ?, ?, ?, ?, ?, ?"
            cursor.execute(query, params)

            # --- POCZƒÑTEK KLUCZOWEJ POPRAWKI ---
            # Ta pƒôtla zmusza sterownik do poczekania na pe≈Çne wykonanie procedury na serwerze,
            # zanim przejdzie do zamkniƒôcia po≈ÇƒÖczenia. Przetwarza wszystkie "ukryte" komunikaty
            # i zestawy wynik√≥w, kt√≥re procedura mog≈Çaby wygenerowaƒá.
            while cursor.nextset():
                pass
            # --- KONIEC KLUCZOWEJ POPRAWKI ---

            conn.commit()
            conn.close()
            return {"success": True}
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas zarzƒÖdzania wyjƒÖtkiem lokalizacyjnym: {e}", exception=e)
            return {"success": False, "message": str(e)}

    def _call_import_changes_procedure(self, nr_kadrowy, rok, miesiac, data, symbol):
        """Wywo≈Çuje procedurƒô i bardziej niezawodnie interpretuje jej wyniki."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(
                f"EXEC {SQL_OBJECTS['p_importzmianynaserwer']} @Nr_Kadrowy = ?, @Rok = ?, @Miesiac = ?, @Data = ?, @Symbol = ?, @CzyPobieranieSugestii = ?",
                (nr_kadrowy, rok, miesiac, data, symbol, None))

            all_results = []
            while True:
                try:
                    rows = cursor.fetchall()
                    if rows: all_results.extend(rows)
                    if not cursor.nextset(): break
                except Exception:
                    break
            conn.commit()
            conn.close()

            returned_symbol, success, message = symbol, True, "Operacja zako≈Ñczona pomy≈õlnie"
            for row in all_results:
                if row and len(row) > 0 and row[0] is not None:
                    raw_value = row[0]
                    if isinstance(raw_value, int) and raw_value == 0: continue
                    value_str = str(raw_value).strip()
                    if not value_str or value_str == "0": continue

                    is_likely_a_symbol = ' ' not in value_str and len(value_str) <= 50
                    if is_likely_a_symbol:
                        returned_symbol = value_str
                    else:
                        success, message = False, value_str
                        break
            if success:
                self._update_modification_date()
            return {"success": success, "message": message, "returned_symbol": returned_symbol}
        except Exception as e:
            log_error(f"B≈ÇƒÖd procedury ImportZmianNaSerwer: {e}")
            return {"success": False, "message": f"B≈ÇƒÖd bazy danych: {str(e)}", "returned_symbol": symbol}

    def _process_and_apply_changes(self, change_requests: list, dialog_instance=None):
        """
        Uruchamia asynchronicznƒÖ aktualizacjƒô w tle dla podanej listy ≈ºƒÖda≈Ñ zmian (krotek).
        Obs≈Çuguje callback do aktualizacji status√≥w w oknie dialogowym.

        Args:
            change_requests (list): Lista krotek ≈ºƒÖda≈Ñ (change_type, cell_data, value/new_symbol).
                                    cell_data MUSI zawieraƒá klucz 'visual_row'.
            dialog_instance (QDialog, optional): Instancja okna dialogowego ScheduleChangeDialog.
        """
        debug_print(
            f"--- _process_and_apply_changes (v2): Otrzymano ≈ºƒÖdanie aktualizacji dla {len(change_requests)} kom√≥rek (format krotki).")
        if not change_requests:
            debug_print("--- _process_and_apply_changes (v2): Brak ≈ºƒÖda≈Ñ, przerywam.")
            return

        # --- UPROSZCZONA LOGIKA: Wszystkie ≈ºƒÖdania idƒÖ do procesora asynchronicznego ---
        # Logika sprawdzania/aktualizacji wyjƒÖtk√≥w lokalizacji odbywa siƒô
        # w ScheduleChangeDialog._handle_location_logic_for_request PRZED wys≈Çaniem sygna≈Çu.
        # Tutaj tylko przekazujemy ≈ºƒÖdania dalej.

        # Sprawd≈∫ poprawno≈õƒá formatu i obecno≈õƒá 'visual_row'
        valid_change_requests = []
        for req_tuple in change_requests:
            if len(req_tuple) != 3:
                log_error(
                    f"Nieprawid≈Çowy format ≈ºƒÖdania w _process_and_apply_changes: {req_tuple}. Oczekiwano 3 element√≥w.")
                continue

            change_type, cell_data, new_symbol_value = req_tuple

            if 'visual_row' not in cell_data:
                log_error(
                    f"Brak 'visual_row' w cell_data dla ≈ºƒÖdania: {req_tuple}. Status w dialogu nie zostanie zaktualizowany.")
                # Mo≈ºna zdecydowaƒá, czy pominƒÖƒá to ≈ºƒÖdanie, czy przetwarzaƒá bez aktualizacji statusu
                # Na razie przetwarzamy dalej:
                valid_change_requests.append(req_tuple)
            else:
                valid_change_requests.append(req_tuple)  # ≈ªƒÖdanie jest poprawne

        if not valid_change_requests:
            debug_print("--- _process_and_apply_changes (v2): Brak poprawnych ≈ºƒÖda≈Ñ po walidacji.")
            return

        # --- KONIEC UPROSZCZONEJ LOGIKI ---

        # Definicja callbacka do aktualizacji status√≥w w dialogu
        def process_results_callback(results):
            if dialog_instance and hasattr(dialog_instance, 'update_status_for_row'):
                successful_updates = [res for res in results if res.get('success')]
                failed_updates = [res for res in results if not res.get('success')]

                # Mapowanie (user_id, date) -> visual_row z oryginalnych ≈ºƒÖda≈Ñ
                request_map = {}
                # U≈ºyj valid_change_requests, kt√≥re by≈Çy faktycznie przekazane do wƒÖtku
                for ch_type, c_data, n_sym in valid_change_requests:  # U≈ºywamy przefiltrowanej listy
                    if 'visual_row' in c_data:  # Sprawd≈∫ czy klucz istnieje
                        # Klucz mapy to (user_id, data_str)
                        request_map[(c_data.get('uzytkownik_id'), c_data.get('date_str'))] = c_data['visual_row']
                    else:
                        # Ten log nie powinien siƒô pojawiƒá, je≈õli walidacja wy≈ºej dzia≈Ça
                        log_error(
                            f"Callback: Brak 'visual_row' dla: {(c_data.get('uzytkownik_id'), c_data.get('date_str'))}")

                debug_print(f"Callback: Zbudowano request_map z {len(request_map)} wpisami.")

                for result in successful_updates:
                    key = (result.get('user_id'), result.get('data'))
                    visual_row = request_map.get(key)
                    if visual_row is not None:
                        debug_print(f"Callback: Aktualizujƒô status SUKCES dla wiersza {visual_row} (key={key})")
                        # Przekazujemy pe≈Çny wynik, aby dialog m√≥g≈Ç od≈õwie≈ºyƒá dane
                        dialog_instance.update_status_for_row(visual_row, 'success', result=result)
                    else:
                        debug_print(f"Callback: Nie znaleziono visual_row dla sukcesu: {key}")

                for result in failed_updates:
                    key = (result.get('user_id'), result.get('data'))
                    visual_row = request_map.get(key)
                    if visual_row is not None:
                        debug_print(f"Callback: Aktualizujƒô status PORA≈ªKA dla wiersza {visual_row} (key={key})")
                        dialog_instance.update_status_for_row(visual_row, 'failure', result=result)
                    else:
                        debug_print(f"Callback: Nie znaleziono visual_row dla b≈Çƒôdu: {key}")
            else:
                debug_print("Callback: Brak dialog_instance lub metody update_status_for_row.")

        debug_print(
            f"--- _process_and_apply_changes (v2): Przekazujƒô {len(valid_change_requests)} ≈ºƒÖda≈Ñ do ScheduleChangeProcessor.")
        # Przeka≈º listƒô krotek do ScheduleChangeProcessor
        self.schedule_change_processor.start_changes(valid_change_requests,
                                                     on_results_processed=process_results_callback)

    def _update_cells_with_new_symbols(self, updated_cells_info: list):
        """
        Aktualizuje kom√≥rki w modelu na podstawie danych zwr√≥conych przez procedurƒô.
        WERSJA ZOPTYMALIZOWANA: Dla du≈ºej liczby zmian, prze≈Çadowuje ca≈Çy model,
        co jest znacznie wydajniejsze ni≈º aktualizacja kom√≥rka po kom√≥rce.
        """
        if not updated_cells_info or not hasattr(self, 'schedule_model'):
            return

        num_changes = len(updated_cells_info)

        # Je≈õli zmian jest niewiele, aktualizuj pojedynczo dla zachowania p≈Çynno≈õci
        if num_changes < 50:
            for user_id, date_str, new_symbol in updated_cells_info:
                if new_symbol is not None:
                    self._update_single_cell_in_model(user_id, date_str, new_symbol, self.year, self.month)
        else:
            # Przy du≈ºej liczbie zmian, zaktualizuj dane wsadowo
            # i wyemituj jeden sygna≈Ç o zmianie ca≈Çego uk≈Çadu.
            self.schedule_model.layoutAboutToBeChanged.emit()
            for user_id, date_str, new_symbol in updated_cells_info:
                if new_symbol is not None:
                    # Wywo≈Çaj logikƒô z _update_single_cell_in_model, ale bez emitowania sygna≈Çu
                    try:
                        row_index = -1
                        for idx, key in enumerate(self.schedule_model._keys):
                            if str(key[3]) == str(user_id):
                                row_index = idx
                                break
                        if row_index == -1: continue

                        day = int(date_str.split('-')[2])

                        # Logika z setData bezpo≈õrednio na danych modelu
                        key = self.schedule_model._keys[row_index]
                        user_data = self.schedule_model._processed_data[key]
                        day_data = user_data.setdefault('days', {}).setdefault(day, {})

                        old_symbol = day_data.get('symbol', '')
                        day_data['symbol'] = str(new_symbol)

                        parsed = parse_symbol(str(new_symbol))
                        old_hours = parse_symbol(old_symbol).get('work_hours', 0) or 0
                        new_hours = parsed.get('work_hours', 0) or 0

                        day_data['hours'] = new_hours
                        day_data['start_hour'] = parsed.get('start_hour')
                        user_data['total_hours'] = (user_data.get('total_hours', 0) or 0) - old_hours + new_hours
                    except (ValueError, IndexError, KeyError):
                        continue

            self.schedule_model.layoutChanged.emit()

        debug_print(f"Zaktualizowano {num_changes} kom√≥rek w modelu.")

    def _update_single_cell_in_model(self, user_id, date_str, new_symbol, year, month):
        """Aktualizuje jednƒÖ kom√≥rkƒô w modelu i wymusza jej od≈õwie≈ºenie."""
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model: return False
            row_index = -1
            for idx, key in enumerate(self.schedule_model._keys):
                if str(key[3]) == str(user_id):
                    row_index = idx
                    break
            if row_index == -1: return False

            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)
            if int(year_str) != year or int(month_str) != month: return False

            col_index = len(self.schedule_model.get_visible_columns()) + day - 1
            model_index = self.schedule_model.index(row_index, col_index)
            if model_index.isValid():
                return self.schedule_model.setData(model_index, new_symbol, Qt.EditRole)
            return False
        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji kom√≥rki {user_id}/{date_str}: {e}")
            return False

    def _get_location_exceptions(self, user_id, start_date, end_date):
        """Pobiera wyjƒÖtki lokalizacyjne dla u≈ºytkownika w danym zakresie dat u≈ºywajƒÖc funkcji TVF."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            fn_name = SQL_OBJECTS.get('fn_getlocationexceptions')
            query = f"SELECT * FROM {fn_name}(?, ?, ?)"
            cursor.execute(query, (user_id, start_date.toString("yyyy-MM-dd"), end_date.toString("yyyy-MM-dd")))
            results = [dict(zip([column[0] for column in cursor.description], row)) for row in cursor.fetchall()]
            conn.close()
            # POPRAWKA: U≈ºycie bezpiecznej metody get() do sortowania, kt√≥ra obs≈Çuguje 'DataOd' i 'Dataod'
            return sorted(results, key=lambda x: x.get('DataOd', x.get('Dataod')), reverse=True)
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas pobierania wyjƒÖtk√≥w (TVF): {e}", exception=e)
            return []

    def show_location_exception_dialog(self):
        """Otwiera okno do zarzƒÖdzania wyjƒÖtkami lokalizacyjnymi."""
        from location_exception_dialog import LocationExceptionDialog

        selected_cells = self.get_selected_cells_data()
        if not selected_cells:
            QMessageBox.warning(self, "Brak zaznaczenia", "Proszƒô zaznaczyƒá przynajmniej jednƒÖ kom√≥rkƒô pracownika.")
            return

        user_ids = {cell['uzytkownik_id'] for cell in selected_cells}
        if len(user_ids) > 1:
            QMessageBox.warning(self, "Wielu u≈ºytkownik√≥w", "Proszƒô zaznaczyƒá kom√≥rki tylko dla jednego pracownika.")
            return

        user_id = user_ids.pop()
        user_name = selected_cells[0]['uzytkownik_dane']

        dates = [QDate.fromString(cell['date_str'], "yyyy-MM-dd") for cell in selected_cells]
        selection_range = {'start': min(dates), 'end': max(dates)}

        dialog = LocationExceptionDialog(self, user_id, user_name, selection_range)
        dialog.data_changed.connect(self.refresh_data)

        # Zapisz stan widoku przed otwarciem dialogu
        self._state_to_restore = self._save_view_state()

        dialog.exec()

    def check_for_new_data(self):
        """Sprawdza nowe dane i wersjƒô, u≈ºywajƒÖc jednego po≈ÇƒÖczenia z bazƒÖ."""
        conn = None
        try:
            # Krok 1: Otw√≥rz JEDNO po≈ÇƒÖczenie na poczƒÖtku
            conn = DatabaseConnector.get_connection()

            # Krok 2: Za≈Çaduj ustawienia, przekazujƒÖc istniejƒÖce po≈ÇƒÖczenie
            if not load_all_app_settings(existing_conn=conn):
                log_warning("Nie uda≈Ço siƒô od≈õwie≈ºyƒá ustawie≈Ñ aplikacji w tle.")
                return

            # Krok 3: Sprawd≈∫ wersjƒô (korzystajƒÖc z ju≈º za≈Çadowanych danych)
            is_update_forced = app_settings.FORCE_UPDATE
            is_version_obsolete = self.check_if_update_is_required()
            if is_update_forced or is_version_obsolete:
                debug_print(
                    f"Wykryto polecenie zdalnej aktualizacji (force: {is_update_forced}, obsolete: {is_version_obsolete}). Zamykanie aplikacji.")
                self.check_timer.stop()
                dialog = UpdateRequiredDialog(self)
                dialog.exec()
                self.close()
                return

            # --- KLUCZOWA POPRAWKA: Sprawd≈∫ ponownie uprawnienia u≈ºytkownika po od≈õwie≈ºeniu ustawie≈Ñ ---
            self.check_user_permissions()
            # --- KONIEC POPRAWKI ---

            # Krok 4: Sprawd≈∫ daty modyfikacji, u≈ºywajƒÖc wciƒÖ≈º tego samego po≈ÇƒÖczenia
            current_date_data = self.date_combo.currentData()
            if not current_date_data: return
            year, month = current_date_data
            if not hasattr(self, 'last_modification_date') or not self.last_modification_date:
                self._update_modification_date()
                return

            cursor = conn.cursor()
            cursor.execute(
                f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['grafikipracy']} WHERE Rok = ? AND Miesiac = ?",
                (year, month))
            schedule_max_date = cursor.fetchone()[0]
            cursor.execute(f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['fn_geteventsdata']}(?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]

            new_data_types = []
            if schedule_max_date and schedule_max_date > self.last_modification_date:
                new_data_types.append("grafiku")
            if events_max_date and events_max_date > self.last_modification_date:
                new_data_types.append("zdarze≈Ñ")
            if new_data_types:
                latest_overall_modification = max(d for d in [schedule_max_date, events_max_date] if d)
                is_self_change = False
                if hasattr(self, 'last_self_modification_date') and self.last_self_modification_date:
                    if abs(latest_overall_modification - self.last_self_modification_date) < timedelta(seconds=2):
                        is_self_change = True
                if not is_self_change:
                    change_type_text = " i ".join(new_data_types)
                    self.refresh_button.setText(f"Nowe dane {change_type_text}!")
                    self.refresh_button.setToolTip(
                        f"Wykryto zmiany w sekcji: {change_type_text}. Kliknij, aby za≈Çadowaƒá.")

                    # --- KLUCZOWA POPRAWKA ---
                    # U≈ºycie nowej, kompletnej definicji stylu z pliku styles.py
                    alert_style = AppStyles.get_alert_button_style(
                        'dark' if self.is_dark_theme else 'light',
                        self.current_font,
                        self.current_font_size
                    )
                    self.refresh_button.setStyleSheet(alert_style)
                    # --- KONIEC POPRAWKI ---

                    self.check_timer.stop()
                else:
                    self.last_modification_date = latest_overall_modification

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas sprawdzania nowych danych: {e}", exception=e)
        finally:
            # Krok 5: Zawsze zamknij po≈ÇƒÖczenie na ko≈Ñcu
            if conn:
                try:
                    conn.close()
                except Exception as e:
                    log_warning(f"Problem z zamkniƒôciem po≈ÇƒÖczenia w check_for_new_data: {e}")

    def _save_current_filter_settings(self):
        """Zapisuje aktualny stan filtr√≥w do s≈Çownika ustawie≈Ñ i do bazy danych."""
        if not hasattr(self, 'user_app_settings'):
            return

        # Zaktualizuj s≈Çownik o bie≈ºƒÖcy stan filtr√≥w
        self.user_app_settings['last_filters'] = self.get_current_filters_state()

        # Zapisz ca≈Çy, zaktualizowany s≈Çownik w bazie danych
        self.settings_db.save_settings(self.user_app_settings)
        debug_print("Zapisano bie≈ºƒÖcy stan filtr√≥w do bazy danych.")

    def refresh_data(self):
        """Wymusza od≈õwie≈ºenie danych z bazy, zachowujƒÖc stan filtr√≥w i sortowania."""
        # Krok 1: Pobierz bie≈ºƒÖcy stan filtr√≥w do zmiennej.
        filters_to_preserve = self.get_current_filters_state()

        self.refresh_button.setText("Od≈õwie≈º")

        # --- KLUCZOWA POPRAWKA ---
        # Przekazujemy aktualne ustawienia czcionki, aby zapewniƒá sp√≥jno≈õƒá wyglƒÖdu.
        self.refresh_button.setStyleSheet(AppStyles.get_button_style(
            'dark' if self.is_dark_theme else 'light',
            self.current_font,
            self.current_font_size
        ))
        # --- KONIEC POPRAWKI ---

        self.refresh_button.setToolTip("Od≈õwie≈º dane")

        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            self.update_buttons_visibility()
            self.data_provider.clear_monthly_cache(year, month)
            # Krok 2: Przeka≈º stan filtr√≥w do procesu aktualizacji danych.
            self.update_data(year, month, self.import_grupa, self.import_funkcja, use_async=True,
                             filters_to_restore=filters_to_preserve)
            self.update_filter_dates()
            self._update_modification_date()
            if hasattr(self, 'check_timer'):
                self.check_timer.start(60000)

    def _update_modification_date(self):
        """Aktualizuje datƒô ostatniej modyfikacji po dokonaniu zmian."""
        try:
            current_date_data = self.date_combo.currentData()
            if not current_date_data: return
            year, month = current_date_data
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(
                f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['grafikipracy']} WHERE Rok = ? AND Miesiac = ?",
                (year, month))
            schedule_max_date = cursor.fetchone()[0]
            cursor.execute(f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['fn_geteventsdata']}(?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]
            conn.close()
            all_dates = [d for d in [schedule_max_date, events_max_date] if d is not None]
            if not all_dates: return

            latest_modification = max(all_dates)
            self.last_self_modification_date = latest_modification
            self.last_modification_date = latest_modification

            # --- POCZƒÑTEK POPRAWKI: Resetowanie timera po w≈Çasnej zmianie ---
            # Zatrzymaj bie≈ºƒÖce odliczanie i uruchom je od nowa.
            if hasattr(self, 'check_timer'):
                self.check_timer.start(60000)
                # --- KONIEC POPRAWKI ---

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji daty modyfikacji: {e}", exception=e)

    def filter_data(self):
        """Filtruje dane grafiku i ZAWSZE stosuje sortowanie z ustawie≈Ñ u≈ºytkownika."""
        if not hasattr(self, 'schedule_model') or not self.schedule_model or getattr(self, '_updating_filters', False):
            return
        self._updating_filters = True
        try:
            # Krok 1: Aktualizacja i zastosowanie filtr√≥w
            self.update_cross_filters()
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

            # Krok 2: Zawsze po filtrowaniu, zastosuj zapisane sortowanie
            self.apply_custom_sort()

        finally:
            self._updating_filters = False
            current_data = self.date_combo.currentData()
            if current_data and self.staffing_details_win and not self.staffing_details_win.isHidden():
                year, month = current_data
                self.staffing_details_win.update_for_new_month_or_filters(year, month)

    def filter_events_table(self):
        """Filtruje tabelƒô zdarze≈Ñ, bazujƒÖc na danych z modelu."""
        try:
            if not hasattr(self, 'events_model') or not self.events_model: return

            # ZMIANA: Zawsze pobieraj dane ≈∫r√≥d≈Çowe z modelu,
            # kt√≥re zosta≈Çy tam wstawione przez `on_selection_changed`.
            source_data = self.events_model.get_all_events()
            if not source_data:
                self.events_model.filtered_update([])
                return

            filtered_data = source_data.copy()

            # Filtr typ√≥w
            allowed_types = []
            if self.meetings_checkbox.isChecked(): allowed_types.append('Spotkanie')
            if self.trainings_checkbox.isChecked(): allowed_types.append('Szkolenie')
            if self.overtime_checkbox.isChecked(): allowed_types.append('Nadgodziny')
            if allowed_types:
                filtered_data = [e for e in filtered_data if e.get('type') in allowed_types]

            # Filtr statusu
            selected_statuses = self.status_filter_combo.get_selected_items()
            if selected_statuses:
                filtered_data = [e for e in filtered_data if e.get('status') in selected_statuses]

            # Filtry tekstowe i dat
            topic_filter = self.topic_filter.text().lower()
            if topic_filter:
                filtered_data = [e for e in filtered_data if topic_filter in str(e.get('topic', '')).lower()]

            name_filter = self.name_filter.text().lower()
            if name_filter:
                filtered_data = [e for e in filtered_data if name_filter in str(e.get('name', '')).lower()]

            date_from_str = self.date_from.date().toString('yyyy-MM-dd')
            date_to_str = self.date_to.date().toString('yyyy-MM-dd')
            if date_from_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') >= date_from_str]
            if date_to_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') <= date_to_str]

            self.events_model.filtered_update(filtered_data)
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas filtrowania zdarze≈Ñ: {str(e)}")

    def setup_events_table_columns(self):
        """Konfiguruje kolumny dla tabeli zdarze≈Ñ w spos√≥b jawny i niezawodny."""
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        header = self.events_table.horizontalHeader()
        header.setStretchLastSection(False)

        # Ustawiamy tryb interaktywny, aby u≈ºytkownik m√≥g≈Ç sam zmieniaƒá rozmiar,
        # ale definiujemy rozsƒÖdne szeroko≈õci startowe.
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(0, 40)  # Id

        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(1, 80)  # Typ

        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)  # Temat
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.Stretch)  # Nazwa

        header.setSectionResizeMode(4, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(4, 150)  # U≈ºytkownik

        header.setSectionResizeMode(5, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(5, 90)  # Data

        header.setSectionResizeMode(6, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(6, 120)  # Czas od

        header.setSectionResizeMode(7, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(7, 120)  # Czas do

        header.setSectionResizeMode(8, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(8, 100)  # Status

        header.setSectionResizeMode(9, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(9, 125)  # Data Modyfikacji

        # Kolumna Akcje - sta≈Ça i nienaruszalna
        header.setSectionResizeMode(10, QHeaderView.ResizeMode.Fixed)
        self.events_table.setColumnWidth(10, 85)  # Akcje

    def show_schedule_control_dialog(self):
        """
        Pokazuje odpowiednie okno dialogowe w zale≈ºno≈õci od roli u≈ºytkownika.
        WERSJA ZMODYFIKOWANA: Otwiera okno jako nieblokujƒÖce i niezale≈ºne.
        """
        from schedule_control_dialog import ScheduleControlDialog, SuggestionsOutDialog

        # --- POCZƒÑTEK NOWEJ LOGIKI ---
        # Krok 1: Sprawd≈∫, czy okno ju≈º istnieje i jest widoczne
        if self.schedule_control_win:
            try:
                debug_print("Aktywujƒô istniejƒÖce okno 'ZarzƒÖdzaj grafikiem'.")
                self.schedule_control_win.activateWindow()  # Przenie≈õ na wierzch
                self.schedule_control_win.raise_()
                return  # Zako≈Ñcz, nie tw√≥rz nowego okna
            except RuntimeError:
                # B≈ÇƒÖd: Okno zosta≈Ço zniszczone (np. przez b≈ÇƒÖd),
                # ale referencja nie zosta≈Ça wyczyszczona. Wyczy≈õƒá jƒÖ teraz.
                self.schedule_control_win = None
        # --- KONIEC NOWEJ LOGIKI ---

        # G≈Ç√≥wmy przycisk jest ju≈º chroniony przez 'button_schedule_control'.
        # Poni≈ºsza logika jedynie decyduje, kt√≥re okno pokazaƒá dla uprawnionego u≈ºytkownika.
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Proszƒô najpierw wybraƒá miesiƒÖc.")
            return

        year, month = current_data

        dialog = None  # Zmienna tymczasowa

        if self.current_user_app_role == "Pracownik WPR":
            dialog = ScheduleControlDialog(self, year, month)
        elif self.current_user_app_role == "Lider OUT":
            dialog = SuggestionsOutDialog(self, year, month)
        else:
            QMessageBox.information(self, "Brak dostƒôpu", "Twoja rola nie ma dostƒôpu do tej funkcji.")
            return

        # --- ZMIANA: Zapisz referencjƒô i pod≈ÇƒÖcz sygna≈Çy ---
        self.schedule_control_win = dialog
        self.schedule_control_win.data_refresh_needed.connect(self.refresh_data)

        # Pod≈ÇƒÖcz sygna≈Ç 'finished', kt√≥ry QDialog emituje po zamkniƒôciu (przez OK, Anuluj lub 'X')
        # do naszej funkcji czyszczƒÖcej referencjƒô.
        self.schedule_control_win.finished.connect(self._on_schedule_control_closed)

        # Zamiast .exec() (blokujƒÖce), u≈ºyj .show() (nieblokujƒÖce)
        self.schedule_control_win.show()
        # --- KONIEC ZMIANY ---

    def show_insert_change_dialog(self):
        """Pokazuje okno dialogowe do wstawiania zmian w grafiku"""
        if not app_settings.has_permission(self.current_user_app_role, 'schedule_cell_actions'):
            self.statusBar().showMessage("Brak uprawnie≈Ñ do wstawiania zmian.", 3000)
            return

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Nie wybrano miesiƒÖca. Nie mo≈ºna dodaƒá zmiany grafiku.", QMessageBox.Ok)
            return

        year, month = current_data
        selected_cells = self.table.get_data_for_selected_cells()

        if not selected_cells:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono ≈ºadnych kom√≥rek do edycji.", QMessageBox.Ok)
            return

        grouped_cells = self.group_cells_by_user_and_day(selected_cells)

        dialog = ScheduleChangeDialog(self, grouped_cells=grouped_cells, year=year, month=month, main_window=self)

        # Pod≈ÇƒÖcz sygna≈Ç z dialogu do metody, kt√≥ra uruchomi BatchUpdater
        dialog.changes_requested.connect(
            lambda requests: self._process_and_apply_changes(requests, dialog)
        )
        dialog.exec()

    def _handle_location_change_logic(self, cell_data: dict, new_location_code: str, reason: str = None) -> dict:
        """
        Scentralizowana logika do zarzƒÖdzania wyjƒÖtkami lokalizacyjnymi.
        Sprawdza, tworzy, aktualizuje lub usuwa wyjƒÖtki.
        """
        try:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            q_date = QDate.fromString(date_str, "yyyy-MM-dd")
            default_location = cell_data.get('lokalizacja_domyslna')
            user_app_id, _, _, _, _, _ = get_modifier_id()
            location_map = {'h': 1, 's': 3, 'p': 2}

            # <<< KRYTYCZNA POPRAWKA: Upewnij siƒô, ≈ºe new_location_code nie jest puste >>>
            # Je≈õli kod lokalizacji jest pusty (None), a nie jest to powr√≥t do domy≈õlnej,
            # oznacza to b≈ÇƒÖd logiki - ale na potrzeby tej funkcji bezpieczniej jest
            # przyjƒÖƒá lokalizacjƒô domy≈õlnƒÖ, aby uniknƒÖƒá NULL.
            if not new_location_code:
                new_location_code = default_location

            new_location_id = location_map.get(new_location_code)
            # --- KONIEC POPRAWKI ---

            exact, in_range = self._check_location_exception(user_id, q_date)

            # Scenariusz 1: Powr√≥t do lokalizacji domy≈õlnej -> usu≈Ñ wyjƒÖtek
            if new_location_code == default_location:
                if exact:
                    params = (None, user_app_id, None, None, None, None, 3, exact['Id'])
                    return self._manage_location_exception(params)
                elif in_range:
                    return {"success": False, "message": "Dzie≈Ñ jest czƒô≈õciƒÖ wielodniowego wyjƒÖtku. Zmie≈Ñ go rƒôcznie."}
                else:
                    return {"success": True}  # Nie ma czego usuwaƒá

            # Scenariusz 2: Zmiana na niedomy≈õlnƒÖ lokalizacjƒô
            else:
                if exact:  # Istnieje dok≈Çadny wpis na ten dzie≈Ñ
                    if exact.get('Lokalizacja') != new_location_id:
                        params = (user_id, user_app_id, date_str, date_str, new_location_id, reason, 2, exact['Id'])
                        return self._manage_location_exception(params)
                    else:
                        return {"success": True}  # Lokalizacja ju≈º siƒô zgadza
                elif in_range:  # Dzie≈Ñ jest czƒô≈õciƒÖ wielodniowego wyjƒÖtku
                    return {"success": False, "message": "Dzie≈Ñ jest czƒô≈õciƒÖ wielodniowego wyjƒÖtku. Zmie≈Ñ go rƒôcznie."}
                else:  # Brak wyjƒÖtku, utw√≥rz nowy
                    params = (user_id, user_app_id, date_str, date_str, new_location_id, reason, 1, None)
                    return self._manage_location_exception(params)
        except Exception as e:
            log_error(f"B≈ÇƒÖd w _handle_location_change_logic: {e}", exception=e)
            return {"success": False, "message": str(e)}

    def handle_schedule_change_request(self, change_requests: list):
        """
        Przetwarza listƒô ≈ºƒÖda≈Ñ zmian w grafiku, delegujƒÖc zadanie do nowej
        scentralizowanej metody, kt√≥ra uruchamia BatchUpdater.
        """
        dialog = self.sender()

        # Przeka≈º ≈ºƒÖdania i referencjƒô do dialogu do nowej metody
        self._process_and_apply_changes(change_requests, dialog)

    def get_data_from_model_by_id(self, user_id, date_str):
        """
        Wyszukuje i zwraca aktualne dane dla konkretnej kom√≥rki (u≈ºytkownik/data)
        bezpo≈õrednio z g≈Ç√≥wnego modelu danych.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return None

        try:
            row_index = -1
            for idx, key in enumerate(self.schedule_model._keys):
                if str(key[3]) == str(user_id):
                    row_index = idx
                    break

            if row_index == -1:
                return None

            day = int(date_str.split('-')[2])
            col_index = len(self.schedule_model.get_visible_columns()) + day - 1

            model_index = self.schedule_model.index(row_index, col_index)
            if model_index.isValid():
                return self.schedule_model.data(model_index, ROLE_DATA)

        except (ValueError, IndexError) as e:
            log_error(f"B≈ÇƒÖd przy pobieraniu danych z modelu dla {user_id}/{date_str}: {e}")

        return None

    def _save_view_state(self):
        """Zapisuje stabilne identyfikatory zaznaczenia, sortowanie i pozycjƒô przewijania."""
        schedule_selection_ids = []
        if self.table.schedule_view.selectionModel():
            for index in self.table.schedule_view.selectionModel().selectedIndexes():
                data = index.data(ROLE_DATA)
                if isinstance(data, dict) and 'uzytkownik_id' in data and 'date_str' in data:
                    schedule_selection_ids.append((data['uzytkownik_id'], data['date_str']))

        employees_selection_ids = set()
        if self.table.employees_view.selectionModel():
            for index in self.table.employees_view.selectionModel().selectedIndexes():
                data = index.data(ROLE_DATA)
                if isinstance(data, dict) and 'uzytkownik_id' in data:
                    employees_selection_ids.add(data['uzytkownik_id'])

        state = {
            'schedule_selection_ids': schedule_selection_ids,
            'employees_selection_ids': list(employees_selection_ids),
            'emp_sort_col': self.table.employees_view.horizontalHeader().sortIndicatorSection(),
            'emp_sort_order': self.table.employees_view.horizontalHeader().sortIndicatorOrder(),
            'sched_sort_col': self.table.schedule_view.horizontalHeader().sortIndicatorSection(),
            'sched_sort_order': self.table.schedule_view.horizontalHeader().sortIndicatorOrder(),
            'v_scroll_pos': self.table.schedule_view.verticalScrollBar().value(),
            'h_scroll_pos': self.table.schedule_view.horizontalScrollBar().value()
        }
        debug_print(
            f"[DB] ZAPISYWANIE STANU: emp_sort_col={state['emp_sort_col']}, sched_sort_col={state['sched_sort_col']}, selections={len(schedule_selection_ids)}")
        return state

    def _restore_view_state(self, state):
        """Przywraca sortowanie, zaznaczenie i pozycjƒô przewijania po resecie modelu."""
        debug_print(f"[DB] ROZPOCZƒòTO PRZYWRACANIE STANU...")
        if not self.schedule_model or self.schedule_model.rowCount() == 0:
            debug_print("[DB] PRZERWANO PRZYWRACANIE: Model jest pusty.")
            return

        schedule_sm = self.table.schedule_view.selectionModel()
        employees_sm = self.table.employees_view.selectionModel()
        if schedule_sm: schedule_sm.blockSignals(True)
        if employees_sm: employees_sm.blockSignals(True)

        try:
            # Krok 1: Zawsze stosuj pe≈Çne, wielopoziomowe sortowanie z ustawie≈Ñ u≈ºytkownika.
            # To jest jedyne ≈∫r√≥d≈Ço prawdy o po≈ºƒÖdanym porzƒÖdku po resecie danych.
            self.apply_custom_sort()

            # Krok 2: Zbuduj mapƒô do wyszukania nowych indeks√≥w wierszy po posortowaniu.
            user_id_to_new_row_map = {str(key[3]): i for i, key in enumerate(self.schedule_model._keys)}

            # Krok 3: Odtw√≥rz zaznaczenie na podstawie nowych, prawid≈Çowych indeks√≥w.
            schedule_selection = QItemSelection()
            employee_cols_count = len(self.schedule_model.get_visible_columns())
            for user_id, date_str in state['schedule_selection_ids']:
                new_row = user_id_to_new_row_map.get(str(user_id))
                if new_row is not None:
                    try:
                        day = int(date_str.split('-')[2])
                        new_col = employee_cols_count + day - 1
                        model_index = self.schedule_model.index(new_row, new_col)
                        if model_index.isValid():
                            schedule_selection.select(model_index, model_index)
                    except (ValueError, IndexError):
                        continue

            employees_selection = QItemSelection()
            for user_id in state['employees_selection_ids']:
                new_row = user_id_to_new_row_map.get(str(user_id))
                if new_row is not None:
                    top_left = self.schedule_model.index(new_row, 0)
                    bottom_right = self.schedule_model.index(new_row, employee_cols_count - 1)
                    if top_left.isValid() and bottom_right.isValid():
                        employees_selection.select(top_left, bottom_right)

            debug_print(
                f"[DB] Przywracam zaznaczenie: {len(state['schedule_selection_ids'])} kom√≥rek, {len(state['employees_selection_ids'])} wierszy.")
            if schedule_sm: schedule_sm.select(schedule_selection, QItemSelectionModel.ClearAndSelect)
            if employees_sm: employees_sm.select(employees_selection,
                                                 QItemSelectionModel.ClearAndSelect | QItemSelectionModel.Rows)

            # Krok 4: Przywr√≥ƒá pozycjƒô pask√≥w przewijania.
            self.table.schedule_view.verticalScrollBar().setValue(state['v_scroll_pos'])
            self.table.schedule_view.horizontalScrollBar().setValue(state['h_scroll_pos'])
            debug_print(f"[DB] Przywr√≥cono pozycjƒô przewijania: V={state['v_scroll_pos']}, H={state['h_scroll_pos']}")

        finally:
            # Zawsze w≈ÇƒÖczaj sygna≈Çy z powrotem.
            if schedule_sm: schedule_sm.blockSignals(False)
            if employees_sm: employees_sm.blockSignals(False)
        debug_print(f"[DB] ZAKO≈ÉCZONO PRZYWRACANIE STANU.")

    def format_date(self, date_str: str) -> str:
        """
        Formatuje datƒô z formatu 'YYYY-MM-DD' na 'DD.MM.YYYY'.

        Args:
            date_str (str): Data w formacie 'YYYY-MM-DD'.

        Returns:
            str: Sformatowana data lub oryginalny ciƒÖg w razie b≈Çƒôdu.
        """
        try:
            year, month, day = date_str.split('-')
            return f"{day}.{month}.{year}"
        except (ValueError, AttributeError):
            return date_str

    def show_add_overtime_dialog(self):
        """Pokazuje okno dialogowe do dodawania nadgodzin."""
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Nie wybrano miesiƒÖca.", QMessageBox.Ok)
            return
        year, month = current_data
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not self._can_modify_cells(selected_cells_data) or not selected_cells_data or len(selected_cells_data) > 1:
            QMessageBox.warning(self, "B≈ÇƒÖd zaznaczenia", "Zaznacz dok≈Çadnie jednƒÖ kom√≥rkƒô, aby dodaƒá nadgodziny.",
                                QMessageBox.Ok)
            return

        cell_data = selected_cells_data[0]
        selected_user_id, selected_user_name, day, date_str, nr_kadrowy, start_hour, current_symbol, lokalizacja_domyslna = (
            cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane'), cell_data.get('day'),
            cell_data.get('date_str'), cell_data.get('nr_kadrowy'), cell_data.get('start_hour'),
            cell_data.get('symbol', ''), cell_data.get('lokalizacja_domyslna')
        )

        if not all([selected_user_id, day, date_str]):
            QMessageBox.warning(self, "B≈ÇƒÖd", "Brak wymaganych danych w zaznaczonej kom√≥rce.", QMessageBox.Ok)
            return

        selected_date = QDate.fromString(date_str, "yyyy-MM-dd")
        is_day_off = not current_symbol or current_symbol.strip() == ''
        if start_hour is None: start_hour = 9 if is_day_off else 8

        parsed_symbol = parse_symbol(current_symbol)
        current_location = parsed_symbol.get('location') if parsed_symbol and parsed_symbol.get(
            'location') else lokalizacja_domyslna

        dialog = QDialog(self)
        polish_months = ["stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca", "lipca", "sierpnia", "wrze≈õnia",
                         "pa≈∫dziernika", "listopada", "grudnia"]
        dialog.setWindowTitle(
            f"Dodaj nadgodziny w dniu {selected_date.day()} {polish_months[selected_date.month() - 1]} {selected_date.year()}")
        dialog.setMinimumWidth(300)
        layout = QVBoxLayout(dialog)
        layout.addWidget(QLabel(f"Pracownik: {selected_user_name}"))
        if nr_kadrowy: layout.addWidget(QLabel(f"Numer kadrowy: {nr_kadrowy}"))
        layout.addWidget(QLabel(f"MiesiƒÖc rozliczenia: {month:02d}.{year}"))
        if is_day_off: layout.addWidget(QLabel("Zaznaczony dzie≈Ñ jest dniem wolnym pracownika."))

        form_frame = QFrame()
        form_layout = QGridLayout(form_frame)
        time_combo = QComboBox()

        # --- POCZƒÑTEK POPRAWKI ---
        time_combo.setEditable(True)
        time_combo.setFocus()

        # Dodajemy listƒô zdefiniowanych godzin
        valid_times = [f"{h:02d}:{m:02d}" for h in range(24) for m in [0, 30]]
        time_combo.addItems(valid_times)

        # --- POCZƒÑTEK POPRAWKI ---
        # Tworzymy dedykowanƒÖ klasƒô walidatora, poniewa≈º QValidator jest klasƒÖ abstrakcyjnƒÖ.
        class TimeValidator(QValidator):
            def __init__(self, valid_entries, parent=None):
                super().__init__(parent)
                self.valid_entries = set(valid_entries)

            def validate(self, text, pos):
                if text in self.valid_entries:
                    return (QValidator.State.Acceptable, text, pos)
                # Pozw√≥l na wpisywanie, je≈õli tekst jest poczƒÖtkiem kt√≥rej≈õ z poprawnych warto≈õci
                if any(entry.startswith(text) for entry in self.valid_entries):
                    return (QValidator.State.Intermediate, text, pos)
                return (QValidator.State.Invalid, text, pos)

        time_combo.lineEdit().setValidator(TimeValidator(valid_times))

        # --- KONIEC POPRAWKI ---

        def on_text_edited(text):
            """Automatycznie dodaje dwukropek po wpisaniu dw√≥ch cyfr."""
            line_edit = time_combo.lineEdit()
            # Zablokuj sygna≈Çy, aby uniknƒÖƒá rekurencyjnego wywo≈Çania
            line_edit.blockSignals(True)
            if len(text) == 2 and text.isdigit():
                line_edit.setText(text + ":")
            # Przywr√≥ƒá sygna≈Çy
            line_edit.blockSignals(False)

        time_combo.lineEdit().textEdited.connect(on_text_edited)

        # --- POCZƒÑTEK NOWEJ LOGIKI ---
        # Domy≈õlna godzina rozpoczƒôcia nadgodzin to godzina zako≈Ñczenia zmiany
        work_hours = parsed_symbol.get('work_hours')
        if not is_day_off and start_hour is not None and work_hours is not None:
            end_hour_decimal = start_hour + work_hours
            end_hour_int = int(end_hour_decimal)
            end_minute = int(round((end_hour_decimal - end_hour_int) * 60))
            final_end_hour = end_hour_int % 24
            default_time = f"{final_end_hour:02d}:{end_minute:02d}"
        else:
            # Fallback dla dni wolnych lub braku danych o zmianie
            default_time = "09:00"
        # --- KONIEC NOWEJ LOGIKI ---
        time_combo.setCurrentText(default_time)

        # --- POCZƒÑTEK POPRAWKI ---
        # Ustawienie wszystkich p√≥l jako edytowalne z autouzupe≈Çnianiem
        hours_combo = QComboBox()
        hours_combo.setEditable(True)
        for h in [i * 0.5 for i in range(1, 27)]: hours_combo.addItem(f"{h:.1f}", h)
        hours_combo.setCurrentIndex(1)

        type_combo = QComboBox()
        type_combo.setEditable(True)
        type_combo.addItems(["wyp≈Çata", "odbi√≥r", "odpracowanie"])

        ld_combo = QComboBox()
        ld_combo.setEditable(True)
        ld_combo.addItems(["h", "p", "s"])
        ld_combo.setCurrentText(current_location)

        overdue_combo = QComboBox()
        overdue_combo.setEditable(True)
        overdue_combo.addItems(["nie", "tak"])

        # --- POCZƒÑTEK POPRAWKI ---
        add_button = QPushButton("Dodaj")

        # Ustawienie poprawnej kolejno≈õci przechodzenia (TAB)
        QWidget.setTabOrder(time_combo, hours_combo)
        QWidget.setTabOrder(hours_combo, type_combo)
        QWidget.setTabOrder(type_combo, ld_combo)
        QWidget.setTabOrder(ld_combo, overdue_combo)
        QWidget.setTabOrder(overdue_combo, add_button)
        # --- KONIEC POPRAWKI ---
        form_layout.addWidget(QLabel("od kiedy"), 0, 0)
        form_layout.addWidget(time_combo, 0, 1)
        form_layout.addWidget(QLabel("ile godzin"), 0, 2);
        form_layout.addWidget(hours_combo, 0, 3)
        form_layout.addWidget(QLabel("typ"), 0, 4);
        form_layout.addWidget(type_combo, 0, 5)
        form_layout.addWidget(QLabel("LD"), 0, 6);
        form_layout.addWidget(ld_combo, 0, 7)
        form_layout.addWidget(QLabel("czy zaleg≈Çe"), 0, 8);
        form_layout.addWidget(overdue_combo, 0, 9)
        form_layout.addWidget(add_button, 0, 10)
        layout.addWidget(form_frame)

        # --- POCZƒÑTEK POPRAWKI ---
        # Zaznacz ca≈Çy tekst, aby mo≈ºna go by≈Ço ≈Çatwo nadpisaƒá
        time_combo.lineEdit().selectAll()
        # --- KONIEC POPRAWKI ---

        # --- POCZƒÑTEK POPRAWKI ---
        self.add_overtime_dialog_instance = dialog

        def add_overtime():
            # Krok 1: Zapisz stan widoku (zaznaczenie i przewiniƒôcie)
            view_state = self._save_view_state()

            # --- POCZƒÑTEK NOWEJ LOGIKI ---
            # Sprawd≈∫, czy zmiana przechodzi przez p√≥≈Çnoc i dostosuj daty
            overtime_start_datetime = datetime.strptime(f"{date_str} {time_combo.currentText()}", "%Y-%m-%d %H:%M")
            shift_work_hours = parsed_symbol.get('work_hours') if not is_day_off else None

            if start_hour is not None and shift_work_hours is not None:
                shift_end_datetime = datetime.strptime(date_str, "%Y-%m-%d") + timedelta(
                    hours=start_hour + shift_work_hours)
                shift_start_datetime = datetime.strptime(f"{date_str} {start_hour:02d}:00", "%Y-%m-%d %H:%M")

                # Warunek: zmiana przechodzi przez p√≥≈Çnoc ORAZ nadgodziny zaczynajƒÖ siƒô o tej samej godzinie co koniec zmiany
                if shift_end_datetime.date() > shift_start_datetime.date() and \
                        shift_end_datetime.time() == overtime_start_datetime.time():
                    overtime_start_datetime += timedelta(days=1)
            # --- KONIEC NOWEJ LOGIKI ---

            result = self.call_add_overtime_procedure_fixed(
                selected_user_id, selected_date.year(), selected_date.month(),
                overtime_start_datetime, date_str,  # Przekazujemy zmodyfikowanƒÖ datƒô i czas ORAZ oryginalnƒÖ datƒô
                float(hours_combo.currentData()), f"{year}-{month:02d}-01",
                overdue_combo.currentIndex(), type_combo.currentText(),
                ld_combo.currentText(), nr_kadrowy
            )
            if result["success"]:
                # --- POCZƒÑTEK POPRAWKI ---
                # Krok 2: Po sukcesie w bazie, uniewa≈ºniamy cache dla tej kom√≥rki.
                # To zmusi DataProvider do ponownego za≈Çadowania danych (w tym zdarze≈Ñ) przy nastƒôpnym zapytaniu.
                self.data_provider.invalidate_complete_cache_for_pairs([(selected_user_id, date_str)])

                # --- POCZƒÑTEK NOWEJ, ZOPTYMALIZOWANEJ LOGIKI ---
                # Krok 3: Zamiast pobieraƒá wszystkie zdarzenia dla miesiƒÖca, pobieramy je tylko dla zmienionej kom√≥rki.
                fresh_events_for_cell = self.data_provider.get_events_for_user_date(selected_user_id, date_str,
                                                                                    active_only=False)

                # Krok 4: Inteligentnie zaktualizuj `self.all_events_data`, aby uniknƒÖƒá pe≈Çnego prze≈Çadowania.
                # Usu≈Ñ stare zdarzenia dla tej kom√≥rki i dodaj nowe, ≈õwie≈ºo pobrane.
                self.all_events_data = [e for e in self.all_events_data if
                                        not (e.get('user_id') == selected_user_id and e.get('date_key') == date_str)]
                self.all_events_data.extend([self._convert_dp_event_to_local(e) for e in fresh_events_for_cell])
                debug_print(
                    f"Zaktualizowano `self.all_events_data` tylko dla kom√≥rki ({selected_user_id}, {date_str}). Nowa liczba zdarze≈Ñ: {len(self.all_events_data)}")
                # --- KONIEC NOWEJ, ZOPTYMALIZOWANEJ LOGIKI ---

                # Krok 5: Przywracamy zaznaczenie kom√≥rki, kt√≥re by≈Ço zapamiƒôtane przed otwarciem okna.
                self._restore_view_state(view_state)

                # Krok 6: Wywo≈Çujemy metodƒô, kt√≥ra jest odpowiedzialna za aktualizacjƒô tabeli zdarze≈Ñ.
                # U≈ºyje ona ≈õwie≈ºych danych z DataProvider (dziƒôki krokowi 2) i poprawnie wy≈õwietli
                # nowo dodane nadgodziny. To r√≥wnie≈º zaktualizuje `self.all_events_data`.
                self.on_selection_changed()
                # --- KONIEC POPRAWKI ---

                self.statusBar().showMessage("Pomy≈õlnie dodano nadgodziny.", 3000)
                dialog.accept()
            else:
                QMessageBox.warning(dialog, "B≈ÇƒÖd", result["message"], QMessageBox.Ok)

        add_button.clicked.connect(add_overtime)

        dialog.exec()

    def show_settings_dialog(self):
        """Pokazuje okno dialogowe ustawie≈Ñ aplikacji."""
        from settings_dialog import AppSettingsDialog

        dialog = AppSettingsDialog(self, settings=self.user_app_settings)
        dialog.live_theme_changed.connect(self.apply_theme_settings)
        # --- POD≈ÅƒÑCZENIE NOWEGO SYGNA≈ÅU ---
        dialog.import_requested.connect(self.on_import_requested)

        if dialog.exec() == QDialog.Accepted:
            # Ta czƒô≈õƒá wykona siƒô po klikniƒôciu "OK" lub "Importuj teraz"
            new_settings = dialog.get_current_settings()
            should_save = new_settings.pop('save_to_db', False)

            self.user_app_settings.update(new_settings)

            self.is_dark_theme = self.user_app_settings.get('theme') == 'dark'
            self.current_font = self.user_app_settings.get('font_family')
            self.current_font_size = self.user_app_settings.get('font_size')

            self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font,
                                      self.current_font_size)
            self.setup_table_properties()
            self.table.schedule_view.viewport().update()

            if should_save:
                self.settings_db.save_settings(self.user_app_settings)
                debug_print(f"Zapisano ustawienia z dialogu.")

    def on_import_requested(self, grupa, funkcja):
        """Obs≈Çuguje ≈ºƒÖdanie importu z okna ustawie≈Ñ."""
        debug_print(f"Otrzymano ≈ºƒÖdanie importu z ustawieniami: Grupa={grupa}, Funkcja={funkcja}")

        # Zaktualizuj atrybuty w g≈Ç√≥wnym oknie
        self.import_grupa = grupa
        self.import_funkcja = funkcja

        # Wywo≈Çaj od≈õwie≈ºenie danych
        self.refresh_data()

    def _update_model_with_new_symbols(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje symbole bezpo≈õrednio w modelu
        """
        try:
            if not updated_symbols or not hasattr(self, 'schedule_model'):
                return

            processed_data = self.schedule_model.get_processed_data()
            if not processed_data:
                return

            updated_count = 0
            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Znajd≈∫ klucz u≈ºytkownika w processed_data
                target_key = None
                for key in processed_data.keys():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        target_key = key
                        break

                if not target_key:
                    debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                    continue

                # Oblicz dzie≈Ñ z daty
                try:
                    year_str, month_str, day_str = date_str.split('-')
                    day = int(day_str)

                    if int(year_str) != year or int(month_str) != month:
                        continue

                except ValueError:
                    continue

                # Aktualizuj symbol w processed_data
                user_data = processed_data[target_key]
                days_data = user_data.setdefault('days', {})
                day_data = days_data.setdefault(day, {})

                old_symbol = day_data.get('symbol', '')
                day_data['symbol'] = new_symbol

                # Przelicz godziny na podstawie nowego symbolu
                from symbol_parser import parse_symbol
                parsed = parse_symbol(new_symbol)
                day_data['hours'] = parsed.get('work_hours', 0) or 0
                day_data['start_hour'] = parsed.get('start_hour')

                # Aktualizuj total_hours u≈ºytkownika
                old_hours = 0
                if old_symbol:
                    old_parsed = parse_symbol(old_symbol)
                    old_hours = old_parsed.get('work_hours', 0) or 0

                new_hours = day_data['hours']
                user_data['total_hours'] = (user_data.get('total_hours', 0) or 0) - old_hours + new_hours

                updated_count += 1
                debug_print(
                    f"Model: Zaktualizowano {user_id}/{day}: '{old_symbol}' -> '{new_symbol}' ({old_hours}h -> {new_hours}h)")

            debug_print(f"Zaktualizowano {updated_count} kom√≥rek w modelu")

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji modelu: {e}")

    def _update_data_provider_cache(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje cache w DataProvider
        """
        try:
            if not updated_symbols or not hasattr(self.data_provider, 'monthly_cache'):
                return

            month_key = (year, month)
            if month_key not in self.data_provider.monthly_cache:
                return

            container = self.data_provider.monthly_cache[month_key]

            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Aktualizuj processed_data w kontenerze
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):
                        try:
                            year_str, month_str, day_str = date_str.split('-')
                            day = int(day_str)

                            if int(year_str) == year and int(month_str) == month:
                                days_data = user_data.setdefault('days', {})
                                day_data = days_data.setdefault(day, {})
                                day_data['symbol'] = new_symbol

                                # Przelicz godziny
                                from symbol_parser import parse_symbol
                                parsed = parse_symbol(new_symbol)
                                day_data['hours'] = parsed.get('work_hours', 0) or 0
                                day_data['start_hour'] = parsed.get('start_hour')

                                debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")
                                break
                        except:
                            continue

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji DataProvider cache: {e}")

    def _force_full_refresh(self):
        """Fallback - pe≈Çne od≈õwie≈ºenie danych"""
        try:
            current_data = self.date_combo.currentData()
            if current_data:
                year, month = current_data
                self.data_provider.refresh_data(year, month)
                self.update_table_content()
        except Exception as e:
            log_error(f"B≈ÇƒÖd pe≈Çnego od≈õwie≈ºenia: {e}")

    def _force_refresh_specific_cells(self, affected_pairs, year, month):
        """
        POPRAWIONA METODA: Wymusza od≈õwie≈ºenie konkretnych kom√≥rek w widoku
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycjƒô kom√≥rki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajd≈∫ wiersz u≈ºytkownika w modelu
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnƒô dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymusza od≈õwie≈ºenie kom√≥rki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej kom√≥rki
                        self.schedule_model.dataChanged.emit(model_index, model_index,
                                                             [Qt.DisplayRole, Qt.BackgroundRole])

                        # Metoda 2: Wymu≈õ update widoku dla tej kom√≥rki
                        self.table.schedule_view.update(model_index)

                        refreshed_cells += 1
                        debug_print(f"Od≈õwie≈ºono kom√≥rkƒô tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"B≈ÇƒÖd od≈õwie≈ºania kom√≥rki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymu≈õ ca≈Ço≈õciowy update viewport je≈õli zmieniono jakie≈õ kom√≥rki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po od≈õwie≈ºeniu {refreshed_cells} kom√≥rek")

                # DODATKOWE: Wymu≈õ te≈º od≈õwie≈ºenie tabeli pracownik√≥w (dla sum RBH)
                if hasattr(self.table, 'employees_view'):
                    self.table.employees_view.viewport().update()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas wymuszania od≈õwie≈ºenia kom√≥rek tabeli: {e}")

    def _update_model_cells_directly(self, updated_symbols, year, month):
        """
        Aktualizuje symbole bezpo≈õrednio w modelu i DataProvider

        Args:
            updated_symbols (dict): S≈Çownik {(user_id, date_str): symbol}
            year (int): Rok
            month (int): MiesiƒÖc
        """
        try:
            if not updated_symbols:
                return

            updated_count = 0

            # AKTUALIZACJA 1: Schedule Model processed_data
            if hasattr(self, 'schedule_model') and self.schedule_model:
                processed_data = self.schedule_model.get_processed_data()

                if processed_data:
                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        if self._update_single_cell_in_processed_data(processed_data, user_id, date_str, new_symbol,
                                                                      year, month):
                            updated_count += 1

            # AKTUALIZACJA 2: DataProvider cache (je≈õli istnieje)
            if hasattr(self.data_provider, 'monthly_cache'):
                month_key = (year, month)
                if month_key in self.data_provider.monthly_cache:
                    container = self.data_provider.monthly_cache[month_key]

                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        self._update_single_cell_in_data_provider(container, user_id, date_str, new_symbol, year, month)

            debug_print(f"Zaktualizowano {updated_count} kom√≥rek w modelu")

        except Exception as e:
            log_error(f"B≈ÇƒÖd bezpo≈õredniej aktualizacji modelu: {e}")

    def _update_single_cell_in_processed_data(self, processed_data, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczƒÖ kom√≥rkƒô w processed_data

        Returns:
            bool: True je≈õli zaktualizowano
        """
        try:
            # Znajd≈∫ klucz u≈ºytkownika
            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if not target_key:
                debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                return False

            # Oblicz dzie≈Ñ
            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)

            if int(year_str) != year or int(month_str) != month:
                return False

            # Aktualizuj symbol
            user_data = processed_data[target_key]
            days_data = user_data.setdefault('days', {})
            day_data = days_data.setdefault(day, {})

            old_symbol = day_data.get('symbol', '')
            day_data['symbol'] = new_symbol

            # Przelicz godziny i inne parametry
            from symbol_parser import parse_symbol
            parsed = parse_symbol(new_symbol)
            day_data['hours'] = parsed.get('work_hours', 0) or 0
            day_data['start_hour'] = parsed.get('start_hour')

            debug_print(f"Model: {user_id}/{day} '{old_symbol}' -> '{new_symbol}'")
            return True

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji kom√≥rki processed_data {user_id}/{date_str}: {e}")
            return False

    def _update_single_cell_in_data_provider(self, container, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczƒÖ kom√≥rkƒô w DataProvider cache
        """
        try:
            if not hasattr(container, 'processed_data') or not container.processed_data:
                return

            # Podobna logika jak dla processed_data w modelu
            processed_data = container.processed_data

            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if target_key:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)

                if int(year_str) == year and int(month_str) == month:
                    user_data = processed_data[target_key]
                    days_data = user_data.setdefault('days', {})
                    day_data = days_data.setdefault(day, {})
                    day_data['symbol'] = new_symbol

                    # Przelicz godziny
                    from symbol_parser import parse_symbol
                    parsed = parse_symbol(new_symbol)
                    day_data['hours'] = parsed.get('work_hours', 0) or 0
                    day_data['start_hour'] = parsed.get('start_hour')

                    debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji DataProvider cache: {e}")

    def _force_refresh_table_cells(self, affected_pairs, year, month):
        """
        WYMUSZA od≈õwie≈ºenie konkretnych kom√≥rek w widoku tabeli

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
            year (int): Rok
            month (int): MiesiƒÖc
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycjƒô kom√≥rki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajd≈∫ wiersz u≈ºytkownika
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnƒô dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymu≈õ od≈õwie≈ºenie kom√≥rki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej kom√≥rki
                        self.schedule_model.dataChanged.emit(model_index, model_index, [])

                        # Metoda 2: Wymu≈õ update widoku (backup)
                        self.table.schedule_view.update(model_index)

                        # Metoda 3: Invalidate item (backup)
                        if hasattr(self.table.schedule_view, 'setDirtyRegion'):
                            rect = self.table.schedule_view.visualRect(model_index)
                            if not rect.isEmpty():
                                self.table.schedule_view.viewport().update(rect)

                        refreshed_cells += 1
                        debug_print(f"Od≈õwie≈ºono kom√≥rkƒô tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"B≈ÇƒÖd od≈õwie≈ºania kom√≥rki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymu≈õ ca≈Ço≈õciowy update viewport je≈õli zmieniono jakie≈õ kom√≥rki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po od≈õwie≈ºeniu {refreshed_cells} kom√≥rek")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas wymuszania od≈õwie≈ºenia kom√≥rek tabeli: {e}")

    def _find_user_row_in_model(self, user_id):
        """
        POPRAWIONA METODA: Znajduje indeks wiersza dla danego u≈ºytkownika w modelu
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return -1

            # Pobierz klucze z modelu
            if hasattr(self.schedule_model, '_keys'):
                keys = self.schedule_model._keys
            else:
                return -1

            user_id_str = str(user_id)

            for row_index, key in enumerate(keys):
                if len(key) > 3 and str(key[3]) == user_id_str:
                    return row_index

            return -1

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas szukania wiersza u≈ºytkownika {user_id}: {e}")
            return -1

    def _update_local_events_for_cells(self, affected_pairs):
        """
        Aktualizuje lokalny events_data tylko dla zmienionych kom√≥rek

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
        """
        try:
            if not hasattr(self, 'events_data'):
                return

            # Sprawd≈∫ czy jakie≈õ z zmienionych kom√≥rek sƒÖ obecnie zaznaczone
            if not hasattr(self, 'table'):
                return

            current_selection = self.table.get_data_for_selected_cells()
            selected_pairs = set()

            for cell_data in current_selection:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    selected_pairs.add((user_id, date_str))

            # Sprawd≈∫ czy kt√≥ra≈õ ze zmienionych kom√≥rek jest zaznaczona
            intersection = set(affected_pairs) & selected_pairs

            if intersection:
                debug_print(f"Zaktualizowano {len(intersection)} zmienionych kom√≥rek w events_data")
                # Je≈õli tak, od≈õwie≈º events_data tylko dla zaznaczonych kom√≥rek
                self.on_selection_changed()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji lokalnych events: {e}")

    def _show_symbol_change_results(self, successful_updates: int, failed_updates: int, error_messages: list,
                                    events_to_cancel: list, skipped_employees: list):
        """
        Wy≈õwietla uzytkownikowi podsumowanie operacji wstawiania symboli,
        uwzglƒôdniajƒÖc kom√≥rki pominiƒôte z powodu braku uprawnie≈Ñ.
        """
        title = ""
        full_message = ""

        # Komunikat o sukcesach
        if successful_updates > 0:
            full_message += f"Pomy≈õlnie zaktualizowano {successful_updates} kom√≥rek."
            if events_to_cancel:
                full_message += f" i odwo≈Çano {len(events_to_cancel)} delegacji."
            full_message += "<br>"

        # Komunikat o pominiƒôtych z powodu braku uprawnie≈Ñ
        if skipped_employees:
            full_message += f"<br>Pominiƒôto {len(skipped_employees)} kom√≥rek z powodu braku uprawnie≈Ñ dla:<br>- {', '.join(set(skipped_employees))}<br>"

        # Komunikat o b≈Çƒôdach
        if failed_updates > 0:
            title = "Czƒô≈õciowy sukces" if successful_updates > 0 or skipped_employees else "B≈ÇƒÖd aktualizacji"
            error_list_str = "<br> - " + "<br> - ".join(error_messages[:10])
            full_message += f"<br>Nie uda≈Ço siƒô zaktualizowaƒá {failed_updates} kom√≥rek z powodu b≈Çƒôd√≥w:{error_list_str}"
            if len(error_messages) > 10:
                full_message += f"<br>... i {len(error_messages) - 10} wiƒôcej b≈Çƒôd√≥w."
        elif successful_updates > 0 or skipped_employees:
            title = "Zako≈Ñczono operacjƒô"

        # Wy≈õwietl komunikat tylko je≈õli co≈õ siƒô wydarzy≈Ço
        if full_message:
            # Je≈õli nie by≈Ço b≈Çƒôd√≥w i pominiƒôƒá, poka≈º tylko info na pasku statusu
            if successful_updates > 0 and failed_updates == 0 and not skipped_employees:
                self.statusBar().showMessage(full_message.strip(), 4000)
            else:
                QMessageBox.information(self, title, full_message.strip())

    def _prepare_delegations_description(self, grouped_events, max_groups=10):
        """
        Przygotowuje opis delegacji do odwo≈Çania.

        Args:
            grouped_events: S≈Çownik zdarze≈Ñ pogrupowanych wed≈Çug u≈ºytkownika i daty
            max_groups: Maksymalna liczba grup do wy≈õwietlenia

        Returns:
            str: Opis delegacji do odwo≈Çania
        """
        delegations_info = ""

        if not grouped_events:
            return delegations_info

        delegations_info += "<br>NastƒôpujƒÖce delegacje zostanƒÖ automatycznie odwo≈Çane:<br><br>"

        # Licznik dla ograniczenia liczby wy≈õwietlanych grup
        group_count = 0

        for (user_id, date_str), events in grouped_events.items():
            # Ograniczenie liczby wy≈õwietlanych grup
            if group_count >= max_groups:
                delegations_info += f"<br>...oraz wiƒôcej zdarze≈Ñ dla innych u≈ºytkownik√≥w/dni ({len(grouped_events) - max_groups} wiƒôcej grup)...<br>"
                break

            # Pobierz nazwƒô u≈ºytkownika z pierwszego zdarzenia
            user_name = events[0].get('user_name', f"ID: {user_id}")

            # Przygotuj datƒô w ≈Çadniejszym formacie (DD.MM.YYYY)
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            delegations_info += f"&nbsp;&nbsp;&nbsp;üë§ {user_name} - üìÖ {formatted_date}:<br>"

            # Wy≈õwietl zdarzenia dla tego u≈ºytkownika i daty
            for i, event in enumerate(events):
                delegations_info += f"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{i + 1}.  {event['type']}: {event['name']}<br>"

            group_count += 1

        return delegations_info

    def filter_processed_data(self):
        """Filtruje przetworzone dane na podstawie wszystkich filtr√≥w."""
        if not hasattr(self, 'processed_data') or not self.processed_data: return {}

        # --- POCZƒÑTEK PRZYWR√ìCONEJ, STABILNEJ LOGIKI ---
        # Pobranie stanu wszystkich filtr√≥w
        show_only_at_work = self.filter_by_presence_check.isChecked()
        selected_wydzialy = set(self.wydzial_combo.get_selected_items())
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)
        selected_dtn = self.dtn_combo.get_selected_items()
        selected_role = self.rola_combo.get_selected_items()
        selected_podrola = self.podrola_combo.get_selected_items()
        selected_rka = self.rka_combo.get_selected_items()
        selected_jezyki = self.jezyk_combo.get_selected_items()
        selected_etaty = self.etat_combo.get_selected_items()
        selected_scp = self.system_czasu_pracy_combo.get_selected_items()
        selected_grupy = self.grupa_main_filter_combo.get_selected_items()
        selected_locations_default = self.default_location_combo.get_selected_items()

        # Logika dla grup wydzia≈Ç√≥w
        allowed_depts_from_groups = set()
        if selected_grupy:
            group_mapping = app_settings.get_group_mapping()
            for group_name in selected_grupy:
                allowed_depts_from_groups.update(group_mapping.get(group_name, set()))
            if selected_wydzialy:
                selected_wydzialy = selected_wydzialy.intersection(allowed_depts_from_groups)
            else:
                selected_wydzialy = allowed_depts_from_groups

        filtered_data = {}
        for key, data in self.processed_data.items():
            if selected_locations_default and data.get(
                'lokalizacja_domyslna') not in selected_locations_default: continue
            if selected_wydzialy and key[0] not in selected_wydzialy: continue
            if selected_przelozeni and key[1] not in selected_przelozeni: continue
            if selected_uzytkownicy and str(key[2]) not in selected_uzytkownicy: continue
            if selected_dtn and str(data.get('dtn', '')) not in selected_dtn: continue
            if selected_role and data.get('rola_nazwa', '') not in selected_role: continue
            if selected_jezyki and data.get('jezyk', '') not in selected_jezyki: continue
            if selected_etaty and str(data.get('etat', '')) not in selected_etaty: continue
            if selected_scp and data.get('system_czasu_pracy', '') not in selected_scp: continue
            if selected_rka and data.get('rka', '') not in selected_rka: continue
            if selected_podrola and data.get('pod_rola_nazwa', '') not in selected_podrola: continue

            if show_only_at_work:
                if data.get('dtn') == 1: continue
                selected_date = self.presence_date_edit.date()
                selected_hours_str = self.presence_hour_combo.get_selected_items()
                selected_hours = {int(h.split(':')[0]) for h in selected_hours_str}
                day_to_check = selected_date.day()
                day_data = data.get('days', {}).get(day_to_check, {})
                symbol = day_data.get('symbol', '')
                parsed = parse_symbol(symbol)
                is_working_today = False
                special_symbol = parsed.get('special_symbol')
                # U≈ºycie app_settings.WORK_LIKE_SYMBOLS
                if symbol and (
                        not special_symbol or special_symbol in app_settings.WORK_LIKE_SYMBOLS): is_working_today = True
                user_id = key[3]
                date_str = selected_date.toString("yyyy-MM-dd")
                user_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                overtime_events = [e for e in user_events if e.get('type') == 'Nadgodziny']
                if not is_working_today and overtime_events: is_working_today = True
                if not is_working_today: continue

            filtered_data[key] = data

        return filtered_data
        # --- KONIEC PRZYWR√ìCONEJ, STABILNEJ LOGIKI ---

    def _cancel_delegations(self, events_to_cancel_input: List[Dict]):
        debug_print(f"Rozpoczynam _cancel_delegations dla {len(events_to_cancel_input)} zdarze≈Ñ.")
        if not events_to_cancel_input:
            return 0

        successful_db_updates = 0
        # Lista par (user_id, date_key) dla zdarze≈Ñ, kt√≥re zosta≈Çy pomy≈õlnie zaktualizowane w DB
        affected_user_date_pairs_for_refresh = set()

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            user_app_id, _, _, _, _, _ = get_modifier_id()

            for event_details in events_to_cancel_input:
                event_id = event_details.get('id')
                event_type = event_details.get('type')
                user_id_for_event = event_details.get('user_id')  # U≈ºyj user_id z event_details
                date_key_for_event = event_details.get('date_key', event_details.get('date'))

                if not event_id or not event_type or not user_id_for_event or not date_key_for_event:
                    log_warning(f"Pominiƒôto zdarzenie z niepe≈Çnymi danymi w _cancel_delegations: {event_details}")
                    continue

                table_name = ""
                if event_type == "Spotkanie":
                    table_name = SQL_OBJECTS['spotkania']
                elif event_type == "Szkolenie":
                    table_name = SQL_OBJECTS['szkolenia']
                elif event_type == "Nadgodziny":
                    table_name = SQL_OBJECTS['nadgodziny']

                if not table_name:
                    log_warning(f"Nieznany typ zdarzenia w _cancel_delegations: {event_type}")
                    continue

                try:
                    if event_type in ["Spotkanie", "Szkolenie"]:
                        update_query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                        cursor.execute(update_query, (user_app_id, event_id))
                    else:  # Nadgodziny
                        delete_query = f"DELETE FROM {table_name} WHERE Id = ?"
                        cursor.execute(delete_query, (event_id,))

                    if cursor.rowcount > 0:
                        successful_db_updates += 1
                        affected_user_date_pairs_for_refresh.add((user_id_for_event, date_key_for_event))
                        debug_print(f"DB: Pomy≈õlnie zaktualizowano/usuniƒôto {event_type} ID {event_id}")
                    else:
                        log_warning(f"DB: Nie znaleziono {event_type} ID {event_id} do aktualizacji/usuniƒôcia.")

                except Exception as db_err:
                    log_error(f"B≈ÇƒÖd DB podczas odwo≈Çywania {event_type} ID {event_id}: {db_err}", exception=db_err)

            if successful_db_updates > 0:
                conn.commit()
                debug_print(f"DB: Zatwierdzono {successful_db_updates} zmian.")
                # Rejestrujemy, ≈ºe to my dokonali≈õmy zmiany w bazie danych
                self._update_modification_date()
            conn.close()

        except Exception as e:
            log_error(f"Generalny b≈ÇƒÖd w _cancel_delegations podczas operacji DB: {e}", exception=e)
            return 0  # Zwr√≥ƒá 0 je≈õli wystƒÖpi≈Ç b≈ÇƒÖd przed aktualizacjƒÖ UI

        # Je≈õli by≈Çy jakiekolwiek udane aktualizacje w DB
        if affected_user_date_pairs_for_refresh:
            debug_print(
                f"_cancel_delegations: Uruchamiam od≈õwie≈ºanie DataProvider dla {len(affected_user_date_pairs_for_refresh)} par.")
            # Krok 1: Uniewa≈ºnij i od≈õwie≈º cache DataProvider dla dotkniƒôtych zdarze≈Ñ/miesiƒôcy
            self.data_provider.invalidate_complete_cache_for_pairs(list(affected_user_date_pairs_for_refresh))

            # Krok 2: Od≈õwie≈º tabelƒô zdarze≈Ñ - on_selection_changed u≈ºyje ≈õwie≈ºych danych z DataProvider
            # Ta metoda zaktualizuje self.events_data i self.events_model
            debug_print(f"_cancel_delegations: Uruchamiam on_selection_changed() w celu od≈õwie≈ºenia tabeli zdarze≈Ñ.")
            selected_cells_data = self.table.get_data_for_selected_cells()  # Pobierz aktualnie zaznaczone kom√≥rki
            if selected_cells_data:
                self.on_selection_changed()  # To powinno teraz poprawnie wyczy≈õciƒá zdarzenia
            else:  # Je≈õli nic nie jest zaznaczone, wyczy≈õƒá tabelƒô zdarze≈Ñ rƒôcznie
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])
                debug_print("_cancel_delegations: Brak zaznaczenia, wyczyszczono tabelƒô zdarze≈Ñ.")

            # Krok 3: Zaktualizuj ikony w tabeli grafiku na podstawie ≈õwie≈ºych danych z DataProvider
            if hasattr(self, 'schedule_model'):
                debug_print(
                    f"_cancel_delegations: Uruchamiam aktualizacjƒô ikon grafiku dla {len(affected_user_date_pairs_for_refresh)} par.")
                for user_id, date_str in affected_user_date_pairs_for_refresh:
                    # Pobierz aktualne aktywne zdarzenia dla tej kom√≥rki z DataProvider
                    # DataProvider powinien teraz mieƒá ≈õwie≈ºe dane po invalidate_complete_cache_for_pairs
                    remaining_active_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                    has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_active_events)
                    has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_active_events)
                    has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_active_events)

                    self.schedule_model.update_cell_icons_directly(
                        user_id, date_str, has_meetings, has_trainings, has_overtime
                    )

            # Wymu≈õ od≈õwie≈ºenie widok√≥w tabel, je≈õli to konieczne
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        debug_print(f"_cancel_delegations: Zako≈Ñczono, pomy≈õlnie przetworzono w DB: {successful_db_updates} zdarze≈Ñ.")
        return successful_db_updates

    def update_filter_dates(self):
        """Aktualizuje daty filtrowania do pierwszego i ostatniego dnia wybranego miesiƒÖca"""
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # KLUCZOWA POPRAWKA: Blokuj sygna≈Çy przed zmianƒÖ dat
        self.date_from.blockSignals(True)
        self.date_to.blockSignals(True)

        try:
            # Pierwszy dzie≈Ñ miesiƒÖca
            first_day = QDate(year, month, 1)
            self.date_from.setDate(first_day)

            # Ostatni dzie≈Ñ miesiƒÖca
            if month == 12:
                next_month = QDate(year + 1, 1, 1)
            else:
                next_month = QDate(year, month + 1, 1)

            last_day = next_month.addDays(-1)
            self.date_to.setDate(last_day)

        finally:
            # ZAWSZE odblokuj sygna≈Çy
            self.date_from.blockSignals(False)
            self.date_to.blockSignals(False)

        # Wywo≈Çaj filtrowanie tylko RAZ po wszystkich zmianach
        self.filter_events_table()

    def update_data(self, year, month, grupa, funkcja, use_async=True, filters_to_restore=None):
        """
        NOWA WERSJA: ≈Åadowanie danych z opcjƒÖ przekazania stanu filtr√≥w do przywr√≥cenia.
        """
        debug_print(f"Rozpoczynam ≈Çadowanie danych dla {year}-{month} (async={use_async})")

        self.year = year
        self.month = month

        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            self.schedule_model = ScheduleTableModel(self)
            self.schedule_model.set_theme(self.is_dark_theme)
            ui_columns = self.column_definitions.get_ui_display_columns()
            visible_cols = self.visible_columns
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

        if not hasattr(self, 'events_model') or not self.events_model:
            self.events_model = EventsTableModel(self)
            self.events_model.set_theme(self.is_dark_theme)

        if use_async:
            self._load_data_async(year, month, filters_to_restore=filters_to_restore)
        else:
            self._load_data_sync(year, month, filters_to_restore=filters_to_restore)

    def _load_data_sync(self, year, month):
        """
        Synchroniczne ≈Çadowanie danych (fallback), teraz sp√≥jne z logikƒÖ asynchronicznƒÖ.
        """
        debug_print(f"≈Åadowanie synchroniczne dla {year}-{month}")

        try:
            if hasattr(self, 'statusBar'):
                self.statusBar().showMessage(f"≈Åadowanie danych {year}-{month} ...")

            # Krok 1: Pobierz kontener z danymi bazowymi
            container = self.data_provider._get_or_load_monthly_data(
                year, month, self.import_grupa, self.import_funkcja, use_cache=False
            )

            if container:
                # Krok 2: Pobierz przetworzone dane z na≈Ço≈ºonymi ikonami
                processed_data_with_icons = self.data_provider.get_processed_data(
                    year, month, self.import_grupa, self.import_funkcja
                )

                # Krok 3: Zastosuj wszystkie dane
                self._apply_loaded_data({
                    'schedule_data': container.schedule_data,
                    'events_data': container.events_data,
                    'processed_data': processed_data_with_icons,  # U≈ºywamy danych z ikonami
                    'year': year,
                    'month': month
                })
            else:
                log_error("Nie uda≈Ço siƒô pobraƒá danych z DataProvider w trybie synchronicznym.")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas synchronicznego ≈Çadowania: {e}", exception=e)

        finally:
            if hasattr(self, 'statusBar'):
                self.statusBar().clearMessage()

    def _load_data_async(self, year, month, filters_to_restore=None):
        """Asynchroniczne ≈Çadowanie danych z progress dialogiem."""
        from functools import partial

        debug_print(f"Uruchamiam async ≈Çadowanie dla {year}-{month}")

        # --- NOWA LOGIKA: U≈ºycie nowoczesnego wska≈∫nika ≈Çadowania ---
        self.loading_indicator = ModernLoadingIndicator(self, f"≈Åadowanie danych dla {year}-{month}...")
        self.loading_indicator.show()

        self.loading_thread = PreparationThread(self.data_provider, year, month, self.import_grupa, self.import_funkcja)
        self.loading_thread.preparation_finished.connect(
            partial(self._on_async_data_loaded, filters_to_restore=filters_to_restore))
        self.loading_thread.error_occurred.connect(self._on_async_loading_failed)
        self.loading_thread.finished.connect(self.loading_indicator.hide)
        self.loading_thread.finished.connect(self.loading_thread.deleteLater)

        self.loading_thread.start()

    def _on_async_data_loaded(self, data, filters_to_restore=None):
        """Obs≈Çuguje pomy≈õlne za≈Çadowanie danych async."""
        debug_print("Otrzymano dane z async loading")
        try:
            is_initial_load = self.schedule_model.rowCount() == 0

            # Zapisz stan widoku (sortowanie i zaznaczenie) przed resetem modelu
            view_state = self._save_view_state()

            self._apply_loaded_data(data, filters_to_restore=filters_to_restore)

            # Zawsze przywracaj stan widoku, chyba ≈ºe jest to pierwsze ≈Çadowanie
            if not is_initial_load:
                self._restore_view_state(view_state)

            # # Po za≈Çadowaniu nowych danych i przywr√≥ceniu stanu tabel,
            # # ponownie zastosuj wszystkie ustawienia wyglƒÖdu, aby zapewniƒá sp√≥jno≈õƒá.
            # self.apply_theme_settings(
            #     'dark' if self.is_dark_theme else 'light',
            #     self.current_font,
            #     self.current_font_size
            # )

            debug_print("Pomy≈õlnie zastosowano dane z async loading")
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas stosowania za≈Çadowanych danych: {e}")

    def _on_async_loading_failed(self, error_message):
        """Obs≈Çuguje b≈Çƒôdy async loading."""
        debug_print(f"Async loading failed: {error_message}")
        QMessageBox.critical(self, "B≈ÇƒÖd ≈Çadowania danych",
                             f"Nie uda≈Ço siƒô za≈Çadowaƒá danych:<br>{error_message}<br><br>Spr√≥buj ponownie lub skontaktuj siƒô z administratorem.",
                             QMessageBox.Ok)
        try:
            debug_print("Pr√≥bujƒô fallback do synchronicznego ≈Çadowania")
            self._load_data_sync(self.year, self.month)
        except Exception as e:
            log_error(f"Fallback loading te≈º nie powi√≥d≈Ç siƒô: {e}")

    def _apply_loaded_data(self, data, filters_to_restore=None):
        """Aplikuje nowo za≈Çadowane dane do modeli i UI."""
        if data is None:
            log_error("B≈ÇƒÖd: _apply_loaded_data otrzyma≈Ço puste dane (None).")
            return

        schedule_data = data.get('schedule_data', [])
        events_data = data.get('events_data', [])
        processed_data = data.get('processed_data', {})
        year = data.get('year')
        month = data.get('month')

        # --- POCZƒÑTEK POPRAWKI ---
        # Sprawdzamy `is None` zamiast polegaƒá na "prawdziwo≈õci" s≈Çownika,
        # aby zezwoliƒá na ≈Çadowanie pustych miesiƒôcy (gdzie processed_data = {}).
        if processed_data is None or year is None or month is None:
            log_error(f"Niekompletne dane przekazane do _apply_loaded_data: rok={year}, miesiac={month}")
            return
        # --- KONIEC POPRAWKI ---

        self.raw_data = schedule_data
        self.all_events_data = events_data
        self.processed_data = processed_data

        is_initial_load = self.schedule_model.rowCount() == 0
        self.schedule_model.update_data(self.processed_data, year, month)

        self.events_data = []
        if hasattr(self, 'events_model'):
            self.events_model.update_data([])
        self.all_events_data = data.get('events_data', [])

        if hasattr(self, 'status_filter_combo'):
            all_statuses = sorted(list(set(e.get('status', '') for e in self.all_events_data if e.get('status'))))
            self.status_filter_combo.add_items(all_statuses)
            self.status_filter_combo.select_items(all_statuses)

        # NOWA LOGIKA:
        # Je≈õli przekazano stan filtr√≥w (co dzieje siƒô przy od≈õwie≈ºaniu), u≈ºyj go.
        if filters_to_restore:
            self.restore_filters_state(filters_to_restore)
        else:
            # W przeciwnym razie (przy pierwszym ≈Çadowaniu) u≈ºyj filtr√≥w zapisanych w bazie.
            last_filters = self.user_app_settings.get('last_filters')
            if last_filters:
                self.restore_filters_state(last_filters)
            else:
                self.update_filters()
                self.filter_data()

        if is_initial_load:
            self.apply_custom_sort()

        self._apply_dynamic_sizes()
        self.setup_events_table_columns()

    def apply_default_sort(self):
        """
        Rƒôcznie sortuje dane w modelu zgodnie z domy≈õlnƒÖ, wielopoziomowƒÖ
        kolejno≈õciƒÖ i wymusza od≈õwie≈ºenie widoku.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model._processed_data:
            return

        debug_print("Aplikowanie domy≈õlnego, wielopoziomowego sortowania...")

        # Pobieramy klucze i pe≈Çne dane do sortowania
        keys_to_sort = self.schedule_model._keys
        processed_data = self.schedule_model._processed_data

        # Sortujemy klucze wed≈Çug docelowej kolejno≈õci
        sorted_keys = sorted(keys_to_sort, key=lambda k: (
            processed_data[k].get('dtn', 0),  # 1. Po DTN
            k[0] or '',  # 2. Po Wydziale
            k[1] or '',  # 3. Po Prze≈Ço≈ºonym
            k[2] or ''  # 4. Po U≈ºytkowniku
        ))

        # Ustawiamy nowƒÖ, posortowanƒÖ listƒô kluczy w modelu
        self.schedule_model._keys = sorted_keys

        # Informujemy widok, ≈ºe uk≈Çad modelu uleg≈Ç ca≈Çkowitej zmianie
        self.schedule_model.layoutChanged.emit()
        debug_print("Zako≈Ñczono domy≈õlne sortowanie. Widok zosta≈Ç od≈õwie≈ºony.")

    def clear_events_cache(self, year, month):
        """
        Czy≈õci cache zdarze≈Ñ dla danego miesiƒÖca - UPROSZCZONA WERSJA

        Args:
            year: Rok
            month: MiesiƒÖc
        """
        # POPRAWKA: Deleguj TYLKO do DataProvider, bez dodatkowych akcji
        if hasattr(self.data_provider, 'invalidate_icons_cache'):
            self.data_provider.invalidate_icons_cache(year, month)
            debug_print(f"Wyczyszczono cache zdarze≈Ñ dla {year}-{month}")
        else:
            debug_print(f"DataProvider nie ma metody invalidate_icons_cache")

    def get_events_for_user_date(self, user_id, date_str):
        """
        UPROSZCZONA METODA: Deleguje do DataProvider
        """
        return self.data_provider.get_events_for_user_date(user_id, date_str)

    def refresh_column_configuration(self):
        """Od≈õwie≈ºa konfiguracjƒô kolumn z ColumnDefinitions"""
        # ZMODYFIKOWANE: U≈ºywaj self.column_definitions zamiast column_manager
        # Pobierz zaktualizowane dane kolumn
        ui_columns = self.column_definitions.get_ui_display_columns()
        visible_cols = self.visible_columns

        # Aktualizuj referencje w g≈Ç√≥wnej klasie
        self.employee_columns = ui_columns

        # Aktualizuj model
        if hasattr(self, 'schedule_model') and self.schedule_model:
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

            # Je≈õli tabela ju≈º istnieje, zaktualizuj widok
            if hasattr(self, 'table') and self.table:
                self.table.set_model(self.schedule_model)


    def setup_event_table_columns(self):
        """
        Konfiguruje szeroko≈õci kolumn tabeli zdarze≈Ñ.
        Wyodrƒôbnione z metody update_data dla lepszej czytelno≈õci.
        """
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # U≈ºytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

    def show_loading_indicator(self, message="≈Åadowanie..."):
        """
        Pokazuje wska≈∫nik ≈Çadowania w UI
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().showMessage(message)

        # Wy≈ÇƒÖcz niekt√≥re kontrolki podczas ≈Çadowania
        self.date_combo.setEnabled(False)
        self.refresh_button.setEnabled(False)

        if hasattr(self, 'left_panel_visible') and self.left_panel_visible:
            self._left_panel.setEnabled(False)

    def hide_loading_indicator(self):
        """
        Ukrywa wska≈∫nik ≈Çadowania
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().clearMessage()

        # W≈ÇƒÖcz z powrotem kontrolki
        self.date_combo.setEnabled(True)
        self.refresh_button.setEnabled(True)

        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(True)

    def get_loading_preferences(self):
        """
        Zwraca preferencje u≈ºytkownika dotyczƒÖce ≈Çadowania
        """
        # Mo≈ºna dodaƒá ustawienia w settings_db dla kontroli async loading
        # Na razie zawsze async dla du≈ºych zbior√≥w danych
        return {
            'use_async_threshold': 1000,  # U≈ºyj async dla >1000 wierszy
            'show_progress_dialog': True,
            'auto_fallback_to_sync': True
        }

    def update_cross_filters(self):
        """
        Aktualizuje filtry wzajemnie, ale zamiast przebudowywaƒá listy,
        jedynie ukrywa/pokazuje istniejƒÖce elementy, aby zachowaƒá pozycjƒô przewijania.
        """
        if not getattr(self, '_cross_filtering_enabled', True):
            return

        if not hasattr(self, 'processed_data') or not self.processed_data:
            return

        if getattr(self, '_updating_cross_filters', False):
            return

        self._updating_cross_filters = True
        try:
            # Pobranie aktualnych wybor√≥w (logika bez zmian)
            selected_wydzialy = self.wydzial_combo.get_selected_items()
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

            # === AKTUALIZACJA LISTY PRZE≈ÅO≈ªONYCH ===
            if hasattr(self, 'przelozony_list'):
                # Oblicz, kt√≥rzy prze≈Ço≈ºeni powinni byƒá widoczni (logika bez zmian)
                available_przelozeni = set()
                if selected_wydzialy:
                    for key in self.processed_data.keys():
                        if key[0] in selected_wydzialy and key[1]:
                            available_przelozeni.add(key[1])
                else:
                    for key in self.processed_data.keys():
                        if key[1]: available_przelozeni.add(key[1])

                # NOWA LOGIKA: Poka≈º/ukryj elementy zamiast przebudowywaƒá listƒô
                for i in range(self.przelozony_list.count()):
                    item = self.przelozony_list.item(i)
                    item.setHidden(item.text() not in available_przelozeni)

            # === AKTUALIZACJA LISTY U≈ªYTKOWNIK√ìW ===
            if hasattr(self, 'uzytkownik_list'):
                # Oblicz, kt√≥rzy u≈ºytkownicy powinni byƒá widoczni (logika bez zmian)
                available_uzytkownicy = set()
                for key in self.processed_data.keys():
                    wydzial, przelozony, uzytkownik_dane, _ = key
                    if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                            (not selected_przelozeni or przelozony in selected_przelozeni):
                        if uzytkownik_dane: available_uzytkownicy.add(str(uzytkownik_dane))

                # NOWA LOGIKA: Poka≈º/ukryj elementy zamiast przebudowywaƒá listƒô
                for i in range(self.uzytkownik_list.count()):
                    item = self.uzytkownik_list.item(i)
                    item.setHidden(item.text() not in available_uzytkownicy)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas cross-filtrowania: {e}", exception=e)
        finally:
            self._updating_cross_filters = False

    def update_list_safely(self, list_widget, items, selected_items):
        """
        Bezpiecznie aktualizuje QListWidget, blokujƒÖc sygna≈Çy na czas modyfikacji.
        """
        if not list_widget:
            return

        list_widget.blockSignals(True)
        try:
            # Zapamiƒôtanie, co jest aktualnie widoczne z pola wyszukiwania
            search_text = ""
            if list_widget is self.przelozony_list:
                search_text = self.przelozony_filter.text().lower()
            elif list_widget is self.uzytkownik_list:
                search_text = self.uzytkownik_filter.text().lower()

            list_widget.clear()
            for item_text in sorted(items):
                item = QListWidgetItem(item_text)
                list_widget.addItem(item)
                if item_text in selected_items:
                    item.setSelected(True)

                # Przywr√≥cenie ukrycia na podstawie filtra wyszukiwania
                if search_text and search_text not in item_text.lower():
                    item.setHidden(True)

        finally:
            list_widget.blockSignals(False)

    def get_current_filters_state(self):
        """Zapisuje aktualnie wybrane warto≈õci ze wszystkich ISTNIEJƒÑCYCH filtr√≥w do s≈Çownika."""
        state = {
            'grupa': self.grupa_main_filter_combo.currentText(),
            'wydzial': self.wydzial_combo.get_selected_items(),
            'przelozony': self.get_list_selected_items(self.przelozony_list),
            'uzytkownik': self.get_list_selected_items(self.uzytkownik_list),
            'lokalizacja_domyslna': self.default_location_combo.get_selected_items(),
            'system_czasu_pracy': self.system_czasu_pracy_combo.get_selected_items(),
            'rola': self.rola_combo.get_selected_items(),
            'jezyk': self.jezyk_combo.get_selected_items(),
            'etat': self.etat_combo.get_selected_items(),
            'dtn': self.dtn_combo.get_selected_items(),
            'rka': self.rka_combo.get_selected_items(),
            'podrola': self.podrola_combo.get_selected_items(),
        }
        debug_print(f"Zapisano stan filtr√≥w: {state}")
        return state

    def restore_filters_state(self, state):
        """
        Przywraca zapisany stan filtr√≥w po za≈Çadowaniu nowych danych.
        """
        debug_print("Rozpoczynam przywracanie stanu filtr√≥w...")

        self._cross_filtering_enabled = False

        try:
            self.update_filters()

            self.grupa_main_filter_combo.blockSignals(True)
            self.grupa_main_filter_combo.setCurrentText(state.get('grupa', '(Wszyscy)'))
            self.grupa_main_filter_combo.blockSignals(False)

            self.wydzial_combo.select_items(state.get('wydzial', []))
            self.default_location_combo.select_items(state.get('lokalizacja_domyslna', []))
            self.system_czasu_pracy_combo.select_items(state.get('system_czasu_pracy', []))
            self.rola_combo.select_items(state.get('rola', []))
            self.jezyk_combo.select_items(state.get('jezyk', []))
            self.etat_combo.select_items(state.get('etat', []))
            self.dtn_combo.select_items(state.get('dtn', []))
            self.rka_combo.select_items(state.get('rka', []))
            self.podrola_combo.select_items(state.get('podrola', []))

            przelozeni_items = self._get_unique_values_for_filter('przelozony')
            uzytkownicy_items = self._get_unique_values_for_filter('uzytkownik_dane')
            self.update_list_safely(self.przelozony_list, przelozeni_items, state.get('przelozony', []))
            self.update_list_safely(self.uzytkownik_list, uzytkownicy_items, state.get('uzytkownik', []))

        finally:
            self._cross_filtering_enabled = True
            debug_print("Zako≈Ñczono przywracanie stanu filtr√≥w.")

        debug_print("Uruchamiam filtrowanie po przywr√≥ceniu stanu.")
        self.filter_data()

    def _get_unique_values_for_filter(self, filter_key):
        """
        Pobiera unikalne warto≈õci dla danego filtra z aktualnie za≈Çadowanych,
        pe≈Çnych danych w self.processed_data.
        """
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return set()

        unique_values = set()

        key_map = {
            'wydzial': 0,
            'przelozony': 1,
            'uzytkownik_dane': 2
        }

        if filter_key in key_map:
            key_index = key_map[filter_key]
            for key_tuple in self.processed_data.keys():
                if len(key_tuple) > key_index and key_tuple[key_index]:
                    unique_values.add(str(key_tuple[key_index]))
        else:
            for data_dict in self.processed_data.values():
                value = data_dict.get(filter_key)
                # --- POPRAWIONY WARUNEK ---
                # Sprawdzamy, czy warto≈õƒá nie jest None, co poprawnie uwzglƒôdni zero.
                if value is not None and value != '':
                    unique_values.add(str(value))

        return unique_values

    def clear_filters(self):
        """Czy≈õci wszystkie filtry i aktualizuje model."""
        self._cross_filtering_enabled = False
        try:
            combo_names_to_clear = [
                'grupa_main_filter_combo', 'wydzial_combo', 'dtn_combo',
                'rola_combo', 'jezyk_combo', 'etat_combo',
                'system_czasu_pracy_combo',
                'default_location_combo', 'rka_combo',
                'podrola_combo'
            ]
            for combo_name in combo_names_to_clear:
                if hasattr(self, combo_name):
                    getattr(self, combo_name).clear_selection()

            if hasattr(self, 'przelozony_list'): self.przelozony_list.clearSelection()
            if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.clearSelection()
            if hasattr(self, 'przelozony_filter'): self.przelozony_filter.clear()
            if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.clear()

            # Czyszczenie filtra obecno≈õci
            if hasattr(self, 'filter_by_presence_check'):
                self.filter_by_presence_check.setChecked(False)
            if hasattr(self, 'presence_location_combo'):
                self.presence_location_combo.clear_selection()
            # ZMIANA: U≈ºycie metody `clear_selection` dla nowego filtra
            if hasattr(self, 'presence_hour_combo'):
                self.presence_hour_combo.clear_selection()
            if hasattr(self, 'saved_filters_combo'):
                self.saved_filters_combo.setCurrentIndex(0)

        finally:
            self._cross_filtering_enabled = True
            # Wywo≈Çanie filtrowania po wyczyszczeniu wszystkich kontrolek
            self.filter_data()
            self._update_delete_button_state()

    def filter_przelozony_list(self, text):
        """
        Filtruje listƒô prze≈Ço≈ºonych na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'przelozony_list'):
            return

        text = text.lower()
        for i in range(self.przelozony_list.count()):
            item = self.przelozony_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_uzytkownik_list(self, text):
        """
        Filtruje listƒô u≈ºytkownik√≥w na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'uzytkownik_list'):
            return

        text = text.lower()
        for i in range(self.uzytkownik_list.count()):
            item = self.uzytkownik_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def update_filtered_table(self):
        """
        Aktualizuje widok tabeli na podstawie zaznaczonych filtr√≥w
        """
        # Bezpo≈õrednio aktualizuj ca≈ÇƒÖ tabelƒô z przefiltrowanymi danymi
        self.update_table_content()

    def get_list_selected_items(self, list_widget):
        """
        Zwraca teksty zaznaczonych element√≥w z listy.
        POPRAWKA: Zmieniono nazwƒô metody z get_selected_items na get_list_selected_items,
        aby uniknƒÖƒá konfliktu z metodƒÖ get_selected_items w CustomMultiComboBox.

        Args:
            list_widget: QListWidget do pobrania zaznaczonych element√≥w

        Returns:
            list: Lista zaznaczonych tekst√≥w
        """
        if not list_widget:
            return []

        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item and item.isSelected():
                selected.append(item.text())
        return selected

    def update_filters(self):
        """
        Wype≈Çnia wszystkie filtry na podstawie za≈Çadowanych danych.
        WERSJA POPRAWIONA: Zawiera kompletnƒÖ logikƒô dla wszystkich filtr√≥w.
        """
        try:
            if not hasattr(self, 'processed_data') or not self.processed_data:
                debug_print("Brak danych do wype≈Çnienia filtr√≥w, pomijam.")
                return

            debug_print("Rozpoczynam pe≈ÇnƒÖ aktualizacjƒô filtr√≥w...")

            # Zapamiƒôtanie bie≈ºƒÖcych wybor√≥w, aby je przywr√≥ciƒá po od≈õwie≈ºeniu list
            selected_grupy = self.grupa_main_filter_combo.get_selected_items()
            selected_wydzialy = self.wydzial_combo.get_selected_items()
            selected_dtn = self.dtn_combo.get_selected_items()
            selected_role = self.rola_combo.get_selected_items()
            selected_jezyki = self.jezyk_combo.get_selected_items()
            selected_etaty = self.etat_combo.get_selected_items()
            selected_scp = self.system_czasu_pracy_combo.get_selected_items()
            selected_locations = self.default_location_combo.get_selected_items()
            selected_rka = self.rka_combo.get_selected_items()
            selected_podrola = self.podrola_combo.get_selected_items()

            # Filtr "Grupa"
            group_mapping = self.data_provider.get_department_to_group_mapping()
            self.grupa_main_filter_combo.add_items(sorted(group_mapping.keys()))
            self.grupa_main_filter_combo.select_items(selected_grupy)

            # Filtr "Wydzia≈Ç"
            wydzialy = sorted(set(key[0] for key in self.processed_data.keys() if key[0]))
            self.wydzial_combo.add_items(wydzialy)
            self.wydzial_combo.select_items(selected_wydzialy)

            # Filtr "Lokalizacja Domy≈õlna"
            locations = sorted(set(data.get('lokalizacja_domyslna', '') for data in self.processed_data.values() if
                                   data.get('lokalizacja_domyslna')))
            self.default_location_combo.add_items(locations)
            self.default_location_combo.select_items(selected_locations)

            # Filtr "System Pracy"
            scp_values = sorted(set(data.get('system_czasu_pracy', '') for data in self.processed_data.values() if
                                    data.get('system_czasu_pracy', '')))
            self.system_czasu_pracy_combo.add_items(scp_values)
            self.system_czasu_pracy_combo.select_items(selected_scp)

            # Filtr "Rola"
            role_values = sorted(
                set(data.get('rola_nazwa', '') for data in self.processed_data.values() if data.get('rola_nazwa', '')))
            self.rola_combo.add_items(role_values)
            self.rola_combo.select_items(selected_role)

            # Wype≈Çnianie "PodRola" (pod_rola_nazwa)
            podrola_values = self._get_unique_values_for_filter('pod_rola_nazwa')
            self.podrola_combo.add_items(podrola_values)
            self.podrola_combo.select_items(selected_podrola)

            # Filtr "Jƒôzyk"
            jezyki_values = sorted(
                set(data.get('jezyk', '') for data in self.processed_data.values() if data.get('jezyk', '')))
            self.jezyk_combo.add_items(jezyki_values)
            self.jezyk_combo.select_items(selected_jezyki)

            # Filtr "Etat"
            etaty_values = set(str(data.get('etat', '')) for data in self.processed_data.values() if
                               data.get('etat') is not None and str(data.get('etat', '')))
            sorted_etaty = sorted(etaty_values, key=lambda x: float(x) if x.replace('.', '', 1).isdigit() else 0)
            self.etat_combo.add_items(sorted_etaty)
            self.etat_combo.select_items(selected_etaty)

            # Filtr "DTN"
            dtn_values = sorted(
                set(str(data['dtn']) for data in self.processed_data.values() if data.get('dtn') is not None), key=int)
            self.dtn_combo.add_items(dtn_values)
            self.dtn_combo.select_items(selected_dtn)

            # Wype≈Çnianie "Rka" (rola_nazwa)
            rka_values = self._get_unique_values_for_filter('rka')
            self.rka_combo.add_items(rka_values)
            self.rka_combo.select_items(selected_rka)

            # Aktualizacja list dynamicznych (Prze≈Ço≈ºony, U≈ºytkownik)
            self.update_przelozony_filter()
            self.update_uzytkownik_filter()

            debug_print("Zako≈Ñczono pe≈ÇnƒÖ aktualizacjƒô wszystkich filtr√≥w.")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji filtr√≥w: {e}", exception=e)

    def update_przelozony_filter(self, selected_przelozeni=None):
        """
        Aktualizuje listƒô prze≈Ço≈ºonych na podstawie wybranych wydzia≈Ç√≥w.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_przelozeni: Lista zaznaczonych prze≈Ço≈ºonych (opcjonalnie)
        """
        if not hasattr(self, 'przelozony_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiƒôtaj bie≈ºƒÖcƒÖ selekcjƒô je≈õli nie podano
        if selected_przelozeni is None:
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)

        self.przelozony_list.clear()

        # Pobierz wybrane wydzia≈Çy
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []

        # Zbi√≥r unikalnych prze≈Ço≈ºonych
        przelozeni = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, _, _ = key

            # Je≈õli nie wybrano wydzia≈Ç√≥w lub wydzia≈Ç pasuje do filtra
            if not selected_wydzialy or wydzial in selected_wydzialy:
                # Dodaj prze≈Ço≈ºonego do zbioru (tylko niepuste warto≈õci)
                if przelozony:
                    przelozeni.add(przelozony)

        # Dodaj posortowanych prze≈Ço≈ºonych do listy
        for przelozony in sorted(przelozeni):
            item = QListWidgetItem(przelozony)
            self.przelozony_list.addItem(item)

            # Przywr√≥ƒá zaznaczenie je≈õli by≈Ço
            if przelozony in selected_przelozeni:
                item.setSelected(True)

    def update_uzytkownik_filter(self, selected_uzytkownicy=None):
        """
        Aktualizuje listƒô u≈ºytkownik√≥w na podstawie wybranych wydzia≈Ç√≥w i prze≈Ço≈ºonych.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_uzytkownicy: Lista zaznaczonych u≈ºytkownik√≥w (opcjonalnie)
        """
        if not hasattr(self, 'uzytkownik_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiƒôtaj bie≈ºƒÖcƒÖ selekcjƒô je≈õli nie podano
        if selected_uzytkownicy is None:
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

        self.uzytkownik_list.clear()

        # Pobierz wybrane wydzia≈Çy i prze≈Ço≈ºonych
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self,
                                                                                            'przelozony_list') else []

        # Zbi√≥r unikalnych u≈ºytkownik√≥w (u≈ºyj stringa jako tekstowej reprezentacji)
        uzytkownicy = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, uzytkownik_dane, _ = key

            # Sprawd≈∫ czy dane pasujƒÖ do filtr√≥w
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni):
                # Dodaj u≈ºytkownika do zbioru (tylko niepuste warto≈õci)
                if uzytkownik_dane:
                    # Konwertuj do stringa dla sp√≥jno≈õci
                    uzytkownicy.add(str(uzytkownik_dane))

        # Dodaj posortowanych u≈ºytkownik√≥w do listy
        for uzytkownik in sorted(uzytkownicy):
            item = QListWidgetItem(uzytkownik)
            self.uzytkownik_list.addItem(item)

            # Przywr√≥ƒá zaznaczenie je≈õli by≈Ço
            if uzytkownik in selected_uzytkownicy:
                item.setSelected(True)

    def update_table_content(self):
        """
        Aktualizuje zawarto≈õƒá tabeli grafiku u≈ºywajƒÖc modelu danych.
        Zoptymalizowana wersja wykorzystujƒÖca precyzyjne aktualizacje.
        """
        # Sprawd≈∫ czy modele zosta≈Çy zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # Pobierz aktualny rok i miesiƒÖc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # Ustaw rok i miesiƒÖc w modelu (je≈õli jeszcze nie sƒÖ ustawione)
        if self.schedule_model._year != year or self.schedule_model._month != month:
            # Pobierz dane dla wybranego roku i miesiƒÖca
            schedule_data = self.data_provider.get_schedule_data(year, month, self.import_grupa, self.import_funkcja)

            # Aktualizuj model - to wywo≈Ça zoptymalizowanƒÖ metodƒô update_data
            self.schedule_model.update_data(schedule_data, year, month)
            self._apply_dynamic_sizes()
        else:
            # Je≈õli rok i miesiƒÖc nie uleg≈Çy zmianie, tylko zastosuj filtry
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

    def get_cell_color_by_time(self, hour):
        """
        Zwraca kolor t≈Ça kom√≥rki na podstawie godziny rozpoczƒôcia.
        Godziny sƒÖ mapowane na kolory w bardziej czytelnej palecie.

        Args:
            hour (int): Godzina rozpoczƒôcia zmiany (0-23)

        Returns:
            QColor: Kolor t≈Ça kom√≥rki
        """
        # Domy≈õlny kolor (przezroczysty) gdy godzina nie jest zdefiniowana
        if hour is None or hour < 0 or hour > 23:
            return QColor(255, 255, 255, 0)  # Przezroczysty

        # Mapowanie godzin na kolory - zharmonizowana paleta
        if hour == 5:
            return QColor(204, 255, 255)  # Jasny b≈Çƒôkit (bardzo jasny cyjan)
        elif hour == 6:
            return QColor(204, 255, 255)  # Jasny b≈Çƒôkit (bardzo jasny cyjan)
        elif hour == 7:
            return QColor(0, 255, 255)  # Cyjan (akwamaryna)
        elif hour == 8:
            return QColor(0, 204, 255)  # Jasny b≈Çƒôkit (niebieskozielony)
        elif hour == 9:
            return QColor(0, 255, 0)  # Limonkowy (czysty zielony)
        elif hour == 10:
            return QColor(153, 204, 0)  # Oliwkowy (≈º√≥≈Çtozielony)
        elif hour == 11:
            return QColor(204, 255, 204)  # Bardzo jasny zielony (miƒôtowy)
        elif hour == 12:
            return QColor(255, 255, 153)  # Bardzo jasny ≈º√≥≈Çty (kremowy)
        elif hour == 13:
            return QColor(255, 204, 153)  # Jasny ≈Çososiowy (brzoskwiniowy)
        elif hour == 14:
            return QColor(255, 153, 0)  # Ciemny pomara≈Ñczowy
        elif hour == 15:
            return QColor(255, 0, 255)  # Magenta (fuksja)
        elif hour == 16:
            return QColor(204, 0, 0)  # Ciemnoczerwony
        elif hour == 17:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 18:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 19:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 20:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 21:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 22:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 23:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 0:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour in [1, 2, 3, 4]:
            return QColor(51, 51, 51)  # Ciemny szary

        # Domy≈õlny kolor dla innych warto≈õci
        return QColor(255, 255, 255, 0)  # Przezroczysty

    def _handle_selection_change(self):
        """
        Faktyczna obs≈Çuga zmiany zaznaczenia, wywo≈Çywana przez timer po up≈Çywie op√≥≈∫nienia.
        """
        debug_print("Zmiana zaznaczenia - aktualizujƒô tabelƒô zdarze≈Ñ...")
        selected_cells_data = self.table.get_data_for_selected_cells()
        debug_print(f"Zaznaczono {len(selected_cells_data)} kom√≥rek")

        is_one_cell_selected = len(selected_cells_data) == 1

        if hasattr(self, 'add_overtime_button'):
            self.add_overtime_button.setEnabled(is_one_cell_selected)
        if hasattr(self, 'shortcut_insert'):
            self.shortcut_insert.setEnabled(is_one_cell_selected)
        if hasattr(self, 'send_email_button'):
            self.send_email_button.setEnabled(bool(selected_cells_data))

        if selected_cells_data:
            events = []
            for cell_data in selected_cells_data:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    user_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                    for event in user_events:
                        local_event = self._convert_dp_event_to_local(event)
                        events.append(local_event)

            debug_print(f"Pobrano {len(events)} aktywnych zdarze≈Ñ dla zaznaczonych kom√≥rek")
            self.events_data = events
            if hasattr(self, 'events_model'):
                self.events_model.update_data(self.events_data)
                self.filter_events_table()
        else:
            self.events_data = []
            if hasattr(self, 'events_model'):
                self.events_model.update_data([])

    def on_selection_changed(self, selected=None, deselected=None):
        """
        Obs≈Çuguje zmianƒô zaznaczenia z op√≥≈∫nieniem (debouncing), aby uniknƒÖƒá
        nadmiernego wywo≈Çywania aktualizacji przy zaznaczaniu du≈ºych obszar√≥w.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # Zamiast wykonywaƒá logikƒô od razu, uruchom lub zresetuj timer.
        # W≈Ça≈õciwa obs≈Çuga zdarzenia wykona siƒô w funkcji _handle_selection_change.
        if hasattr(self, '_selection_timer'):
            self._selection_timer.stop()
            self._selection_timer.start(self._selection_debounce_delay)

    def _handle_selection_change(self):
        """
        NOWA METODA: Faktyczna obs≈Çuga zmiany zaznaczenia (wywo≈Çywana po debounce)
        """
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        self._updating_selection = True

        try:
            debug_print("Zmiana zaznaczenia - aktualizujƒô tabelƒô zdarze≈Ñ...")
            selected_cells_data = self.table.get_data_for_selected_cells()
            debug_print(f"Zaznaczono {len(selected_cells_data)} kom√≥rek")

            # Sprawd≈∫, czy zaznaczono dok≈Çadnie jednƒÖ kom√≥rkƒô
            is_one_cell_selected = len(selected_cells_data) == 1

            # Zaktualizuj stan przycisku ORAZ obiektu skr√≥tu klawiszowego
            if hasattr(self, 'add_overtime_button'):
                self.add_overtime_button.setEnabled(is_one_cell_selected)
            if hasattr(self, 'shortcut_insert'):
                self.shortcut_insert.setEnabled(is_one_cell_selected)

            # W≈ÇƒÖcz przycisk "Wy≈õlij e-mail", je≈õli cokolwiek jest zaznaczone
            if hasattr(self, 'teams_chat_button'):
                is_selection = bool(selected_cells_data)
                self.teams_chat_button.setEnabled(is_selection)
                if hasattr(self, 'shortcut_teams'):
                    self.shortcut_teams.setEnabled(is_selection)

            if hasattr(self, 'send_email_button'):
                is_selection = bool(selected_cells_data)
                self.send_email_button.setEnabled(is_selection)
                if hasattr(self, 'shortcut_outlook'):
                    self.shortcut_outlook.setEnabled(is_selection)

            if selected_cells_data and len(selected_cells_data) > 0:
                # MAMY ZAZNACZONE KOM√ìRKI - poka≈º zdarzenia
                events = []

                for cell_data in selected_cells_data:
                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')

                    if user_id and date_str:
                        # --- ZMIANA: Usuwamy przekazywanie self.import_grupa i self.import_funkcja ---
                        user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                        for event in user_events:
                            local_event = self._convert_dp_event_to_local(event)
                            events.append(local_event)

                debug_print(f"Pobrano {len(events)} aktywnych zdarze≈Ñ dla zaznaczonych kom√≥rek")

                # Zaktualizuj events_data
                self.events_data = events

                # Aktualizuj model zdarze≈Ñ
                if hasattr(self, 'events_model'):
                    self.events_model.update_data(self.events_data)

                    # WA≈ªNE: Zastosuj filtry po aktualizacji danych
                    self.filter_events_table()
            else:
                # BRAK ZAZNACZENIA - wyczy≈õƒá tabelƒô zdarze≈Ñ
                debug_print("Brak zaznaczenia - czyszczƒô tabelƒô zdarze≈Ñ")
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])

            # DODANE: Wymu≈õ od≈õwie≈ºenie widoku tabeli zdarze≈Ñ
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        finally:
            self._updating_selection = False

    def clear_events_on_startup(self):
        """
        NOWA METODA: Czy≈õci tabelƒô zdarze≈Ñ przy starcie aplikacji
        """
        debug_print("Czyszczƒô tabelƒô zdarze≈Ñ przy starcie aplikacji")

        # Wyczy≈õƒá dane zdarze≈Ñ
        self.events_data = []

        # Wyczy≈õƒá model zdarze≈Ñ je≈õli istnieje
        if hasattr(self, 'events_model') and self.events_model:
            self.events_model.update_data([])

        # Od≈õwie≈º widok tabeli zdarze≈Ñ
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

    def _convert_dp_event_to_local(self, dp_event):
        """Konwertuje format zdarzenia z DataProvider na lokalny format UI."""
        try:
            date_key = dp_event.get('date_key', dp_event.get('date', ''))
            display_date = ".".join(reversed(date_key.split("-"))) if date_key and '-' in date_key else date_key

            # U≈ºyj klucza 'UzytkownikDane' je≈õli jest dostƒôpny, w przeciwnym razie 'user_name'
            user_name = dp_event.get('UzytkownikDane') or dp_event.get('user_name', f"ID: {dp_event.get('user_id')}")

            local_event = {
                'type': dp_event.get('type', ''),
                'topic': dp_event.get('topic', ''),
                'name': dp_event.get('name', ''),
                'user_id': dp_event.get('user_id'),
                'user_name': user_name,
                'date': display_date,
                'date_key': date_key,
                'time_from': dp_event.get('time_from', ''),
                'time_to': dp_event.get('time_to', ''),
                'status': dp_event.get('status', ''),
                'DataModyfikacji': dp_event.get('DataModyfikacji', ''),
                'id': dp_event.get('id')
            }
            return local_event
        except Exception as e:
            log_error(f"B≈ÇƒÖd konwersji zdarzenia: {e}")
            return dp_event

    # def temporarily_disable_filters(self):
    #     """Tymczasowo wy≈ÇƒÖcza filtry zdarze≈Ñ aby zapewniƒá wy≈õwietlenie wszystkich danych"""
    #     # Zapamiƒôtaj obecny stan filtr√≥w
    #     self._saved_filters = {
    #         'meetings': self.meetings_checkbox.isChecked() if hasattr(self, 'meetings_checkbox') else True,
    #         'trainings': self.trainings_checkbox.isChecked() if hasattr(self, 'trainings_checkbox') else True,
    #         'overtime': self.overtime_checkbox.isChecked() if hasattr(self, 'overtime_checkbox') else True,
    #         'topic': self.topic_filter.text() if hasattr(self, 'topic_filter') else "",
    #         'name': self.name_filter.text() if hasattr(self, 'name_filter') else "",
    #         'date_from': self.date_from.date() if hasattr(self, 'date_from') else None,
    #         'date_to': self.date_to.date() if hasattr(self, 'date_to') else None
    #     }
    #
    #     # Ustaw wszystkie filtry na warto≈õci, kt√≥re pokazujƒÖ wszystkie dane
    #     if hasattr(self, 'meetings_checkbox'):
    #         self.meetings_checkbox.setChecked(True)
    #     if hasattr(self, 'trainings_checkbox'):
    #         self.trainings_checkbox.setChecked(True)
    #     if hasattr(self, 'overtime_checkbox'):
    #         self.overtime_checkbox.setChecked(True)
    #     if hasattr(self, 'topic_filter'):
    #         self.topic_filter.setText("")
    #     if hasattr(self, 'name_filter'):
    #         self.name_filter.setText("")
    #
    #     # Daty zostawiamy bez zmian, filtrowanie bƒôdzie nadpisane przez model
    #
    #     debug_print("Tymczasowo wy≈ÇƒÖczono filtry zdarze≈Ñ")

    # def restore_filters(self):
    #     """Przywraca filtry zdarze≈Ñ do ich poprzedniego stanu"""
    #     if not hasattr(self, '_saved_filters'):
    #         return
    #
    #     # Przywr√≥ƒá filtry do ich poprzedniego stanu
    #     if hasattr(self, 'meetings_checkbox') and 'meetings' in self._saved_filters:
    #         self.meetings_checkbox.setChecked(self._saved_filters['meetings'])
    #     if hasattr(self, 'trainings_checkbox') and 'trainings' in self._saved_filters:
    #         self.trainings_checkbox.setChecked(self._saved_filters['trainings'])
    #     if hasattr(self, 'overtime_checkbox') and 'overtime' in self._saved_filters:
    #         self.overtime_checkbox.setChecked(self._saved_filters['overtime'])
    #     if hasattr(self, 'topic_filter') and 'topic' in self._saved_filters:
    #         self.topic_filter.setText(self._saved_filters['topic'])
    #     if hasattr(self, 'name_filter') and 'name' in self._saved_filters:
    #         self.name_filter.setText(self._saved_filters['name'])
    #
    #     # Nie przywracamy dat, aby zapewniƒá sp√≥jno≈õƒá z zaznaczonymi kom√≥rkami
    #
    #     debug_print("Przywr√≥cono filtry zdarze≈Ñ")
    #
    #     # Wymu≈õ od≈õwie≈ºenie z nowymi filtrami
    #     self.filter_events_table()

    def send_email_to_selection(self):
        """Zbiera dane zaznaczonych pracownik√≥w i otwiera okno nowej wiadomo≈õci w Outlook."""
        if not self.table or not self.table.employees_view.selectionModel():
            return

        selected_rows = self.table.get_selected_rows()
        if not selected_rows:
            QMessageBox.warning(self, "Brak zaznaczenia", "Proszƒô zaznaczyƒá przynajmniej jednego pracownika.")
            return

        recipients = []
        missing_email_users = []
        for row_index in selected_rows:
            key = self.schedule_model._keys[row_index]
            full_user_data = self.processed_data.get(key, {})
            email = full_user_data.get('email', '').strip()
            if email:
                recipients.append(email)
            else:
                missing_email_users.append(full_user_data.get('uzytkownik_dane', 'Nieznany'))

        if not recipients:
            QMessageBox.warning(self, "Brak danych",
                                "≈ªaden z zaznaczonych pracownik√≥w nie ma przypisanego adresu e-mail.")
            return

        # Wywo≈Çaj funkcjƒô z outlook_connector z pustym tematem i tre≈õciƒÖ
        success, message = create_outlook_email(recipients=recipients)

        if not success:
            QMessageBox.critical(self, "B≈ÇƒÖd Outlook", message)
        elif missing_email_users:
            QMessageBox.information(self, "Informacja",
                                    "Pominiƒôto nastƒôpujƒÖcych pracownik√≥w z powodu braku adresu e-mail w bazie:<br><br>- " + "<br>- ".join(
                                        missing_email_users))

    def open_teams_chat_for_selection(self):
        """Zbiera dane zaznaczonych pracownik√≥w i otwiera czat w Microsoft Teams."""
        if not self.table or not self.table.employees_view.selectionModel():
            return

        selected_rows = self.table.get_selected_rows()
        if not selected_rows:
            QMessageBox.warning(self, "Brak zaznaczenia", "Proszƒô zaznaczyƒá przynajmniej jednego pracownika.")
            return

        recipient_emails = []
        missing_email_users = []
        for row_index in selected_rows:
            key = self.schedule_model._keys[row_index]
            full_user_data = self.processed_data.get(key, {})
            email = full_user_data.get('email', '').strip()
            if email:
                recipient_emails.append(email)
            else:
                missing_email_users.append(full_user_data.get('uzytkownik_dane', 'Nieznany'))

        if not recipient_emails:
            QMessageBox.warning(self, "Brak danych",
                                "≈ªaden z zaznaczonych pracownik√≥w nie ma przypisanego adresu e-mail.")
            return

        success, message = open_teams_chat(recipient_emails=recipient_emails)
        if not success:
            QMessageBox.critical(self, "B≈ÇƒÖd Microsoft Teams", message)
        elif missing_email_users:
            QMessageBox.information(self, "Informacja",
                                    "Pominiƒôto nastƒôpujƒÖcych pracownik√≥w z powodu braku adresu e-mail w bazie:<br><br>- " + "<br>- ".join(
                                        missing_email_users))

    # def standardize_date(self, date_obj):
    #     """
    #     Standaryzuje format daty do 'YYYY-MM-DD' dla por√≥wna≈Ñ
    #     """
    #     if not date_obj:
    #         return ''
    #
    #     # Je≈õli to ju≈º string, wyciƒÖgnij tylko datƒô
    #     if isinstance(date_obj, str):
    #         # Obs≈Çuga r√≥≈ºnych format√≥w
    #         if 'T' in date_obj:  # Format ISO 'YYYY-MM-DDThh:mm:ss'
    #             return date_obj.split('T')[0]
    #         elif ' ' in date_obj:  # Format 'YYYY-MM-DD hh:mm:ss'
    #             return date_obj.split(' ')[0]
    #         elif len(date_obj) == 10 and date_obj.count('-') == 2:  # Format 'YYYY-MM-DD'
    #             return date_obj
    #         # Je≈õli nie dopasowano do ≈ºadnego formatu, zwr√≥ƒá oryginalny string
    #         return date_obj
    #
    #     # Je≈õli to obiekt datetime, skonwertuj na string
    #     if hasattr(date_obj, 'strftime'):
    #         return date_obj.strftime('%Y-%m-%d')
    #
    #     # W przypadku nieznanego typu, zwr√≥ƒá pusty string
    #     return ''

    # def diagnose_application_state(self):
    #     """Wykonuje pe≈ÇnƒÖ diagnostykƒô stanu aplikacji i wy≈õwietla szczeg√≥≈Çowe informacje"""
    #     try:
    #         debug_print("<br>===== DIAGNOSTYKA STANU APLIKACJI =====")
    #
    #         # 1. Sprawd≈∫ tabele i dane
    #         debug_print("<br>--- TABELA GRAFIKU ---")
    #         debug_print(f"Liczba wierszy: {self.table.rowCount()}")
    #         debug_print(f"Liczba kolumn: {self.table.columnCount()}")
    #
    #         # Sprawd≈∫ pierwsze 3 wiersze i kolumny dla przyk≈Çadu
    #         debug_print("<br>Przyk≈Çadowe kom√≥rki z tabeli grafiku:")
    #         for row in range(min(3, self.table.rowCount())):
    #             for col in range(min(6, self.table.columnCount())):
    #                 item = self.table.item(row, col)
    #                 if item:
    #                     debug_print(f"[{row},{col}] Tekst: {item.text()}")
    #                     user_role_data = item.data(Qt.UserRole)
    #                     user_role_2 = item.data(Qt.UserRole + 2)
    #                     user_role_3 = item.data(Qt.UserRole + 3)
    #                     debug_print(
    #                         f"  UserRole: {type(user_role_data)}, UserRole+2: {user_role_2}, UserRole+3: {user_role_3}")
    #                     if isinstance(user_role_data, dict):
    #                         debug_print(f"  Zawarto≈õƒá: {user_role_data}")
    #                 else:
    #                     debug_print(f"[{row},{col}] Brak elementu")
    #
    #         debug_print("<br>--- TABELA ZDARZE≈É ---")
    #         debug_print(f"Liczba wierszy: {self.events_table.rowCount()}")
    #         debug_print(f"Liczba kolumn: {self.events_table.columnCount()}")
    #
    #         # Sprawd≈∫ zawarto≈õƒá events_data
    #         debug_print(
    #             f"<br>Liczba zdarze≈Ñ w events_data: {len(self.events_data) if hasattr(self, 'events_data') else 'Brak'}")
    #         if hasattr(self, 'events_data') and self.events_data:
    #             debug_print("Pierwsze zdarzenie:")
    #             for key, value in self.events_data[0].items():
    #                 debug_print(f"  {key}: {value}")
    #
    #         # Sprawd≈∫ pierwsze 3 wiersze tabeli zdarze≈Ñ
    #         debug_print("<br>Przyk≈Çadowe wiersze z tabeli zdarze≈Ñ:")
    #         for row in range(min(3, self.events_table.rowCount())):
    #             row_data = []
    #             for col in range(self.events_table.columnCount() - 1):  # Pomijamy ostatniƒÖ kolumnƒô z przyciskami
    #                 item = self.events_table.item(row, col)
    #                 if item:
    #                     row_data.append(f"{col}:{item.text()}")
    #             debug_print(f"Wiersz {row}: {', '.join(row_data)}")
    #
    #         # 2. Sprawd≈∫ delegaty i style
    #         debug_print("<br>--- DELEGATY I STYLE ---")
    #         item_delegate = self.table.itemDelegate()
    #         debug_print(f"Delegat tabeli grafiku: {item_delegate.__class__.__name__}")
    #         if isinstance(item_delegate, OvertimeItemDelegate):
    #             debug_print("  Delegat OvertimeItemDelegate poprawnie przypisany")
    #         else:
    #             debug_print("  UWAGA: Delegat OvertimeItemDelegate nie jest przypisany!")
    #
    #         # 3. Sprawd≈∫ filtrowanie danych
    #         debug_print("<br>--- FILTROWANIE DANYCH ---")
    #         if hasattr(self, 'events_data') and self.events_data:
    #             debug_print(f"Liczba zdarze≈Ñ przed filtrowaniem: {len(self.events_data)}")
    #             # Sprawd≈∫, czy metoda filter_events_table jest wywo≈Çywana
    #             debug_print("Spr√≥buj wykonaƒá filter_events_table:")
    #             try:
    #                 self.filter_events_table()
    #                 debug_print("  Metoda filter_events_table wykonana bez b≈Çƒôd√≥w")
    #             except Exception as e:
    #                 debug_print(f"  B≈ÅƒÑD podczas wykonywania filter_events_table: {e}")
    #
    #         debug_print("<br>===== KONIEC DIAGNOSTYKI =====<br>")
    #
    #     except Exception as e:
    #         debug_print(f"B≈ÅƒÑD podczas diagnostyki: {e}")
    #         import traceback
    #         traceback.print_exc()

    # def _get_current_event_filter_params(self):
    #     """
    #     Pobiera bie≈ºƒÖce parametry filtrowania zdarze≈Ñ.
    #
    #     Returns:
    #         dict: Parametry filtrowania
    #     """
    #     filter_params = {}
    #
    #     # Dodaj filtr typ√≥w zdarze≈Ñ
    #     allowed_types = []
    #     if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
    #         allowed_types.append('Spotkanie')
    #     if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
    #         allowed_types.append('Szkolenie')
    #     if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
    #         allowed_types.append('Nadgodziny')
    #
    #     if allowed_types:
    #         filter_params['allowed_types'] = allowed_types
    #
    #     # Dodaj filtry tematu i nazwy
    #     topic_filter = self.topic_filter.text().lower() if hasattr(self,
    #                                                                'topic_filter') and self.topic_filter.text() else None
    #     name_filter = self.name_filter.text().lower() if hasattr(self,
    #                                                              'name_filter') and self.name_filter.text() else None
    #
    #     if topic_filter:
    #         filter_params['topic'] = topic_filter
    #     if name_filter:
    #         filter_params['name'] = name_filter
    #
    #     # Dodaj filtry zakresu dat
    #     date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
    #     date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None
    #
    #     if date_from_str:
    #         filter_params['date_from'] = date_from_str
    #     if date_to_str:
    #         filter_params['date_to'] = date_to_str
    #
    #     return filter_params

    def _get_cell_data_for_user_date_pairs(self, user_date_pairs: list) -> list:
        """
        Na podstawie listy par (user_id, date_str) odnajduje i zwraca
        pe≈Çne dane kom√≥rek z modelu grafiku.
        """
        if not self.schedule_model or not user_date_pairs:
            return []

        cells_data_to_return = []
        user_row_map = {str(key[3]): idx for idx, key in enumerate(self.schedule_model._keys)}

        for user_id, date_str in user_date_pairs:
            row = user_row_map.get(str(user_id))
            if row is not None:
                try:
                    day = int(date_str.split('-')[2])
                    col_offset = len(self.schedule_model.get_visible_columns())
                    col = col_offset + day - 1

                    index = self.schedule_model.index(row, col)

                    # --- ZMIANA: Poprawne odwo≈Çanie do ROLE_DATA ---
                    cell_data = self.schedule_model.data(index, ROLE_DATA)

                    if isinstance(cell_data, dict):
                        cells_data_to_return.append(cell_data)
                except (ValueError, IndexError) as e:
                    log_warning(f"Nie uda≈Ço siƒô znale≈∫ƒá danych dla kom√≥rki ({user_id}, {date_str}): {e}")

        return cells_data_to_return

    def cancel_delegations(self, ask_for_confirmation: bool = True):
        """
        Inicjuje proces odwo≈Çywania delegacji. Wy≈õwietla okno potwierdzenia
        tylko wtedy, gdy jest to akcja bezpo≈õrednia (ask_for_confirmation=True).
        """
        debug_print(f"--- cancel_delegations: FUNKCJA WYWO≈ÅANA (ask_for_confirmation={ask_for_confirmation}) ---")

        selected_cells_data = self.get_selected_cells_data()
        if not self._can_modify_cells(selected_cells_data):
            return

        user_date_pairs = list(set((cell.get('uzytkownik_id'), cell.get('date_str')) for cell in selected_cells_data if
                                   cell.get('uzytkownik_id') and cell.get('date_str')))
        if not user_date_pairs:
            if ask_for_confirmation:  # Poka≈º b≈ÇƒÖd tylko, gdy to akcja bezpo≈õrednia
                QMessageBox.warning(self, "Brak zaznaczenia", "Proszƒô zaznaczyƒá kom√≥rki do analizy.", QMessageBox.Ok)
            return

        events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        if not events_to_cancel:
            if ask_for_confirmation:  # Poka≈º informacjƒô tylko, gdy to akcja bezpo≈õrednia
                QMessageBox.information(self, "Brak delegacji", "Nie znaleziono aktywnych delegacji do odwo≈Çania.",
                                        QMessageBox.Ok)
            return

        # Krok 1: Wy≈õwietlaj dialog tylko, gdy jest to wymagane
        if ask_for_confirmation:
            grouped_events = self._group_events_by_user_date(events_to_cancel)
            delegations_info = self._prepare_delegations_description(grouped_events)
            confirm_message = f"Czy na pewno chcesz odwo≈Çaƒá nastƒôpujƒÖce delegacje?<br>{delegations_info}"

            reply = show_confirmation_dialog(self, "Potwierdzenie odwo≈Çania delegacji", confirm_message)
            if reply != QMessageBox.Yes:
                return

        # Krok 2: Wykonaj operacje
        try:
            self._state_to_restore = self._save_view_state()

            trainings_to_clear = [evt for evt in events_to_cancel if evt.get('type') == 'Szkolenie']
            if trainings_to_clear:
                pairs_for_trainings = list(
                    set((e.get('user_id'), e.get('date_key', e.get('date'))) for e in trainings_to_clear))
                cells_data = self._get_cell_data_for_user_date_pairs(pairs_for_trainings)
                cells_with_s = [cell for cell in cells_data if
                                (parse_symbol(cell.get('symbol', '')).get('special_symbol') or '').upper() == 'S']
                if cells_with_s:
                    self._remove_s_symbol_directly(cells_with_s)

            self.delegation_canceler.start_cancellation(events_to_cancel)

            # Logika sukcesu/b≈Çƒôdu jest teraz wewnƒÖtrz DelegationCanceler._on_finished
            if ask_for_confirmation:
                if ask_for_confirmation:  # Poka≈º podsumowanie tylko dla akcji bezpo≈õredniej
                    pass  # Wiadomo≈õƒá zostanie pokazana przez DelegationCanceler
            elif ask_for_confirmation:
                QMessageBox.warning(self, "Brak zmian", "Nie uda≈Ço siƒô odwo≈Çaƒá ≈ºadnej delegacji.", QMessageBox.Ok)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas odwo≈Çywania delegacji: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç krytyczny b≈ÇƒÖd: {str(e)}", QMessageBox.Ok)

    def delete_events_for_cells(self, cells_data: list):
        """
        Wyszukuje wszystkie zdarzenia dla podanych kom√≥rek, prosi o potwierdzenie
        i odwo≈Çuje je. Zwraca True, je≈õli u≈ºytkownik potwierdzi≈Ç usuniƒôcie.
        """
        if not cells_data:
            return False

        # Zbierz unikalne pary (u≈ºytkownik, data) z zaznaczonych kom√≥rek
        user_date_pairs = set()
        for cell_data in cells_data:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if user_id and date_str:
                user_date_pairs.add((user_id, date_str))

        # Znajd≈∫ wszystkie zdarzenia do odwo≈Çania dla tych par
        events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        if not events_to_cancel:
            # Je≈õli nie ma zdarze≈Ñ do usuniƒôcia, nic wiƒôcej nie r√≥b
            return False

        # Przygotuj i poka≈º okno dialogowe z potwierdzeniem
        grouped_events = self._group_events_by_user_date(events_to_cancel)
        delegations_info = self._prepare_delegations_description(grouped_events)

        reply = QMessageBox.question(
            self,
            "Potwierdzenie usuniƒôcia zdarze≈Ñ",
            f"Wstawienie tego symbolu wymaga odwo≈Çania istniejƒÖcych zdarze≈Ñ (spotka≈Ñ, nadgodzin itp.).<br><br>{delegations_info}<br>Czy chcesz kontynuowaƒá?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply == QMessageBox.Yes:
            # Je≈õli u≈ºytkownik siƒô zgodzi, odwo≈Çaj delegacje
            self.delegation_canceler.start_cancellation(events_to_cancel)
            return True
        else:
            # Je≈õli u≈ºytkownik anuluje, zwr√≥ƒá informacjƒô o tym
            self.statusBar().showMessage("Operacja anulowana przez u≈ºytkownika.", 3000)
            return False

    def get_data_from_model(self, row, col):
        """
        Pobiera dane z kom√≥rki modelu na podstawie wierszy i kolumn.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny

        Returns:
            dict: Dane kom√≥rki lub pusty s≈Çownik
        """
        if not hasattr(self, 'schedule_model'):
            return {}

        # Pobierz dane z modelu
        index = self.schedule_model.index(row, col)
        cell_data = self.schedule_model.data(index, Qt.UserRole)

        # Upewnij siƒô, ≈ºe dane sƒÖ s≈Çownikiem
        if not isinstance(cell_data, dict):
            return {}

        return cell_data

    def get_selected_cells_data(self):
        """
        Pobiera dane dla zaznaczonych kom√≥rek z modelu.

        Returns:
            list: Lista danych zaznaczonych kom√≥rek
        """
        if not hasattr(self, 'table') or not self.table:
            return []

        # Deleguj do metody w SplitTableView, kt√≥ra ju≈º obs≈Çuguje model
        return self.table.get_data_for_selected_cells()

    # def update_model_after_data_change(self, user_id, date_str):
    #     """
    #     Aktualizuje dane w modelu po zmianach w bazie danych.
    #
    #     Args:
    #         user_id: ID u≈ºytkownika
    #         date_str: Data w formacie YYYY-MM-DD
    #     """
    #     if not user_id or not date_str:
    #         return
    #
    #     # Pobierz rok i miesiƒÖc z daty
    #     if date_str.count('-') != 2:
    #         return
    #
    #     year, month, _ = date_str.split('-')
    #     try:
    #         year = int(year)
    #         month = int(month)
    #     except ValueError:
    #         return
    #
    #     # Pobierz aktualne dane z DataProvider - wymu≈õ od≈õwie≈ºenie cache
    #     self.data_provider.clear_cache()
    #     schedule_data = self.data_provider.get_schedule_data(year, month, use_cache=False)
    #
    #     # Aktualizuj model
    #     if schedule_data and hasattr(self, 'schedule_model'):
    #         # Aktualizuj model bezpo≈õrednio
    #         self.schedule_model.update_data(schedule_data, year, month)
    #
    #         # Zaktualizuj przefiltrowane dane
    #         filtered_data = self.filter_processed_data()
    #         self.schedule_model.update_filtered_data(filtered_data)
    #
    #         # Od≈õwie≈º widok
    #         if hasattr(self, 'table'):
    #             self.table.update()

    # def setup_model_connections(self):
    #     """
    #     ≈ÅƒÖczy sygna≈Çy modeli z obs≈ÇugƒÖ interfejsu u≈ºytkownika.
    #     """
    #     # Po≈ÇƒÖcz zmiany w modelach z aktualizacjƒÖ interfejsu
    #     if hasattr(self, 'schedule_model'):
    #         self.schedule_model.dataChanged.connect(self.on_schedule_data_changed)
    #
    #     if hasattr(self, 'events_model'):
    #         self.events_model.dataChanged.connect(self.on_events_data_changed)

    # def on_schedule_data_changed(self, topLeft, bottomRight):
    #     """
    #     Obs≈Çuguje zmianƒô danych w modelu grafiku.
    #
    #     Args:
    #         topLeft: Indeks g√≥rnego lewego rogu zmienionych danych
    #         bottomRight: Indeks dolnego prawego rogu zmienionych danych
    #     """
    #     # Od≈õwie≈º widok
    #     if hasattr(self, 'table'):
    #         self.table.update()
    #
    #     # Je≈õli zmieni≈Ço siƒô zaznaczenie, zaktualizuj tabelƒô zdarze≈Ñ
    #     if self.table.selection_changed.receivers() > 0:
    #         selected_rows = self.table.get_selected_rows()
    #         if selected_rows:
    #             self.on_selection_changed()

    # def on_events_data_changed(self, topLeft, bottomRight):
    #     """
    #     Obs≈Çuguje zmianƒô danych w modelu zdarze≈Ñ.
    #
    #     Args:
    #         topLeft: Indeks g√≥rnego lewego rogu zmienionych danych
    #         bottomRight: Indeks dolnego prawego rogu zmienionych danych
    #     """
    #     # Od≈õwie≈º tabelƒô zdarze≈Ñ
    #     if hasattr(self, 'events_table'):
    #         self.events_table.viewport().update()

    # def get_selected_schedule_cells(self):
    #     """Zwraca listƒô zaznaczonych kom√≥rek z siatki grafiku"""
    #     selected_cells = []
    #     selected_ranges = self.table.selectedRanges()
    #
    #     for range_item in selected_ranges:
    #         for row in range(range_item.topRow(), range_item.bottomRow() + 1):
    #             for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
    #                 # Sprawd≈∫ czy to kom√≥rka z grafikiem
    #                 if col >= 3:
    #                     # Pobierz element tabeli
    #                     cell_item = self.table.item(row, col)
    #                     if not cell_item:
    #                         continue
    #
    #                     # Pobierz dane z kom√≥rki
    #                     cell_data = self.get_cell_data(cell_item)
    #                     if not cell_data:
    #                         continue
    #
    #                     # Dodaj dane do listy wybranych kom√≥rek
    #                     selected_cells.append(cell_data)
    #
    #     return selected_cells

    def group_cells_by_user_and_day(self, cells):
        """Grupuje kom√≥rki wed≈Çug u≈ºytkownika i dnia dla ≈Çatwiejszej edycji"""
        grouped = {}
        for cell in cells:
            # ZMIANA: Dostosuj do nowej struktury danych z modelu
            user_id = cell.get('uzytkownik_id')  # Zmieniono z 'user_id'
            date_str = cell.get('date_str')  # Zmieniono z 'date'

            if not user_id or not date_str:
                continue

            if user_id not in grouped:
                grouped[user_id] = {}

            if date_str not in grouped[user_id]:
                grouped[user_id][date_str] = []

            grouped[user_id][date_str].append(cell)

        return grouped

    def delete_event(self, event_id, event_type):
        """
        Odwo≈Çuje pojedyncze zdarzenie z tabeli zdarze≈Ñ. Zawsze prosi o potwierdzenie.
        """
        # --- POCZƒÑTEK LOGOWANIA DIAGNOSTYCZNEGO ---
        debug_print(
            f"--- delete_event: Pr√≥ba odwo≈Çania zdarzenia ID: {event_id} (typ: {type(event_id)}), Typ: {event_type} ---")
        # --- KONIEC LOGOWANIA DIAGNOSTYCZNEGO ---

        # Krok 1: Zawsze wy≈õwietlaj dialog potwierdzenia.
        reply = show_confirmation_dialog(self, "Potwierdzenie",
                                         f"Czy na pewno chcesz odwo≈Çaƒá {event_type.lower()} o ID {event_id}?",
                                         )
        if reply != QMessageBox.Yes:
            return

        # Krok 2: Zbierz dane tylko dla tego jednego zdarzenia.
        event_to_cancel = next(
            (e for e in (self.all_events_data or []) if
             str(e.get('id')) == str(event_id) and e.get('type') == event_type), None)
        if not event_to_cancel:
            # --- POCZƒÑTEK LOGOWANIA DIAGNOSTYCZNEGO ---
            debug_print(f"B≈ÅƒÑD: Nie znaleziono zdarzenia ID: {event_id} w self.all_events_data.")
            if hasattr(self, 'all_events_data') and self.all_events_data:
                debug_print("Ostatnie 5 zdarze≈Ñ w `all_events_data` do por√≥wnania:")
                for event in self.all_events_data[-5:]:
                    debug_print(f"  -> ID: {event.get('id')} (typ: {type(event.get('id'))}), Typ: {event.get('type')}")
            # --- KONIEC LOGOWANIA DIAGNOSTYCZNEGO ---
            QMessageBox.warning(self, "B≈ÇƒÖd", "Nie mo≈ºna odnale≈∫ƒá zdarzenia do odwo≈Çania.")
            return

        # Krok 3: Wykonaj operacje.
        try:
            view_state = self._save_view_state()

            user_id = event_to_cancel.get('user_id')
            date_str = event_to_cancel.get('date_key')

            if event_type == 'Szkolenie':
                cell_data = self._get_cell_data_for_user_date_pairs([(user_id, date_str)])
                if cell_data and (
                        parse_symbol(cell_data[0].get('symbol', '')).get('special_symbol') or '').upper() == 'S':
                    self._remove_s_symbol_directly(cell_data)

            self.delegation_canceler.start_cancellation([event_to_cancel])

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas usuwania zdarzenia: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas usuwania zdarzenia: {str(e)}", QMessageBox.Ok)

    def _update_multiple_overtime_locations(self, location_changes):
        """
        Aktualizuje lokalizacjƒô dla wielu wpis√≥w nadgodzin, ka≈ºdy z innƒÖ warto≈õciƒÖ.
        WERSJA POPRAWIONA: Aktualizuje r√≥wnie≈º nazwƒô zdarzenia w interfejsie.
        """
        if not location_changes:
            return True  # Brak zmian do wykonania to nie b≈ÇƒÖd

        location_map = {'h': 1, 's': 3, 'p': 2}

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            for event_id, new_location_code in location_changes:
                location_value = location_map.get(new_location_code)
                if location_value is None:
                    log_warning(
                        f"Pominiƒôto aktualizacjƒô nadgodzin dla ID {event_id} z powodu nieznanego kodu lokalizacji: {new_location_code}")
                    continue

                query = f"UPDATE {SQL_OBJECTS['nadgodziny']} SET Lokalizacja = ? WHERE Id = ?"
                params = (location_value, event_id)
                debug_print(f"Aktualizujƒô lokalizacjƒô nadgodzin: ID={event_id}, nowa lokalizacja={location_value}")
                cursor.execute(query, params)

            conn.commit()
            conn.close()

            # --- NOWA LOGIKA: Aktualizacja nazwy w modelu danych po pomy≈õlnym zapisie w bazie ---

            # Mapa kod√≥w na pe≈Çne nazwy do wy≈õwietlenia
            location_display_map = {'h': 'Home Office', 's': 'SBC', 'p': 'Przystanek'}

            # Stw√≥rz s≈Çownik zmian dla szybszego wyszukiwania
            changes_map = dict(location_changes)

            # Zaktualizuj g≈Ç√≥wnƒÖ listƒô wszystkich zdarze≈Ñ
            for event in self.all_events_data:
                if event.get('id') in changes_map and event.get('type') == 'Nadgodziny':
                    new_loc_code = changes_map[event['id']]
                    new_loc_name = location_display_map.get(new_loc_code, 'N/A')
                    event['name'] = f"Nadgodziny {new_loc_name}"

            # Zaktualizuj listƒô zdarze≈Ñ aktualnie widocznƒÖ w tabeli
            for event in self.events_data:
                if event.get('id') in changes_map and event.get('type') == 'Nadgodziny':
                    new_loc_code = changes_map[event['id']]
                    new_loc_name = location_display_map.get(new_loc_code, 'N/A')
                    event['name'] = f"Nadgodziny {new_loc_name}"

            # Od≈õwie≈º model tabeli zdarze≈Ñ, aby UI pokaza≈Ç zmiany
            if hasattr(self, 'events_model'):
                self.events_model.update_data(self.events_data)

            debug_print(f"Zaktualizowano {len(location_changes)} wpis√≥w nadgodzin w interfejsie.")
            # --- KONIEC NOWEJ LOGIKI ---

            return True

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji wielu lokalizacji nadgodzin: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd Bazy Danych", f"Nie uda≈Ço siƒô zaktualizowaƒá lokalizacji nadgodzin:<br>{e}")
            return False

    def _update_overtime_icon_single(self, user_id, date_str, year, month):
        """
        NOWA METODA: Aktualizuje ikonƒô nadgodzin bez wp≈Çywania na cache innych danych.
        """
        try:
            # 1. Aktualizuj bezpo≈õrednio w modelu grafiku
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonƒô nadgodzin w modelu dla ({user_id}, {date_str})")

            # 2. Wyczy≈õƒá tylko cache ikon dla tej konkretnej kom√≥rki w DataProvider
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla kom√≥rki ({user_id}, {date_str})")

            # 3. Od≈õwie≈º widok grafiku
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji ikony nadgodzin: {e}")

    def _handle_specific_icons_refresh(self, data_type, year, month):
        """Obs≈Çuguje sygna≈Ç o zmianie danych ikon z DataProvider i od≈õwie≈ºa model."""
        if data_type == "icons":
            current_data = self.date_combo.currentData()
            if current_data and current_data == (year, month):
                debug_print(f"[DB] Otrzymano sygna≈Ç od≈õwie≈ºenia ikon dla {year}-{month}. Od≈õwie≈ºam model grafiku.")

                fresh_processed_data = self.data_provider.get_processed_data(
                    year, month, self.import_grupa, self.import_funkcja
                )
                self.processed_data = fresh_processed_data

                # Zamiast wywo≈Çywaƒá filter_data(), kt√≥re powoduje problemy,
                # rƒôcznie przekazujemy przefiltrowane dane do modelu.
                filtered_data = self.filter_processed_data()
                self.schedule_model.update_filtered_data(filtered_data)

                debug_print(
                    f"[DB] W _handle_specific_icons_refresh, sprawdzam flagƒô self._state_to_restore. Jest ona: {'USTAWIONA' if self._state_to_restore else 'PUSTA (None)'}")
                if self._state_to_restore:
                    # Je≈õli istnieje stan do przywr√≥cenia, odtwarzamy go.
                    # Ta funkcja sama zajmie siƒô przywr√≥ceniem sortowania i zaznaczenia.
                    self._restore_view_state(self._state_to_restore)
                    self._state_to_restore = None  # Wyczy≈õƒá flagƒô po u≈ºyciu
                else:
                    # Je≈õli nie ma stanu do przywr√≥cenia, stosujemy domy≈õlne sortowanie z ustawie≈Ñ.
                    debug_print("[DB] Brak stanu do przywr√≥cenia, aplikujƒô sortowanie niestandardowe.")
                    self.apply_custom_sort()

                # Od≈õwie≈ºamy tabelƒô zdarze≈Ñ na samym ko≈Ñcu, gdy zaznaczenie jest ju≈º poprawnie przywr√≥cone.
                self.on_selection_changed()

    def call_add_overtime_procedure_fixed(self, user_id, year, month, start_datetime_obj, original_date_str, hours,
                                          settlement_date, is_overdue, overtime_type, location,
                                          nr_kadrowy):
        """
        Dodaje nadgodziny i zapewnia natychmiastowƒÖ, niezawodnƒÖ aktualizacjƒô
        tabeli zdarze≈Ñ oraz ikony w grafiku.
        """
        try:
            # Krok 1: Dodanie rekordu do bazy danych
            location_map = {'h': 1, 'p': 2, 's': 3}
            location_value = location_map.get(location, 1)
            param_value = 1 if overtime_type == 'odpracowanie' else None
            odebrane_value = 1 if overtime_type == 'odbi√≥r' else 0

            end_datetime_obj = start_datetime_obj + timedelta(hours=float(hours))
            date_str_for_db = original_date_str  # U≈ºywamy oryginalnej daty z kom√≥rki

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            params = [
                nr_kadrowy, year, month, date_str_for_db, start_datetime_obj, end_datetime_obj,
                settlement_date, is_overdue, odebrane_value, location_value,
                param_value
            ]
            sql = f"{{CALL {SQL_OBJECTS['p_nadgodzinywstawienie']} ({', '.join(['?'] * len(params))})}}"
            import pyodbc
            cursor.execute(sql, params)

            # --- NOWA, OSTATECZNA LOGIKA: Niezawodna analiza wynik√≥w z procedury ---
            success = True
            message = "Nadgodziny zosta≈Çy pomy≈õlnie dodane."
            all_results = []

            # Pƒôtla do odczytywania WSZYSTKICH zestaw√≥w wynik√≥w zwr√≥conych przez procedurƒô
            while True:
                try:
                    rows = cursor.fetchall()
                    if rows:
                        all_results.extend(rows)
                    if not cursor.nextset():
                        break
                except pyodbc.ProgrammingError:
                    # Koniec zestaw√≥w wynik√≥w
                    break

            # Przetwarzanie zebranych wynik√≥w
            for row in all_results:
                if row and len(row) > 0 and row[0] is not None:
                    raw_value = row[0]
                    # Je≈õli to tekst, jest to komunikat o b≈Çƒôdzie
                    if isinstance(raw_value, str):
                        success = False
                        message = raw_value
                        break  # Przerywamy, bo wystƒÖpi≈Ç b≈ÇƒÖd

            conn.commit()
            conn.close()

            if success:
                # Krok 2: Rejestracja w≈Çasnej zmiany i uniewa≈ºnienie cache
                self._update_modification_date()

                # --- POCZƒÑTEK POPRAWKI 2.0 ---
                # Krok 2a: Niezawodne wyodrƒôbnienie ID nowego rekordu i rƒôczne dodanie go do
                # g≈Ç√≥wnej listy `all_events_data`, aby by≈Ç od razu dostƒôpny dla operacji "Odwo≈Çaj".
                if hasattr(self, 'all_events_data'):
                    try:
                        # Pr√≥bujemy wyodrƒôbniƒá liczbƒô z komunikatu zwrotnego
                        new_event_id = int(str(message).strip())
                        new_event_data = self._fetch_specific_event_from_db(year, month, new_event_id, 'Nadgodziny')
                        if new_event_data:
                            local_event = self._convert_dp_event_to_local(new_event_data)
                            self.all_events_data.append(local_event)
                            debug_print(f"Rƒôcznie dodano nowe nadgodziny (ID: {new_event_id}) do self.all_events_data.")
                    except (ValueError, TypeError) as e:
                        log_warning(f"Nie uda≈Ço siƒô wyodrƒôbniƒá ID nadgodzin z komunikatu: '{message}'. B≈ÇƒÖd: {e}")

                # --- KONIEC POPRAWKI 2.0 ---

                self.data_provider.invalidate_complete_cache_for_pairs([(user_id, original_date_str)])

                # Krok 3: Od≈õwie≈ºenie dolnej tabeli zdarze≈Ñ
                self.on_selection_changed()

            return {"success": success, "message": message}

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas dodawania nadgodzin: {e}", exception=e)
            return {
                "success": False,
                "message": f"WystƒÖpi≈Ç b≈ÇƒÖd podczas dodawania nadgodzin: {str(e)}"
            }

    def _refresh_data_after_overtime_addition(self, new_id, user_id, date_str, year, month):
        """
        NOWA METODA: Od≈õwie≈ºa dane z bazy po dodaniu nadgodzin
        """
        try:
            debug_print(f"Od≈õwie≈ºam dane po dodaniu nadgodzin ID={new_id}")

            # 1. POBIERZ NOWE ZDARZENIE Z BAZY DANYCH
            new_event = self._fetch_specific_event_from_db(year, month, new_id, 'Nadgodziny')

            if not new_event:
                log_error(f"Nie znaleziono dodanych nadgodzin o ID {new_id} w bazie danych")
                return

            debug_print(f"Pobrano nowe zdarzenie z bazy: {new_event}")

            # 2. AKTUALIZUJ CACHE DATAPROVIDER
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]

                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data")

                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []

                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in
                           container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache")

                # Aktualizuj processed_data - ustaw ikonƒô nadgodzin
                try:
                    day = int(date_str.split('-')[2])
                    for key, user_data in container.processed_data_base.items():
                        if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonƒô nadgodzin w processed_data")
                            break
                except Exception as e:
                    log_error(f"B≈ÇƒÖd aktualizacji processed_data: {e}")

            # 3. AKTUALIZUJ LOKALNE DANE
            # Konwertuj na lokalny format
            local_event = self._convert_dp_event_to_local(new_event)

            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(local_event)
                    debug_print(f"Dodano nadgodziny do all_events_data")

            # 4. AKTUALIZUJ events_data TYLKO JE≈öLI KOM√ìRKA JEST ZAZNACZONA
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )

                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(local_event)
                        debug_print(f"Dodano nadgodziny do events_data")

                        # Aktualizuj model zdarze≈Ñ
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # 5. AKTUALIZUJ MODEL GRAFIKU
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_overtime=True
                )
                debug_print(f"Zaktualizowano ikony w schedule_model")

            # 6. WYCZY≈öƒÜ CACHE IKON
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon")

            # 7. OD≈öWIE≈ª WIDOKI
            if hasattr(self, 'table'):
                if hasattr(self.table, 'schedule_view'):
                    self.table.schedule_view.viewport().update()

            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

            debug_print(f"=== OD≈öWIE≈ªENIE DANYCH ZAKO≈ÉCZONE ===")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas od≈õwie≈ºania danych: {e}")
            import traceback
            traceback.print_exc()

    def _fetch_specific_event_from_db(self, year: int, month: int, event_id: int, event_type: str) -> dict | None:
        """
        Pobiera dane pojedynczego, konkretnego zdarzenia z bazy danych.
        U≈ºywane do od≈õwie≈ºenia stanu po dodaniu nowego rekordu.
        """
        conn = None
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # U≈ºywamy istniejƒÖcej funkcji, ale filtrujemy po ID i typie
            query = f"SELECT * FROM {SQL_OBJECTS['fn_geteventsdata']}(?, ?) WHERE Id = ? AND EventType = ?"
            cursor.execute(query, (year, month, event_id, event_type))

            row = cursor.fetchone()
            if not row:
                return None

            # Mapowanie kolumn (logika skopiowana z DataProvider dla sp√≥jno≈õci)
            columns = [column[0] for column in cursor.description]
            raw_event = dict(zip(columns, row))

            # Przetwarzanie na format u≈ºywany w aplikacji
            processed_event = {
                'type': raw_event.get('EventType'),
                'id': raw_event.get('Id'),
                'topic': raw_event.get('Temat'),
                'name': raw_event.get('Nazwa'),
                'user_id': raw_event.get('Uzytkownik'),
                'UzytkownikDane': raw_event.get('UzytkownikDane'),  #
                'date': raw_event.get('Data').strftime('%Y-%m-%d') if hasattr(raw_event.get('Data'),
                                                                              'strftime') else str(
                    raw_event.get('Data')),
                'time_from': raw_event.get('DataOd').strftime('%Y-%m-%d %H:%M') if hasattr(raw_event.get('DataOd'),
                                                                                           'strftime') else str(
                    raw_event.get('DataOd')),
                'time_to': raw_event.get('DataDo').strftime('%Y-%m-%d %H:%M') if hasattr(raw_event.get('DataDo'),
                                                                                         'strftime') else str(
                    raw_event.get('DataDo')),
                'status': raw_event.get('StatusNazwa'),
                'DataModyfikacji': raw_event.get('DataModyfikacji').strftime('%Y-%m-%d %H:%M') if hasattr(
                    raw_event.get('DataModyfikacji'), 'strftime') else str(raw_event.get('DataModyfikacji'))
            }
            return processed_event

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas pobierania konkretnego zdarzenia (ID: {event_id}): {e}", exception=e)
            return None
        finally:
            if conn:
                conn.close()

    def _add_event_to_data_provider(self, new_id, user_id, user_name, date_str, start_time,
                                    end_time, overtime_type, is_overdue, year, month):
        """
        NOWA METODA: Dodaje zdarzenie bezpo≈õrednio do DataProvider i wszystkich cache'y
        """
        try:
            # Utw√≥rz obiekt zdarzenia w formacie DataProvider
            display_date = ".".join(reversed(date_str.split("-")))

            # Status na podstawie typu i flagi zaleg≈Ço≈õci
            if overtime_type == 'wyp≈Çata':
                status = "Wyp≈Çata - zaleg≈Çe" if is_overdue else "Wyp≈Çata"
            elif overtime_type == 'odbi√≥r':
                status = "Odbi√≥r"
            elif overtime_type == 'odpracowanie':
                status = "Odpracowanie"
            else:
                status = "Aktywne"

            # Utw√≥rz zdarzenie w formacie zgodnym z DataProvider
            new_event_dp_format = {
                'event_type': 'Nadgodziny',
                'event_id': new_id,
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'date': date_str,  # DataProvider oczekuje YYYY-MM-DD
                'time_from': f"{start_time}",  # Format z bazy
                'time_to': f"{end_time}",
                'status': 'Wstawione',  # Status w formacie bazy
                'type': 'Nadgodziny',
                'id': new_id,
                'date_display': display_date,
                'date_key': date_str
            }

            # Utw√≥rz zdarzenie w formacie lokalnym
            new_event_local_format = {
                'type': 'Nadgodziny',
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'user_name': user_name,
                'date': display_date,
                'date_key': date_str,
                'time_from': start_time,
                'time_to': end_time,
                'status': status,
                'id': new_id
            }

            # KLUCZOWA ZMIANA 1: Dodaj do cache DataProvider
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]

                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data (ID: {new_id})")

                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []

                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in
                           container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache (ID: {new_id})")

                # Aktualizuj processed_data - dodaj ikonƒô nadgodzin
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        try:
                            day = int(date_str.split('-')[2])
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonƒô nadgodzin w processed_data dla {user_id}, dzie≈Ñ {day}")
                            break
                        except:
                            pass

            # KLUCZOWA ZMIANA 2: Dodaj do lokalnych danych
            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(new_event_local_format)
                    debug_print(f"Dodano nadgodziny do all_events_data (ID: {new_id})")

            # KLUCZOWA ZMIANA 3: Dodaj do events_data tylko je≈õli kom√≥rka jest zaznaczona
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )

                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(new_event_local_format)
                        debug_print(f"Dodano nadgodziny do events_data (ID: {new_id})")

                        # Aktualizuj model zdarze≈Ñ
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # KLUCZOWA ZMIANA 4: Aktualizuj ikonƒô w modelu
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonƒô nadgodzin w modelu dla ({user_id}, {date_str})")

            # KLUCZOWA ZMIANA 5: Wyczy≈õƒá tylko cache ikon dla tej kom√≥rki (nie ca≈Çy cache)
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla kom√≥rki ({user_id}, {date_str})")

            # Od≈õwie≈º widok
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas dodawania zdarzenia do DataProvider: {e}")

    def debug_check_event_in_index(self, event_id, event_type='Nadgodziny'):
        """
        Sprawdza, czy zdarzenie o podanym ID istnieje w indeksie zdarze≈Ñ
        i wy≈õwietla informacje diagnostyczne.

        Args:
            event_id: ID zdarzenia
            event_type: Typ zdarzenia (domy≈õlnie 'Nadgodziny')

        Returns:
            bool: True je≈õli znaleziono zdarzenie, False w przeciwnym wypadku
        """
        debug_print(f"<br>--- DIAGNOSTYKA INDEKSU ZDARZE≈É ---")
        debug_print(f"Szukam zdarzenia o ID {event_id} i typie {event_type}")

        # Sprawd≈∫ w indeksie zdarze≈Ñ DataProvider
        if hasattr(self.data_provider, 'events_index'):
            # Sprawd≈∫ bezpo≈õrednio przez indeks ID
            event = self.data_provider.events_index.get_event_by_id(event_id)
            if event:
                debug_print(f"ZNALEZIONO w indeksie ID: {event}")
                return True

            # Alternatywnie, przeszukaj wszystkie zdarzenia
            found_in_all = False
            for e in self.data_provider.events_index.all_events:
                if e.get('id') == event_id and e.get('type') == event_type:
                    debug_print(f"ZNALEZIONO w all_events: {e}")
                    found_in_all = True

            # Przeszukaj indeks typ√≥w
            found_in_type_index = False
            type_events = self.data_provider.events_index.type_index.get(event_type, [])
            for e in type_events:
                if e.get('id') == event_id:
                    debug_print(f"ZNALEZIONO w type_index: {e}")
                    found_in_type_index = True

            if not found_in_all and not found_in_type_index:
                debug_print("NIE ZNALEZIONO w indeksie zdarze≈Ñ")
                return False

            return found_in_all or found_in_type_index
        else:
            debug_print("BRAK indeksu zdarze≈Ñ w data_provider")
            return False

    def update_cell_data(self, user_id, date_str, event_type=None, action="update"):
        """
        Aktualizuje dane kom√≥rki i ikony po r√≥≈ºnych operacjach.
        Zoptymalizowana wersja wykorzystujƒÖca precyzyjne aktualizacje.

        Args:
            user_id: ID u≈ºytkownika
            date_str: Data w formacie 'YYYY-MM-DD'
            event_type: Typ zdarzenia (Spotkanie, Szkolenie, Nadgodziny lub None)
            action: Rodzaj operacji - "update", "add", "delete"

        Returns:
            bool: True je≈õli operacja siƒô powiod≈Ça, False w przeciwnym wypadku
        """
        if not user_id or not date_str:
            return False

        # Standardyzuj format daty
        date_str = self.data_provider._standardize_date(date_str)

        # Wyczy≈õƒá cache dla miesiƒÖca tej daty
        if date_str and date_str.count('-') == 2:
            year, month, _ = date_str.split('-')
            self.clear_events_cache(int(year), int(month))

        # Pobierz zdarzenia dla tej pary (u≈ºytkownik, data)
        events = self.data_provider.get_events_for_user_date(user_id, date_str)

        # Sprawd≈∫ typy zdarze≈Ñ
        has_meeting = any(
            e.get('type') == 'Spotkanie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_training = any(
            e.get('type') == 'Szkolenie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_overtime = any(e.get('type') == 'Nadgodziny' for e in events)

        # Aktualizuj wska≈∫niki w modelu - u≈ºywajƒÖc zoptymalizowanej metody
        if hasattr(self, 'schedule_model'):
            if event_type == 'Spotkanie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Szkolenie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Nadgodziny':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny',
                                                                  is_active=(action != "delete"))
            else:
                # Aktualizuj wszystkie wska≈∫niki
                result1 = self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', has_meeting)
                result2 = self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', has_training)
                result3 = self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', has_overtime)
                return result1 or result2 or result3

        return False

    def _remove_s_symbol_directly(self, cells_to_update: list):
        """
        Usuwa symbol 'S' z grafiku przez bezpo≈õredni UPDATE ORAZ aktualizuje
        model danych w aplikacji, aby zmiana by≈Ça widoczna natychmiast.
        """
        if not cells_to_update:
            return

        updated_cells_info = []
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            table_name = SQL_OBJECTS['grafikipracy']

            for cell_data in cells_to_update:
                current_symbol = cell_data.get('symbol', '')
                if not current_symbol:
                    continue

                parsed = parse_symbol(current_symbol)
                if parsed.get('special_symbol', '').upper() == 'S':
                    new_symbol = build_symbol(
                        location=parsed.get('location'),
                        start_hour=parsed.get('start_hour'),
                        work_hours=parsed.get('work_hours'),
                        special_symbol=None
                    )

                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')

                    if user_id and date_str:
                        # Krok 1: Aktualizacja bazy danych
                        sql = f"UPDATE {table_name} SET Symbol = ? WHERE Uzytkownik = ? AND Data = ?"
                        cursor.execute(sql, (new_symbol, user_id, date_str))

                        # Zbierz dane do aktualizacji UI
                        updated_cells_info.append((user_id, date_str, new_symbol))

            if updated_cells_info:
                conn.commit()
                self.statusBar().showMessage(f"Usuniƒôto symbol 'S' z {len(updated_cells_info)} kom√≥rek grafiku.", 3000)

            conn.close()

            # Krok 2: Bezpo≈õrednia aktualizacja modelu danych w aplikacji
            # To zapewni natychmiastowe od≈õwie≈ºenie widoku bez resetowania sortowania.
            if updated_cells_info:
                self._update_cells_with_new_symbols(updated_cells_info)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas bezpo≈õredniego usuwania symbolu 'S': {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd Bazy Danych",
                                 f"Nie uda≈Ço siƒô usunƒÖƒá symbolu 'S' z grafiku z powodu b≈Çƒôdu:<br>{e}")

    def get_all_valid_symbols(self) -> set:
        """Zwraca zbi√≥r wszystkich prawid≈Çowych symboli specjalnych z za≈Çadowanej konfiguracji."""
        all_symbols = set()
        for category in app_settings.SYMBOL_CATEGORIES.values():
            all_symbols.update(category.keys())
        return all_symbols

    def apply_symbol_from_keyboard(self, special_symbol: str):
        """
        Uproszczona metoda: Aplikuje symbol z klawiatury, delegujƒÖc logikƒô
        do scentralizowanej metody.
        """
        if special_symbol:
            self._apply_special_symbol_to_selection(special_symbol)

    def _apply_special_symbol_to_selection(self, special_symbol: str):
        """
        Aplikuje symbol specjalny do zaznaczonych kom√≥rek, u≈ºywajƒÖc mechanizmu masowej aktualizacji.
        """
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not selected_cells_data:
            self.statusBar().showMessage("Nie zaznaczono ≈ºadnych kom√≥rek do edycji.", 3000)
            return

        if not self._can_modify_cells(selected_cells_data):
            return

        # --- NOWA ZMIANA: Sprawdzenie, czy zmieniamy urlop na inny symbol ---
        contains_vacation_symbol_change = any(
            (parse_symbol(cell.get('symbol', '')).get('special_symbol') or '').upper() in ['U', 'UZ']
            and special_symbol.upper() not in ['U', 'UZ']
            for cell in selected_cells_data
        )

        view_state = self._save_view_state()

        processed_cells_to_modify = []
        for cell_data in selected_cells_data:
            parsed_symbol = parse_symbol(cell_data.get('symbol', ''))
            is_empty_cell = parsed_symbol.get('work_hours') is None

            if is_empty_cell:
                if self.current_user_app_role in ['Lider', 'Pracownik WPR']:
                    continue
                elif self.current_user_app_role == 'Lider OUT':
                    try:
                        work_hours = int(float(cell_data.get('etat')))
                    except (ValueError, TypeError):
                        work_hours = 8

                    default_shift_symbol = build_symbol(
                        location=cell_data.get('lokalizacja_domyslna'),
                        start_hour=9,
                        work_hours=work_hours,
                        special_symbol=None
                    )
                    modified_cell = cell_data.copy()
                    modified_cell['symbol'] = default_shift_symbol
                    processed_cells_to_modify.append(modified_cell)
                else:
                    processed_cells_to_modify.append(cell_data)
            else:
                processed_cells_to_modify.append(cell_data)

        if not processed_cells_to_modify:
            QMessageBox.information(self, "Informacja",
                                    "Brak prawid≈Çowych kom√≥rek do modyfikacji dla Twojej roli i zaznaczenia.")
            return

        cells_to_modify_final = []
        skipped_for_dtn = []
        if self.current_user_app_role in ['Lider', 'Lider OUT']:
            for cell in processed_cells_to_modify:
                target_dept = cell.get('wydzial', '').strip().lower()
                if target_dept == 'dtn' and special_symbol.upper() != 'CO':
                    skipped_for_dtn.append(cell.get('uzytkownik_dane', 'Nieznany'))
                else:
                    cells_to_modify_final.append(cell)
        else:
            cells_to_modify_final = processed_cells_to_modify

        if skipped_for_dtn:
            QMessageBox.warning(self, "Operacja zablokowana",
                                f"Dla wydzia≈Çu DTN dozwolony jest tylko symbol 'CO'.<br>"
                                f"Pominiƒôto zmiany dla: {', '.join(set(skipped_for_dtn))}")

        if not cells_to_modify_final:
            return

        events_to_cancel = []
        if special_symbol.upper() in app_settings.get_absence_symbols():
            user_date_pairs = {(c.get('uzytkownik_id'), c.get('date_str')) for c in cells_to_modify_final}
            events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        reply = QMessageBox.Yes
        if self._should_ask_for_confirmation():
            grouped_changes = self._group_cells_for_symbol_changes(cells_to_modify_final)
            changes_info = self._prepare_symbol_changes_description(grouped_changes, special_symbol)
            complete_info = f"Czy na pewno chcesz wprowadziƒá nastƒôpujƒÖce zmiany?{changes_info}"
            if events_to_cancel:
                grouped_events = self._group_events_by_user_date(events_to_cancel)
                delegations_info = self._prepare_delegations_description(grouped_events)
                complete_info += f"<br>{delegations_info}"
            reply = show_confirmation_dialog(self, "Potwierdzenie wstawienia symbolu", complete_info)

        if reply != QMessageBox.Yes:
            self.statusBar().showMessage("Operacja anulowana przez u≈ºytkownika.", 3000)
            return

        if events_to_cancel:
            self.cancel_delegations(ask_for_confirmation=False)

        change_requests = []
        skipped_employees = []

        for cell_data in cells_to_modify_final:
            if self.current_user_app_role == 'Lider' and special_symbol.upper() == 'U':
                target_role = cell_data.get('rola_nazwa', '')
                target_dept = cell_data.get('wydzial', '')
                if not (target_role == 'Lider' and target_dept == self.current_user_app_department):
                    skipped_employees.append(
                        f"{cell_data.get('uzytkownik_dane', 'Nieznany')} (nie jest Liderem w tym samym wydziale)")
                    continue

            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_edit_symbol']:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue

            new_symbol = self._predict_new_symbol(cell_data.get('symbol', ''), special_symbol, cell_data)
            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')

                change_requests.append((ChangeType.APPLY_SPECIAL_SYMBOL, cell_data, special_symbol))
            except Exception as e:
                log_error(f"B≈ÇƒÖd krytyczny podczas przygotowywania ≈ºƒÖdania w _apply_special_symbol_to_selection: {e}",
                          exception=e)

        if skipped_employees:
            QMessageBox.information(self, "Pominiƒôto",
                                    f"Pominiƒôto zmiany dla nastƒôpujƒÖcych os√≥b z powodu braku uprawnie≈Ñ:<br>"
                                    f"- {', '.join(set(skipped_employees))}")

        if change_requests:
            # U≈ºyj partial, aby przekazaƒá dodatkowy argument do callbacka po zako≈Ñczeniu BatchUpdater
            self.schedule_change_processor.start_changes(change_requests)

    def apply_theme_settings(self, theme, font_family, font_size):
        """Stosuje wybrane ustawienia motywu z wykorzystaniem centralnych styl√≥w"""
        # Zapamiƒôtaj wybrane ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Zastosuj czcionkƒô do ca≈Çej aplikacji
        font = QFont(font_family, font_size)
        QApplication.setFont(font)

        # Dodano styl dla QCalendarWidget
        calendar_style = AppStyles.get_calendar_style(theme)
        self.setStyleSheet(AppStyles.get_main_window_style(theme) + calendar_style)

        # Definicje styl√≥w
        button_style = AppStyles.get_button_style(theme, font_family, font_size)
        combo_style = AppStyles.get_combobox_style(theme)
        line_edit_style = AppStyles.get_line_edit_style(theme)
        list_style = AppStyles.get_list_style(theme)
        date_edit_style = AppStyles.get_date_edit_style(theme)
        checkbox_style = AppStyles.get_checkbox_style(theme)
        table_style = AppStyles.get_table_style(theme)
        left_panel_style = AppStyles.get_left_panel_style(theme)

        # Stosowanie styl√≥w do wszystkich istniejƒÖcych kontrolek
        all_buttons = self.findChildren(QPushButton)

        icon_button_style = AppStyles.get_icon_button_style(theme)

        icon_buttons = []
        if hasattr(self, 'teams_chat_button'):
            icon_buttons.append(self.teams_chat_button)
        if hasattr(self, 'send_email_button'):
            icon_buttons.append(self.send_email_button)
        if hasattr(self, 'export_button'):
            icon_buttons.append(self.export_button)
        if hasattr(self, 'filter_settings_button'):
            icon_buttons.append(self.filter_settings_button)
        if hasattr(self, 'save_filter_button'):
            icon_buttons.append(self.save_filter_button)
        if hasattr(self, 'delete_filter_button'):
            icon_buttons.append(self.delete_filter_button)

        for button in icon_buttons:
            if button:
                button.setStyleSheet(icon_button_style)

        for button in all_buttons:
            if button not in icon_buttons:
                if "FilterClearButton" not in button.objectName():
                    button.setStyleSheet(button_style)

        new_icon = self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light
        for button in self.findChildren(QPushButton, "FilterClearButton"):
            button.setIcon(new_icon)

        # Pola wyboru (ComboBox)
        combos_to_style = [
            getattr(self, name, None) for name in [
                'date_combo', 'grupa_main_filter_combo', 'wydzial_combo',
                'default_location_combo', 'system_czasu_pracy_combo',
                'rola_combo', 'jezyk_combo', 'etat_combo', 'dtn_combo',
                'rka_combo', 'podrola_combo', 'presence_location_combo',
                'presence_hour_combo', 'status_filter_combo', 'saved_filters_combo'
            ]
        ]
        for combo in combos_to_style:
            if combo:
                combo.setStyleSheet(combo_style)

        # Inne kontrolki
        if hasattr(self, '_left_panel'): self._left_panel.setStyleSheet(left_panel_style)
        if hasattr(self, 'przelozony_filter'): self.przelozony_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'topic_filter'): self.topic_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'name_filter'): self.name_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'przelozony_list'): self.przelozony_list.setStyleSheet(list_style)
        if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.setStyleSheet(list_style)
        if hasattr(self, 'date_from'): self.date_from.setStyleSheet(date_edit_style)
        if hasattr(self, 'date_to'): self.date_to.setStyleSheet(date_edit_style)
        if hasattr(self, 'presence_date_edit'): self.presence_date_edit.setStyleSheet(date_edit_style)

        checkboxes_to_style = [
            getattr(self, name, None) for name in [
                'meetings_checkbox', 'trainings_checkbox', 'overtime_checkbox',
                'filter_by_presence_check'
            ]
        ]
        for checkbox in checkboxes_to_style:
            if checkbox:
                checkbox.setStyleSheet(checkbox_style)

        # Aktualizacja modeli i tabel
        if hasattr(self, 'schedule_model'): self.schedule_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'events_model'): self.events_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'table'):
            if hasattr(self.table, 'employees_view'): self.table.employees_view.setStyleSheet(table_style)
            if hasattr(self.table, 'schedule_view'): self.table.schedule_view.setStyleSheet(table_style)
        if hasattr(self, 'events_table'): self.events_table.setStyleSheet(table_style)

        # --- POCZƒÑTEK ZMIANY: Aktualizacja otwartych okien ---

        # Aktualizacja okna "Obsada"
        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            self.staffing_details_win.set_current_theme(self.is_dark_theme)

        # Aktualizacja okna "ZarzƒÖdzaj grafikiem"
        if self.schedule_control_win and not self.schedule_control_win.isHidden():
            try:
                self.schedule_control_win.set_current_theme(self.is_dark_theme)
                debug_print("Od≈õwie≈ºono motyw dla okna 'ZarzƒÖdzaj grafikiem'.")

                # --- POCZƒÑTEK NOWEJ LOGIKI ---
                # Je≈õli okno b≈Çƒôd√≥w jest otwarte i nale≈ºy do okna "ZarzƒÖdzaj",
                # jemu te≈º zaktualizuj motyw.
                if hasattr(self.schedule_control_win, 'error_dialog') and self.schedule_control_win.error_dialog:
                    self.schedule_control_win.error_dialog.set_current_theme(self.is_dark_theme)
                    debug_print("Od≈õwie≈ºono motyw dla okna 'B≈Çƒôdy importu'.")
                # --- KONIEC NOWEJ LOGIKI ---

            except RuntimeError as e:
                log_error(f"B≈ÇƒÖd przy od≈õwie≈ºaniu motywu okna 'ZarzƒÖdzaj': {e}")
                self.schedule_control_win = None  # Wyczy≈õƒá referencjƒô, je≈õli okno nie istnieje
        # --- KONIEC ZMIANY ---

        if hasattr(self, 'table'):
            self._apply_dynamic_sizes()

    def save_user_settings_on_exit(self):
        """Zbiera i zapisuje wszystkie ustawienia u≈ºytkownika przy zamykaniu."""
        if not hasattr(self, 'user_app_settings'):
            return

        # Zbierz dynamiczne ustawienia z UI
        ui_settings = {
            'is_maximized': self.isMaximized(),
            'window_size': (self.size().width(), self.size().height()),
            'last_filters': self.get_current_filters_state(),
            'column_widths': self.table.get_column_widths(),
            'visible_columns': self.visible_columns,
            'schedule_splitter_sizes': self.table.splitter.sizes() if hasattr(self, 'table') and hasattr(self.table,
                                                                                                         'splitter') else None,
            'theme': 'dark' if self.is_dark_theme else 'light',
            'font_family': self.current_font,
            'font_size': self.current_font_size
        }

        # Zaktualizuj g≈Ç√≥wny s≈Çownik ustawie≈Ñ
        self.user_app_settings.update(ui_settings)

        # Zapisz ca≈Çy s≈Çownik do bazy
        self.settings_db.save_settings(self.user_app_settings)
        debug_print("Zapisano ustawienia u≈ºytkownika przy zamkniƒôciu.")

    def copy_selection_to_clipboard(self):
        """
        Zbiera dane z zaznaczonych kom√≥rek i kopiuje je do schowka
        w formacie TSV, gotowym do wklejenia w Excelu.
        """
        if not hasattr(self, 'table') or not self.schedule_model:
            return

        selection_model_employees = self.table.employees_view.selectionModel()
        selection_model_schedule = self.table.schedule_view.selectionModel()

        if not selection_model_employees.hasSelection() or not selection_model_schedule.hasSelection():
            self.statusBar().showMessage("Proszƒô zaznaczyƒá wiersze pracownik√≥w oraz kolumny dni do skopiowania.", 3000)
            return

        # Krok 1: Zbierz unikalne, posortowane indeksy wierszy i kolumn
        selected_rows = sorted(list(set(index.row() for index in selection_model_employees.selectedIndexes())))
        selected_schedule_cols = sorted(
            list(set(index.column() for index in selection_model_schedule.selectedIndexes())))

        if not selected_rows or not selected_schedule_cols:
            return

        # --- POCZƒÑTEK POPRAWKI: Inicjalizacja pustego stringa na dane ---
        clipboard_string = ""
        # --- KONIEC POPRAWKI ---
        # Krok 2: Przygotuj nag≈Ç√≥wki
        employee_headers = []
        visible_employee_cols_ids = self.schedule_model.get_visible_columns()
        for col_id in visible_employee_cols_ids:
            # Znajd≈∫ nazwƒô kolumny na podstawie jej ID
            header_name = next((name for id, name, width in self.employee_columns if id == col_id), col_id)
            employee_headers.append(header_name)

        day_letters = []
        day_numbers = []
        for col in selected_schedule_cols:
            # --- POPRAWKA: U≈ºywamy roli RawTextRole, aby pobraƒá tekst bez formatowania HTML ---
            header_text = str(self.schedule_model.headerData(col, Qt.Horizontal, self.schedule_model.RawTextRole))
            parts = header_text.split('\n')
            if len(parts) == 2:
                day_numbers.append(parts[0])
                day_letters.append(parts[1])
            else:
                day_numbers.append(header_text)
                day_letters.append('')

        # --- POCZƒÑTEK POPRAWKI: Dodanie dwuwierszowych nag≈Ç√≥wk√≥w (z dniami tygodnia) ---
        clipboard_string += "\t".join([''] * len(employee_headers) + day_letters) + "\n"
        clipboard_string += "\t".join(employee_headers + day_numbers) + "\n"
        # --- KONIEC POPRAWKI ---

        # Krok 3: Przygotuj wiersze z danymi
        for row in selected_rows:
            row_values = []
            # Dodaj dane pracownik√≥w
            for col_idx in range(len(visible_employee_cols_ids)):
                index = self.schedule_model.index(row, col_idx)
                value = self.schedule_model.data(index, Qt.DisplayRole)
                row_values.append(str(value or ''))

            # Dodaj dane z grafiku
            for col in selected_schedule_cols:
                index = self.schedule_model.index(row, col)
                # --- ZMIANA: Pobieramy pe≈Çne dane kom√≥rki, a nie tylko dane do wy≈õwietlenia ---
                cell_data = self.schedule_model.data(index, ROLE_DATA)
                if isinstance(cell_data, dict):
                    # Z danych wyciƒÖgamy oryginalny, pe≈Çny symbol
                    symbol = cell_data.get('symbol', '')
                    row_values.append(symbol)
                else:
                    row_values.append('')

            # --- POCZƒÑTEK POPRAWKI: Dodanie wiersza danych do stringa wynikowego ---
            clipboard_string += "\t".join(row_values) + "\n"
            # --- KONIEC POPRAWKI ---

        # Krok 4: Wstaw sformatowany tekst do schowka
        QApplication.clipboard().setText(clipboard_string)
        self.statusBar().showMessage(f"Skopiowano {len(selected_rows)} wierszy do schowka.", 3000)

    def closeEvent(self, event):
        """Obs≈Çuguje zamkniƒôcie aplikacji i zapisuje ustawienia."""
        try:
            # Wywo≈Çaj nowƒÖ metodƒô zapisu
            self.save_user_settings_on_exit()

            debug_print("=== ZAMYKANIE APLIKACJI TEAMFLOW ===")
            self.cleanup_keyboard_filter()
            close_log_file()
        except Exception as e:
            log_error(f"WystƒÖpi≈Ç b≈ÇƒÖd podczas zamykania aplikacji: {e}", exception=e)
        finally:
            event.accept()


if __name__ == "__main__":
    app = QApplication(sys.argv)

    # Krok 1: Za≈Çaduj kluczowe ustawienia PRZED utworzeniem g≈Ç√≥wnego okna
    if not load_all_app_settings():
        QMessageBox.critical(None, "B≈ÇƒÖd Krytyczny",
                             "Nie uda≈Ço siƒô za≈Çadowaƒá konfiguracji aplikacji z serwera.<br>"
                             "Sprawd≈∫ po≈ÇƒÖczenie z bazƒÖ danych i plik config.ini.<br><br>"
                             "Aplikacja nie mo≈ºe zostaƒá uruchomiona.")
        sys.exit(1)

    # Krok 2: Sprawd≈∫ wersjƒô aplikacji PRZED utworzeniem g≈Ç√≥wnego okna
    if parse_version(APP_VERSION) != parse_version(app_settings.REQUIRED_VERSION):
        dialog = UpdateRequiredDialog()
        dialog.exec()
        sys.exit(0)

    # Krok 3: Zainicjuj logowanie
    try:
        current_windows_user = getpass.getuser().lower()
    except Exception:
        current_windows_user = "unknown_user"
    log_to_file = False
    log_to_console = True
    setup_logging(log_to_file=log_to_file, log_to_console=log_to_console)

    # Krok 4: Utw√≥rz g≈Ç√≥wne okno (wczyta ustawienia u≈ºytkownika w __init__)
    window = WorkScheduleWindow()

    # === POCZƒÑTEK ZMIAN ===
    # Krok 5: Ustaw stan i rozmiar okna PRZED jego pokazaniem
    is_maximized = window.user_app_settings.get('is_maximized', False)  # Pobierz ustawienie

    if is_maximized:
        # Ustaw stan na zmaksymalizowany (ale jeszcze nie pokazuj)
        window.setWindowState(Qt.WindowMaximized)
        debug_print("Ustawiono stan okna na zmaksymalizowany przed pokazaniem.")
    else:
        # Pobierz zapisany rozmiar lub domy≈õlny
        width, height = window.user_app_settings.get('window_size', (1600, 800))
        # Ustaw rozmiar okna (bez ustawiania pozycji)
        window.resize(width, height)
        debug_print(f"Ustawiono rozmiar okna na {width}x{height} przed pokazaniem.")
        # Opcjonalnie: wy≈õrodkuj okno na ekranie
        try:
            screen_geometry = QApplication.primaryScreen().availableGeometry()
            window.move(int((screen_geometry.width() - width) / 2),
                        int((screen_geometry.height() - height) / 2))
            debug_print("Wy≈õrodkowano okno.")
        except Exception as e:
            log_error(f"Nie uda≈Ço siƒô wy≈õrodkowaƒá okna: {e}")

    # Krok 6: Poka≈º okno (powinno siƒô pojawiƒá ju≈º w docelowym stanie/rozmiarze)
    window.show()
    debug_print("Wywo≈Çano window.show().")
    # === KONIEC ZMIAN ===

    sys.exit(app.exec())
