Ten b≈ÇƒÖd wynika z tego, ≈ºe w funkcji insert_data przekazujemy teraz dodatkowy argument (sqlalchemy_dtype_dict), ale definicja funkcji create_table_if_not_exists nie zosta≈Ça zaktualizowana, aby go przyjƒÖƒá.
Przyczyna:
 * Wywo≈Çanie: self.create_table_if_not_exists(engine, sqlalchemy_dtype_dict, df, ...) (7 argument√≥w ≈ÇƒÖcznie z self).
 * Definicja: def create_table_if_not_exists(self, engine, df, ...) (6 argument√≥w ≈ÇƒÖcznie z self).
Musimy zaktualizowaƒá definicjƒô create_table_if_not_exists, aby przyjmowa≈Ça s≈Çownik typ√≥w jako argument (nazwijmy go column_types), zamiast generowaƒá go wewnƒÖtrz.
Oto poprawiony kod funkcji create_table_if_not_exists. Podmie≈Ñ jƒÖ w ca≈Ço≈õci w klasie DatabaseManager.
üõ†Ô∏è Poprawiona funkcja create_table_if_not_exists
    def create_table_if_not_exists(self, engine, column_types: dict, df: pd.DataFrame, 
                                   table_name: str, schema: str, target_db: str) -> bool:
        """
        Tworzy tabelƒô docelowƒÖ, je≈õli nie istnieje, u≈ºywajƒÖc przekazanych typ√≥w danych.
        Argument column_types zawiera obiekty SQLAlchemy.
        """
        
        # 1. Sprawdzenie, czy tabela ju≈º istnieje
        with engine.connect() as connection:
            if connection.dialect.has_table(connection, table_name, schema=schema):
                self.logger.info(f"Tabela {schema}.{table_name} ju≈º istnieje.")
                return True # Tabela istnieje

        # UWAGA: Tutaj wcze≈õniej by≈Ço wywo≈Çanie map_data_types. 
        # Teraz pobieramy typy z argumentu 'column_types', kt√≥ry przekazali≈õmy z insert_data.
        
        columns_def = []

        # 2. Dynamiczne tworzenie definicji kolumn SQL (columns_def)
        
        if target_db.lower() == 'oracle':
            # --- LOGIKA DLA ORACLE ---
            for col_name, col_type in column_types.items():
                col_name_sql = f'"{col_name}"' # Cudzys≈Çowy dla nazwy kolumny w Oracle
                col_type_str = str(col_type).upper()
                
                # Dodajemy pusty string na start, ≈ºeby m√≥c go nadpisaƒá przez indeks [-1]
                columns_def.append("") 

                if 'VARCHAR' in col_type_str or 'STRING' in col_type_str:
                    length = getattr(col_type, 'length', 255)
                    if length <= 4000:
                        columns_def[-1] = f"{col_name_sql} VARCHAR2({length})"
                    else:
                        columns_def[-1] = f"{col_name_sql} CLOB"
                elif 'INTEGER' in col_type_str:
                    columns_def[-1] = f"{col_name_sql} NUMBER(38)"
                elif 'FLOAT' in col_type_str or 'NUMBER' in col_type_str:
                    columns_def[-1] = f"{col_name_sql} NUMBER"
                elif 'TIMESTAMP' in col_type_str or 'DATETIME' in col_type_str:
                    columns_def[-1] = f"{col_name_sql} TIMESTAMP"
                elif 'DATE' in col_type_str:
                    columns_def[-1] = f"{col_name_sql} DATE"
                elif 'BOOLEAN' in col_type_str:
                    columns_def[-1] = f"{col_name_sql} NUMBER(1)"
                else:
                     # Fallback
                     columns_def[-1] = f"{col_name_sql} VARCHAR2(100)"
                     
        elif target_db.lower() == 'impala':
            # --- LOGIKA DLA IMPALA ---
            for col_name, col_type in column_types.items():
                col_name_sql = f"`{col_name}`"
                columns_def.append("")
                
                if hasattr(col_type, 'length'):
                    length = getattr(col_type, 'length', 255)
                    columns_def[-1] = f"{col_name_sql} VARCHAR({length})"
                elif str(col_type) == 'INTEGER' or 'BIGINT' in str(col_type):
                    columns_def[-1] = f"{col_name_sql} BIGINT"
                elif 'FLOAT' in str(col_type):
                    columns_def[-1] = f"{col_name_sql} DOUBLE"
                elif 'DATETIME' in str(col_type) or 'TIMESTAMP' in str(col_type):
                    columns_def[-1] = f"{col_name_sql} TIMESTAMP"
                elif 'BOOLEAN' in str(col_type):
                    columns_def[-1] = f"{col_name_sql} BOOLEAN"
                else:
                    columns_def[-1] = f"{col_name_sql} STRING"
                    
        elif target_db.lower() == 'sqlserver':
            # --- LOGIKA DLA SQL SERVER ---
            for col_name, col_type in column_types.items():
                col_name_sql = f'[{col_name}]'
                columns_def.append("")
                
                col_type_str = str(col_type).upper()
                
                if 'VARCHAR' in col_type_str or 'NVARCHAR' in col_type_str or 'STRING' in col_type_str:
                    length = getattr(col_type, 'length', 4000)
                    if length is None or length > 4000: # NVARCHAR(MAX)
                         columns_def[-1] = f"{col_name_sql} NVARCHAR(MAX)"
                    else:
                         columns_def[-1] = f"{col_name_sql} NVARCHAR({length})"
                elif 'INTEGER' in col_type_str or 'BIGINT' in col_type_str:
                    columns_def[-1] = f"{col_name_sql} BIGINT"
                elif 'FLOAT' in col_type_str:
                    columns_def[-1] = f"{col_name_sql} FLOAT"
                elif 'DATETIME' in col_type_str:
                    columns_def[-1] = f"{col_name_sql} DATETIME2"
                elif 'DATE' in col_type_str:
                    columns_def[-1] = f"{col_name_sql} DATE"
                elif 'BOOLEAN' in col_type_str or 'BIT' in col_type_str:
                    columns_def[-1] = f"{col_name_sql} BIT"
                else:
                    columns_def[-1] = f"{col_name_sql} NVARCHAR(100)"
        
        # 3. Wykonanie zapytania CREATE TABLE
        if not columns_def:
            self.logger.warning(f"Brak definicji kolumn dla tabeli {table_name}. Przerwanie tworzenia.")
            return False

        cols_definition = ',\n'.join(columns_def)
        create_table_sql = f'CREATE TABLE {schema}.{table_name} (\n{cols_definition}\n)'
        
        try:
            with engine.connect() as connection:
                connection.execute(create_table_sql)
                self.logger.info(f"Utworzono nowƒÖ tabelƒô {schema}.{table_name} w bazie {target_db}.")
                return False # Tabela zosta≈Ça utworzona (nie istnia≈Ça wcze≈õniej)
            
        except Exception as e:
            self.logger.error(f"Krytyczny b≈ÇƒÖd podczas tworzenia tabeli {table_name}: {str(e)}")
            self.logger.error(f"SQL: {create_table_sql}")
            raise

üîé Co zmienili≈õmy?
 * Sygnatura funkcji:
   * By≈Ço: def create_table_if_not_exists(self, engine, df, table_name, schema, target_db)
   * Jest: def create_table_if_not_exists(self, engine, column_types, df, table_name, schema, target_db)
   * Dodano column_types jako drugi argument (po engine).
 * U≈ºycie column_types:
   * WewnƒÖtrz funkcji usunƒôli≈õmy liniƒô column_types = self.map_data_types(...), poniewa≈º typy sƒÖ teraz przekazywane jako argument.
Teraz liczba argument√≥w w wywo≈Çaniu (w insert_data) i w definicji bƒôdzie siƒô zgadzaƒá (7 argument√≥w).
