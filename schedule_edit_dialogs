# schedule_edit_dialogs.py

from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel,
                               QPushButton, QComboBox, QGroupBox, QRadioButton,
                               QFontComboBox, QSpinBox, QCheckBox, QWidget,
                               QTabWidget, QGridLayout, QMessageBox, QLineEdit,
                               QApplication, QSpacerItem, QSizePolicy,
                               QTableWidget, QTableWidgetItem, QHeaderView, QDialogButtonBox)
from PySide6.QtCore import Qt, Signal, QTimer, QDate
from PySide6.QtGui import QFont, QColor
from styles import AppStyles
from debug_utils import debug_print, log_error
from app_settings import app_settings
from db_connector import get_modifier_id
from symbol_parser import parse_symbol

class DateTableWidgetItem(QTableWidgetItem):
    """Niestandardowy element tabeli do sortowania dat chronologicznie."""
    def __init__(self, date_str):
        # Format wyświetlania: DD.MM.YYYY
        super().__init__(QDate.fromString(date_str, "yyyy-MM-dd").toString("dd.MM.yyyy"))
        # Przechowujemy obiekt QDate do poprawnego sortowania
        self.date = QDate.fromString(date_str, "yyyy-MM-dd")

    def __lt__(self, other):
        # Porównaj obiekty QDate zamiast tekstu
        return self.date < other.date

class DayOfWeekItem(QTableWidgetItem):
    """Niestandardowy element tabeli do sortowania dni tygodnia."""
    def __init__(self, qdate_obj):
        day_names = ["Pon", "Wt", "Śr", "Czw", "Pt", "Sob", "Nd"]
        super().__init__(day_names[qdate_obj.dayOfWeek() - 1])
        # Przechowujemy numer dnia tygodnia (1-7) do sortowania
        self.day_of_week = qdate_obj.dayOfWeek()

    def __lt__(self, other):
        # Porównaj numery dni tygodnia
        return self.day_of_week < other.day_of_week

class ThemeSettingsDialog(QDialog):
    """
    Dialog do wyboru ustawień motywu aplikacji.
    """
    settings_changed = Signal(str, str, int)

    def __init__(self, parent=None, current_theme="dark", current_font="", current_font_size=9):
        super().__init__(parent)
        self.parent_widget = parent  # Zapisz rodzica

        self.setWindowTitle("Ustawienia motywu")
        self.setMinimumWidth(300)

        self.current_theme = current_theme
        self.current_font = current_font
        self.current_font_size = current_font_size

        self.setup_ui()  # Najpierw UI
        self.apply_dialog_theme()  # Potem styl zgodny z przekazanym/rodzica

        # Podłączenie sygnałów do natychmiastowej zmiany - PO setup_ui i apply_dialog_theme
        self.dark_theme_radio.toggled.connect(self.apply_immediate_changes)
        # Unikamy podwójnego wywołania przy przełączaniu radio, wystarczy jeden sygnał
        # self.light_theme_radio.toggled.connect(self.apply_immediate_changes)
        self.font_combo.currentFontChanged.connect(self.apply_immediate_changes)
        self.font_size_spin.valueChanged.connect(self.apply_immediate_changes)

    def apply_dialog_theme(self):  # Ta metoda stylizuje dialog na podstawie motywu rodzica lub current_theme
        """Stosuje motyw dla samego okna dialogowego."""
        theme_to_apply = self.current_theme  # Domyślnie użyj przekazanego motywu

        # Jeśli dialog ma rodzica i rodzic ma informację o motywie, użyj jej
        # To jest na wypadek, gdyby current_theme nie było zsynchronizowane
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            theme_to_apply = "dark" if self.parent_widget.is_dark_theme else "light"

        # Jeśli aktualnie wybrane radio buttony wskazują inny motyw, użyj go
        # To jest kluczowe dla odświeżania "na żywo"
        if hasattr(self, 'dark_theme_radio') and self.dark_theme_radio.isChecked():
            theme_to_apply = "dark"
        elif hasattr(self, 'light_theme_radio') and self.light_theme_radio.isChecked():
            theme_to_apply = "light"

        self.setStyleSheet(AppStyles.get_dialog_style(theme_to_apply))

        # Odśwież style przycisków w dialogu, bo get_dialog_style ich nie obejmuje
        button_style = AppStyles.get_button_style(theme_to_apply)
        if hasattr(self, 'ok_button'): self.ok_button.setStyleSheet(button_style)
        if hasattr(self, 'cancel_button'): self.cancel_button.setStyleSheet(button_style)

    def setup_ui(self):  # Tutaj tylko tworzymy widgety
        main_layout = QVBoxLayout(self)

        theme_group = QGroupBox("Motyw")
        theme_layout = QVBoxLayout()
        self.dark_theme_radio = QRadioButton("Ciemny")
        self.light_theme_radio = QRadioButton("Jasny")

        if self.current_theme == "dark":
            self.dark_theme_radio.setChecked(True)
        else:  # Domyślnie lub jeśli light
            self.light_theme_radio.setChecked(True)

        theme_layout.addWidget(self.dark_theme_radio)
        theme_layout.addWidget(self.light_theme_radio)
        theme_group.setLayout(theme_layout)

        font_group = QGroupBox("Czcionka")
        font_layout = QVBoxLayout()
        font_type_layout = QHBoxLayout()
        font_type_label = QLabel("Typ czcionki:")
        self.font_combo = QFontComboBox()
        if self.current_font:
            self.font_combo.setCurrentFont(QFont(self.current_font))
        font_type_layout.addWidget(font_type_label)
        font_type_layout.addWidget(self.font_combo)

        font_size_layout = QHBoxLayout()
        font_size_label = QLabel("Rozmiar czcionki:")
        self.font_size_spin = QSpinBox()
        self.font_size_spin.setRange(6, 24)
        self.font_size_spin.setValue(self.current_font_size)
        font_size_layout.addWidget(font_size_label)
        font_size_layout.addWidget(self.font_size_spin)

        font_layout.addLayout(font_type_layout)
        font_layout.addLayout(font_size_layout)
        font_group.setLayout(font_layout)

        self.save_settings_checkbox = QCheckBox("Zapamiętaj ustawienia")
        self.save_settings_checkbox.setChecked(True)

        buttons_layout = QHBoxLayout()
        self.ok_button = QPushButton("OK")
        self.cancel_button = QPushButton("Anuluj")

        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

        buttons_layout.addStretch()
        buttons_layout.addWidget(self.ok_button)
        buttons_layout.addWidget(self.cancel_button)

        main_layout.addWidget(theme_group)
        main_layout.addWidget(font_group)
        main_layout.addWidget(self.save_settings_checkbox)
        main_layout.addLayout(buttons_layout)

    def apply_immediate_changes(self):
        """Aplikuje zmiany natychmiastowo podczas wybierania opcji W TYM SAMYM DIALOGU"""
        if not hasattr(self, 'font_combo') or not hasattr(self, 'font_size_spin') or not hasattr(self,
                                                                                                 'dark_theme_radio'):
            return

        selected_theme = "dark" if self.dark_theme_radio.isChecked() else "light"
        font_family = self.font_combo.currentFont().family()
        font_size = self.font_size_spin.value()

        # Emituj sygnał dla głównego okna, aby ono zaktualizowało swoje style
        self.settings_changed.emit(selected_theme, font_family, font_size)

        # Zaktualizuj styl samego dialogu ThemeSettingsDialog "na żywo"
        # Musimy przekazać wybrany motyw, a niekoniecznie ten z rodzica
        # (bo właśnie go zmieniamy)
        current_dialog_theme_choice = self.get_current_theme_choice()  # Użyj wyboru z radio buttonów

        # Zastosuj pełny styl dialogu na nowo
        self.setStyleSheet(AppStyles.get_dialog_style(current_dialog_theme_choice))

        # Zastosuj style dla przycisków, które nie są objęte get_dialog_style
        button_style = AppStyles.get_button_style(current_dialog_theme_choice)
        if hasattr(self, 'ok_button'): self.ok_button.setStyleSheet(button_style)
        if hasattr(self, 'cancel_button'): self.cancel_button.setStyleSheet(button_style)

        # Może być konieczne odświeżenie stylów dla kontrolek wewnątrz groupboxów,
        # jeśli dziedziczenie nie zadziała idealnie po zmianie głównego stylu dialogu.
        # Na przykład:
        # self.font_combo.setStyleSheet(AppStyles.get_combobox_style(current_dialog_theme_choice))
        # self.font_size_spin.setStyleSheet(AppStyles.get_line_edit_style(current_dialog_theme_choice)) # SpinBox często dziedziczy styl LineEdit
        # self.dark_theme_radio.setStyleSheet(AppStyles.get_checkbox_style(current_dialog_theme_choice)) # RadioButton często jak CheckBox
        # self.light_theme_radio.setStyleSheet(AppStyles.get_checkbox_style(current_dialog_theme_choice))
        # To jest bardziej granularne i może być potrzebne, jeśli prosty self.setStyleSheet() nie wystarczy.

        # Dla pewności można wymusić odświeżenie wyglądu, choć zmiana stylesheetu powinna to zrobić.
        self.update()

    def get_current_theme_choice(self):  # Zmieniono nazwę, aby odróżnić od current_theme przy inicjalizacji
        """Zwraca nazwę aktualnie wybranego motywu w tym dialogu."""
        if hasattr(self, 'dark_theme_radio') and self.dark_theme_radio.isChecked():
            return "dark"
        elif hasattr(self, 'light_theme_radio') and self.light_theme_radio.isChecked():
            return "light"
        # Fallback na current_theme, jeśli radio buttony nie są jeszcze dostępne
        return self.current_theme


class InsertSymbolDialog(QDialog):
    """Dialog do wyboru symbolu z kontekstowym blokowaniem opcji."""
    symbol_selected = Signal(str)

    # ZMIANA: Dodano argument 'selected_cells_data'
    def __init__(self, parent=None, selected_cells_data=None):
        super().__init__(parent)
        self.parent_widget = parent
        self.setWindowTitle("Wstaw symbol")
        self.setMinimumWidth(300)
        self.setMinimumHeight(250)

        self.selected_symbol = ""
        self.user_role = getattr(self.parent_widget, 'current_user_role', "")
        self.valid_symbols = set()
        self.parent_font = QApplication.font()
        if self.parent_widget: self.parent_font = self.parent_widget.font()

        # --- NOWA LOGIKA: Sprawdź, czy włączamy tryb "Tylko CO dla DTN" ---
        self.dtn_co_only_mode = False
        if self.user_role in ['Lider', 'Lider OUT'] and selected_cells_data:
            # Sprawdź, czy WSZYSTKIE zaznaczone komórki należą do wydziału DTN
            if all(cell.get('wydzial', '').strip().lower() == 'dtn' for cell in selected_cells_data):
                self.dtn_co_only_mode = True
        # --- KONIEC NOWEJ LOGIKI ---

        self.setup_ui()
        self.apply_dialog_theme()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu InsertSymbolDialog."""
        actual_theme = "dark"
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            actual_theme = "dark" if self.parent_widget.is_dark_theme else "light"

        # debug_print(f"InsertSymbolDialog ('{self.windowTitle()}'): Stosuję motyw '{actual_theme}'")

        # Ustaw ogólny styl dialogu (powinien zawierać QDialog#InsertSymbolDialogInstance)
        self.setStyleSheet(AppStyles.get_dialog_style(actual_theme))

        # Styl dla przycisków i innych kontrolek w tym dialogu
        button_style_qss = AppStyles.get_button_style(actual_theme)
        line_edit_style_qss = AppStyles.get_line_edit_style(actual_theme)
        tab_widget_style_qss = self._get_tab_widget_style(actual_theme)  # Dedykowana metoda dla QTabWidget

        if hasattr(self, 'symbol_input'):
            self.symbol_input.setStyleSheet(line_edit_style_qss)

        if hasattr(self, 'tabs'):
            self.tabs.setStyleSheet(tab_widget_style_qss)
            # Można dodatkowo ostylować przyciski wewnątrz zakładek, jeśli to konieczne
            # i jeśli nie dziedziczą poprawnie stylu z button_style_qss
            for i in range(self.tabs.count()):
                tab_content_widget = self.tabs.widget(i)
                if tab_content_widget:
                    buttons_in_tab = tab_content_widget.findChildren(QPushButton)
                    for btn in buttons_in_tab:
                        btn.setStyleSheet(button_style_qss)  # Użyj głównego stylu przycisków
                        # lub dedykowanego mniejszego stylu

        if hasattr(self, 'cancel_button'):
            self.cancel_button.setStyleSheet(button_style_qss)

        # Styl dla etykiet, jeśli potrzeba specyficznego
        label_style_qss = AppStyles.get_label_style(actual_theme)
        if hasattr(self, 'instruction_label'): self.instruction_label.setStyleSheet(label_style_qss)
        if hasattr(self, 'input_label'): self.input_label.setStyleSheet(label_style_qss)
        if hasattr(self, 'validation_label'): self.validation_label.setStyleSheet(label_style_qss)

        self.style().unpolish(self)
        self.style().polish(self)
        self.update()

    def _get_tab_widget_style(self, theme):
        """Zwraca styl dla QTabWidget i QTabBar zgodny z motywem."""
        # Pobierz kolory z AppStyles
        main_bg = AppStyles.DARK_BACKGROUND_MAIN if theme == "dark" else AppStyles.LIGHT_BACKGROUND_MAIN
        control_bg = AppStyles.DARK_BACKGROUND_CONTROLS if theme == "dark" else AppStyles.LIGHT_BACKGROUND_CONTROLS
        text_color = AppStyles.DARK_TEXT_PRIMARY if theme == "dark" else AppStyles.LIGHT_TEXT_PRIMARY
        border_color = AppStyles.DARK_BORDER_SECONDARY if theme == "dark" else AppStyles.LIGHT_BORDER_PRIMARY
        accent_color = AppStyles.ACCENT_COLOR_DARK if theme == "dark" else AppStyles.ACCENT_COLOR_LIGHT

        # Dla jasnego motywu zakładki mogą mieć nieco inne tło niż sam dialog
        tab_bar_bg = control_bg if theme == "dark" else AppStyles.LIGHT_BACKGROUND_HOVER
        tab_pane_bg = control_bg  # Tło zawartości zakładki

        return f"""
            QTabWidget::pane {{
                border: 1px solid {border_color};
                border-top: none; /* Łączy się z QTabBar */
                background-color: {tab_pane_bg};
                border-bottom-left-radius: {AppStyles.BORDER_RADIUS};
                border-bottom-right-radius: {AppStyles.BORDER_RADIUS};
            }}
            QTabBar::tab {{
                background-color: {tab_bar_bg};
                color: {text_color};
                border: 1px solid {border_color};
                border-bottom: none; 
                padding: 5px 10px;
                margin-right: 1px;
                border-top-left-radius: {AppStyles.BORDER_RADIUS};
                border-top-right-radius: {AppStyles.BORDER_RADIUS};
            }}
            QTabBar::tab:selected {{
                background-color: {accent_color};
                color: {'white' if theme == "dark" else AppStyles.LIGHT_BACKGROUND_CONTROLS}; /* Poprawiony kolor tekstu dla jasnego motywu */
                /* border-bottom: 1px solid {accent_color}; */ /* Usuwamy, bo pane ma border-top */
            }}
            QTabBar::tab:!selected {{
                background-color: {main_bg if theme == "dark" else AppStyles.LIGHT_BACKGROUND_MAIN};
                 /* margin-top: 2px; */ /* Można usunąć dla płaskiego wyglądu */
            }}
            QTabBar::tab:hover:!selected {{
                background-color: {AppStyles.DARK_BACKGROUND_HOVER if theme == "dark" else AppStyles.LIGHT_BACKGROUND_HOVER};
            }}
        """

    def setup_ui(self):
        main_layout = QVBoxLayout(self)

        self.instruction_label = QLabel("Wpisz symbol lub wybierz z poniższych zakładek")
        self.instruction_label.setStyleSheet("color: gray; font-style: italic;")
        self.instruction_label.setFont(self.parent_font)
        main_layout.addWidget(self.instruction_label)

        input_layout = QHBoxLayout()
        self.input_label = QLabel("Symbol:")
        self.input_label.setFont(self.parent_font)

        self.symbol_input = QLineEdit()
        self.symbol_input.setMaxLength(5)
        font = QFont(self.parent_font)
        font.setBold(True)
        font.setPointSize(font.pointSize() + 2)
        self.symbol_input.setFont(font)
        self.symbol_input.textChanged.connect(self.on_symbol_input_changed)
        self.symbol_input.returnPressed.connect(self.check_and_accept)
        input_layout.addWidget(self.input_label)
        input_layout.addWidget(self.symbol_input)
        main_layout.addLayout(input_layout)

        self.tabs = QTabWidget()
        self.tabs.setFont(self.parent_font)

        # Dynamiczne tworzenie zakładek na podstawie ustawień z bazy
        self.valid_symbols.clear()
        symbol_categories = app_settings.SYMBOL_CATEGORIES

        # Tworzy wszystkie zakładki, a uprawnienia są sprawdzane dla każdego przycisku osobno
        for category_name, symbols_dict in symbol_categories.items():
            symbols_list = list(symbols_dict.items())
            self.add_tab_with_symbols(symbols_list, category_name)
            # Dodaje wszystkie symbole do listy walidacji (dla wpisywania ręcznego)
            for symbol_key in symbols_dict.keys():
                self.valid_symbols.add(symbol_key)

        buttons_layout = QHBoxLayout()
        self.cancel_button = QPushButton("Anuluj")
        self.cancel_button.setFont(self.parent_font)
        self.cancel_button.clicked.connect(self.reject)

        self.validation_label = QLabel("")
        self.validation_label.setFont(self.parent_font)

        buttons_layout.addWidget(self.validation_label)
        buttons_layout.addStretch()
        buttons_layout.addWidget(self.cancel_button)

        main_layout.addWidget(self.tabs)
        main_layout.addLayout(buttons_layout)
        self.symbol_input.setFocus()

    def add_tab_with_symbols(self, symbols, tab_name):
        """Dodaje zakładkę z symbolami, uwzględniając uprawnienia i tryb DTN."""
        tab = QWidget()
        tab_layout = QGridLayout(tab)
        tab_layout.setSpacing(5)

        for idx, (symbol, desc) in enumerate(symbols):
            button = QPushButton(symbol)
            button.setFont(self.parent_font)
            button.setProperty("symbol", symbol)
            button.setFocusPolicy(Qt.NoFocus)
            button.clicked.connect(self.on_symbol_button_clicked)

            # --- ZMIENIONA LOGIKA: Sprawdzanie uprawnień do symbolu ---
            is_generally_allowed = app_settings.has_symbol_permission(self.user_role, symbol)

            # Jeśli jest w trybie "tylko CO dla DTN", zablokuj wszystko oprócz CO
            if self.dtn_co_only_mode:
                if symbol.upper() == 'CO' and is_generally_allowed:
                    button.setEnabled(True)
                    button.setToolTip(desc)
                else:
                    button.setEnabled(False)
                    button.setToolTip(f"Dla wydziału DTN dozwolony jest tylko symbol 'CO'.")
            # W przeciwnym razie, działaj jak dotychczas
            elif is_generally_allowed:
                button.setEnabled(True)
                button.setToolTip(desc)
            else:
                button.setEnabled(False)
                button.setToolTip(f"{desc}\n(Brak uprawnień dla Twojej roli)")
            # --- KONIEC ZMIENIONEJ LOGIKI ---

            row = idx // 4
            col = idx % 4
            tab_layout.addWidget(button, row, col)

        tab_layout.addItem(QSpacerItem(10, 10, QSizePolicy.Expanding, QSizePolicy.Expanding), (len(symbols) // 4) + 1,
                           0, 1, 4)
        self.tabs.addTab(tab, tab_name)

    def on_symbol_button_clicked(self):
        """Obsługuje kliknięcie przycisku z symbolem"""
        button = self.sender()  # Pobierz obiekt, który wysłał sygnał
        if button:
            symbol = button.property("symbol")
            if symbol:
                self.accept_symbol(symbol)

    def on_symbol_input_changed(self, text):
        """Obsługuje zmianę symbolu wpisanego z klawiatury"""
        # Konwersja do dużych liter
        uppercase_text = text.upper()
        if text != uppercase_text:
            # Blokuj sygnał, aby uniknąć nieskończonej pętli
            self.symbol_input.blockSignals(True)
            self.symbol_input.setText(uppercase_text)
            self.symbol_input.blockSignals(False)

        self.selected_symbol = uppercase_text.strip()

        # Sprawdź, czy symbol jest na liście dostępnych
        if self.selected_symbol:
            if self.selected_symbol in self.valid_symbols:
                self.validation_label.setText("Symbol prawidłowy")
                self.validation_label.setStyleSheet("color: green;")
            else:
                self.validation_label.setText("Symbol niedostępny!")
                self.validation_label.setStyleSheet("color: red;")
        else:
            self.validation_label.setText("")

    def accept_symbol(self, symbol):
        """Akceptuje symbol i zamyka dialog"""
        self.selected_symbol = symbol

        # Blokuj sygnał, aby uniknąć wywołania on_symbol_input_changed
        self.symbol_input.blockSignals(True)
        self.symbol_input.setText(symbol)
        self.symbol_input.blockSignals(False)

        # Aktualizuj etykietę walidacji
        self.validation_label.setText("Symbol prawidłowy")
        self.validation_label.setStyleSheet("color: green;")

        # Wywołaj metodę sprawdzającą
        self.check_and_accept()

    def check_and_accept(self):
        """Sprawdza symbol i uprawnienia przed zamknięciem okna."""
        # --- POCZĄTEK ZMIANY: Dodatkowa walidacja uprawnień ---
        if self.selected_symbol and self.selected_symbol in self.valid_symbols:
            if app_settings.has_symbol_permission(self.user_role, self.selected_symbol):
                super().accept()
            else:
                QMessageBox.warning(self, "Brak uprawnień",
                                    f"Twoja rola ('{self.user_role}') nie ma uprawnień do użycia symbolu '{self.selected_symbol}'.",
                                    QMessageBox.Ok)
        # --- KONIEC ZMIANY ---
        elif self.selected_symbol:
            QMessageBox.warning(self, "Nieprawidłowy symbol",
                                f"Symbol '{self.selected_symbol}' nie jest poprawnym symbolem.", QMessageBox.Ok)
        else:
            QMessageBox.warning(self, "Brak symbolu", "Proszę wpisać lub wybrać symbol.", QMessageBox.Ok)

            self.selected_symbol = ""
            self.symbol_input.setText("")
            self.symbol_input.setFocus()

    def get_selected_symbol(self):
        """Zwraca wybrany symbol"""
        return self.selected_symbol


class ReasonDialog(QDialog):
    """Prosty dialog do wpisania i pobrania powodu zmiany."""

    def __init__(self, parent=None, user_name: str = ""):
        super().__init__(parent)
        self.is_dark_theme = (parent.determined_theme == 'dark')
        self.setWindowTitle("Powód zmiany lokalizacji")
        self.setMinimumWidth(350)

        layout = QVBoxLayout(self)

        if user_name:
            user_label = QLabel(f"<b>Pracownik:</b> {user_name}")
            layout.addWidget(user_label)

        layout.addWidget(QLabel("Proszę podać powód zmiany lokalizacji:"))

        self.reason_input = QLineEdit("Na prośbę doradcy")
        layout.addWidget(self.reason_input)

        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

        self.apply_styles()

    def getReason(self):
        return self.reason_input.text()

    def apply_styles(self):
        theme = "dark" if self.is_dark_theme else "light"
        self.setStyleSheet(AppStyles.get_dialog_style(theme))
        for button in self.button_box.buttons():
            button.setStyleSheet(AppStyles.get_button_style(theme))
        self.reason_input.setStyleSheet(AppStyles.get_line_edit_style(theme))


class ScheduleChangeDialog(QDialog):
    """
    Dialog do edycji zmian w grafiku. W tej wersji pełni rolę wyłącznie
    prezentacyjną, emitując sygnał z danymi do przetworzenia przez okno nadrzędne.
    """
    # NOWY SYGNAŁ: Emituje listę słowników ze zmianami do przetworzenia.
    changes_requested = Signal(list)

    def __init__(self, parent=None, grouped_cells=None, year=None, month=None, main_window=None):
        super().__init__(parent)
        self.parent_widget = parent
        self.main_window = main_window # Zapisujemy referencję do okna głównego
        self.determined_theme = "dark"
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            self.determined_theme = "dark" if self.parent_widget.is_dark_theme else "light"
        self.setWindowTitle("Wstaw zmianę grafiku")
        self.setMinimumWidth(1100)
        self.setMinimumHeight(600)
        self.grouped_cells = grouped_cells
        self.year = year
        self.month = month
        self.flattened_cells = self.flatten_grouped_cells(grouped_cells)
        self.user_role = getattr(self.parent_widget, 'current_user_role', "Użytkownik")
        self.default_button_style = AppStyles.get_button_style(self.determined_theme)
        self.reason_cache = {}
        self.setup_ui()
        self.apply_dialog_theme()

    def apply_dialog_theme(self):
        """Stosuje motyw do wszystkich elementów okna dialogowego."""
        actual_theme = self.determined_theme
        self.setStyleSheet(AppStyles.get_dialog_style(actual_theme))

        # Pobierz style z centralnej klasy
        button_style = AppStyles.get_button_style(actual_theme)
        combobox_style = AppStyles.get_combobox_style(actual_theme)
        checkbox_style = AppStyles.get_checkbox_style(actual_theme)

        # Styl dla panelu "Zastosuj dla wszystkich"
        if hasattr(self, 'all_time_button'):
            self.all_time_button.setStyleSheet(button_style)
            self.all_hours_button.setStyleSheet(button_style)
            self.all_location_combo.setStyleSheet(combobox_style)
            self.apply_location_check.setStyleSheet(checkbox_style)
            self.apply_time_check.setStyleSheet(checkbox_style)
            self.apply_hours_check.setStyleSheet(checkbox_style)

            # --- POPRAWKA: Bezpośrednie odwołanie do przycisku ---
            if hasattr(self, 'apply_all_button'):
                self.apply_all_button.setStyleSheet(button_style)
            # --- KONIEC POPRAWKI ---

        # --- POPRAWKA: Dodano styl dla przycisku "Zatwierdź wszystkie zmiany" ---
        if hasattr(self, 'apply_all_rows_button'):
            self.apply_all_rows_button.setStyleSheet(button_style)
        # --- KONIEC POPRAWKI ---

        # Styl dla przycisku "Zamknij"
        if hasattr(self, 'close_button'):
            self.close_button.setStyleSheet(button_style)

        # Style dla kontrolek w tabeli
        if hasattr(self, 'cells_table'):
            self.cells_table.setStyleSheet(AppStyles.get_tablewidget_style(actual_theme))
            for row in range(self.cells_table.rowCount()):
                for col_idx in [4, 5, 6, 7]:
                    widget = self.cells_table.cellWidget(row, col_idx)
                    if isinstance(widget, QComboBox):
                        widget.setStyleSheet(combobox_style)
                    elif isinstance(widget, QPushButton):
                        widget.setStyleSheet(button_style)

    def flatten_grouped_cells(self, grouped_cells):
        flattened = []
        if not grouped_cells: return flattened
        for user_id, dates in grouped_cells.items():
            for date, cells in dates.items():
                flattened.extend(cells)
        return flattened

    def _create_apply_all_group(self):
        group = QGroupBox("Zastosuj dla wszystkich (z uwzględnieniem uprawnień)")
        layout = QHBoxLayout()
        group.setLayout(layout)

        # Lokalizacja
        self.apply_location_check = QCheckBox("Lokalizacja:")
        layout.addWidget(self.apply_location_check)
        self.all_location_combo = QComboBox()
        self.all_location_combo.addItem("SBC (s)", "s")
        self.all_location_combo.addItem("Przystanek (p)", "p")
        self.all_location_combo.addItem("HomeOffice (h)", "h")
        layout.addWidget(self.all_location_combo)
        layout.addSpacing(15)

        # Godzina rozpoczęcia
        self.apply_time_check = QCheckBox("Godzina rozp.:")
        layout.addWidget(self.apply_time_check)
        self.all_time_button = QPushButton("Wybierz")
        self.all_time_button.setProperty("field_type", "hour")
        self.all_time_button.clicked.connect(self.show_digit_selection)  # <-- Ujednolicony sposób
        layout.addWidget(self.all_time_button)
        layout.addSpacing(15)

        # Liczba godzin
        self.apply_hours_check = QCheckBox("Liczba godzin:")
        layout.addWidget(self.apply_hours_check)
        self.all_hours_button = QPushButton("Wybierz")
        self.all_hours_button.setProperty("field_type", "hours")
        self.all_hours_button.clicked.connect(self.show_digit_selection)  # <-- Ujednolicony sposób
        layout.addWidget(self.all_hours_button)

        layout.addStretch()

        self.apply_all_button = QPushButton("Wstaw dla wszystkich")
        self.apply_all_button.clicked.connect(self._apply_all_changes)
        layout.addWidget(self.apply_all_button)

        return group

    def setup_ui(self):
        main_layout = QVBoxLayout(self)
        apply_all_group = self._create_apply_all_group()
        main_layout.addWidget(apply_all_group)
        self.cells_table = QTableWidget()
        self.cells_table.setColumnCount(9)
        self.cells_table.setHorizontalHeaderLabels(
            ["Data", "Dzień tyg.", "Użytkownik", "Symbol", "Lokalizacja", "Godzina rozp.", "Liczba godzin", "Akcje",
             "Status"])
        self.cells_table.setSortingEnabled(True)
        self.cells_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.cells_table.horizontalHeader().setStretchLastSection(True)
        self.cells_table.setRowCount(len(self.flattened_cells))

        for row, cell in enumerate(self.flattened_cells):
            permissions = self.parent_widget._get_permission_for_cell(cell)
            date_str = cell.get('date_str', '')
            date_item = DateTableWidgetItem(date_str)
            date_item.setFlags(date_item.flags() & ~Qt.ItemIsEditable)
            date_item.setData(Qt.UserRole, row)
            self.cells_table.setItem(row, 0, date_item)
            qdate_obj = QDate.fromString(date_str, "yyyy-MM-dd")
            day_name_item = DayOfWeekItem(qdate_obj)
            day_name_item.setFlags(day_name_item.flags() & ~Qt.ItemIsEditable)
            day_name_item.setTextAlignment(Qt.AlignCenter)
            self.cells_table.setItem(row, 1, day_name_item)
            user_name = cell.get('uzytkownik_dane', 'Nieznany')
            self.cells_table.setItem(row, 2, QTableWidgetItem(user_name))
            self.cells_table.item(row, 2).setFlags(self.cells_table.item(row, 2).flags() & ~Qt.ItemIsEditable)
            symbol = cell.get('symbol', '')
            self.cells_table.setItem(row, 3, QTableWidgetItem(symbol))
            self.cells_table.item(row, 3).setFlags(self.cells_table.item(row, 3).flags() & ~Qt.ItemIsEditable)

            from symbol_parser import parse_symbol
            parsed_symbol = parse_symbol(symbol)
            is_empty_cell = parsed_symbol.get('work_hours') is None

            location_code = parsed_symbol.get('location')
            if not location_code:
                if is_empty_cell:
                    if self.main_window:
                        location_code = self.main_window.determine_correct_location(cell)
                    else:
                        location_code = cell.get('lokalizacja_domyslna')
                else:
                    location_code = cell.get('lokalizacja_domyslna')

            # --- NOWA LOGIKA: Sprawdzenie, czy symbol może mieć lokalizację ---
            special_symbol = parsed_symbol.get('special_symbol')
            symbol_accepts_location = True
            if special_symbol and special_symbol.upper() not in app_settings.WORK_LIKE_SYMBOLS:
                symbol_accepts_location = False
            # --- KONIEC NOWEJ LOGIKI ---

            can_edit_location_by_permission = permissions['can_edit_location']
            cell_date = QDate.fromString(date_str, "yyyy-MM-dd")
            if self.user_role == 'Lider' and cell_date < QDate.currentDate():
                can_edit_location_by_permission = False

            start_hour = parsed_symbol.get('start_hour')
            parsed_hours = parsed_symbol.get('work_hours')
            work_hours = int(float(parsed_hours if parsed_hours is not None else cell.get('etat', 8.0)))

            location_combo = QComboBox()
            location_combo.addItem("SBC (s)", "s")
            location_combo.addItem("mPrzystanek (p)", "p")
            location_combo.addItem("HomeOffice (h)", "h")

            if location_code and location_code in ['h', 's', 'p']:
                location_combo.setCurrentIndex({'s': 0, 'p': 1, 'h': 2}.get(location_code))
            else:
                location_combo.setCurrentIndex(-1)

            # ZMIANA: Złożony warunek do włączenia/wyłączenia comboboxa
            location_combo.setEnabled(can_edit_location_by_permission and symbol_accepts_location)
            if not symbol_accepts_location:
                location_combo.clear()  # Wyczyść opcje, jeśli symbol nie przyjmuje lokalizacji

            self.cells_table.setCellWidget(row, 4, location_combo)

            # Reszta logiki wiersza bez zmian
            time_button = QPushButton(str(start_hour) if start_hour is not None else "")
            time_button.setProperty("cell_index", row)
            time_button.setProperty("field_type", "hour")
            time_button.clicked.connect(self.show_digit_selection)
            time_button.setEnabled(permissions['can_edit_hours'])
            self.cells_table.setCellWidget(row, 5, time_button)

            hours_button = QPushButton(str(work_hours))
            hours_button.setProperty("cell_index", row)
            hours_button.setProperty("field_type", "hours")
            hours_button.clicked.connect(self.show_digit_selection)
            hours_button.setEnabled(permissions['can_edit_hours'])
            self.cells_table.setCellWidget(row, 6, hours_button)

            apply_button = QPushButton("Zastosuj")
            apply_button.setProperty("cell_index", row)
            apply_button.clicked.connect(self.apply_change_by_index)
            apply_button.setEnabled(any(permissions.values()) and start_hour is not None)
            self.cells_table.setCellWidget(row, 7, apply_button)

            status_item = QTableWidgetItem("")
            status_item.setFlags(status_item.flags() & ~Qt.ItemIsEditable)
            status_item.setTextAlignment(Qt.AlignCenter)
            self.cells_table.setItem(row, 8, status_item)

        # Pozostała część metody `setup_ui` bez zmian
        main_layout.addWidget(self.cells_table)
        button_layout = QHBoxLayout()
        self.close_button = QPushButton("Zamknij")
        self.close_button.clicked.connect(self.close)
        self.apply_all_rows_button = QPushButton("Zatwierdź wszystkie zmiany")
        self.apply_all_rows_button.clicked.connect(self._apply_all_pending_changes)
        button_layout.addStretch()
        button_layout.addWidget(self.apply_all_rows_button)
        button_layout.addWidget(self.close_button)
        main_layout.addLayout(button_layout)
        self.cells_table.sortByColumn(0, Qt.AscendingOrder)

    def show_digit_selection(self):
        target_button = self.sender()
        if not target_button: return
        field_type = target_button.property("field_type")
        is_hour = (field_type == "hour")
        values = list(range(24)) if is_hour else list(range(1, 14))
        title = "Wybierz godzinę rozp." if is_hour else "Wybierz liczbę godzin"

        dialog = DigitSelectionDialog(self, title, values, current_theme=self.determined_theme)
        if dialog.exec() == QDialog.Accepted:
            selected_value = dialog.get_selected_value()

            # --- POCZĄTEK POPRAWKI: Logika włączania/wyłączania przycisku "Zastosuj" ---
            # Ustaw tekst przycisku (pusty, jeśli wyczyszczono)
            target_button.setText(str(selected_value) if selected_value is not None else "")

            # Jeśli zmieniano godzinę rozpoczęcia, zaktualizuj stan przycisku "Zastosuj"
            if is_hour:
                row = target_button.property("cell_index")
                if row is not None:
                    apply_button = self.cells_table.cellWidget(row, 7)
                    if apply_button:
                        # Sprawdź, czy użytkownik nadal ma ogólne uprawnienia
                        original_index = self.cells_table.item(row, 0).data(Qt.UserRole)
                        cell_data = self.flattened_cells[original_index]
                        permissions = self.parent_widget._get_permission_for_cell(cell_data)

                        # Włącz przycisk tylko, jeśli są uprawnienia ORAZ wybrano godzinę
                        apply_button.setEnabled(any(permissions.values()) and selected_value is not None)
            # --- KONIEC POPRAWKI ---

    def format_date(self, date_str):
        try:
            year, month, day = date_str.split('-')
            return f"{day}.{month}.{year}"
        except:
            return date_str

    def _reset_button_state(self, button: QPushButton):
        """Przywraca domyślny wygląd i stan przycisku 'Zastosuj'."""
        if button:
            button.setText("Zastosuj")
            button.setStyleSheet(self.default_button_style)
            button.setEnabled(True)

    def _update_row_widgets_from_global_settings(self, visual_row: int):
        """Aktualizuje kontrolki w danym wierszu na podstawie globalnych ustawień 'Wstaw dla wszystkich'."""
        item = self.cells_table.item(visual_row, 0)
        if not item: return
        original_data_index = item.data(Qt.UserRole)
        cell_data = self.flattened_cells[original_data_index]
        permissions = self.parent_widget._get_permission_for_cell(cell_data)

        # Logika sprawdzania daty dla Lidera (bez zmian)
        can_apply_location_by_date = True
        if self.user_role == 'Lider' and self.apply_location_check.isChecked():
            cell_date = QDate.fromString(cell_data.get('date_str', ''), "yyyy-MM-dd")
            if cell_date.isValid() and cell_date < QDate.currentDate():
                can_apply_location_by_date = False

        # --- NOWA LOGIKA: Sprawdzenie, czy symbol w komórce może mieć lokalizację ---
        symbol_can_have_location = False
        parsed_symbol = parse_symbol(cell_data.get('symbol', ''))
        special_symbol = parsed_symbol.get('special_symbol')

        # Lokalizację można ustawić, jeśli nie ma symbolu specjalnego (jest to zmiana robocza)
        # lub jeśli symbol specjalny jest na liście symboli pracujących.
        if not special_symbol or special_symbol.upper() in app_settings.WORK_LIKE_SYMBOLS:
            symbol_can_have_location = True
        # --- KONIEC NOWEJ LOGIKI ---

        # ZMIANA: Dodano `and symbol_can_have_location` do warunku
        if self.apply_location_check.isChecked() and permissions[
            'can_edit_location'] and can_apply_location_by_date and symbol_can_have_location:
            combo = self.cells_table.cellWidget(visual_row, 4)
            new_location = self.all_location_combo.currentData()
            combo.setCurrentIndex(combo.findData(new_location))

        # Pozostała część metody bez zmian
        if self.apply_time_check.isChecked() and permissions['can_edit_hours']:
            time_btn = self.cells_table.cellWidget(visual_row, 5)
            new_start_hour = self.all_time_button.text()
            time_btn.setText(new_start_hour)
            apply_button = self.cells_table.cellWidget(visual_row, 7)
            if apply_button:
                apply_button.setEnabled(bool(new_start_hour) and any(permissions.values()))

        if self.apply_hours_check.isChecked() and permissions['can_edit_hours']:
            hours_btn = self.cells_table.cellWidget(visual_row, 6)
            new_work_hours = self.all_hours_button.text()
            hours_btn.setText(new_work_hours)

    def apply_change_by_index(self):
        """
        Obsługuje kliknięcie przycisku 'Zastosuj' dla pojedynczego wiersza.
        Najpierw zarządza logiką wyjątków, a potem emituje żądanie zmiany grafiku.
        """
        button = self.sender()
        if not button: return

        visual_row = button.property("cell_index")
        if visual_row is None: return

        # Przygotuj żądanie (to sprawdza, czy faktycznie są jakieś zmiany)
        change_request = self._prepare_change_request_for_row(visual_row)
        if not change_request:
            # _prepare_change_request_for_row samo ustawi status "Brak zmiany"
            return

        # Sprawdź, czy lokalizacja się zmieniła
        original_cell_data = change_request['cell_data']
        parsed_original = parse_symbol(original_cell_data.get('symbol', ''))
        original_location = parsed_original.get('location') or original_cell_data.get('lokalizacja_domyslna', 'h')
        new_location = change_request['new_location_code']  # Ten klucz będzie teraz obecny

        location_changed = original_location != new_location

        if location_changed:
            user_name = original_cell_data.get('uzytkownik_dane', '')
            reason_dialog = ReasonDialog(self, user_name=user_name)
            if reason_dialog.exec() == QDialog.Accepted:
                reason = reason_dialog.getReason()
                result = self.main_window._handle_location_change_logic(original_cell_data, new_location, reason)
                if not result.get('success'):
                    self.update_status_for_row(visual_row, 'failure', result.get('message'))
                    return  # Przerwij operację, jeśli zarządzanie wyjątkiem się nie powiodło
            else:
                self.update_status_for_row(visual_row, 'failure', "Anulowano")
                return  # Użytkownik anulował wprowadzanie powodu

        # Jeśli wszystko poszło dobrze, wyślij żądanie aktualizacji grafiku
        self.changes_requested.emit([change_request])
        button.setEnabled(False)
        button.setText("Wysyłanie...")
        QApplication.processEvents()

    def _prepare_change_request_for_row(self, visual_row_index: int) -> dict | None:
        """
        Sprawdza, czy faktycznie nastąpiła zmiana i przygotowuje słownik z żądaniem.
        Porównuje wartości z widgetów do aktualnego stanu komórki, poprawnie obsługując symbole specjalne.
        """
        try:
            item_w_danych = self.cells_table.item(visual_row_index, 0)
            original_data_index = item_w_danych.data(Qt.UserRole)
            identifying_cell_data = self.flattened_cells[original_data_index]

            current_symbol_in_table = self.cells_table.item(visual_row_index, 3).text()
            parsed = parse_symbol(current_symbol_in_table)

            previous_loc = parsed.get('location') or identifying_cell_data.get('lokalizacja_domyslna', 'h')
            previous_start = parsed.get('start_hour')
            previous_hours = parsed.get('work_hours')

            if previous_hours is None:
                if current_symbol_in_table:
                    previous_hours = int(float(identifying_cell_data.get('etat', 8.0)))
                else:
                    hours_button_widget = self.cells_table.cellWidget(visual_row_index, 6)
                    previous_hours = int(hours_button_widget.text())

            location_combo = self.cells_table.cellWidget(visual_row_index, 4)
            time_button = self.cells_table.cellWidget(visual_row_index, 5)
            hours_button = self.cells_table.cellWidget(visual_row_index, 6)

            if not time_button.text() and not parsed.get('special_symbol'):
                self.update_status_for_row(visual_row_index, 'failure', "Brak godziny!")
                return None

            new_loc = location_combo.currentData()
            new_start = int(time_button.text()) if time_button.text() else None
            new_hours = int(hours_button.text())

            symbol_can_have_location = True
            special_symbol = parsed.get('special_symbol')
            if special_symbol and special_symbol.upper() not in app_settings.WORK_LIKE_SYMBOLS:
                symbol_can_have_location = False

            location_is_same = True
            if symbol_can_have_location:
                location_is_same = (previous_loc == new_loc)

            if location_is_same and previous_start == new_start and previous_hours == new_hours:
                self.update_status_for_row(visual_row_index, 'no_change')
                return None

            final_location_for_build = new_loc if symbol_can_have_location else None
            from symbol_parser import build_symbol
            new_symbol = build_symbol(
                location=final_location_for_build,
                start_hour=new_start,
                work_hours=new_hours,
                special_symbol=special_symbol
            )

            # ZMIANA: Dodano brakujące klucze do zwracanego słownika
            return {
                'cell_data': identifying_cell_data,
                'nr_kadrowy': identifying_cell_data.get('nr_kadrowy'),
                'rok': self.year,
                'miesiac': self.month,
                'data': identifying_cell_data.get('date_str'),
                'symbol': new_symbol,
                'user_id': identifying_cell_data.get('uzytkownik_id'),
                'user_name': identifying_cell_data.get('uzytkownik_dane'),
                'visual_row': visual_row_index,
                'new_location_code': new_loc,
                'new_start_hour': new_start,
                'new_work_hours': new_hours
            }
        except Exception as e:
            self.update_status_for_row(visual_row_index, 'failure', str(e))
            log_error(f"Błąd podczas przygotowywania żądania zmiany: {e}", exception=e)
            return None

    def refresh_row_data_from_model(self, visual_row: int, returned_symbol: str):
        """
        Pobiera najświeższe dane z modelu głównego okna i w pełni aktualizuje
        zarówno wewnętrzny stan, jak i kontrolki dla danego wiersza w dialogu.
        """
        try:
            debug_print(f"--- Dialog.refresh_row_data: Rozpoczynam odświeżanie wiersza {visual_row}")
            original_data_index = self.cells_table.item(visual_row, 0).data(Qt.UserRole)
            identifying_data = self.flattened_cells[original_data_index]
            user_id = identifying_data.get('uzytkownik_id')
            date_str = identifying_data.get('date_str')

            fresh_cell_data = self.main_window.get_data_from_model_by_id(user_id, date_str)
            if not fresh_cell_data:
                log_error(f"Nie udało się pobrać świeżych danych dla wiersza {visual_row}.")
                # Mimo wszystko zaktualizuj symbol na podstawie tego, co zwróciła procedura
                self.cells_table.item(visual_row, 3).setText(returned_symbol)
                return

            # Zaktualizuj wewnętrzną pamięć dialogu
            self.flattened_cells[original_data_index] = fresh_cell_data
            debug_print(f"--- Dialog.refresh_row_data: Wewnętrzna pamięć dla wiersza {visual_row} zaktualizowana.")

            # Zaktualizuj wszystkie kontrolki w wierszu na podstawie świeżych danych
            self.cells_table.item(visual_row, 3).setText(fresh_cell_data.get('symbol', ''))

            location_combo = self.cells_table.cellWidget(visual_row, 4)
            parsed = parse_symbol(fresh_cell_data.get('symbol', ''))
            loc_code = parsed.get('location') or fresh_cell_data.get('lokalizacja_domyslna', 'h')
            if loc_code and location_combo:
                index = location_combo.findData(loc_code)
                if index != -1:
                    location_combo.setCurrentIndex(index)

            time_button = self.cells_table.cellWidget(visual_row, 5)
            start_hour = fresh_cell_data.get('start_hour')
            if time_button: time_button.setText(str(start_hour) if start_hour is not None else "")

            hours_button = self.cells_table.cellWidget(visual_row, 6)
            work_hours = fresh_cell_data.get('hours')
            if work_hours is None:
                work_hours = int(float(fresh_cell_data.get('etat', 8.0)))
            if hours_button: hours_button.setText(str(work_hours))

            debug_print(f"--- Dialog.refresh_row_data: Pomyślnie odświeżono kontrolki dla wiersza {visual_row}.")

        except Exception as e:
            log_error(f"Błąd w refresh_row_data_from_model: {e}", exception=e)

    def _apply_all_pending_changes(self):
        """
        Zbiera wszystkie oczekujące zmiany, zarządza logiką wyjątków lokalizacyjnych,
        a następnie emituje je razem do wykonania asynchronicznego.
        """
        reply = QMessageBox.question(self, "Potwierdzenie",
                                     "Czy na pewno chcesz zatwierdzić wszystkie wprowadzone zmiany w tabeli?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if reply == QMessageBox.No:
            return

        all_change_requests = []
        reason_cache = {}  # Cache dla powodów zmian dla danego użytkownika

        for row in range(self.cells_table.rowCount()):
            # Krok 1: Przygotuj żądanie (to sprawdza, czy faktycznie jest jakakolwiek zmiana)
            change_request = self._prepare_change_request_for_row(row)
            if not change_request:
                continue

            # Krok 2: Zarządzaj logiką wyjątków lokalizacyjnych (logika skopiowana z _apply_all_changes)
            cell_data = change_request['cell_data']
            user_id = cell_data.get('uzytkownik_id')
            user_name = cell_data.get('uzytkownik_dane', '')
            parsed_original = parse_symbol(cell_data.get('symbol', ''))
            original_location = parsed_original.get('location') or cell_data.get('lokalizacja_domyslna', 'h')
            new_location = change_request['new_location_code']

            location_changed = original_location != new_location

            if location_changed:
                reason = None
                # Jeśli zmiana nie jest na domyślną, zapytaj o powód (tylko raz na użytkownika)
                if new_location != cell_data.get('lokalizacja_domyslna', 'h'):
                    if user_id not in reason_cache:
                        reason_dialog = ReasonDialog(self, user_name=user_name)
                        if reason_dialog.exec() == QDialog.Accepted:
                            reason = reason_dialog.getReason()
                            reason_cache[user_id] = reason
                        else:
                            # Jeśli użytkownik anuluje, przerwij całą operację masową
                            QMessageBox.information(self, "Anulowano", "Operacja masowego zatwierdzania została przerwana.")
                            return
                    else:
                        reason = reason_cache[user_id]

                # Wywołaj logikę zarządzania wyjątkiem
                result = self.main_window._handle_location_change_logic(cell_data, new_location, reason)
                if not result.get('success'):
                    self.update_status_for_row(row, 'failure', result.get('message'))
                    continue  # Pomiń ten wiersz i przejdź do następnego

            # Krok 3: Jeśli wszystko się udało, dodaj do listy i zaktualizuj przycisk
            all_change_requests.append(change_request)
            button = self.cells_table.cellWidget(row, 7)
            if button:
                button.setEnabled(False)
                button.setText("W kolejce...")

        # Krok 4: Wyślij wszystkie zebrane żądania do przetworzenia
        if all_change_requests:
            self.changes_requested.emit(all_change_requests)
            QApplication.processEvents()
        else:
            QMessageBox.information(self, "Informacja", "Nie wykryto żadnych zmian do zatwierdzenia.")

    def _prepare_and_emit_change_for_row(self, visual_row_index: int):
        """
        Zbiera dane, sprawdza czy nastąpiła zmiana i emituje sygnał.
        """
        button = self.cells_table.cellWidget(visual_row_index, 7)
        status_item = self.cells_table.item(visual_row_index, 8)
        if not button or not button.isEnabled(): return

        try:
            item = self.cells_table.item(visual_row_index, 0)
            if not item: raise ValueError("Brak danych w wierszu.")

            original_data_index = item.data(Qt.UserRole)
            cell_data = self.flattened_cells[original_data_index]

            location_combo = self.cells_table.cellWidget(visual_row_index, 4)
            time_button = self.cells_table.cellWidget(visual_row_index, 5)
            hours_button = self.cells_table.cellWidget(visual_row_index, 6)

            if not time_button.text():
                self.update_status_for_row(visual_row_index, 'failure', "Brak godziny!")
                return

            # --- ZMIANA 1: Logika porównawcza ---
            parsed = parse_symbol(cell_data.get('symbol', ''))
            original_loc = parsed.get('location') or cell_data.get('lokalizacja_domyslna', 'h')
            original_start = parsed.get('start_hour')
            original_hours = parsed.get('work_hours')
            if original_hours is None:
                original_hours = int(float(cell_data.get('etat', 8.0)))

            new_loc = location_combo.currentData()
            new_start = int(time_button.text())
            new_hours = int(hours_button.text())

            if original_loc == new_loc and original_start == new_start and original_hours == new_hours:
                self.update_status_for_row(visual_row_index, 'no_change')
                return  # Zakończ, jeśli nie ma zmian
            # --- Koniec ZMIANY 1 ---

            change_request = {
                'cell_data': cell_data,
                'new_location_code': new_loc,
                'new_start_hour': new_start,
                'new_work_hours': new_hours,
                'visual_row': visual_row_index
            }

            self.changes_requested.emit([change_request])
            button.setEnabled(False);
            button.setText("Wysyłanie...")
            QApplication.processEvents()

        except Exception as e:
            self.update_status_for_row(visual_row_index, 'failure', str(e))
            log_error(f"Błąd podczas przygotowywania żądania zmiany: {e}", exception=e)

    def _apply_all_changes(self):
        """
        Implementuje Fazę 1 (Przygotowanie) dla masowej, asynchronicznej aktualizacji.
        Zbiera wszystkie dane, zarządza wyjątkami lokalizacyjnymi, a następnie emituje sygnał.
        """
        if not any([self.apply_location_check.isChecked(), self.apply_time_check.isChecked(),
                    self.apply_hours_check.isChecked()]):
            QMessageBox.warning(self, "Brak wyboru", "Proszę zaznaczyć, które atrybuty chcesz zastosować.")
            return

        reply = QMessageBox.question(self, "Potwierdzenie",
                                     "Czy na pewno chcesz zastosować zmiany dla wszystkich wierszy?\n"
                                     "Operacja zostanie wykonana w tle.",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.No:
            return

        all_change_requests = []
        reason_cache = {}

        # --- FAZA 1: PRZYGOTOWANIE ---
        for row in range(self.cells_table.rowCount()):
            # Krok 1: Zastosuj globalne ustawienia do kontrolek w wierszu
            self._update_row_widgets_from_global_settings(row)

            # Krok 2: Przygotuj żądanie (to sprawdza, czy jest jakakolwiek zmiana)
            change_request = self._prepare_change_request_for_row(row)
            if not change_request:
                continue

            # Krok 3: Zarządzaj logiką wyjątków lokalizacyjnych
            cell_data = change_request['cell_data']
            user_id = cell_data.get('uzytkownik_id')
            user_name = cell_data.get('uzytkownik_dane', '')
            parsed_original = parse_symbol(cell_data.get('symbol', ''))
            original_location = parsed_original.get('location') or cell_data.get('lokalizacja_domyslna', 'h')
            new_location = change_request['new_location_code']

            location_changed = original_location != new_location

            if location_changed:
                reason = None
                # Jeśli zmiana nie jest na domyślną, zapytaj o powód (tylko raz na użytkownika)
                if new_location != cell_data.get('lokalizacja_domyslna', 'h'):
                    if user_id not in reason_cache:
                        reason_dialog = ReasonDialog(self, user_name=user_name)
                        if reason_dialog.exec() == QDialog.Accepted:
                            reason = reason_dialog.getReason()
                            reason_cache[user_id] = reason
                        else:
                            QMessageBox.information(self, "Anulowano", "Operacja masowa została przerwana.")
                            return
                    else:
                        reason = reason_cache[user_id]

                result = self.main_window._handle_location_change_logic(cell_data, new_location, reason)
                if not result.get('success'):
                    self.update_status_for_row(row, 'failure', result.get('message'))
                    continue  # Pomiń ten wiersz i przejdź do następnego

            # Jeśli wszystko się udało, dodaj do listy
            all_change_requests.append(change_request)
            button = self.cells_table.cellWidget(row, 7)
            if button:
                button.setEnabled(False)
                button.setText("W kolejce...")

        # Krok 4: Wyślij wszystkie zebrane żądania do przetworzenia
        if all_change_requests:
            self.changes_requested.emit(all_change_requests)
            QApplication.processEvents()
        else:
            QMessageBox.information(self, "Informacja", "Nie wykryto żadnych zmian do zatwierdzenia.")

    def update_status_for_row(self, visual_row: int, status: str, message: str = "", result: dict = None):
        """
        Aktualizuje status wiersza. Po sukcesie odświeża dane tego wiersza.
        Obsługuje 3 stany: 'success', 'failure', 'no_change'.
        """
        if visual_row >= self.cells_table.rowCount(): return

        status_item = self.cells_table.item(visual_row, 8)
        button = self.cells_table.cellWidget(visual_row, 7)

        if status == 'success':
            status_item.setText("Sukces ✅")
            status_item.setForeground(QColor("green"))
            # Jeśli operacja się powiodła, odśwież dane dla tego wiersza
            if result and 'returned_symbol' in result:
                self.refresh_row_data_from_model(visual_row, result['returned_symbol'])
        elif status == 'no_change':
            status_item.setText("Brak zmiany")
            status_item.setForeground(QColor("orange"))
        else:  # 'failure'
            status_item.setText("Porażka ❌")
            status_item.setForeground(QColor("red"))
            if message:
                status_item.setToolTip(message)

        if button:
            QTimer.singleShot(1000, lambda b=button: self._reset_button_state(b))


class DigitSelectionDialog(QDialog):
    """Dialog do wyboru cyfry z siatki przycisków."""

    def __init__(self, parent=None, title="Wybierz wartość", values=None, current_theme="dark"):
        super().__init__(parent)
        self.parent_widget = parent
        self.current_theme = current_theme
        self.setWindowTitle(title)
        self.setModal(True)
        self.selected_value = None
        if values is None: values = list(range(10))
        self.values = values
        self.setObjectName("DigitSelectionDialogInstance")
        self.setup_ui()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu DigitSelectionDialog."""
        # --- TUTAJ BYŁ BŁĄD ---
        actual_theme = self.current_theme  # POPRAWKA: Użyj 'self.current_theme'
        # --- KONIEC POPRAWKI ---

        self.setStyleSheet(AppStyles.get_dialog_style(actual_theme))
        button_style_qss = AppStyles.get_button_style(actual_theme)

        if hasattr(self, 'grid_layout'):
            for i in range(self.grid_layout.count()):
                widget = self.grid_layout.itemAt(i).widget()
                if isinstance(widget, QPushButton):
                    widget.setStyleSheet(button_style_qss)
                    widget.style().unpolish(widget)
                    widget.style().polish(widget)

        if hasattr(self, 'cancel_button'):
            self.cancel_button.setStyleSheet(button_style_qss)
            self.cancel_button.style().unpolish(self.cancel_button)
            self.cancel_button.style().polish(self.cancel_button)

        self.style().unpolish(self)
        self.style().polish(self)
        self.update()

    def setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        self.grid_layout = QGridLayout()
        self.grid_layout.setSpacing(5)
        cols = min(6, len(self.values))
        if cols == 0: cols = 1
        for i, value in enumerate(self.values):
            row, col = i // cols, i % cols
            button = QPushButton(str(value))
            button.setMinimumSize(25, 25)
            button.setProperty("value", value)
            button.clicked.connect(self.on_value_selected)
            self.grid_layout.addWidget(button, row, col)
        main_layout.addLayout(self.grid_layout)

        # --- POCZĄTEK POPRAWKI: Dodanie przycisku "Wyczyść" ---
        self.clear_button = QPushButton("Wyczyść")
        self.clear_button.clicked.connect(self.on_clear_selected)
        # --- KONIEC POPRAWKI ---

        self.cancel_button = QPushButton("Anuluj")
        self.cancel_button.clicked.connect(self.reject)
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        button_layout.addWidget(self.clear_button)  # <-- Dodano przycisk
        button_layout.addWidget(self.cancel_button)
        main_layout.addLayout(button_layout)
        self.adjustSize()
        self.apply_dialog_theme()

    def on_value_selected(self):
        """Obsługuje wybór wartości"""
        button = self.sender()
        if button:
            self.selected_value = button.property("value")
            self.accept()

    def on_clear_selected(self):
        """Obsługuje wyczyszczenie wartości."""
        self.selected_value = None
        self.accept()

    def get_selected_value(self):
        """Zwraca wybraną wartość"""
        return self.selected_value

class OvertimeLocationDialog(QDialog):
    """Dialog do indywidualnej edycji lokalizacji dla wykrytych nadgodzin."""

    def __init__(self, parent, overtime_events, current_shift_location, current_theme="dark"):
        super().__init__(parent)
        self.setWindowTitle("Zmiana lokalizacji a nadgodziny")
        self.setMinimumWidth(450)  # Zwiększamy szerokość
        self.theme = current_theme
        self.events = overtime_events
        self.location_combos = []  # Będziemy przechowywać tu referencje do ComboBoxów

        self.setup_ui(current_shift_location)
        self.apply_styles()

    def setup_ui(self, current_shift_location):
        layout = QVBoxLayout(self)

        info_text = (f"Wykryto {len(self.events)} wpis(y) nadgodzin w tym dniu. "
                     f"Lokalizacja w grafiku została zmieniona na <b>'{current_shift_location.upper()}'</b>.<br><br>"
                     "Dla każdego wpisu nadgodzin możesz ustawić inną lokalizację.")
        layout.addWidget(QLabel(info_text))

        # Używamy QGridLayout dla lepszego ułożenia kontrolek
        grid_layout = QGridLayout()
        grid_layout.setSpacing(10)

        # Nagłówki
        grid_layout.addWidget(QLabel("<b>Godziny nadliczbowe</b>"), 0, 0)
        grid_layout.addWidget(QLabel("<b>Obecna lokalizacja</b>"), 0, 1)
        grid_layout.addWidget(QLabel("<b>Nowa lokalizacja</b>"), 0, 2)

        # Dane dla każdego wpisu nadgodzin
        for i, event in enumerate(self.events):
            row = i + 1
            # Informacje o godzinach
            event_label = QLabel(f"{event.get('time_from', '?')} - {event.get('time_to', '?')}")

            # Aktualna lokalizacja nadgodzin (zakładamy, że jest w danych zdarzenia)
            current_ot_location_code = event.get('location', 'b/d')  # 'b/d' - brak danych
            location_map = {'h': 'Home Office', 's': 'SBC', 'p': 'Przystanek'}
            current_ot_location_label = QLabel(location_map.get(current_ot_location_code, "Nieznana"))

            # Menu wyboru nowej lokalizacji
            location_combo = QComboBox()
            location_combo.addItem("Bez zmian", "skip")
            location_combo.addItem(f"Jak w grafiku ({current_shift_location.upper()})", current_shift_location)
            location_combo.addItem("Home Office (h)", "h")
            location_combo.addItem("SBC (s)", "s")
            location_combo.addItem("Przystanek (p)", "p")

            # Ustaw domyślnie "Bez zmian"
            location_combo.setCurrentIndex(0)

            self.location_combos.append(location_combo)  # Zapisz referencję

            grid_layout.addWidget(event_label, row, 0)
            grid_layout.addWidget(current_ot_location_label, row, 1)
            grid_layout.addWidget(location_combo, row, 2)

        layout.addLayout(grid_layout)

        button_box = QHBoxLayout()
        self.ok_button = QPushButton("Zatwierdź zmiany")
        self.cancel_button = QPushButton("Anuluj")
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)
        button_box.addStretch()
        button_box.addWidget(self.cancel_button)
        button_box.addWidget(self.ok_button)
        layout.addLayout(button_box)

    def apply_styles(self):
        self.setStyleSheet(AppStyles.get_dialog_style(self.theme))
        for button in self.findChildren(QPushButton):
            button.setStyleSheet(AppStyles.get_button_style(self.theme))
        for combo in self.findChildren(QComboBox):
            combo.setStyleSheet(AppStyles.get_combobox_style(self.theme))
        for box in self.findChildren(QGroupBox):
            box.setStyleSheet(f"""
                QGroupBox {{
                    border: 1px solid {'#495057' if self.theme == 'dark' else '#ced4da'};
                    border-radius: 4px;
                    margin-top: 10px;
                }}
                QGroupBox::title {{
                    subcontrol-origin: margin;
                    subcontrol-position: top left;
                    padding: 0 3px;
                    left: 10px;
                }}
            """)

    def get_selected_locations(self):
        """Zwraca listę zmian w formacie [(event_id, nowa_lokalizacja), ...]."""
        changes = []
        for i, combo in enumerate(self.location_combos):
            selected_loc = combo.currentData()
            if selected_loc != "skip":  # Zapisujemy tylko te, które faktycznie mają być zmienione
                event_id = self.events[i]['id']
                changes.append((event_id, selected_loc))
        return changes
