To jest kluczowy moment. JeÅ›li proces trwa bardzo dÅ‚ugo, to brak indeksu jest gÅ‚Ã³wnym winowajcÄ….
ğŸš€ O ile przyspieszy indeks?
Drastycznie. To rÃ³Å¼nica rzÄ™du rzÄ™du wielkoÅ›ci (np. z 2 godzin do 2 minut).
 * Bez indeksu: Baza danych dla kaÅ¼dego wstawianego wiersza musi przeszukaÄ‡ caÅ‚Ä… tabelÄ™ docelowÄ… linijka po linijce, aby sprawdziÄ‡, czy klucz istnieje (tzw. Full Table Scan). Przy milionach rekordÃ³w to miliardy operacji.
 * Z indeksem: Baza uÅ¼ywa drzewa binarnego. Sprawdzenie istnienia to uÅ‚amek sekundy.
âš ï¸ Problem uprawnieÅ„
Skoro nie mogÅ‚eÅ› utworzyÄ‡ tabeli tymczasowej (CREATE TABLE), istnieje bardzo duÅ¼e ryzyko, Å¼e nie bÄ™dziesz miaÅ‚ teÅ¼ uprawnieÅ„ do CREATE INDEX.
Mimo to, przygotowaÅ‚em dla Ciebie funkcjÄ™, ktÃ³ra:
 * Sprawdza, czy indeks na danych kolumnach juÅ¼ istnieje.
 * JeÅ›li nie â€“ prÃ³buje go utworzyÄ‡.
 * JeÅ›li nie ma uprawnieÅ„ â€“ Å‚apie bÅ‚Ä…d i loguje ostrzeÅ¼enie (wtedy musimy uÅ¼yÄ‡ "Planu B" - filtrowania w Pythonie).
RozwiÄ…zanie 1: Funkcja sprawdzajÄ…ca i tworzÄ…ca indeksy (Dodaj do DatabaseManager)
Wklej tÄ™ metodÄ™ do klasy DatabaseManager.
    def ensure_index_exists(self, target_db: str, table: str, schema: str, lookup_keys: List[str]) -> None:
        """
        Sprawdza czy istnieje indeks na kolumnach lookup_keys.
        JeÅ›li nie - prÃ³buje go utworzyÄ‡.
        """
        if not lookup_keys:
            return

        from sqlalchemy import text
        
        # Nazwa indeksu (musi byÄ‡ unikalna i krÃ³tka, Oracle ma limit 30 znakÃ³w w starszych wersjach)
        # Tworzymy nazwÄ™ np. IDX_TABELA_COL1_COL2
        short_table = table[:10]
        cols_suffix = "_".join([k[:3] for k in lookup_keys])[:10]
        index_name = f"IDX_{short_table}_{cols_suffix}".upper()
        
        cols_str = ", ".join([f'"{col}"' for col in lookup_keys])
        
        engine = self._get_engine(target_db)
        
        try:
            with engine.connect() as connection:
                # 1. Sprawdzenie czy indeks istnieje (Oracle)
                if target_db.lower() == 'oracle':
                    # Sprawdzamy czy istnieje JAKIKOLWIEK indeks zawierajÄ…cy te kolumny jako wiodÄ…ce
                    # To uproszczone sprawdzenie - sprawdzamy po prostu czy nazwa indeksu, ktÃ³rÄ… chcemy nadaÄ‡, juÅ¼ jest
                    check_sql = f"""
                        SELECT COUNT(*) FROM ALL_INDEXES 
                        WHERE INDEX_NAME = '{index_name}' AND OWNER = '{schema.upper()}'
                    """
                    count = connection.execute(text(check_sql)).scalar()
                    
                    if count > 0:
                        self.logger.info(f"Indeks {index_name} juÅ¼ istnieje.")
                        return

                    # 2. PrÃ³ba utworzenia indeksu
                    self.logger.info(f"PrÃ³ba utworzenia indeksu {index_name} na kolumnach: {lookup_keys}...")
                    create_sql = f'CREATE INDEX "{schema}"."{index_name}" ON "{schema}"."{table}" ({cols_str})'
                    connection.execute(text(create_sql))
                    self.logger.info(f"PomyÅ›lnie utworzono indeks {index_name}.")
                    
                elif target_db.lower() == 'sqlserver':
                    # Logika dla SQL Server (IF NOT EXISTS...)
                    create_sql = f"""
                    IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = '{index_name}' AND object_id = OBJECT_ID('{schema}.{table}'))
                    BEGIN
                        CREATE INDEX [{index_name}] ON [{schema}].[{table}] ({", ".join([f"[{k}]" for k in lookup_keys])})
                    END
                    """
                    connection.execute(text(create_sql))
                    self.logger.info(f"Zweryfikowano/Utworzono indeks {index_name} w SQL Server.")

        except Exception as e:
            # ğŸ’¥ JeÅ›li nie masz uprawnieÅ„, tutaj wpadniemy
            error_msg = str(e)
            if "ORA-01031" in error_msg: # Insufficient privileges
                self.logger.warning(f"BRAK UPRAWNIEÅƒ do tworzenia indeksÃ³w na tabeli {table}. "
                                    f"Proces insertu bÄ™dzie BARDZO WOLNY.")
            else:
                self.logger.warning(f"Nie udaÅ‚o siÄ™ utworzyÄ‡ indeksu: {e}")

Gdzie to wywoÅ‚aÄ‡?
Dodaj wywoÅ‚anie tej funkcji w insert_data przed pÄ™tlÄ… przetwarzajÄ…cÄ… batche, np. zaraz po check_column_size:
# WewnÄ…trz insert_data, okolice linii 1165 (po check_column_size)

# ...
self.check_column_size(engine, df_to_load, table_name, schema, target_db)

# ğŸ’¥ NOWE: PrÃ³ba utworzenia indeksu przed insertem
if lookup_keys:
    self.ensure_index_exists(target_db, table_name, schema, lookup_keys)

# 4. Åadowanie partii (Batching)
# ...

ğŸš¨ Plan B: Co jeÅ›li NIE MASZ uprawnieÅ„ do indeksÃ³w? (Opcja Python)
JeÅ›li dostaniesz ORA-01031 (brak uprawnieÅ„) przy tworzeniu indeksu, a tabela jest duÅ¼a, metoda SQL NOT EXISTS nigdy nie skoÅ„czy siÄ™ w rozsÄ…dnym czasie.
Wtedy musisz zmieniÄ‡ strategiÄ™ na filtrowanie w Pythonie. Jest to jedyne szybkie wyjÅ›cie przy braku uprawnieÅ„ DB.
Logika:
 * Pobierz tylko klucze z bazy do Pythona (jest to szybkie, nawet przy milionach wierszy, jeÅ›li to tylko 1-2 kolumny).
 * UsuÅ„ z DataFrame wiersze, ktÃ³re juÅ¼ sÄ… w tym zbiorze kluczy.
 * Wykonaj szybki, zwykÅ‚y INSERT (bez WHERE NOT EXISTS).
Zmieniona funkcja _custom_merge_insert dla Planu B (Filtrowanie w RAM):
JeÅ›li okaÅ¼e siÄ™, Å¼e indeksy nie wchodzÄ… w grÄ™, napisz, a podam kod, ktÃ³ry pobiera klucze (SELECT ID FROM TABLE) do set() w Pythonie i filtruje DataFrame przed wysÅ‚aniem. To zuÅ¼yje trochÄ™ wiÄ™cej RAMu (ok. 50-100MB na 2mln rekordÃ³w), ale bÄ™dzie nieporÃ³wnywalnie szybsze niÅ¼ insert bez indeksu.
