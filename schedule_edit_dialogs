# schedule_edit_dialogs.py
from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel,
                               QPushButton, QComboBox, QGroupBox, QRadioButton,
                               QFontComboBox, QSpinBox, QCheckBox, QWidget,
                               QTabWidget, QGridLayout, QMessageBox, QLineEdit,
                               QApplication, QSpacerItem, QSizePolicy,
                               QTableWidget, QTableWidgetItem, QHeaderView, QDialogButtonBox)
from PySide6.QtCore import Qt, Signal, QTimer, QDate
from PySide6.QtGui import QFont, QColor
from styles import AppStyles
from debug_utils import debug_print, log_error
from app_settings import app_settings
from db_connector import get_modifier_id

class DateTableWidgetItem(QTableWidgetItem):
    """Niestandardowy element tabeli do sortowania dat chronologicznie."""
    def __init__(self, date_str):
        # Format wy≈õwietlania: DD.MM.YYYY
        super().__init__(QDate.fromString(date_str, "yyyy-MM-dd").toString("dd.MM.yyyy"))
        # Przechowujemy obiekt QDate do poprawnego sortowania
        self.date = QDate.fromString(date_str, "yyyy-MM-dd")

    def __lt__(self, other):
        # Por√≥wnaj obiekty QDate zamiast tekstu
        return self.date < other.date

class DayOfWeekItem(QTableWidgetItem):
    """Niestandardowy element tabeli do sortowania dni tygodnia."""
    def __init__(self, qdate_obj):
        day_names = ["Pon", "Wt", "≈ör", "Czw", "Pt", "Sob", "Nd"]
        super().__init__(day_names[qdate_obj.dayOfWeek() - 1])
        # Przechowujemy numer dnia tygodnia (1-7) do sortowania
        self.day_of_week = qdate_obj.dayOfWeek()

    def __lt__(self, other):
        # Por√≥wnaj numery dni tygodnia
        return self.day_of_week < other.day_of_week

class ThemeSettingsDialog(QDialog):
    """
    Dialog do wyboru ustawie≈Ñ motywu aplikacji.
    """
    settings_changed = Signal(str, str, int)

    def __init__(self, parent=None, current_theme="dark", current_font="", current_font_size=9):
        super().__init__(parent)
        self.parent_widget = parent  # Zapisz rodzica

        self.setWindowTitle("Ustawienia motywu")
        self.setMinimumWidth(300)

        self.current_theme = current_theme
        self.current_font = current_font
        self.current_font_size = current_font_size

        self.setup_ui()  # Najpierw UI
        self.apply_dialog_theme()  # Potem styl zgodny z przekazanym/rodzica

        # Pod≈ÇƒÖczenie sygna≈Ç√≥w do natychmiastowej zmiany - PO setup_ui i apply_dialog_theme
        self.dark_theme_radio.toggled.connect(self.apply_immediate_changes)
        # Unikamy podw√≥jnego wywo≈Çania przy prze≈ÇƒÖczaniu radio, wystarczy jeden sygna≈Ç
        # self.light_theme_radio.toggled.connect(self.apply_immediate_changes)
        self.font_combo.currentFontChanged.connect(self.apply_immediate_changes)
        self.font_size_spin.valueChanged.connect(self.apply_immediate_changes)

    def apply_dialog_theme(self):  # Ta metoda stylizuje dialog na podstawie motywu rodzica lub current_theme
        """Stosuje motyw dla samego okna dialogowego."""
        theme_to_apply = self.current_theme  # Domy≈õlnie u≈ºyj przekazanego motywu

        # Je≈õli dialog ma rodzica i rodzic ma informacjƒô o motywie, u≈ºyj jej
        # To jest na wypadek, gdyby current_theme nie by≈Ço zsynchronizowane
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            theme_to_apply = "dark" if self.parent_widget.is_dark_theme else "light"

        # Je≈õli aktualnie wybrane radio buttony wskazujƒÖ inny motyw, u≈ºyj go
        # To jest kluczowe dla od≈õwie≈ºania "na ≈ºywo"
        if hasattr(self, 'dark_theme_radio') and self.dark_theme_radio.isChecked():
            theme_to_apply = "dark"
        elif hasattr(self, 'light_theme_radio') and self.light_theme_radio.isChecked():
            theme_to_apply = "light"

        self.setStyleSheet(AppStyles.get_dialog_style(theme_to_apply))

        # Od≈õwie≈º style przycisk√≥w w dialogu, bo get_dialog_style ich nie obejmuje
        button_style = AppStyles.get_button_style(theme_to_apply)
        if hasattr(self, 'ok_button'): self.ok_button.setStyleSheet(button_style)
        if hasattr(self, 'cancel_button'): self.cancel_button.setStyleSheet(button_style)

    def setup_ui(self):  # Tutaj tylko tworzymy widgety
        main_layout = QVBoxLayout(self)

        theme_group = QGroupBox("Motyw")
        theme_layout = QVBoxLayout()
        self.dark_theme_radio = QRadioButton("Ciemny")
        self.light_theme_radio = QRadioButton("Jasny")

        if self.current_theme == "dark":
            self.dark_theme_radio.setChecked(True)
        else:  # Domy≈õlnie lub je≈õli light
            self.light_theme_radio.setChecked(True)

        theme_layout.addWidget(self.dark_theme_radio)
        theme_layout.addWidget(self.light_theme_radio)
        theme_group.setLayout(theme_layout)

        font_group = QGroupBox("Czcionka")
        font_layout = QVBoxLayout()
        font_type_layout = QHBoxLayout()
        font_type_label = QLabel("Typ czcionki:")
        self.font_combo = QFontComboBox()
        if self.current_font:
            self.font_combo.setCurrentFont(QFont(self.current_font))
        font_type_layout.addWidget(font_type_label)
        font_type_layout.addWidget(self.font_combo)

        font_size_layout = QHBoxLayout()
        font_size_label = QLabel("Rozmiar czcionki:")
        self.font_size_spin = QSpinBox()
        self.font_size_spin.setRange(6, 24)
        self.font_size_spin.setValue(self.current_font_size)
        font_size_layout.addWidget(font_size_label)
        font_size_layout.addWidget(self.font_size_spin)

        font_layout.addLayout(font_type_layout)
        font_layout.addLayout(font_size_layout)
        font_group.setLayout(font_layout)

        self.save_settings_checkbox = QCheckBox("Zapamiƒôtaj ustawienia")
        self.save_settings_checkbox.setChecked(True)

        buttons_layout = QHBoxLayout()
        self.ok_button = QPushButton("OK")
        self.cancel_button = QPushButton("Anuluj")

        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

        buttons_layout.addStretch()
        buttons_layout.addWidget(self.ok_button)
        buttons_layout.addWidget(self.cancel_button)

        main_layout.addWidget(theme_group)
        main_layout.addWidget(font_group)
        main_layout.addWidget(self.save_settings_checkbox)
        main_layout.addLayout(buttons_layout)

    def apply_immediate_changes(self):
        """Aplikuje zmiany natychmiastowo podczas wybierania opcji W TYM SAMYM DIALOGU"""
        if not hasattr(self, 'font_combo') or not hasattr(self, 'font_size_spin') or not hasattr(self,
                                                                                                 'dark_theme_radio'):
            return

        selected_theme = "dark" if self.dark_theme_radio.isChecked() else "light"
        font_family = self.font_combo.currentFont().family()
        font_size = self.font_size_spin.value()

        # Emituj sygna≈Ç dla g≈Ç√≥wnego okna, aby ono zaktualizowa≈Ço swoje style
        self.settings_changed.emit(selected_theme, font_family, font_size)

        # Zaktualizuj styl samego dialogu ThemeSettingsDialog "na ≈ºywo"
        # Musimy przekazaƒá wybrany motyw, a niekoniecznie ten z rodzica
        # (bo w≈Ça≈õnie go zmieniamy)
        current_dialog_theme_choice = self.get_current_theme_choice()  # U≈ºyj wyboru z radio button√≥w

        # Zastosuj pe≈Çny styl dialogu na nowo
        self.setStyleSheet(AppStyles.get_dialog_style(current_dialog_theme_choice))

        # Zastosuj style dla przycisk√≥w, kt√≥re nie sƒÖ objƒôte get_dialog_style
        button_style = AppStyles.get_button_style(current_dialog_theme_choice)
        if hasattr(self, 'ok_button'): self.ok_button.setStyleSheet(button_style)
        if hasattr(self, 'cancel_button'): self.cancel_button.setStyleSheet(button_style)

        # Mo≈ºe byƒá konieczne od≈õwie≈ºenie styl√≥w dla kontrolek wewnƒÖtrz groupbox√≥w,
        # je≈õli dziedziczenie nie zadzia≈Ça idealnie po zmianie g≈Ç√≥wnego stylu dialogu.
        # Na przyk≈Çad:
        # self.font_combo.setStyleSheet(AppStyles.get_combobox_style(current_dialog_theme_choice))
        # self.font_size_spin.setStyleSheet(AppStyles.get_line_edit_style(current_dialog_theme_choice)) # SpinBox czƒôsto dziedziczy styl LineEdit
        # self.dark_theme_radio.setStyleSheet(AppStyles.get_checkbox_style(current_dialog_theme_choice)) # RadioButton czƒôsto jak CheckBox
        # self.light_theme_radio.setStyleSheet(AppStyles.get_checkbox_style(current_dialog_theme_choice))
        # To jest bardziej granularne i mo≈ºe byƒá potrzebne, je≈õli prosty self.setStyleSheet() nie wystarczy.

        # Dla pewno≈õci mo≈ºna wymusiƒá od≈õwie≈ºenie wyglƒÖdu, choƒá zmiana stylesheetu powinna to zrobiƒá.
        self.update()

    def get_current_theme_choice(self):  # Zmieniono nazwƒô, aby odr√≥≈ºniƒá od current_theme przy inicjalizacji
        """Zwraca nazwƒô aktualnie wybranego motywu w tym dialogu."""
        if hasattr(self, 'dark_theme_radio') and self.dark_theme_radio.isChecked():
            return "dark"
        elif hasattr(self, 'light_theme_radio') and self.light_theme_radio.isChecked():
            return "light"
        # Fallback na current_theme, je≈õli radio buttony nie sƒÖ jeszcze dostƒôpne
        return self.current_theme


class InsertSymbolDialog(QDialog):
    """Dialog do wyboru symbolu z kontekstowym blokowaniem opcji."""
    symbol_selected = Signal(str)

    # ZMIANA: Dodano argument 'selected_cells_data'
    def __init__(self, parent=None, selected_cells_data=None):
        super().__init__(parent)
        self.parent_widget = parent
        self.setWindowTitle("Wstaw symbol")
        self.setMinimumWidth(300)
        self.setMinimumHeight(250)

        self.selected_symbol = ""
        self.user_role = getattr(self.parent_widget, 'current_user_role', "")
        self.valid_symbols = set()
        self.parent_font = QApplication.font()
        if self.parent_widget: self.parent_font = self.parent_widget.font()

        # --- NOWA LOGIKA: Sprawd≈∫, czy w≈ÇƒÖczamy tryb "Tylko CO dla DTN" ---
        self.dtn_co_only_mode = False
        if self.user_role in ['Lider', 'Lider OUT'] and selected_cells_data:
            # Sprawd≈∫, czy WSZYSTKIE zaznaczone kom√≥rki nale≈ºƒÖ do wydzia≈Çu DTN
            if all(cell.get('wydzial', '').strip().lower() == 'dtn' for cell in selected_cells_data):
                self.dtn_co_only_mode = True
        # --- KONIEC NOWEJ LOGIKI ---

        self.setup_ui()
        self.apply_dialog_theme()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu InsertSymbolDialog."""
        actual_theme = "dark"
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            actual_theme = "dark" if self.parent_widget.is_dark_theme else "light"

        # debug_print(f"InsertSymbolDialog ('{self.windowTitle()}'): Stosujƒô motyw '{actual_theme}'")

        # Ustaw og√≥lny styl dialogu (powinien zawieraƒá QDialog#InsertSymbolDialogInstance)
        self.setStyleSheet(AppStyles.get_dialog_style(actual_theme))

        # Styl dla przycisk√≥w i innych kontrolek w tym dialogu
        button_style_qss = AppStyles.get_button_style(actual_theme)
        line_edit_style_qss = AppStyles.get_line_edit_style(actual_theme)
        tab_widget_style_qss = self._get_tab_widget_style(actual_theme)  # Dedykowana metoda dla QTabWidget

        if hasattr(self, 'symbol_input'):
            self.symbol_input.setStyleSheet(line_edit_style_qss)

        if hasattr(self, 'tabs'):
            self.tabs.setStyleSheet(tab_widget_style_qss)
            # Mo≈ºna dodatkowo ostylowaƒá przyciski wewnƒÖtrz zak≈Çadek, je≈õli to konieczne
            # i je≈õli nie dziedziczƒÖ poprawnie stylu z button_style_qss
            for i in range(self.tabs.count()):
                tab_content_widget = self.tabs.widget(i)
                if tab_content_widget:
                    buttons_in_tab = tab_content_widget.findChildren(QPushButton)
                    for btn in buttons_in_tab:
                        btn.setStyleSheet(button_style_qss)  # U≈ºyj g≈Ç√≥wnego stylu przycisk√≥w
                        # lub dedykowanego mniejszego stylu

        if hasattr(self, 'cancel_button'):
            self.cancel_button.setStyleSheet(button_style_qss)

        # Styl dla etykiet, je≈õli potrzeba specyficznego
        label_style_qss = AppStyles.get_label_style(actual_theme)
        if hasattr(self, 'instruction_label'): self.instruction_label.setStyleSheet(label_style_qss)
        if hasattr(self, 'input_label'): self.input_label.setStyleSheet(label_style_qss)
        if hasattr(self, 'validation_label'): self.validation_label.setStyleSheet(label_style_qss)

        self.style().unpolish(self)
        self.style().polish(self)
        self.update()

    def _get_tab_widget_style(self, theme):
        """Zwraca styl dla QTabWidget i QTabBar zgodny z motywem."""
        # Pobierz kolory z AppStyles
        main_bg = AppStyles.DARK_BACKGROUND_MAIN if theme == "dark" else AppStyles.LIGHT_BACKGROUND_MAIN
        control_bg = AppStyles.DARK_BACKGROUND_CONTROLS if theme == "dark" else AppStyles.LIGHT_BACKGROUND_CONTROLS
        text_color = AppStyles.DARK_TEXT_PRIMARY if theme == "dark" else AppStyles.LIGHT_TEXT_PRIMARY
        border_color = AppStyles.DARK_BORDER_SECONDARY if theme == "dark" else AppStyles.LIGHT_BORDER_PRIMARY
        accent_color = AppStyles.ACCENT_COLOR_DARK if theme == "dark" else AppStyles.ACCENT_COLOR_LIGHT

        # Dla jasnego motywu zak≈Çadki mogƒÖ mieƒá nieco inne t≈Ço ni≈º sam dialog
        tab_bar_bg = control_bg if theme == "dark" else AppStyles.LIGHT_BACKGROUND_HOVER
        tab_pane_bg = control_bg  # T≈Ço zawarto≈õci zak≈Çadki

        return f"""
            QTabWidget::pane {{
                border: 1px solid {border_color};
                border-top: none; /* ≈ÅƒÖczy siƒô z QTabBar */
                background-color: {tab_pane_bg};
                border-bottom-left-radius: {AppStyles.BORDER_RADIUS};
                border-bottom-right-radius: {AppStyles.BORDER_RADIUS};
            }}
            QTabBar::tab {{
                background-color: {tab_bar_bg};
                color: {text_color};
                border: 1px solid {border_color};
                border-bottom: none; 
                padding: 5px 10px;
                margin-right: 1px;
                border-top-left-radius: {AppStyles.BORDER_RADIUS};
                border-top-right-radius: {AppStyles.BORDER_RADIUS};
            }}
            QTabBar::tab:selected {{
                background-color: {accent_color};
                color: {'white' if theme == "dark" else AppStyles.LIGHT_BACKGROUND_CONTROLS}; /* Poprawiony kolor tekstu dla jasnego motywu */
                /* border-bottom: 1px solid {accent_color}; */ /* Usuwamy, bo pane ma border-top */
            }}
            QTabBar::tab:!selected {{
                background-color: {main_bg if theme == "dark" else AppStyles.LIGHT_BACKGROUND_MAIN};
                 /* margin-top: 2px; */ /* Mo≈ºna usunƒÖƒá dla p≈Çaskiego wyglƒÖdu */
            }}
            QTabBar::tab:hover:!selected {{
                background-color: {AppStyles.DARK_BACKGROUND_HOVER if theme == "dark" else AppStyles.LIGHT_BACKGROUND_HOVER};
            }}
        """

    def setup_ui(self):
        main_layout = QVBoxLayout(self)

        self.instruction_label = QLabel("Wpisz symbol lub wybierz z poni≈ºszych zak≈Çadek")
        self.instruction_label.setStyleSheet("color: gray; font-style: italic;")
        self.instruction_label.setFont(self.parent_font)
        main_layout.addWidget(self.instruction_label)

        input_layout = QHBoxLayout()
        self.input_label = QLabel("Symbol:")
        self.input_label.setFont(self.parent_font)

        self.symbol_input = QLineEdit()
        self.symbol_input.setMaxLength(5)
        font = QFont(self.parent_font)
        font.setBold(True)
        font.setPointSize(font.pointSize() + 2)
        self.symbol_input.setFont(font)
        self.symbol_input.textChanged.connect(self.on_symbol_input_changed)
        self.symbol_input.returnPressed.connect(self.check_and_accept)
        input_layout.addWidget(self.input_label)
        input_layout.addWidget(self.symbol_input)
        main_layout.addLayout(input_layout)

        self.tabs = QTabWidget()
        self.tabs.setFont(self.parent_font)

        # Dynamiczne tworzenie zak≈Çadek na podstawie ustawie≈Ñ z bazy
        self.valid_symbols.clear()
        symbol_categories = app_settings.SYMBOL_CATEGORIES

        # Tworzy wszystkie zak≈Çadki, a uprawnienia sƒÖ sprawdzane dla ka≈ºdego przycisku osobno
        for category_name, symbols_dict in symbol_categories.items():
            symbols_list = list(symbols_dict.items())
            self.add_tab_with_symbols(symbols_list, category_name)
            # Dodaje wszystkie symbole do listy walidacji (dla wpisywania rƒôcznego)
            for symbol_key in symbols_dict.keys():
                self.valid_symbols.add(symbol_key)

        buttons_layout = QHBoxLayout()
        self.cancel_button = QPushButton("Anuluj")
        self.cancel_button.setFont(self.parent_font)
        self.cancel_button.clicked.connect(self.reject)

        self.validation_label = QLabel("")
        self.validation_label.setFont(self.parent_font)

        buttons_layout.addWidget(self.validation_label)
        buttons_layout.addStretch()
        buttons_layout.addWidget(self.cancel_button)

        main_layout.addWidget(self.tabs)
        main_layout.addLayout(buttons_layout)
        self.symbol_input.setFocus()

    def add_tab_with_symbols(self, symbols, tab_name):
        """Dodaje zak≈Çadkƒô z symbolami, uwzglƒôdniajƒÖc uprawnienia i tryb DTN."""
        tab = QWidget()
        tab_layout = QGridLayout(tab)
        tab_layout.setSpacing(5)

        for idx, (symbol, desc) in enumerate(symbols):
            button = QPushButton(symbol)
            button.setFont(self.parent_font)
            button.setProperty("symbol", symbol)
            button.setFocusPolicy(Qt.NoFocus)
            button.clicked.connect(self.on_symbol_button_clicked)

            # --- ZMIENIONA LOGIKA: Sprawdzanie uprawnie≈Ñ do symbolu ---
            is_generally_allowed = app_settings.has_symbol_permission(self.user_role, symbol)

            # Je≈õli jest w trybie "tylko CO dla DTN", zablokuj wszystko opr√≥cz CO
            if self.dtn_co_only_mode:
                if symbol.upper() == 'CO' and is_generally_allowed:
                    button.setEnabled(True)
                    button.setToolTip(desc)
                else:
                    button.setEnabled(False)
                    button.setToolTip(f"Dla wydzia≈Çu DTN dozwolony jest tylko symbol 'CO'.")
            # W przeciwnym razie, dzia≈Çaj jak dotychczas
            elif is_generally_allowed:
                button.setEnabled(True)
                button.setToolTip(desc)
            else:
                button.setEnabled(False)
                button.setToolTip(f"{desc}\n(Brak uprawnie≈Ñ dla Twojej roli)")
            # --- KONIEC ZMIENIONEJ LOGIKI ---

            row = idx // 4
            col = idx % 4
            tab_layout.addWidget(button, row, col)

        tab_layout.addItem(QSpacerItem(10, 10, QSizePolicy.Expanding, QSizePolicy.Expanding), (len(symbols) // 4) + 1,
                           0, 1, 4)
        self.tabs.addTab(tab, tab_name)

    def on_symbol_button_clicked(self):
        """Obs≈Çuguje klikniƒôcie przycisku z symbolem"""
        button = self.sender()  # Pobierz obiekt, kt√≥ry wys≈Ça≈Ç sygna≈Ç
        if button:
            symbol = button.property("symbol")
            if symbol:
                self.accept_symbol(symbol)

    def on_symbol_input_changed(self, text):
        """Obs≈Çuguje zmianƒô symbolu wpisanego z klawiatury"""
        # Konwersja do du≈ºych liter
        uppercase_text = text.upper()
        if text != uppercase_text:
            # Blokuj sygna≈Ç, aby uniknƒÖƒá niesko≈Ñczonej pƒôtli
            self.symbol_input.blockSignals(True)
            self.symbol_input.setText(uppercase_text)
            self.symbol_input.blockSignals(False)

        self.selected_symbol = uppercase_text.strip()

        # Sprawd≈∫, czy symbol jest na li≈õcie dostƒôpnych
        if self.selected_symbol:
            if self.selected_symbol in self.valid_symbols:
                self.validation_label.setText("Symbol prawid≈Çowy")
                self.validation_label.setStyleSheet("color: green;")
            else:
                self.validation_label.setText("Symbol niedostƒôpny!")
                self.validation_label.setStyleSheet("color: red;")
        else:
            self.validation_label.setText("")

    def accept_symbol(self, symbol):
        """Akceptuje symbol i zamyka dialog"""
        self.selected_symbol = symbol

        # Blokuj sygna≈Ç, aby uniknƒÖƒá wywo≈Çania on_symbol_input_changed
        self.symbol_input.blockSignals(True)
        self.symbol_input.setText(symbol)
        self.symbol_input.blockSignals(False)

        # Aktualizuj etykietƒô walidacji
        self.validation_label.setText("Symbol prawid≈Çowy")
        self.validation_label.setStyleSheet("color: green;")

        # Wywo≈Çaj metodƒô sprawdzajƒÖcƒÖ
        self.check_and_accept()

    def check_and_accept(self):
        """Sprawdza symbol i uprawnienia przed zamkniƒôciem okna."""
        # --- POCZƒÑTEK ZMIANY: Dodatkowa walidacja uprawnie≈Ñ ---
        if self.selected_symbol and self.selected_symbol in self.valid_symbols:
            if app_settings.has_symbol_permission(self.user_role, self.selected_symbol):
                super().accept()
            else:
                QMessageBox.warning(self, "Brak uprawnie≈Ñ",
                                    f"Twoja rola ('{self.user_role}') nie ma uprawnie≈Ñ do u≈ºycia symbolu '{self.selected_symbol}'.",
                                    QMessageBox.Ok)
        # --- KONIEC ZMIANY ---
        elif self.selected_symbol:
            QMessageBox.warning(self, "Nieprawid≈Çowy symbol",
                                f"Symbol '{self.selected_symbol}' nie jest poprawnym symbolem.", QMessageBox.Ok)
        else:
            QMessageBox.warning(self, "Brak symbolu", "Proszƒô wpisaƒá lub wybraƒá symbol.", QMessageBox.Ok)

            self.selected_symbol = ""
            self.symbol_input.setText("")
            self.symbol_input.setFocus()

    def get_selected_symbol(self):
        """Zwraca wybrany symbol"""
        return self.selected_symbol


class ReasonDialog(QDialog):
    """Prosty dialog do wpisania i pobrania powodu zmiany."""

    def __init__(self, parent=None):
        super().__init__(parent)

        # --- POCZƒÑTEK POPRAWKI ---
        # Odwo≈Çujemy siƒô do poprawnego atrybutu 'determined_theme' z okna nadrzƒôdnego
        self.is_dark_theme = (parent.determined_theme == 'dark')
        # --- KONIEC POPRAWKI ---

        self.setWindowTitle("Pow√≥d zmiany lokalizacji")
        self.setMinimumWidth(350)

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Proszƒô podaƒá pow√≥d zmiany lokalizacji:"))

        self.reason_input = QLineEdit("Na pro≈õbƒô doradcy")
        layout.addWidget(self.reason_input)

        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

        self.apply_styles()

    def getReason(self):
        """Zwraca tekst wpisany przez u≈ºytkownika."""
        return self.reason_input.text()

    def apply_styles(self):
        theme = "dark" if self.is_dark_theme else "light"
        self.setStyleSheet(AppStyles.get_dialog_style(theme))
        for button in self.button_box.buttons():
            button.setStyleSheet(AppStyles.get_button_style(theme))
        self.reason_input.setStyleSheet(AppStyles.get_line_edit_style(theme))


class ScheduleChangeDialog(QDialog):
    """Dialog do edycji zmian w grafiku"""

    def __init__(self, parent=None, grouped_cells=None, year=None, month=None):
        super().__init__(parent)
        self.parent_widget = parent
        self.determined_theme = "dark"
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            self.determined_theme = "dark" if self.parent_widget.is_dark_theme else "light"
        self.setWindowTitle("Wstaw zmianƒô grafiku")
        self.setMinimumWidth(1000)
        self.setMinimumHeight(600)
        self.grouped_cells = grouped_cells
        self.year = year
        self.month = month
        self.flattened_cells = self.flatten_grouped_cells(grouped_cells)
        self.user_role = getattr(self.parent_widget, 'current_user_role', "U≈ºytkownik")
        self.default_button_style = AppStyles.get_button_style(self.determined_theme)
        self.reason_cache = {}
        self.setup_ui()
        self.apply_dialog_theme()

    def apply_dialog_theme(self):
        actual_theme = self.determined_theme
        self.setStyleSheet(AppStyles.get_dialog_style(actual_theme))

        # Pobierz style z centralnej klasy
        button_style = AppStyles.get_button_style(actual_theme)
        combobox_style = AppStyles.get_combobox_style(actual_theme)
        checkbox_style = AppStyles.get_checkbox_style(actual_theme)  # Pobierz styl dla checkbox√≥w

        # Styl dla panelu "Zastosuj dla wszystkich"
        if hasattr(self, 'all_time_button'):
            self.all_time_button.setStyleSheet(button_style)
            self.all_hours_button.setStyleSheet(button_style)
            self.all_location_combo.setStyleSheet(combobox_style)

            # --- POCZƒÑTEK POPRAWKI ---
            # Zastosuj styl do checkbox√≥w w tym panelu
            self.apply_location_check.setStyleSheet(checkbox_style)
            self.apply_time_check.setStyleSheet(checkbox_style)
            self.apply_hours_check.setStyleSheet(checkbox_style)
            # --- KONIEC POPRAWKI ---

            # Znajd≈∫ przycisk "Zastosuj dla wszystkich" wewnƒÖtrz grupy i zastosuj styl
            apply_all_button = self.findChild(QGroupBox).findChild(QPushButton)
            if apply_all_button:
                apply_all_button.setStyleSheet(button_style)

        # Styl dla przycisku "Zamknij"
        if hasattr(self, 'close_button'):
            self.close_button.setStyleSheet(button_style)

        # Style dla kontrolek w tabeli
        if hasattr(self, 'cells_table'):
            self.cells_table.setStyleSheet(AppStyles.get_tablewidget_style(actual_theme))
            for row in range(self.cells_table.rowCount()):
                for col_idx in [4, 5, 6, 7]:
                    widget = self.cells_table.cellWidget(row, col_idx)
                    if isinstance(widget, QComboBox):
                        widget.setStyleSheet(combobox_style)
                    elif isinstance(widget, QPushButton):
                        widget.setStyleSheet(button_style)

    def flatten_grouped_cells(self, grouped_cells):
        flattened = []
        if not grouped_cells: return flattened
        for user_id, dates in grouped_cells.items():
            for date, cells in dates.items():
                flattened.extend(cells)
        return flattened

    def _create_apply_all_group(self):
        group = QGroupBox("Zastosuj dla wszystkich (z uwzglƒôdnieniem uprawnie≈Ñ)")
        layout = QHBoxLayout()
        group.setLayout(layout)

        # Lokalizacja
        self.apply_location_check = QCheckBox("Lokalizacja:")
        layout.addWidget(self.apply_location_check)
        self.all_location_combo = QComboBox()
        self.all_location_combo.addItem("SBC (s)", "s")
        self.all_location_combo.addItem("Przystanek (p)", "p")
        self.all_location_combo.addItem("HomeOffice (h)", "h")
        layout.addWidget(self.all_location_combo)
        layout.addSpacing(15)

        # Godzina rozpoczƒôcia
        self.apply_time_check = QCheckBox("Godzina rozp.:")
        layout.addWidget(self.apply_time_check)
        self.all_time_button = QPushButton("Wybierz")
        self.all_time_button.setProperty("field_type", "hour")
        self.all_time_button.clicked.connect(self.show_digit_selection)  # <-- Ujednolicony spos√≥b
        layout.addWidget(self.all_time_button)
        layout.addSpacing(15)

        # Liczba godzin
        self.apply_hours_check = QCheckBox("Liczba godzin:")
        layout.addWidget(self.apply_hours_check)
        self.all_hours_button = QPushButton("Wybierz")
        self.all_hours_button.setProperty("field_type", "hours")
        self.all_hours_button.clicked.connect(self.show_digit_selection)  # <-- Ujednolicony spos√≥b
        layout.addWidget(self.all_hours_button)

        layout.addStretch()

        apply_all_button = QPushButton("Zastosuj dla wszystkich")
        apply_all_button.clicked.connect(self._apply_all_changes)
        layout.addWidget(apply_all_button)

        return group

    def setup_ui(self):
        main_layout = QVBoxLayout(self)
        apply_all_group = self._create_apply_all_group()
        main_layout.addWidget(apply_all_group)
        self.cells_table = QTableWidget()
        self.cells_table.setColumnCount(9)
        self.cells_table.setHorizontalHeaderLabels(
            ["Data", "Dzie≈Ñ tyg.", "U≈ºytkownik", "Symbol", "Lokalizacja", "Godzina rozp.", "Liczba godzin", "Akcje",
             "Status"])
        self.cells_table.setSortingEnabled(True)
        self.cells_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.cells_table.horizontalHeader().setStretchLastSection(True)
        self.cells_table.setRowCount(len(self.flattened_cells))

        for row, cell in enumerate(self.flattened_cells):
            permissions = self.parent_widget._get_permission_for_cell(cell)
            date_str = cell.get('date_str', '')
            date_item = DateTableWidgetItem(date_str)
            date_item.setFlags(date_item.flags() & ~Qt.ItemIsEditable)
            date_item.setData(Qt.UserRole, row)
            self.cells_table.setItem(row, 0, date_item)
            qdate_obj = QDate.fromString(date_str, "yyyy-MM-dd")
            day_name_item = DayOfWeekItem(qdate_obj)
            day_name_item.setFlags(day_name_item.flags() & ~Qt.ItemIsEditable)
            day_name_item.setTextAlignment(Qt.AlignCenter)
            self.cells_table.setItem(row, 1, day_name_item)
            user_name = cell.get('uzytkownik_dane', 'Nieznany')
            self.cells_table.setItem(row, 2, QTableWidgetItem(user_name))
            self.cells_table.item(row, 2).setFlags(self.cells_table.item(row, 2).flags() & ~Qt.ItemIsEditable)
            symbol = cell.get('symbol', '')
            self.cells_table.setItem(row, 3, QTableWidgetItem(symbol))
            self.cells_table.item(row, 3).setFlags(self.cells_table.item(row, 3).flags() & ~Qt.ItemIsEditable)

            from symbol_parser import parse_symbol
            parsed_symbol = parse_symbol(symbol)

            # --- POCZƒÑTEK NOWEJ LOGIKI ---
            can_edit_location = permissions['can_edit_location']
            cell_date = QDate.fromString(date_str, "yyyy-MM-dd")

            # Je≈õli rola to 'Lider' i data jest przesz≈Ça, zablokuj edycjƒô lokalizacji
            if self.user_role == 'Lider' and cell_date < QDate.currentDate():
                can_edit_location = False
            # --- KONIEC NOWEJ LOGIKI ---

            location_code = parsed_symbol.get('location') or cell.get('lokalizacja_domyslna')
            start_hour = parsed_symbol.get('start_hour')
            parsed_hours = parsed_symbol.get('work_hours')
            if parsed_hours is not None:
                work_hours = parsed_hours
            else:
                work_hours = cell.get('etat', 8.0)
            try:
                work_hours = int(float(work_hours))
            except (ValueError, TypeError):
                work_hours = 8

            location_combo = QComboBox()
            location_combo.addItem("SBC (s)", "s")
            location_combo.addItem("mPrzystanek (p)", "p")
            location_combo.addItem("HomeOffice (h)", "h")

            if location_code and location_code in ['h', 's', 'p']:
                location_combo.setCurrentIndex({'s': 0, 'p': 1, 'h': 2}.get(location_code))
            else:
                location_combo.setCurrentIndex(-1)

            location_combo.setEnabled(can_edit_location)  # U≈ºyj nowej, zweryfikowanej zmiennej
            self.cells_table.setCellWidget(row, 4, location_combo)

            time_button = QPushButton(str(start_hour) if start_hour is not None else "")
            time_button.setProperty("cell_index", row)
            time_button.setProperty("field_type", "hour")
            time_button.clicked.connect(self.show_digit_selection)
            time_button.setEnabled(permissions['can_edit_hours'])
            self.cells_table.setCellWidget(row, 5, time_button)

            hours_button = QPushButton(str(work_hours))
            hours_button.setProperty("cell_index", row)
            hours_button.setProperty("field_type", "hours")
            hours_button.clicked.connect(self.show_digit_selection)
            hours_button.setEnabled(permissions['can_edit_hours'])
            self.cells_table.setCellWidget(row, 6, hours_button)

            apply_button = QPushButton("Zastosuj")
            apply_button.setProperty("cell_index", row)
            apply_button.clicked.connect(self.apply_change_by_index)
            apply_button.setEnabled(any(permissions.values()) and start_hour is not None)
            self.cells_table.setCellWidget(row, 7, apply_button)

            status_item = QTableWidgetItem("")
            status_item.setFlags(status_item.flags() & ~Qt.ItemIsEditable)
            status_item.setTextAlignment(Qt.AlignCenter)
            self.cells_table.setItem(row, 8, status_item)

        main_layout.addWidget(self.cells_table)
        button_layout = QHBoxLayout()
        self.close_button = QPushButton("Zamknij")
        self.close_button.clicked.connect(self.close)
        button_layout.addStretch()
        button_layout.addWidget(self.close_button)
        main_layout.addLayout(button_layout)
        self.cells_table.sortByColumn(0, Qt.AscendingOrder)

    def show_digit_selection(self):
        target_button = self.sender()
        if not target_button: return
        field_type = target_button.property("field_type")
        is_hour = (field_type == "hour")
        values = list(range(24)) if is_hour else list(range(1, 14))
        title = "Wybierz godzinƒô rozp." if is_hour else "Wybierz liczbƒô godzin"

        dialog = DigitSelectionDialog(self, title, values, current_theme=self.determined_theme)
        if dialog.exec() == QDialog.Accepted:
            selected_value = dialog.get_selected_value()

            # --- POCZƒÑTEK POPRAWKI: Logika w≈ÇƒÖczania/wy≈ÇƒÖczania przycisku "Zastosuj" ---
            # Ustaw tekst przycisku (pusty, je≈õli wyczyszczono)
            target_button.setText(str(selected_value) if selected_value is not None else "")

            # Je≈õli zmieniano godzinƒô rozpoczƒôcia, zaktualizuj stan przycisku "Zastosuj"
            if is_hour:
                row = target_button.property("cell_index")
                if row is not None:
                    apply_button = self.cells_table.cellWidget(row, 7)
                    if apply_button:
                        # Sprawd≈∫, czy u≈ºytkownik nadal ma og√≥lne uprawnienia
                        original_index = self.cells_table.item(row, 0).data(Qt.UserRole)
                        cell_data = self.flattened_cells[original_index]
                        permissions = self.parent_widget._get_permission_for_cell(cell_data)

                        # W≈ÇƒÖcz przycisk tylko, je≈õli sƒÖ uprawnienia ORAZ wybrano godzinƒô
                        apply_button.setEnabled(any(permissions.values()) and selected_value is not None)
            # --- KONIEC POPRAWKI ---

    def _reset_button_state(self, button):
        button.setText("Zastosuj")
        button.setStyleSheet(self.default_button_style)
        button.setEnabled(True)

    def apply_change_by_index(self):
        button = self.sender()
        if not button: return
        # Znajd≈∫ wizualny wiersz, w kt√≥rym jest przycisk
        for row in range(self.cells_table.rowCount()):
            if self.cells_table.cellWidget(row, 7) == button:
                self._apply_change_for_row(row)
                return

    def _apply_change_for_row(self, visual_row_index):
        """Stosuje zmianƒô dla konkretnego wiersza, implementujƒÖc logikƒô wyjƒÖtk√≥w lokalizacyjnych."""
        button = self.cells_table.cellWidget(visual_row_index, 7)
        if not button or not button.isEnabled(): return

        status_item = self.cells_table.item(visual_row_index, 8)

        try:
            item = self.cells_table.item(visual_row_index, 0)
            if not item: raise ValueError("Nie mo≈ºna odnale≈∫ƒá elementu w wierszu.")
            original_data_index = item.data(Qt.UserRole)
            cell_data = self.flattened_cells[original_data_index]

            # Inicjalizacja danych
            user_id = cell_data.get('uzytkownik_id')
            nr_kadrowy = cell_data.get('nr_kadrowy')
            user_name = cell_data.get('uzytkownik_dane')
            date_str = cell_data.get('date_str')
            q_date = QDate.fromString(date_str, "yyyy-MM-dd")
            _, modyfikujacy_id, _, _, _ = get_modifier_id()
            location_map = {'h': 1, 's': 3, 'p': 2}
            default_location_code = cell_data.get('lokalizacja_domyslna')

            location_combo = self.cells_table.cellWidget(visual_row_index, 4)
            time_button = self.cells_table.cellWidget(visual_row_index, 5)
            hours_button = self.cells_table.cellWidget(visual_row_index, 6)

            from symbol_parser import parse_symbol, build_symbol
            original_parsed_symbol = parse_symbol(cell_data.get('symbol', ''))

            new_location_code = location_combo.currentData()
            new_start_hour = int(time_button.text())
            new_work_hours = int(hours_button.text())

            original_location_code = original_parsed_symbol.get('location') or default_location_code
            loc_changed = new_location_code != original_location_code
            is_reverting_to_default = loc_changed and (new_location_code == default_location_code)

            reason_for_change = ""
            if loc_changed:
                # Sprawd≈∫, czy ju≈º pytali≈õmy o pow√≥d dla tego u≈ºytkownika
                if user_id in self.reason_cache:
                    reason_for_change = self.reason_cache[user_id]
                else:
                    # Je≈õli nie, otw√≥rz okno dialogowe
                    reason_dialog = ReasonDialog(self)
                    if reason_dialog.exec() == QDialog.Accepted:
                        reason_for_change = reason_dialog.getReason()
                        # Zapisz pow√≥d w pamiƒôci podrƒôcznej dla kolejnych zmian tego u≈ºytkownika
                        self.reason_cache[user_id] = reason_for_change
                    else:
                        # U≈ºytkownik anulowa≈Ç wpisanie powodu, wiƒôc przerywamy ca≈ÇƒÖ operacjƒô
                        status_item.setText("Anulowano")
                        status_item.setForeground(QColor("gray"))
                        return

            button.setEnabled(False)
            button.setText("Przetwarzanie...")
            QApplication.processEvents()

            result = {}
            new_symbol = build_symbol(
                location=new_location_code, start_hour=new_start_hour, work_hours=new_work_hours,
                special_symbol=original_parsed_symbol.get('special_symbol')
            )

            if loc_changed:
                exact_exception, range_exception = self.parent_widget._check_location_exception(user_id, q_date)
                new_location_id = location_map.get(new_location_code, 1)

                if is_reverting_to_default:
                    if range_exception:
                        result = {"success": False,
                                  "message": "Ten dzie≈Ñ jest czƒô≈õciƒÖ wielodniowego wyjƒÖtku. Zaktualizuj go rƒôcznie, aby kontynuowaƒá."}
                    else:
                        result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year, self.month,
                                                                                   date_str, new_symbol)
                        if result.get("success") and exact_exception:
                            params = (None, modyfikujacy_id, None, None, None, None, 3, exact_exception['Id'])
                            self.parent_widget._manage_location_exception(params)
                else:
                    if exact_exception:
                        if exact_exception['Lokalizacja'] == new_location_id:
                            result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year,
                                                                                         self.month, date_str,
                                                                                         new_symbol)
                        else:
                            result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year,
                                                                                       self.month, date_str, new_symbol)
                            if result.get("success"):
                                params = (
                                user_id, modyfikujacy_id, date_str, date_str, new_location_id, "Zmiana z TeamFlowApp",
                                2, exact_exception['Id'])
                                self.parent_widget._manage_location_exception(params)
                    elif range_exception:
                        if range_exception['Lokalizacja'] != new_location_id:
                            result = {"success": False,
                                      "message": "Istnieje wyjƒÖtek w zakresie dat z innƒÖ lokalizacjƒÖ. Edytuj lub usu≈Ñ go, aby kontynuowaƒá."}
                        else:
                            result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year,
                                                                                       self.month, date_str, new_symbol)
                    else:
                        result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year, self.month,
                                                                                   date_str, new_symbol)
                        if result.get("success"):
                            params = (
                            user_id, modyfikujacy_id, date_str, date_str, new_location_id, "Wpis z TeamFlowApp", 1,
                            None)
                            self.parent_widget._manage_location_exception(params)
            else:
                result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year, self.month, date_str,
                                                                           new_symbol)

            if loc_changed and result.get("success"):
                overtime_events = self.parent_widget.data_provider.get_events_for_user_date(user_id, date_str)
                overtime_events = [e for e in overtime_events if e.get('type') == 'Nadgodziny']
                if overtime_events:
                    ot_dialog = OvertimeLocationDialog(self, overtime_events, new_location_code, self.determined_theme)
                    if ot_dialog.exec() == QDialog.Accepted:
                        location_changes = ot_dialog.get_selected_locations()
                        if location_changes:
                            self.parent_widget._update_multiple_overtime_locations(location_changes)

            if result.get("success", False):
                status_item.setText("Sukces ‚úÖ");
                status_item.setForeground(QColor("green"))
                returned_symbol = result.get('returned_symbol', new_symbol)
                self.cells_table.item(visual_row_index, 3).setText(returned_symbol)
                self.parent_widget._update_cells_with_new_symbols([(user_id, date_str, returned_symbol)])
                self.parent_widget.schedule_model.layoutChanged.emit()

                # --- POCZƒÑTEK KLUCZOWEJ POPRAWKI ---
                # Zaktualizuj wewnƒôtrznƒÖ pamiƒôƒá dialogu o nowy, zapisany symbol.
                self.flattened_cells[original_data_index]['symbol'] = returned_symbol
                # --- KONIEC KLUCZOWEJ POPRAWKI ---

            else:
                status_item.setText("Pora≈ºka ‚ùå");
                status_item.setForeground(QColor("red"))
                error_msg = result.get("message", "Nieznany b≈ÇƒÖd.")
                QMessageBox.warning(self, "B≈ÇƒÖd", f"üë§ {user_name} ({self.format_date(date_str)}):\n{error_msg}",
                                    QMessageBox.Ok)

        except Exception as e:
            if status_item: status_item.setText("Pora≈ºka ‚ùå"); status_item.setForeground(QColor("red"))
            log_error(f"B≈ÇƒÖd krytyczny w _apply_change_for_row: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd krytyczny", f"WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd: {str(e)}", QMessageBox.Ok)
        finally:
            QTimer.singleShot(2000, lambda b=button: self._reset_button_state(b))

    def format_date(self, date_str):
        try:
            year, month, day = date_str.split('-')
            return f"{day}.{month}.{year}"
        except:
            return date_str

    def _apply_all_changes(self):
        if not any([self.apply_location_check.isChecked(), self.apply_time_check.isChecked(),
                    self.apply_hours_check.isChecked()]):
            QMessageBox.warning(self, "Brak wyboru",
                                "Proszƒô zaznaczyƒá, kt√≥re atrybuty chcesz zastosowaƒá dla wszystkich.")
            return

        if (self.apply_time_check.isChecked() and self.all_time_button.text() == "Wybierz") or \
                (self.apply_hours_check.isChecked() and self.all_hours_button.text() == "Wybierz"):
            QMessageBox.warning(self, "Brak danych", "Proszƒô wybraƒá warto≈õci dla zaznaczonych atrybut√≥w.")
            return

        reply = QMessageBox.question(self, "Potwierdzenie",
                                     "Czy na pewno chcesz zastosowaƒá wybrane zmiany dla wszystkich widocznych wierszy?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.No:
            return

        # Pƒôtla aktualizujƒÖca UI, a nastƒôpnie wywo≈ÇujƒÖca zapis
        for row in range(self.cells_table.rowCount()):
            # Najpierw zaktualizuj wizualnie kontrolki w wierszu
            self._update_row_widgets_from_global_settings(row)
            # Nastƒôpnie spr√≥buj zapisaƒá zmiany dla tego wiersza
            self._apply_change_for_row(row)


    def _update_row_widgets_from_global_settings(self, visual_row):
        item = self.cells_table.item(visual_row, 0)
        if not item: return
        original_data_index = item.data(Qt.UserRole)
        cell_data = self.flattened_cells[original_data_index]
        permissions = self.parent_widget._get_permission_for_cell(cell_data)

        if self.apply_location_check.isChecked() and permissions['can_edit_location']:
            combo = self.cells_table.cellWidget(visual_row, 4)
            new_location = self.all_location_combo.currentData()
            combo.setCurrentIndex(combo.findData(new_location))
        if self.apply_time_check.isChecked() and permissions['can_edit_hours']:
            time_btn = self.cells_table.cellWidget(visual_row, 5)
            new_start_hour = self.all_time_button.text()
            time_btn.setText(new_start_hour)
        if self.apply_hours_check.isChecked() and permissions['can_edit_hours']:
            hours_btn = self.cells_table.cellWidget(visual_row, 6)
            new_work_hours = self.all_hours_button.text()
            hours_btn.setText(new_work_hours)


class DigitSelectionDialog(QDialog):
    """Dialog do wyboru cyfry z siatki przycisk√≥w."""

    def __init__(self, parent=None, title="Wybierz warto≈õƒá", values=None, current_theme="dark"):
        super().__init__(parent)
        self.parent_widget = parent
        self.current_theme = current_theme
        self.setWindowTitle(title)
        self.setModal(True)
        self.selected_value = None
        if values is None: values = list(range(10))
        self.values = values
        self.setObjectName("DigitSelectionDialogInstance")
        self.setup_ui()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu DigitSelectionDialog."""
        # --- TUTAJ BY≈Å B≈ÅƒÑD ---
        actual_theme = self.current_theme  # POPRAWKA: U≈ºyj 'self.current_theme'
        # --- KONIEC POPRAWKI ---

        self.setStyleSheet(AppStyles.get_dialog_style(actual_theme))
        button_style_qss = AppStyles.get_button_style(actual_theme)

        if hasattr(self, 'grid_layout'):
            for i in range(self.grid_layout.count()):
                widget = self.grid_layout.itemAt(i).widget()
                if isinstance(widget, QPushButton):
                    widget.setStyleSheet(button_style_qss)
                    widget.style().unpolish(widget)
                    widget.style().polish(widget)

        if hasattr(self, 'cancel_button'):
            self.cancel_button.setStyleSheet(button_style_qss)
            self.cancel_button.style().unpolish(self.cancel_button)
            self.cancel_button.style().polish(self.cancel_button)

        self.style().unpolish(self)
        self.style().polish(self)
        self.update()

    def setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        self.grid_layout = QGridLayout()
        self.grid_layout.setSpacing(5)
        cols = min(6, len(self.values))
        if cols == 0: cols = 1
        for i, value in enumerate(self.values):
            row, col = i // cols, i % cols
            button = QPushButton(str(value))
            button.setMinimumSize(25, 25)
            button.setProperty("value", value)
            button.clicked.connect(self.on_value_selected)
            self.grid_layout.addWidget(button, row, col)
        main_layout.addLayout(self.grid_layout)

        # --- POCZƒÑTEK POPRAWKI: Dodanie przycisku "Wyczy≈õƒá" ---
        self.clear_button = QPushButton("Wyczy≈õƒá")
        self.clear_button.clicked.connect(self.on_clear_selected)
        # --- KONIEC POPRAWKI ---

        self.cancel_button = QPushButton("Anuluj")
        self.cancel_button.clicked.connect(self.reject)
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        button_layout.addWidget(self.clear_button)  # <-- Dodano przycisk
        button_layout.addWidget(self.cancel_button)
        main_layout.addLayout(button_layout)
        self.adjustSize()
        self.apply_dialog_theme()

    def on_value_selected(self):
        """Obs≈Çuguje wyb√≥r warto≈õci"""
        button = self.sender()
        if button:
            self.selected_value = button.property("value")
            self.accept()

    def on_clear_selected(self):
        """Obs≈Çuguje wyczyszczenie warto≈õci."""
        self.selected_value = None
        self.accept()

    def get_selected_value(self):
        """Zwraca wybranƒÖ warto≈õƒá"""
        return self.selected_value

class OvertimeLocationDialog(QDialog):
    """Dialog do indywidualnej edycji lokalizacji dla wykrytych nadgodzin."""

    def __init__(self, parent, overtime_events, current_shift_location, current_theme="dark"):
        super().__init__(parent)
        self.setWindowTitle("Zmiana lokalizacji a nadgodziny")
        self.setMinimumWidth(450)  # Zwiƒôkszamy szeroko≈õƒá
        self.theme = current_theme
        self.events = overtime_events
        self.location_combos = []  # Bƒôdziemy przechowywaƒá tu referencje do ComboBox√≥w

        self.setup_ui(current_shift_location)
        self.apply_styles()

    def setup_ui(self, current_shift_location):
        layout = QVBoxLayout(self)

        info_text = (f"Wykryto {len(self.events)} wpis(y) nadgodzin w tym dniu. "
                     f"Lokalizacja w grafiku zosta≈Ça zmieniona na <b>'{current_shift_location.upper()}'</b>.<br><br>"
                     "Dla ka≈ºdego wpisu nadgodzin mo≈ºesz ustawiƒá innƒÖ lokalizacjƒô.")
        layout.addWidget(QLabel(info_text))

        # U≈ºywamy QGridLayout dla lepszego u≈Ço≈ºenia kontrolek
        grid_layout = QGridLayout()
        grid_layout.setSpacing(10)

        # Nag≈Ç√≥wki
        grid_layout.addWidget(QLabel("<b>Godziny nadliczbowe</b>"), 0, 0)
        grid_layout.addWidget(QLabel("<b>Obecna lokalizacja</b>"), 0, 1)
        grid_layout.addWidget(QLabel("<b>Nowa lokalizacja</b>"), 0, 2)

        # Dane dla ka≈ºdego wpisu nadgodzin
        for i, event in enumerate(self.events):
            row = i + 1
            # Informacje o godzinach
            event_label = QLabel(f"{event.get('time_from', '?')} - {event.get('time_to', '?')}")

            # Aktualna lokalizacja nadgodzin (zak≈Çadamy, ≈ºe jest w danych zdarzenia)
            current_ot_location_code = event.get('location', 'b/d')  # 'b/d' - brak danych
            location_map = {'h': 'Home Office', 's': 'SBC', 'p': 'Przystanek'}
            current_ot_location_label = QLabel(location_map.get(current_ot_location_code, "Nieznana"))

            # Menu wyboru nowej lokalizacji
            location_combo = QComboBox()
            location_combo.addItem("Bez zmian", "skip")
            location_combo.addItem(f"Jak w grafiku ({current_shift_location.upper()})", current_shift_location)
            location_combo.addItem("Home Office (h)", "h")
            location_combo.addItem("SBC (s)", "s")
            location_combo.addItem("Przystanek (p)", "p")

            # Ustaw domy≈õlnie "Bez zmian"
            location_combo.setCurrentIndex(0)

            self.location_combos.append(location_combo)  # Zapisz referencjƒô

            grid_layout.addWidget(event_label, row, 0)
            grid_layout.addWidget(current_ot_location_label, row, 1)
            grid_layout.addWidget(location_combo, row, 2)

        layout.addLayout(grid_layout)

        button_box = QHBoxLayout()
        self.ok_button = QPushButton("Zatwierd≈∫ zmiany")
        self.cancel_button = QPushButton("Anuluj")
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)
        button_box.addStretch()
        button_box.addWidget(self.cancel_button)
        button_box.addWidget(self.ok_button)
        layout.addLayout(button_box)

    def apply_styles(self):
        self.setStyleSheet(AppStyles.get_dialog_style(self.theme))
        for button in self.findChildren(QPushButton):
            button.setStyleSheet(AppStyles.get_button_style(self.theme))
        for combo in self.findChildren(QComboBox):
            combo.setStyleSheet(AppStyles.get_combobox_style(self.theme))
        for box in self.findChildren(QGroupBox):
            box.setStyleSheet(f"""
                QGroupBox {{
                    border: 1px solid {'#495057' if self.theme == 'dark' else '#ced4da'};
                    border-radius: 4px;
                    margin-top: 10px;
                }}
                QGroupBox::title {{
                    subcontrol-origin: margin;
                    subcontrol-position: top left;
                    padding: 0 3px;
                    left: 10px;
                }}
            """)

    def get_selected_locations(self):
        """Zwraca listƒô zmian w formacie [(event_id, nowa_lokalizacja), ...]."""
        changes = []
        for i, combo in enumerate(self.location_combos):
            selected_loc = combo.currentData()
            if selected_loc != "skip":  # Zapisujemy tylko te, kt√≥re faktycznie majƒÖ byƒá zmienione
                event_id = self.events[i]['id']
                changes.append((event_id, selected_loc))
        return changes
