# preparation_thread.py

from PySide6.QtCore import QThread, Signal, QMutex, QMutexLocker
from debug_utils import log_error


class PreparationThread(QThread):
    """
    Wątek roboczy do asynchronicznego ładowania i przygotowywania danych.
    """
    progress_updated = Signal(int)
    preparation_finished = Signal(object) # Zmieniono na obiekt, aby przenosić słownik z danymi
    error_occurred = Signal(str)

    def __init__(self, data_provider, year, month, grupa, funkcja, parent=None):
        super().__init__(parent)
        self.data_provider = data_provider
        self.year = year
        self.month = month
        self.grupa = grupa
        self.funkcja = funkcja
        self.mutex = QMutex()
        self._is_cancelled = False

    def run(self):
        """Główna metoda wątku ładującego dane."""
        try:
            if self.is_cancelled(): return

            # Krok 1: Pobierz kontener z danymi bazowymi
            container = self.data_provider._get_or_load_monthly_data(
                self.year, self.month, self.grupa, self.funkcja, use_cache=False
            )

            if self.is_cancelled(): return

            if not container:
                error_msg = f"Nie udało się załadować kontenera danych dla {self.year}-{self.month}"
                self.error_occurred.emit(error_msg)
                return

            # Krok 2: Pobierz przetworzone dane z nałożonymi ikonami
            processed_data_with_icons = self.data_provider.get_processed_data(
                self.year, self.month, self.grupa, self.funkcja
            )

            if self.is_cancelled(): return

            result_data = {
                'schedule_data': container.schedule_data,
                'events_data': container.events_data,
                'processed_data': processed_data_with_icons,
                'year': self.year,
                'month': self.month
            }

            self.preparation_finished.emit(result_data)

        except Exception as e:
            log_error(f"Krytyczny błąd w wątku ładowania danych: {e}", exception=e)
            if not self.is_cancelled():
                self.error_occurred.emit(str(e))

    def cancel(self):
        """Metoda do bezpiecznego anulowania wątku."""
        with QMutexLocker(self.mutex):
            self._is_cancelled = True

    def is_cancelled(self):
        """Sprawdza, czy zażądano anulowania."""
        with QMutexLocker(self.mutex):
            return self._is_cancelled
