import sys
import time
from collections import defaultdict
from datetime import datetime, timedelta, date
from typing import List, Dict, Optional, Tuple, Any
from PySide6.QtWidgets import (QApplication, QMainWindow, QTableWidget, QTableWidgetItem, QTableView, QItemDelegate,
                               QVBoxLayout, QHBoxLayout, QWidget, QLabel, QComboBox, QCompleter,
                               QPushButton, QHeaderView, QAbstractItemView, QListWidget,
                               QListWidgetItem, QLineEdit, QDialog, QCheckBox, QFrame, QDateEdit,
                               QFormLayout, QDialogButtonBox, QMessageBox, QSplitter, QStyledItemDelegate, QStyle,
                               QGridLayout, QSizePolicy, QTableWidgetSelectionRange)
from PySide6.QtCore import Qt, QThread, Signal, QDate, QTimer, QPoint, QModelIndex, QRect, QEvent, QItemSelectionModel, \
    QAbstractTableModel, QObject
from PySide6.QtGui import QShortcut, QKeySequence, QFont, QColor, QIcon, QPixmap, QPainter, QPolygon, QBrush, QPen, \
    QLinearGradient, QRadialGradient, QStandardItem, QStandardItemModel

from db_connector import DatabaseConnector, get_modifier_id
from settings_dialog import AppSettingsDialog
from schedule_edit_dialogs import InsertSymbolDialog, ScheduleChangeDialog
from settings_db import SettingsDatabase
from data_provider import DataProvider
from styles import AppStyles
from progress_dialog import LoadingProgressDialog, show_loading_dialog_async
from column_select_dialog import ColumnSelectDialog
from column_definitions import ColumnDefinitions

from schedule_model import ScheduleTableModel, ROLE_DATA
from events_model import EventsTableModel
from split_table_view import SplitTableView
from schedule_delegates import OvertimeItemDelegate
from events_delegates import ButtonDelegate
from staffing_details_window import StaffingDetailsWindow

# POPRAWKA: Dodaj import funkcji debug
from debug_utils import debug_print, log_warning, log_error, setup_logging, close_log_file

from symbol_parser import parse_symbol, build_symbol, get_symbol_description


class ScheduleKeyboardFilter(QObject):
    """
    Dedykowany filtr zdarze≈Ñ klawiatury dla tabeli grafiku z obs≈ÇugƒÖ:
    - dwucyfrowych godzin i wieloznakowych symboli (z buforowaniem)
    - modyfikacji liczby godzin (+/-/=) z poprawnym od≈õwie≈ºaniem bilansu.
    """

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window

        # Bufor i timer dla dwucyfrowych godzin
        self._digit_buffer = ""
        self._buffer_timer = QTimer()
        self._buffer_timer.setSingleShot(True)
        self._buffer_timer.timeout.connect(self._process_digit_buffer_on_timeout)
        self._buffer_timeout = 1200

        # Bufor i timer dla wieloznakowych symboli
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1200

    def eventFilter(self, obj, event):
        """G≈Ç√≥wna metoda filtrujƒÖca zdarzenia klawiatury."""
        if not (hasattr(self.main_window, 'table') and
                hasattr(self.main_window.table, 'schedule_view') and
                obj == self.main_window.table.schedule_view and
                event.type() == QEvent.KeyPress):
            return False

        key = event.key()

        if key in (Qt.Key_Plus, Qt.Key_Equal, Qt.Key_Minus):
            self._clear_digit_buffer()
            self._clear_char_buffer()
            self._handle_hour_modification(key)
            return True

        role = self.main_window.current_user_role
        can_edit_hours_symbols = role in ["Pracownik WPR", "Lider OUT"]

        is_digit_key = (Qt.Key_0 <= key <= Qt.Key_9)
        is_char_key = (Qt.Key_A <= key <= Qt.Key_Z)
        is_delete_key = key in [Qt.Key_Delete, Qt.Key_Backspace]
        is_escape_key = key == Qt.Key_Escape

        if not can_edit_hours_symbols and (is_digit_key or is_char_key or is_delete_key):
            return True

        if is_digit_key or is_char_key or is_delete_key:
            if not self._validate_selected_cells():
                return True

        if is_digit_key:
            self._handle_digit_input(key - Qt.Key_0)
            return True

        if is_char_key:
            self._handle_char_input(event.text())
            return True

        if is_delete_key:
            self.main_window.clear_selected_cells()
            self._clear_digit_buffer()
            self._clear_char_buffer()
            return True

        if is_escape_key:
            self._clear_digit_buffer()
            self._clear_char_buffer()
            self.main_window.table.schedule_view.clearSelection()
            return True

        if key in [Qt.Key_Space, Qt.Key_Enter, Qt.Key_Return, Qt.Key_Tab]:
            return True

        return False

    def _handle_hour_modification(self, key):
        """Obs≈Çuguje zwiƒôkszanie/zmniejszanie liczby godzin (+/-/=)."""
        if self.main_window.current_user_role not in ["Pracownik WPR", "Lider OUT"]:
            return

        selected_cells_data = self.main_window.table.get_data_for_selected_cells()
        if not selected_cells_data: return
        if not self.main_window._can_modify_cells(selected_cells_data): return

        updated_info = []
        error_messages = []
        skipped_count = 0

        for cell_data in selected_cells_data:
            system_pracy = cell_data.get('system_czasu_pracy', '')

            if not system_pracy or system_pracy.strip().lower() != 'zmianowy':
                skipped_count += 1
                continue

            current_symbol = cell_data.get('symbol', '')
            if not current_symbol: continue

            try:
                parsed = parse_symbol(current_symbol)
                if parsed.get('work_hours') is None: continue

                current_hours = int(parsed['work_hours'])
                new_hours = min(12, current_hours + 1) if key in (Qt.Key_Plus, Qt.Key_Equal) else max(1,
                                                                                                      current_hours - 1)
                if new_hours == current_hours: continue

                new_symbol = build_symbol(
                    location=parsed.get('location'), start_hour=parsed.get('start_hour'),
                    work_hours=new_hours, special_symbol=parsed.get('special_symbol')
                )

                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self.main_window._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )

                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"üë§ {cell_data.get('uzytkownik_dane')}: {result.get('message', 'B≈ÇƒÖd zapisu.')}")
            except (ValueError, TypeError) as e:
                log_warning(f"B≈ÇƒÖd modyfikacji godzin dla symbolu '{current_symbol}': {e}")
                error_messages.append(f"üë§ {cell_data.get('uzytkownik_dane')}: B≈ÇƒÖd aplikacji: {e}")

        if updated_info:
            self.main_window._update_cells_with_new_symbols(updated_info)
            self.main_window.schedule_model.layoutChanged.emit()
            self.main_window.statusBar().showMessage(f"Zmieniono liczbƒô godzin dla {len(updated_info)} kom√≥rek.", 4000)

        if error_messages:
            # --- ZMIANA: U≈ºycie self.main_window jako rodzica okna komunikatu ---
            QMessageBox.warning(self.main_window, "B≈Çƒôdy podczas zapisu",
                                "WystƒÖpi≈Çy nastƒôpujƒÖce b≈Çƒôdy:\n\n" + "\n".join(error_messages))
        elif not updated_info and skipped_count > 0 and skipped_count == len(selected_cells_data):
            self.main_window.statusBar().showMessage(f"Operacja dozwolona tylko dla Zmianowego Systemu Czasu Pracy.",
                                                     5000)

    def _handle_char_input(self, char: str):
        self._clear_digit_buffer()
        self._char_buffer += char.upper()
        self.main_window.statusBar().showMessage(f"Wpisywanie symbolu: {self._char_buffer}", self._char_buffer_timeout)
        if len(self._char_buffer) >= 3:
            self._char_buffer_timer.stop()
            self._process_char_buffer()
        else:
            self._char_buffer_timer.start(self._char_buffer_timeout)

    def _process_char_buffer(self):
        symbol = self._char_buffer
        self._clear_char_buffer()
        if not symbol: return

        if symbol in self.main_window.get_all_valid_symbols():
            self.main_window.apply_symbol_from_keyboard(symbol)
        else:
            self.main_window.statusBar().showMessage(f"B≈ÇƒÖd: Symbol '{symbol}' jest nieprawid≈Çowy!", 4000)

    def _handle_digit_input(self, digit: int):
        self._clear_char_buffer()
        self._digit_buffer += str(digit)
        self.main_window.statusBar().showMessage(f"Wpisywanie godziny: {self._digit_buffer}", self._buffer_timeout)

        if len(self._digit_buffer) == 1:
            if int(self._digit_buffer) >= 3:
                self.main_window.quick_edit_selected_cells(int(self._digit_buffer))
                self._clear_digit_buffer()
            else:
                self._buffer_timer.start(self._buffer_timeout)
        elif len(self._digit_buffer) == 2:
            self._buffer_timer.stop()
            potential_hour = int(self._digit_buffer)
            hour = potential_hour if 0 <= potential_hour <= 23 else int(self._digit_buffer[0])
            self.main_window.quick_edit_selected_cells(hour)
            self._clear_digit_buffer()
        else:
            self._buffer_timer.stop()
            self.main_window.quick_edit_selected_cells(digit)
            self._clear_digit_buffer()

    def _process_digit_buffer_on_timeout(self):
        if self._digit_buffer:
            self.main_window.quick_edit_selected_cells(int(self._digit_buffer))
            self._clear_digit_buffer()

    def _clear_digit_buffer(self):
        self._digit_buffer = ""
        if self._buffer_timer.isActive(): self._buffer_timer.stop()
        if self.main_window.statusBar().currentMessage().startswith("Wpisywanie godziny:"):
            self.main_window.statusBar().clearMessage()

    def _clear_char_buffer(self):
        self._char_buffer = ""
        if self._char_buffer_timer.isActive(): self._char_buffer_timer.stop()
        if self.main_window.statusBar().currentMessage().startswith("Wpisywanie symbolu:"):
            self.main_window.statusBar().clearMessage()

    def _validate_selected_cells(self) -> bool:
        selected_cells_data = self.main_window.table.get_data_for_selected_cells()
        if not selected_cells_data: return False
        return self.main_window._can_modify_cells(selected_cells_data)


class CustomMultiComboBox(QComboBox):
    """Niestandardowy ComboBox z obs≈ÇugƒÖ wielokrotnego wyboru (wersja poprawiona)."""
    selection_changed = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)

        self._selected_items = set()
        self._select_all_text = "-Wszystkie-"

        # Konfiguracja modelu
        self.setModel(QStandardItemModel(self))

        # Konfiguracja wyglƒÖdu
        self.setEditable(True)
        self.lineEdit().setReadOnly(True)
        self.setEditText("-Wszystkie-")
        self.setSizeAdjustPolicy(QComboBox.AdjustToContents)

        # U≈ºywamy filtra zdarze≈Ñ do przechwytywania klikniƒôƒá, co zapobiega zamykaniu listy
        self.view().viewport().installEventFilter(self)
        self.lineEdit().installEventFilter(self)

        # Delegat jest potrzebny do poprawnego renderowania
        self.setItemDelegate(QStyledItemDelegate(self))

    def eventFilter(self, obj, event):
        # Przechwytujemy klikniƒôcie myszƒÖ w polu tekstowym, aby pokazaƒá listƒô
        if obj == self.lineEdit() and event.type() == QEvent.MouseButtonPress:
            self.showPopup()
            return True

        # Przechwytujemy zwolnienie przycisku myszy na li≈õcie (widoku)
        if obj == self.view().viewport() and event.type() == QEvent.MouseButtonRelease:
            index = self.view().indexAt(event.position().toPoint())  # U≈ºyj .position().toPoint() zamiast .pos()
            if index.isValid():
                self.handle_item_pressed(index)
            return True

        return False

    def handle_item_pressed(self, index):
        """Logika zaznaczania/odznaczania elementu."""
        item = self.model().itemFromIndex(index)
        if not item:
            return

        if item.text() == self._select_all_text:
            # Logika dla przycisku "Zaznacz wszystkie"
            is_checked = (item.checkState() == Qt.Checked)
            new_state = Qt.Unchecked if is_checked else Qt.Checked
            for i in range(1, self.model().rowCount()):
                self.model().item(i).setCheckState(new_state)
        else:
            # Logika dla zwyk≈Çego elementu
            current_state = item.checkState()
            item.setCheckState(Qt.Checked if current_state == Qt.Unchecked else Qt.Unchecked)

        self._rebuild_selected_items()
        self.update_display_text()

        self.selection_changed.emit()

    def _rebuild_selected_items(self):
        """Przebudowuje zbi√≥r zaznaczonych element√≥w na podstawie stanu modelu."""
        self._selected_items.clear()
        all_selected = True
        # Pƒôtla od 1, aby pominƒÖƒá element "Zaznacz wszystkie"
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.checkState() == Qt.Checked:
                self._selected_items.add(item.text())
            else:
                all_selected = False

        # Aktualizuj stan checkboxa "Zaznacz wszystkie"
        if self.model().rowCount() > 0:
            select_all_item = self.model().item(0)
            select_all_item.setCheckState(Qt.Checked if all_selected else Qt.Unchecked)

    def hidePopup(self):
        """Aktualizuje tekst po zamkniƒôciu listy."""
        self.update_display_text()
        super().hidePopup()

    def add_items(self, items):
        """Dodaje elementy do ComboBoxa."""
        self.clear()

        select_all_item = QStandardItem(self._select_all_text)
        select_all_item.setCheckable(True)
        self.model().appendRow(select_all_item)

        for item_text in sorted(items):
            item = QStandardItem(item_text)
            item.setCheckable(True)
            self.model().appendRow(item)

        self.update_display_text()

    def showPopup(self):
        """Poka≈º menu rozwijane z dostosowanƒÖ szeroko≈õciƒÖ."""
        super().showPopup()  # Najpierw poka≈º listƒô, aby mo≈ºna by≈Ço obliczyƒá jej wymiary

        # Oblicz wymaganƒÖ szeroko≈õƒá na podstawie najd≈Çu≈ºszego elementu
        width = self.view().sizeHintForColumn(0) + 20  # +20 na margines i pasek przewijania

        # OPCJA 1: Ustawienie nowego, wiƒôkszego limitu szeroko≈õci
        # Zwiƒôksz limit z 250 do np. 450 pikseli. Mo≈ºna tu wpisaƒá innƒÖ warto≈õƒá.
        width = min(width, 450)

        # OPCJA 2: Ca≈Çkowite usuniƒôcie limitu (odkomentuj poni≈ºszƒÖ liniƒô i zakomentuj powy≈ºszƒÖ)
        # W tej opcji lista bƒôdzie tak szeroka, jak najd≈Çu≈ºszy element.
        # pass # Nie r√≥b nic, aby nie ograniczaƒá szeroko≈õci

        # Ustaw obliczonƒÖ minimalnƒÖ szeroko≈õƒá dla widoku listy
        self.view().setMinimumWidth(width)

    def clear(self):
        """Czy≈õci listƒô element√≥w."""
        self.model().clear()
        self._selected_items.clear()
        self.setEditText("-Wszystkie-")

    def clear_selection(self):
        """Czy≈õci zaznaczenie wszystkich element√≥w."""
        for i in range(self.model().rowCount()):
            self.model().item(i).setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()

    def get_selected_items(self):
        """Zwraca listƒô zaznaczonych element√≥w."""
        return list(self._selected_items)

    def select_items(self, items_to_select):
        """Zaznacza programowo okre≈õlone elementy na li≈õcie."""
        lookup = set(items_to_select)
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.text() in lookup:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()

    def update_display_text(self):
        """Aktualizuje tekst wy≈õwietlany w comboboxie."""
        if not self._selected_items:
            self.setEditText("-Wszystkie-")
        elif len(self._selected_items) == (self.model().rowCount() - 1):
            self.setEditText("-Wszystkie-")
        else:
            self.setEditText(f"Wybrano {len(self._selected_items)} z {self.model().rowCount() - 1}")


# class OvertimeItemDelegate(QStyledItemDelegate):
#     """
#     Niestandardowy delegat do rysowania kom√≥rek tabeli.
#     Wy≈õwietla subtelne znaczniki w prawym dolnym rogu:
#     - Czerwony tr√≥jkƒÖt dla nadgodzin
#     - Bia≈Çe k√≥≈Çko dla spotka≈Ñ/szkole≈Ñ
#
#     Zoptymalizowana wersja, kt√≥ra korzysta z dedykowanych flag zamiast deserializacji JSON.
#     """
#
#     def paint(self, painter, option, index):
#         """
#         Maluje kom√≥rkƒô z dodatkowymi ikonami dla nadgodzin, spotka≈Ñ i szkole≈Ñ.
#         Bezpieczna wersja z obs≈ÇugƒÖ wszystkich typ√≥w danych.
#         """
#         try:
#             # Najpierw spr√≥buj narysowaƒá standardowƒÖ kom√≥rkƒô
#             super().paint(painter, option, index)
#
#             # Bezpieczne pobieranie flag - u≈ºywaj metody get() lub defaultowego konwertowania na bool
#             from schedule_model import ROLE_HAS_MEETING, ROLE_HAS_OVERTIME
#             has_overtime = bool(index.data(ROLE_HAS_OVERTIME))
#             has_meeting_or_training = bool(index.data(ROLE_HAS_MEETING))
#
#             # Je≈õli element ma jakiekolwiek oznaczenia
#             if has_overtime or has_meeting_or_training:
#                 painter.save()
#                 # W≈ÇƒÖcz antyaliasing dla g≈Çadkich krawƒôdzi
#                 painter.setRenderHint(QPainter.Antialiasing)
#
#                 # Okre≈õl szeroko≈õƒá i pozycjƒô znacznik√≥w
#                 marker_width = 8  # Rozmiar znacznika
#                 marker_height = 8
#
#                 # Rysuj znacznik spotka≈Ñ/szkole≈Ñ (bia≈Çe k√≥≈Çko) w g√≥rnym prawym rogu
#                 if has_meeting_or_training:
#                     # Oblicz pozycjƒô w g√≥rnym prawym rogu
#                     top_right_x = option.rect.right() - marker_width - 2  # -2 to margines
#                     top_right_y = option.rect.top() + 2  # +2 to margines
#
#                     # Rysujemy k√≥≈Çko z bia≈Çym wype≈Çnieniem i czarnƒÖ obw√≥dkƒÖ
#                     painter.setBrush(QBrush(QColor(255, 255, 255, 240)))  # Bia≈Çe wype≈Çnienie
#                     painter.setPen(QPen(QColor(0, 0, 0, 220), 1.0))  # Czarna obw√≥dka
#                     painter.drawEllipse(
#                         top_right_x,
#                         top_right_y,
#                         marker_width,
#                         marker_height
#                     )
#
#                 # Rysuj znacznik nadgodzin (czerwony tr√≥jkƒÖt) w dolnym prawym rogu
#                 if has_overtime:
#                     # Oblicz pozycjƒô w dolnym prawym rogu
#                     bottom_right_x = option.rect.right() - marker_width - 2  # -2 to margines
#                     bottom_right_y = option.rect.bottom() - marker_height - 2  # -2 to margines
#
#                     # Czerwony tr√≥jkƒÖt z czarnƒÖ obw√≥dkƒÖ
#                     painter.setBrush(QBrush(QColor(220, 0, 0, 220)))  # Czerwone wype≈Çnienie
#                     painter.setPen(QPen(Qt.black, 1.0))  # Czarna obw√≥dka
#
#                     triangle = QPolygon()
#                     triangle.append(QPoint(bottom_right_x, bottom_right_y + marker_height))
#                     triangle.append(QPoint(bottom_right_x + marker_width, bottom_right_y + marker_height))
#                     triangle.append(QPoint(bottom_right_x + marker_width, bottom_right_y))
#                     painter.drawPolygon(triangle)
#
#                 painter.restore()
#         except Exception as e:
#             # W przypadku b≈Çƒôdu po prostu wy≈õwietl domy≈õlny wyglƒÖd kom√≥rki
#             log_error(f"B≈ÇƒÖd podczas rysowania delegata: {e}")
#             QStyledItemDelegate.paint(self, painter, option, index)

class WorkScheduleWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # --- SEKCJA 1: Wstƒôpna konfiguracja i wczytanie ustawie≈Ñ ---
        self.staffing_details_win = None
        self.settings_db = SettingsDatabase()

        # Wczytujemy CA≈ÅY s≈Çownik ustawie≈Ñ do atrybutu klasy
        self.user_settings = self.settings_db.load_settings()

        # --- KLUCZOWA POPRAWKA: Konfiguracja logowania po wczytaniu ustawie≈Ñ ---
        # U≈ºywamy zaimportowanej funkcji bezpo≈õrednio tutaj
        from debug_utils import setup_logging, debug_print

        # Pobieramy ustawienia z wczytanego s≈Çownika.
        # Je≈õli jakiego≈õ klucza brakuje, Domy≈õlnie logowanie jest WY≈ÅƒÑCZONE.
        log_to_file_setting = self.user_settings.get('log_to_file', False)
        log_to_console_setting = self.user_settings.get('log_to_console', False)

        # Konfigurujemy logowanie na podstawie faktycznych ustawie≈Ñ.
        setup_logging(
            log_to_file=log_to_file_setting,
            log_to_console=log_to_console_setting
        )
        # --- KONIEC POPRAWKI ---

        debug_print(f"ZA≈ÅADOWANE USTAWIENIA PRZY STARCIE: {self.user_settings}")
        debug_print(f"Logowanie do pliku ustawiono na: {log_to_file_setting}")
        debug_print(f"Logowanie do konsoli ustawiono na: {log_to_console_setting}")

        # Dalsza czƒô≈õƒá konstruktora __init__ pozostaje bez zmian
        self.current_user_role = None
        self.current_user_id = None
        self.db_connector = DatabaseConnector()
        # U≈ºywamy wczytanego s≈Çownika do konfiguracji
        self.is_dark_theme = self.user_settings.get('theme') == 'dark'
        self.current_font = self.user_settings.get('font_family')
        self.current_font_size = self.user_settings.get('font_size')
        self.import_grupa = self.user_settings.get('import_grupa', 3)
        self.import_funkcja = self.user_settings.get('import_funkcja', 1)
        self.show_comment_column = self.user_settings.get('show_schedule_comment', False)
        self.can_see_next_month = False

        from data_provider import DataProvider
        self.data_provider = DataProvider()
        self.statusBar().showMessage("Gotowy")

        self.column_definitions = ColumnDefinitions()
        self.employee_columns = self.column_definitions.get_ui_display_columns()
        self.default_visible_columns = self.column_definitions.DEFAULT_VISIBLE_COLUMNS
        saved_columns = self.user_settings.get('visible_columns')
        self.visible_columns = saved_columns if saved_columns else self.default_visible_columns.copy()

        self.data_provider.data_changed.connect(self.on_data_changed)
        self.setWindowTitle("TeamFlowApp")
        self.setGeometry(100, 100, 1600, 800)

        # Inicjalizacja atrybut√≥w
        self.left_panel_visible = True
        self._updating_selection = False
        self._cross_filtering_enabled = True
        self.raw_data = []
        self.processed_data = {}
        self.last_modification_date = None
        self.all_events_data = []
        self.user_info_map = {}
        self._selection_timer = QTimer();
        self._selection_timer.setSingleShot(True)
        self._selection_timer.timeout.connect(self._handle_selection_change)

        self._selection_debounce_delay = 50  # Op√≥≈∫nienie w milisekundach (50ms)

        # --- SEKCJA 2: Budowa UI i sprawdzenie uprawnie≈Ñ ---
        font = QFont(self.current_font, self.current_font_size)
        QApplication.setFont(font)

        # Tworzymy UI
        self.setup_ui()

        # Sprawdzamy uprawnienia
        if not self.check_user_permissions():
            return

        # --- SEKCJA 3: Tworzenie modeli i ≈ÇƒÖczenie z UI ---
        self.schedule_model = ScheduleTableModel(self, user_role=self.current_user_role)
        self.events_model = EventsTableModel(self)

        # --- KLUCZOWA ZMIANA KOLEJNO≈öCI ---
        # Konfigurujemy modele i delegat√≥w DOPIERO po setup_ui i check_user_permissions
        self.schedule_model.set_visible_columns(self.visible_columns)
        self.schedule_model.set_show_comment_column(self.show_comment_column)
        self.schedule_model.set_theme(self.is_dark_theme)
        self.events_model.set_theme(self.is_dark_theme)

        self.table.set_model(self.schedule_model)
        self.events_table.setModel(self.events_model)

        # Ta metoda tworzy delegata na podstawie wczytanych self.user_settings
        self.setup_table_properties()

        # --- SEKCJA 4: Za≈Çadowanie danych i pod≈ÇƒÖczenie sygna≈Ç√≥w ---
        self.setup_keyboard_editing()
        self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font, self.current_font_size)
        self.setup_date_combo()
        self.date_combo.currentIndexChanged.connect(self.on_date_combo_changed)

        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data
            self.update_data(year, month)
            self.update_filter_dates()

        self.clear_events_on_startup()

        self.check_timer = QTimer(self);
        self.check_timer.timeout.connect(self.check_for_new_data);
        self.check_timer.start(60000)

        # Skr√≥ty klawiszowe
        self.shortcut_f1 = QShortcut(QKeySequence(Qt.Key_F1), self);
        self.shortcut_f1.activated.connect(self.toggle_left_panel)
        self.shortcut_f2 = QShortcut(QKeySequence(Qt.Key_F2), self);
        self.shortcut_f2.activated.connect(self.toggle_events_panel)
        self.shortcut_f12 = QShortcut(QKeySequence(Qt.Key_F12), self);
        self.shortcut_f12.activated.connect(self.clear_special_symbol_from_selected_cells)
        self.shortcut_f3 = QShortcut(QKeySequence(Qt.Key_F3), self);
        self.shortcut_f3.activated.connect(self.show_insert_change_dialog)
        self.shortcut_f4 = QShortcut(QKeySequence(Qt.Key_F4), self);
        self.shortcut_f4.activated.connect(self.show_insert_symbol_dialog)
        self.shortcut_f5 = QShortcut(QKeySequence(Qt.Key_F5), self);
        self.shortcut_f5.activated.connect(self.cancel_delegations)

        debug_print("=== APLIKACJA TEAMFLOW URUCHOMIONA ===")
        debug_print(f"U≈ºytkownik: {self.current_user_app_id} ({self.current_user_role})")
        debug_print(f"Motyw: {'ciemny' if self.is_dark_theme else 'jasny'}")
        debug_print(f"Czcionka: {self.current_font} {self.current_font_size}pt")

    def show_staffing_details_window(self):
        # Sprawd≈∫, czy wybrany jest miesiƒÖc
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Brak danych", "Proszƒô wybraƒá miesiƒÖc, aby wy≈õwietliƒá szczeg√≥≈Çy obsady.",
                                QMessageBox.Ok)
            return

        year, month = current_data

        # Je≈õli okno ju≈º istnieje i jest widoczne, aktywuj je i zaktualizuj dane
        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            self.staffing_details_win.activateWindow()
            self.staffing_details_win.raise_()  # Upewnij siƒô, ≈ºe okno jest na wierzchu
            # Ustaw aktualny motyw przed aktualizacjƒÖ danych, na wypadek gdyby siƒô zmieni≈Ç
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.update_for_new_month_or_filters(year, month)
            debug_print(f"StaffingDetailsWindow: Aktywowano i zaktualizowano istniejƒÖce okno dla {year}-{month}.")
        else:
            # Utw√≥rz nowe okno, przekazujƒÖc siebie jako rodzica, data_provider oraz aktualny rok i miesiƒÖc
            debug_print(f"StaffingDetailsWindow: Tworzenie nowego okna dla {year}-{month}.")
            self.staffing_details_win = StaffingDetailsWindow(
                self, self.data_provider, year, month, self.import_grupa, self.import_funkcja
            )
            # Ustaw motyw przed pierwszym pokazaniem
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.show()
            # Po pokazaniu, dane zostanƒÖ za≈Çadowane przez `load_and_display_data` w konstruktorze StaffingDetailsWindow
            # lub przez wywo≈Çanie `update_for_new_month_or_filters` je≈õli dane majƒÖ byƒá ≈Çadowane tylko po pokazaniu.
            # Obecna implementacja StaffingDetailsWindow ≈Çaduje dane w __init__ (poprzez load_and_display_data).

        # Je≈õli chcesz, aby dane by≈Çy ≈Çadowane/od≈õwie≈ºane za ka≈ºdym razem, gdy okno jest pokazywane (nawet je≈õli ju≈º istnia≈Ço):
        # if self.staffing_details_win:
        # self.staffing_details_win.set_current_theme(self.is_dark_theme) # Ustaw motyw
        # self.staffing_details_win.update_for_new_month_or_filters(year, month) #

    def setup_keyboard_editing(self):
        """Konfiguruje edycjƒô klawiatury dla kom√≥rek grafiku"""
        # Sprawd≈∫ czy u≈ºytkownik ma uprawnienia do edycji klawiatury
        allowed_roles = ["Pracownik WPR", "Lider OUT"]
        if not hasattr(self, 'current_user_role') or self.current_user_role not in allowed_roles:
            debug_print(
                f"Edycja klawiatury wy≈ÇƒÖczona - rola '{getattr(self, 'current_user_role', 'Brak')}' nie ma uprawnie≈Ñ.")
            return

        # Utw√≥rz dedykowany filtr klawiatury
        self.keyboard_filter = ScheduleKeyboardFilter(self)

        # Zainstaluj filtr zdarze≈Ñ dla tabeli grafiku
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            self.table.schedule_view.installEventFilter(self.keyboard_filter)
            debug_print(f"W≈ÇƒÖczono edycjƒô klawiatury dla roli: {self.current_user_role}")

    def cleanup_keyboard_filter(self):
        """Czy≈õci filtr klawiatury przy zamykaniu aplikacji"""
        if hasattr(self, 'keyboard_filter'):
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.removeEventFilter(self.keyboard_filter)
            del self.keyboard_filter
            debug_print("Wyczyszczono filtr klawiatury")

    def quick_edit_selected_cells(self, start_hour):
        """
        Szybka edycja zaznaczonych kom√≥rek z klawiatury

        Args:
            start_hour (int): Godzina rozpoczƒôcia (0-9)
        """
        try:
            # Sprawd≈∫ uprawnienia
            allowed_roles = ["Pracownik WPR", "Lider OUT"]
            if not hasattr(self, 'current_user_role') or self.current_user_role not in allowed_roles:
                debug_print("Brak uprawnie≈Ñ do edycji klawiatury")
                return

            # Pobierz zaznaczone kom√≥rki
            selected_cells_data = self.table.get_data_for_selected_cells()

            if not self._can_modify_cells(selected_cells_data):
                return

            if not selected_cells_data:
                debug_print("Brak zaznaczonych kom√≥rek do edycji")
                return

            # Filtruj tylko kom√≥rki grafiku (nie kolumny pracownik√≥w)
            schedule_cells = []
            for cell_data in selected_cells_data:
                if isinstance(cell_data, dict) and 'date_str' in cell_data and 'uzytkownik_id' in cell_data:
                    schedule_cells.append(cell_data)

            if not schedule_cells:
                debug_print("Brak kom√≥rek grafiku do edycji")
                return

            debug_print(f"Szybka edycja: {len(schedule_cells)} kom√≥rek, godzina start: {start_hour}")

            # Pogrupuj kom√≥rki dla lepszego komunikatu potwierdzenia
            grouped_changes = {}
            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                user_name = cell_data.get('uzytkownik_dane', '')
                date_str = cell_data.get('date_str')

                # Formatuj datƒô
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str

                user_key = (user_id, user_name)
                if user_key not in grouped_changes:
                    grouped_changes[user_key] = []
                grouped_changes[user_key].append(formatted_date)

            # Przygotuj komunikat potwierdzenia
            changes_info = f"Zmiana godziny rozpoczƒôcia na {start_hour}:00 dla:\n\n"
            for (user_id, user_name), dates in grouped_changes.items():
                changes_info += f"üë§ {user_name}:\n"
                dates_str = ", ".join(sorted(dates))
                changes_info += f"   üìÖ {dates_str}\n\n"

            changes_info += f"≈ÅƒÖcznie: {len(schedule_cells)} kom√≥rek"

            # Poka≈º potwierdzenie
            reply = QMessageBox.question(
                self,
                "Potwierdzenie szybkiej edycji",
                changes_info,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )

            if reply == QMessageBox.Yes:
                self._apply_quick_changes(schedule_cells, start_hour)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas szybkiej edycji: {e}")
            QMessageBox.critical(
                self,
                "B≈ÇƒÖd",
                f"WystƒÖpi≈Ç b≈ÇƒÖd podczas edycji: {str(e)}",
                QMessageBox.Ok
            )

    def _apply_quick_changes(self, schedule_cells, start_hour):
        """Stosuje szybkƒÖ zmianƒô godziny rozpoczƒôcia z obs≈ÇugƒÖ b≈Çƒôd√≥w."""
        updated_info = []
        error_messages = []
        for cell_data in schedule_cells:
            current_symbol = cell_data.get('symbol', '')
            parsed = parse_symbol(current_symbol)
            try:
                work_hours = int(float(cell_data.get('etat', 8.0)))
            except (ValueError, TypeError):
                work_hours = 8

            new_symbol = build_symbol(
                location=parsed.get('location') or cell_data.get('lokalizacja_domyslna'),
                start_hour=start_hour,
                work_hours=parsed.get('work_hours') or work_hours,
                special_symbol=None  # Szybka zmiana godziny usuwa symbol specjalny
            )

            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"üë§ {cell_data.get('uzytkownik_dane')}: {result.get('message', 'B≈ÇƒÖd zapisu.')}")
            except Exception as e:
                log_error(f"B≈ÇƒÖd krytyczny w _apply_quick_changes: {e}")
                error_messages.append(f"üë§ {cell_data.get('uzytkownik_dane')}: B≈ÇƒÖd aplikacji: {e}")

        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Zmieniono godzinƒô rozpoczƒôcia dla {len(updated_info)} kom√≥rek.", 4000)
            self.schedule_model.layoutChanged.emit()

        if error_messages:
            QMessageBox.warning(self, "B≈Çƒôdy podczas zapisu",
                                "WystƒÖpi≈Çy nastƒôpujƒÖce b≈Çƒôdy:\n\n" + "\n".join(error_messages))

    def _show_keyboard_edit_results(self, successful_updates, failed_updates, error_messages, start_hour):
        """
        Pokazuje wyniki edycji klawiatury - uproszczone komunikaty
        """
        if successful_updates > 0:
            message = f"Pomy≈õlnie zaktualizowano {successful_updates} kom√≥rek (cyfra: {start_hour})"

            if failed_updates > 0:
                message += f"\n\n‚ö†Ô∏è {failed_updates} aktualizacji nie powiod≈Ço siƒô"
                if error_messages:
                    message += ":\n" + "\n".join(error_messages[:3])  # Poka≈º tylko 3 b≈Çƒôdy
                    if len(error_messages) > 3:
                        message += f"\n... i {len(error_messages) - 3} wiƒôcej b≈Çƒôd√≥w"

            QMessageBox.information(
                self,
                "Edycja klawiatury",
                message,
                QMessageBox.Ok
            )
        else:
            message = f"Nie uda≈Ço siƒô zaktualizowaƒá ≈ºadnej kom√≥rki (cyfra: {start_hour})"
            if error_messages:
                message += f"\n\nB≈Çƒôdy:\n" + "\n".join(error_messages[:5])

            QMessageBox.warning(
                self,
                "B≈ÇƒÖd edycji klawiatury",
                message,
                QMessageBox.Ok
            )

    def _prepare_deletion_summary_message(self, schedule_cells: list) -> str:
        """
        Przygotowuje sformatowanƒÖ wiadomo≈õƒá podsumowujƒÖcƒÖ, kt√≥re symbole zostanƒÖ usuniƒôte,
        grupujƒÖc je wed≈Çug u≈ºytkownika i dat.
        """
        if not schedule_cells:
            return "Nie wybrano ≈ºadnych kom√≥rek z symbolami do usuniƒôcia."

        grouped_deletions = {}
        # Grupowanie kom√≥rek: U≈ºytkownik -> Lista sformatowanych dat z symbolami
        for cell_data in schedule_cells:
            user_name = cell_data.get('uzytkownik_dane', 'Nieznany U≈ºytkownik')
            date_str = cell_data.get('date_str', 'Nieznana Data')
            symbol = cell_data.get('symbol', '??')  # Pobierz symbol do wy≈õwietlenia

            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except ValueError:
                formatted_date = date_str

            if user_name not in grouped_deletions:
                grouped_deletions[user_name] = []
            grouped_deletions[user_name].append(f"{formatted_date} (symbol: {symbol})")

        summary_lines = ["Czy na pewno chcesz usunƒÖƒá symbole dla nastƒôpujƒÖcych pozycji?\n"]
        for user_name, date_symbol_list in grouped_deletions.items():
            summary_lines.append(f"üë§ {user_name}:")
            # Aby uniknƒÖƒá zbyt d≈Çugich linii, mo≈ºna dzieliƒá listƒô dat
            # Na razie wy≈õwietlimy wszystkie dla danego u≈ºytkownika
            for date_with_symbol in sorted(date_symbol_list):  # Sortuj daty dla sp√≥jno≈õci
                summary_lines.append(f"   ‚Ä¢ {date_with_symbol}")
            summary_lines.append("")  # Pusta linia dla lepszej czytelno≈õci miƒôdzy u≈ºytkownikami

        summary_lines.append(f"≈ÅƒÖcznie zostanie wyczyszczonych: {len(schedule_cells)} kom√≥rek.")
        return "\n".join(summary_lines)

    def clear_selected_cells(self):
        """
        Czy≈õci symbole z zaznaczonych kom√≥rek (Delete/Backspace) z ulepszonym potwierdzeniem.
        """
        try:
            if hasattr(self, 'keyboard_filter') and hasattr(self.keyboard_filter, '_buffer_timer'):
                self.keyboard_filter._buffer_timer.stop()
                self.keyboard_filter._digit_buffer = ""

            allowed_roles = ["Pracownik WPR", "Lider OUT"]
            if not hasattr(self, 'current_user_role') or self.current_user_role not in allowed_roles:
                debug_print("Brak uprawnie≈Ñ do usuwania symboli klawiatury")
                return

            selected_cells_data = self.table.get_data_for_selected_cells()

            if not self._can_modify_cells(selected_cells_data):
                return

            if not selected_cells_data:
                debug_print("Brak zaznaczonych kom√≥rek do wyczyszczenia")
                return

            schedule_cells = []
            for cell_data in selected_cells_data:
                if isinstance(cell_data, dict) and 'date_str' in cell_data and 'uzytkownik_id' in cell_data:
                    current_symbol = cell_data.get('symbol', '')
                    if current_symbol and current_symbol.strip():
                        schedule_cells.append(cell_data)

            if not schedule_cells:
                debug_print("Brak kom√≥rek z symbolami do wyczyszczenia")
                self.statusBar().showMessage("Zaznaczone kom√≥rki sƒÖ puste lub nie zawierajƒÖ symboli do usuniƒôcia.",
                                             3000)
                return

            # Przygotuj szczeg√≥≈Çowy komunikat potwierdzenia
            confirmation_message = self._prepare_deletion_summary_message(schedule_cells)

            # Poka≈º potwierdzenie, ustawiajƒÖc "Tak" jako domy≈õlny przycisk (reagujƒÖcy na Enter)
            reply = QMessageBox.question(
                self,
                "Potwierdzenie usuniƒôcia symboli",
                confirmation_message,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes  # Ustawia "Tak" jako domy≈õlny przycisk
            )

            if reply == QMessageBox.Yes:
                self._clear_cells_symbols(schedule_cells)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas czyszczenia kom√≥rek: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd krytyczny",
                                 f"WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd podczas pr√≥by usuniƒôcia symboli: {str(e)}")

    def _clear_cells_symbols(self, schedule_cells: list):
        """
        Usuwa symbole z podanych kom√≥rek poprzez wywo≈Çanie procedury
        p_P_ZZ_ImportZmianyNaSerwer_v3 z pustym symbolem.
        """
        successful_updates = 0
        failed_updates = 0
        error_messages = []
        affected_pairs = []  # Ta lista musi zawieraƒá krotki 3-elementowe

        debug_print(f"Rozpoczynam usuwanie symboli dla {len(schedule_cells)} kom√≥rek.")

        for cell_data in schedule_cells:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            nr_kadrowy = cell_data.get('nr_kadrowy')

            if not user_id or not date_str or not nr_kadrowy:
                failed_updates += 1
                error_detail = f"user_id={user_id}, data={date_str}, nr_kadrowy={nr_kadrowy}"
                if not nr_kadrowy:
                    error_messages.append(f"Brak numeru kadrowego dla u≈ºytkownika {user_id} w dniu {date_str}.")
                else:
                    error_messages.append(f"Niekompletne dane dla kom√≥rki: {error_detail}.")
                log_warning(f"Pominiƒôto kom√≥rkƒô z powodu niekompletnych danych: {error_detail}")
                continue

            try:
                year, month, day = date_str.split('-')
                date_obj = f"{year}-{month}-{day}"

                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy,
                    rok=int(year),
                    miesiac=int(month),
                    data=date_obj,
                    symbol=""  # Pusty symbol oznacza usuniƒôcie
                )

                if result.get('success', False):
                    successful_updates += 1
                    # --- KLUCZOWA POPRAWKA ---
                    # Dodajemy krotkƒô z 3 elementami, w tym symbolem zwrotnym z procedury.
                    # Dla usuwania, zwr√≥cony symbol powinien byƒá pustym stringiem.
                    affected_pairs.append((user_id, date_str, result.get('returned_symbol')))
                    debug_print(f"Pomy≈õlnie usuniƒôto symbol: U≈ºytkownik {user_id} ({nr_kadrowy}), Data {date_str}")
                else:
                    failed_updates += 1
                    error_msg = result.get('message', 'Nieznany b≈ÇƒÖd podczas usuwania symbolu.')
                    error_messages.append(f"Pracownik {nr_kadrowy} (dnia {date_str}): {error_msg}")
                    debug_print(f"B≈ÇƒÖd usuwania symbolu dla {nr_kadrowy} ({date_str}): {error_msg}")

            except ValueError:
                failed_updates += 1
                error_messages.append(f"{nr_kadrowy} ({date_str}): Nieprawid≈Çowy format daty.")
                log_error(f"Nieprawid≈Çowy format daty dla {nr_kadrowy}, {date_str} przy usuwaniu symbolu.")
            except Exception as e:
                failed_updates += 1
                error_messages.append(f"{nr_kadrowy} ({date_str}): B≈ÇƒÖd krytyczny - {str(e)}")
                log_error(f"Krytyczny b≈ÇƒÖd podczas usuwania symbolu dla {user_id}, {date_str}: {e}", exception=e)

        # Od≈õwie≈º dane w UI, je≈õli by≈Çy jakie≈õ udane operacje
        if successful_updates > 0 and affected_pairs:
            # Wywo≈Çanie metody od≈õwie≈ºajƒÖcej z poprawnie sformatowanymi danymi
            self._update_cells_with_new_symbols(affected_pairs)
            debug_print(f"Od≈õwie≈ºono {len(affected_pairs)} kom√≥rek po usuniƒôciu symboli.")

        # Poka≈º wyniki operacji
        self._show_clear_symbols_results(successful_updates, failed_updates, error_messages)

    def _show_clear_symbols_results(self, successful_updates: int, failed_updates: int, error_messages: list):
        """
        Wy≈õwietla u≈ºytkownikowi podsumowanie operacji usuwania symboli.
        """
        if successful_updates > 0:
            # ZMIANA: U≈ºycie paska statusu zamiast okna dialogowego
            message = f"Pomy≈õlnie usuniƒôto symbole z {successful_updates} kom√≥rek."
            if failed_updates > 0:
                # Je≈õli by≈Çy b≈Çƒôdy, poka≈º je w oknie dialogowym, ale nie pokazuj ju≈º okna sukcesu
                error_list_str = "\n - " + "\n - ".join(error_messages[:5])
                QMessageBox.warning(self, "Czƒô≈õciowy sukces",
                                    f"{message}\n\nNie uda≈Ço siƒô usunƒÖƒá {failed_updates} symboli:{error_list_str}",
                                    QMessageBox.Ok)
            else:
                # Je≈õli nie by≈Ço b≈Çƒôd√≥w, poka≈º informacjƒô tylko na pasku statusu
                self.statusBar().showMessage(message, 4000)
        else:
            message = "Nie uda≈Ço siƒô usunƒÖƒá symboli z ≈ºadnej zaznaczonej kom√≥rki."
            if error_messages:
                error_list_str = "\n - " + "\n - ".join(error_messages[:10])
                message += f"\n\nB≈Çƒôdy ({len(error_messages)}):" + error_list_str
            QMessageBox.warning(self, "B≈ÇƒÖd usuwania symboli", message, QMessageBox.Ok)

    def set_cell_data(self, row, col, data_dict):
        """
        Ustawia dane w kom√≥rce modelu.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny
            data_dict: S≈Çownik z danymi do zapisania

        Returns:
            bool: True je≈õli operacja siƒô powiod≈Ça, False w przeciwnym razie
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return False

        if not isinstance(data_dict, dict):
            log_error(f"B≈ÇƒÖd: data_dict nie jest s≈Çownikiem: {type(data_dict)}")
            return False

        # Utw√≥rz indeks modelu dla podanej pozycji
        index = self.schedule_model.index(row, col)
        if not index.isValid():
            return False

        # Ustaw dane w modelu
        return self.schedule_model.setData(index, data_dict, Qt.UserRole)

    def on_data_changed(self, data_type, year, month):
        """Obs≈Çuguje powiadomienie o zmianie danych z DataProvider."""
        current_data = self.date_combo.currentData()
        if not (current_data and current_data == (year, month)):
            return

        if data_type == "schedule":
            self.update_table_content()
        elif data_type == "events":
            # Po prostu od≈õwie≈ºamy tabelƒô zdarze≈Ñ, je≈õli co≈õ siƒô w nich zmieni≈Ço
            self.on_selection_changed()

    def log_time(self, label, start_time):
        """Pomocnicza funkcja do logowania czasu"""
        end_time = time.time()
        elapsed = end_time - start_time
        debug_print(f"[CZAS] {label}: {elapsed:.3f} sekundy")
        return end_time

    def setup_ui(self):
        """Ustawia interfejs u≈ºytkownika"""
        # G≈Ç√≥wny widget i layout
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)

        # WA≈ªNA ZMIANA: Usuniƒôcie marginesy g√≥rnego i dolnego
        main_layout.setContentsMargins(10, 0, 10, 0)  # Lewy, G√≥rny, Prawy, Dolny
        main_layout.setSpacing(0)  # Brak odstƒôpu miƒôdzy elementami

        # Tworzenie poszczeg√≥lnych czƒô≈õci interfejsu
        top_bar = self.setup_top_bar(main_layout)

        # Dodanie g√≥rnego paska do g≈Ç√≥wnego layoutu
        main_layout.addWidget(top_bar)

        # Dodanie splittera ≈õrodkowego
        middle_splitter = self.setup_middle_section(main_layout)
        main_layout.addWidget(middle_splitter, 1)  # Dodaj z rozciƒÖganiem (waga 1)

        # Ustawienie g≈Ç√≥wnego widgetu
        self.setCentralWidget(central_widget)

        # Dodatkowe konfiguracje
        self.setup_table_properties()

        # ZMIANA: Pod≈ÇƒÖcz sygna≈Ç selection_changed dopiero po utworzeniu wszystkich komponent√≥w
        if hasattr(self, 'table'):
            # Od≈ÇƒÖcz poprzednie po≈ÇƒÖczenia je≈õli istniejƒÖ
            try:
                self.table.selection_changed.disconnect()
            except:
                pass

            # Pod≈ÇƒÖcz nowe po≈ÇƒÖczenie
            self.table.selection_changed.connect(self.on_selection_changed)

    def setup_top_bar(self, main_layout):
        """Tworzy g√≥rny pasek z przyciskami i kontrolkami"""
        top_bar_frame = QFrame()
        top_bar_frame.setFrameShape(QFrame.StyledPanel)
        top_bar_frame.setFrameShadow(QFrame.Raised)
        top_bar_frame.setFixedHeight(50)

        top_bar_layout = QHBoxLayout(top_bar_frame)
        top_bar_layout.setContentsMargins(5, 5, 5, 5)
        top_bar_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        self.toggle_menu_button = QPushButton()
        self.toggle_menu_button.setFixedSize(32, 32)
        self.toggle_menu_button.setText("‚ò∞")
        self.toggle_menu_button.setToolTip("Poka≈º/ukryj panel filtr√≥w (F1)")
        self.toggle_menu_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))  #
        self.toggle_menu_button.clicked.connect(self.toggle_left_panel)
        top_bar_layout.addWidget(self.toggle_menu_button)

        self.settings_button = QPushButton("Ustawienia")  # NOWY PRZYCISK
        self.settings_button.clicked.connect(self.show_settings_dialog)  # NOWA METODA
        self.settings_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))  #

        date_label = QLabel("MiesiƒÖc:")
        self.date_combo = QComboBox()
        self.date_combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        self.setup_date_combo()
        # self.date_combo.currentIndexChanged.connect(self.on_date_combo_changed)

        self.refresh_button = QPushButton("Od≈õwie≈º dane")
        self.refresh_button.clicked.connect(self.refresh_data)
        self.refresh_button.setToolTip("Od≈õwie≈º dane (u≈ºywa async loading dla lepszej wydajno≈õci)")
        self.refresh_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))  #

        self.show_audit_button = QPushButton("Historia Zmian")
        self.show_audit_button.clicked.connect(self.show_audit_log_window)
        self.show_audit_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.show_audit_button.setToolTip("Poka≈º historiƒô modyfikacji grafiku dla wybranego miesiƒÖca i filtr√≥w")

        self.staffing_details_button = QPushButton("Obsada")  # Mo≈ºesz wybraƒá innƒÖ nazwƒô
        self.staffing_details_button.clicked.connect(self.show_staffing_details_window)  # Po≈ÇƒÖcz z nowƒÖ metodƒÖ
        self.staffing_details_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))  #
        self.staffing_details_button.setToolTip("Poka≈º szczeg√≥≈Çy obsady godzinowej")

        top_bar_layout.addWidget(self.settings_button)
        top_bar_layout.addWidget(date_label)
        top_bar_layout.addWidget(self.date_combo)
        top_bar_layout.addWidget(self.refresh_button)
        top_bar_layout.addWidget(self.show_audit_button)
        top_bar_layout.addWidget(self.staffing_details_button)  # Dodaj nowy przycisk do layoutu
        self.schedule_control_button = QPushButton("ZarzƒÖdzaj Grafikiem")
        self.schedule_control_button.clicked.connect(self.show_schedule_control_dialog)
        self.schedule_control_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.schedule_control_button.setToolTip("Otwiera panel zarzƒÖdzania statusami, publikacjƒÖ i blokadami grafiku")
        top_bar_layout.addWidget(self.schedule_control_button)
        top_bar_layout.addStretch()

        # Nie dodawaj top_bar_frame do main_layout tutaj, je≈õli setup_ui robi to globalnie
        # main_layout.addWidget(top_bar_frame) # Zak≈ÇadajƒÖc, ≈ºe setup_ui dodaje top_bar_frame

        return top_bar_frame

    def setup_date_combo(self):
        """Konfiguruje combobox z datami, uwzglƒôdniajƒÖc uprawnienia."""
        current_date = datetime.now()
        months_to_show = []
        year, month = current_date.year, current_date.month

        # Generowanie 3 miesiƒôcy wstecz
        for i in range(3, 0, -1):
            prev_month, prev_year = (month - i, year)
            while prev_month <= 0:
                prev_month += 12
                prev_year -= 1
            months_to_show.append((prev_year, prev_month))

        # Dodaj bie≈ºƒÖcy miesiƒÖc
        months_to_show.append((year, month))

        # --- ZMIANA: Warunkowe dodawanie przysz≈Çego miesiƒÖca ---
        if self.can_see_next_month:
            next_month, next_year = (month + 1, year)
            if next_month > 12:
                next_month = 1
                next_year += 1
            months_to_show.append((next_year, next_month))
            debug_print("Dodano przysz≈Çy miesiƒÖc do listy wyboru.")

        # Zapisujemy aktualnie wybrany indeks, aby go przywr√≥ciƒá
        current_index = self.date_combo.currentIndex()
        if current_index == -1:  # Je≈õli to pierwsze uruchomienie
            current_index = 3  # Domy≈õlnie bie≈ºƒÖcy miesiƒÖc

        self.date_combo.clear()
        for y, m in months_to_show:
            self.date_combo.addItem(f"{y}-{m:02d}", (y, m))

        # Przywracamy indeks, upewniajƒÖc siƒô, ≈ºe jest w zakresie
        if current_index < self.date_combo.count():
            self.date_combo.setCurrentIndex(current_index)
        else:
            # Je≈õli usunƒôli≈õmy przysz≈Çy miesiƒÖc, ustawiamy na ostatni dostƒôpny
            self.date_combo.setCurrentIndex(self.date_combo.count() - 1)

    def setup_middle_section(self, main_layout):
        """Tworzy ≈õrodkowƒÖ sekcjƒô z filtrem i tabelami"""
        # G≈Ç√≥wny kontener na ≈õrodkowƒÖ czƒô≈õƒá (filtry po lewej, tabela po prawej)
        main_splitter = QSplitter(Qt.Horizontal)

        # Ustaw politykƒô rozmiaru - aby element wype≈Çnia≈Ç dostƒôpnƒÖ przestrze≈Ñ
        main_splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Tworzenie lewego panelu filtr√≥w
        self.setup_left_panel()
        # Zapamiƒôtaj standardowƒÖ szeroko≈õƒá lewego panelu
        self.left_panel_width = 280  # Domy≈õlna szeroko≈õƒá panelu

        # Tworzenie prawego panelu z tabelami
        right_panel = self.setup_right_panel()

        # Dodaj panele do g≈Ç√≥wnego splittera
        main_splitter.addWidget(self._left_panel)
        main_splitter.addWidget(right_panel)

        # Ustaw poczƒÖtkowe proporcje dla g≈Ç√≥wnego splittera (np. 25% lewy panel, 75% prawy panel)
        main_splitter.setSizes([280, 720])

        # Zapisz referencjƒô do splittera
        self.main_splitter = main_splitter

        self.main_splitter.setStretchFactor(0, 0)  # Lewy panel (employees_view) nie jest rozciƒÖgany
        self.main_splitter.setStretchFactor(1, 1)  # Prawy panel (schedule_view) jest rozciƒÖgany

        # NIE dodawaj main_splitter do main_layout - zwr√≥ƒá go tylko
        return main_splitter

    def setup_left_panel(self):
        """Tworzy lewy panel z filtrami."""
        self._left_panel = QWidget()
        self._left_panel.setStyleSheet(AppStyles.get_left_panel_style("dark" if self.is_dark_theme else "light"))
        self._left_panel.setMinimumWidth(280)
        self._left_panel.setMaximumWidth(280)

        filters_layout = QVBoxLayout(self._left_panel)
        filters_layout.setContentsMargins(10, 10, 10, 10)
        filters_layout.setSpacing(6)

        filters_title = QLabel("Filtry")
        filters_title.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light", is_title=True))
        filters_layout.addWidget(filters_title)

        self.add_horizontal_filter("Grupa:", "grupa_main_filter_combo", filters_layout)
        self.add_horizontal_filter("Wydzia≈Ç:", "wydzial_combo", filters_layout)
        self.add_horizontal_search_filter("Prze≈Ço≈ºony:", "przelozony_filter", filters_layout)
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)

        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_list.setFixedHeight(150)
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.przelozony_list)

        self.add_horizontal_search_filter("U≈ºytkownik:", "uzytkownik_filter", filters_layout)
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)

        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_list.setFixedHeight(200)
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.uzytkownik_list)

        # ZMIANA: Etykieta i nazwa widgetu zmienione na "Lokalizacja Domy≈õlna"
        self.add_horizontal_filter("Lokalizacja Domy≈õlna:", "default_location_combo", filters_layout)

        self.add_horizontal_filter("System Pracy:", "system_czasu_pracy_combo", filters_layout)
        self.add_horizontal_filter("Rola:", "rola_combo", filters_layout)
        self.add_horizontal_filter("Jƒôzyk:", "jezyk_combo", filters_layout)
        self.add_horizontal_filter("Etat:", "etat_combo", filters_layout)
        self.add_horizontal_filter("DTN:", "dtn_combo", filters_layout)

        self.clear_filters_button = QPushButton("Wyczy≈õƒá filtry")
        self.clear_filters_button.clicked.connect(self.clear_filters)
        filters_layout.addStretch()
        filters_layout.addWidget(self.clear_filters_button)

    def add_horizontal_filter(self, label_text, combo_name, parent_layout):
        """Dodaje filtr w uk≈Çadzie poziomym (etykieta + kontrolka w jednej linii)"""
        # Uk≈Çad poziomy dla filtru
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)  # Minimalne marginesy
        filter_layout.setSpacing(4)  # Mniejszy odstƒôp

        # Etykieta
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        filter_label.setFixedWidth(80)  # Ustaw sta≈ÇƒÖ szeroko≈õƒá etykiet
        filter_layout.addWidget(filter_label)

        # Kontrolka ComboBox
        combo = CustomMultiComboBox()
        combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        combo.setFixedHeight(24)  # Ustaw wysoko≈õƒá podobnƒÖ do p√≥l tekstowych
        combo.view().setMaximumWidth(250)  # Ograniczenie szeroko≈õci rozwijanej listy
        # combo.activated.connect(self.filter_data)  # Pod≈ÇƒÖcz sygna≈Ç filtrowania
        combo.selection_changed.connect(self.filter_data)

        # Zapisz referencjƒô do kontrolki
        setattr(self, combo_name, combo)

        filter_layout.addWidget(combo, 1)  # Dodaj z rozciƒÖganiem
        parent_layout.addLayout(filter_layout)

    def add_horizontal_search_filter(self, label_text, filter_name, parent_layout):
        """Dodaje filtr wyszukiwania w uk≈Çadzie poziomym (etykieta + pole tekstowe w jednej linii)"""
        # Uk≈Çad poziomy dla filtru
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)  # Minimalne marginesy
        filter_layout.setSpacing(4)  # Mniejszy odstƒôp

        # Etykieta
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        filter_label.setFixedWidth(80)  # Ustaw sta≈ÇƒÖ szeroko≈õƒá etykiet
        filter_layout.addWidget(filter_label)

        # Pole tekstowe
        text_edit = QLineEdit()
        text_edit.setPlaceholderText(f"Filtruj {label_text.lower()[:-1]}...")
        text_edit.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        text_edit.setFixedHeight(24)  # Ustaw sta≈ÇƒÖ wysoko≈õƒá

        # Zapisz referencjƒô do kontrolki
        setattr(self, filter_name, text_edit)

        filter_layout.addWidget(text_edit, 1)  # Dodaj z rozciƒÖganiem
        parent_layout.addLayout(filter_layout)

    def setup_filter_combo(self, label_text, combo_name, parent_layout):
        """Konfiguruje filtr jako ComboBox z wielokrotnym wyborem"""
        # Etykieta filtru
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(filter_label)

        # ComboBox z wielokrotnym wyborem
        combo = CustomMultiComboBox()
        combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        combo.view().setMinimumWidth(200)  # Ustaw minimalnƒÖ szeroko≈õƒá listy rozwijanej

        # Dodaj sygna≈Ç zmiany stanu ComboBoxa
        combo.view().pressed.connect(self.filter_data)

        # Zapisz referencjƒô do ComboBoxa
        setattr(self, combo_name, combo)

        parent_layout.addWidget(combo)
        parent_layout.addSpacing(10)  # Dodaj odstƒôp miƒôdzy filtrami

    # Te metody pozostajƒÖ bez zmian, tylko przenosimy je do oddzielnych funkcji
    def setup_filter_przelozony(self, parent_layout):
        """Konfiguruje filtr prze≈Ço≈ºonego"""
        # Filtr prze≈Ço≈ºonego
        przelozony_label = QLabel("Prze≈Ço≈ºony:")
        przelozony_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(przelozony_label)

        # Lista prze≈Ço≈ºonych
        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_list.setFixedHeight(120)

        # Dodaj pole wyszukiwania dla prze≈Ço≈ºonych
        self.przelozony_filter = QLineEdit()
        self.przelozony_filter.setPlaceholderText("Filtruj prze≈Ço≈ºonych...")
        self.przelozony_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)

        parent_layout.addWidget(self.przelozony_filter)
        parent_layout.addWidget(self.przelozony_list)

        # Pod≈ÇƒÖcz sygna≈Ç zmiany filtru
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)

    def setup_filter_uzytkownik(self, parent_layout):
        """Konfiguruje filtr u≈ºytkownika"""
        # Filtr u≈ºytkownika
        uzytkownik_label = QLabel("U≈ºytkownik:")
        uzytkownik_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(uzytkownik_label)

        # Lista u≈ºytkownik√≥w
        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_list.setFixedHeight(120)

        # Dodaj pole wyszukiwania dla u≈ºytkownik√≥w
        self.uzytkownik_filter = QLineEdit()
        self.uzytkownik_filter.setPlaceholderText("Filtruj u≈ºytkownik√≥w...")
        self.uzytkownik_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)

        parent_layout.addWidget(self.uzytkownik_filter)
        parent_layout.addWidget(self.uzytkownik_list)

        # Pod≈ÇƒÖcz sygna≈Ç zmiany filtru
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)

    def setup_right_panel(self):
        """Tworzy prawy panel z tabelami"""
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)

        # Splitter pionowy dla prawego panelu (grafik | zdarzenia)
        right_splitter = QSplitter(Qt.Vertical)

        # Dodaj sekcje
        schedule_frame = self.setup_schedule_section()
        events_frame = self.setup_events_section()

        # Dodaj panele do pionowego splittera
        right_splitter.addWidget(schedule_frame)
        right_splitter.addWidget(events_frame)

        # Ustaw poczƒÖtkowe proporcje dla pionowego splittera (np. 60% grafik, 40% zdarzenia)
        right_splitter.setSizes([600, 400])

        # # Ustawiamy, aby obie czƒô≈õci (g√≥rna i dolna) rozciƒÖga≈Çy siƒô wraz z oknem.
        # right_splitter.setStretchFactor(0, 1)  # G√≥rny panel (grafik) ma siƒô rozciƒÖgaƒá
        # right_splitter.setStretchFactor(1, 1)  # Dolny panel (zdarzenia) r√≥wnie≈º

        # Dodaj pionowy splitter do layoutu prawego panelu
        right_layout.addWidget(right_splitter)

        return right_panel

    # W pliku main.py - klasa WorkScheduleWindow, metoda setup_schedule_section

    def setup_schedule_section(self):
        """
        Tworzy sekcjƒô grafiku (g√≥rna czƒô≈õƒá prawego panelu) u≈ºywajƒÖc SplitTableView
        """
        schedule_frame = QFrame()
        schedule_layout = QVBoxLayout(schedule_frame)
        schedule_layout.setContentsMargins(5, 5, 5, 5)

        # NIE INICJALIZUJ employee_columns tutaj, u≈ºyj warto≈õci z inicjalizacji klasy

        # Tworzenie i konfiguracja SplitTableView
        self.table = SplitTableView()

        # Ustaw style dla obu tabel
        self.table.employees_view.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))
        self.table.schedule_view.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))

        # Dodaj przycisk zarzƒÖdzania kolumnami do przycisk√≥w akcji
        self.manage_columns_button = QPushButton("ZarzƒÖdzaj kolumnami")
        self.manage_columns_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.manage_columns_button.clicked.connect(self.show_column_select_dialog)

        # Pod≈ÇƒÖcz sygna≈Ç zmiany zaznaczenia do aktualizacji zdarze≈Ñ
        self.table.selection_changed.connect(self.on_selection_changed)

        # Dodaj tabelƒô do layoutu
        schedule_layout.addWidget(self.table)

        # Dodaj przyciski akcji
        button_frame = self.setup_schedule_buttons()
        button_layout = button_frame.layout()

        # NOWE: Ustaw, aby panel z przyciskami zajmowa≈Ç tylko tyle miejsca, ile potrzebuje
        schedule_layout.addWidget(button_frame, 0)  # 0 = minimum stretch factor

        # Dodaj przycisk zarzƒÖdzania kolumnami do przycisk√≥w akcji
        if isinstance(button_layout, QHBoxLayout):
            button_layout.insertWidget(0, self.manage_columns_button)

        schedule_layout.addWidget(button_frame)

        return schedule_frame

    def setup_schedule_buttons(self):
        """Tworzy przyciski akcji dla sekcji grafiku"""
        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setContentsMargins(0, 0, 0, 0)

        # NOWE: Ustaw sta≈ÇƒÖ wysoko≈õƒá ramki przycisk√≥w
        button_frame.setFixedHeight(40)  # Mo≈ºesz dostosowaƒá wysoko≈õƒá wed≈Çug potrzeb

        # NOWE: Ustaw politykƒô rozmiaru, aby zapobiec rozciƒÖganiu
        button_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        # NOWO≈öƒÜ: Dodajemy przycisk do ukrywania/pokazywania panelu zdarze≈Ñ (po lewej stronie)
        self.toggle_events_panel_button = QPushButton("Ukryj zdarzenia‚Üì")
        self.toggle_events_panel_button.setToolTip(
            "Ukryj panel zdarze≈Ñ (dla wiƒôkszego widoku grafiku) (F2)")  # Dodano (F2)
        self.toggle_events_panel_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.toggle_events_panel_button.clicked.connect(self.toggle_events_panel)

        # Dodaj przycisk po lewej stronie
        button_layout.addWidget(self.toggle_events_panel_button)

        # Dodaj elastyczny odstƒôp, aby rozdzieliƒá przyciski
        button_layout.addStretch()

        # Przycisk "Wstaw zmianƒô"
        self.insert_change_button = QPushButton("Wstaw zmianƒô")
        self.insert_change_button.setToolTip("Wstaw zmianƒô grafiku (F3)")
        self.insert_change_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.insert_change_button.clicked.connect(self.show_insert_change_dialog)
        button_layout.addWidget(self.insert_change_button)

        # Przycisk "Wstaw nieobecno≈õƒá"
        self.insert_symbol_button = QPushButton("Wstaw nieobecno≈õƒá")
        self.insert_symbol_button.setToolTip("Wstaw nieobecno≈õƒá (F4)")
        self.insert_symbol_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.insert_symbol_button.clicked.connect(self.show_insert_symbol_dialog)
        button_layout.addWidget(self.insert_symbol_button)

        # Przycisk "Odwo≈Çaj delegacje"
        self.cancel_delegation_button = QPushButton("Odwo≈Çaj delegacje")
        self.cancel_delegation_button.setToolTip("Odwo≈Çaj delegacje dla zaznaczonych kom√≥rek (F5)")
        self.cancel_delegation_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.cancel_delegation_button.clicked.connect(self.cancel_delegations)
        button_layout.addWidget(self.cancel_delegation_button)

        # Przycisk "Dodaj nadgodziny"
        self.add_overtime_button = QPushButton("Dodaj nadgodziny")
        self.add_overtime_button.setShortcut("Insert")  # Skr√≥t klawiszowy Insert
        self.add_overtime_button.setToolTip("Dodaj nadgodziny dla zaznaczonych kom√≥rek (Insert)")
        self.add_overtime_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.add_overtime_button.clicked.connect(self.show_add_overtime_dialog)

        # ZMODYFIKOWANA LINIA: Zawsze dodawaj przycisk do layoutu
        button_layout.addWidget(self.add_overtime_button)

        # Ewentualnie ustaw widoczno≈õƒá przycisku na podstawie roli
        # Mo≈ºna to zrobiƒá po inicjalizacji wszystkich komponent√≥w
        if hasattr(self, 'current_user_role'):
            self.add_overtime_button.setVisible(self.current_user_role == "Pracownik WPR")
        else:
            # Domy≈õlnie widoczny, mo≈ºemy to zmieniƒá p√≥≈∫niej
            self.add_overtime_button.setVisible(True)

        return button_frame

    def setup_events_section(self):
        """
        Tworzy sekcjƒô zdarze≈Ñ u≈ºywajƒÖc QTableView i od razu konfiguruje jej kolumny.
        """
        events_frame = QFrame()
        events_frame.setFrameShape(QFrame.Shape.StyledPanel)
        events_frame.setFrameShadow(QFrame.Shadow.Raised)
        events_layout = QVBoxLayout(events_frame)
        events_layout.setContentsMargins(5, 5, 5, 5)

        # Dodaj kontrolki filtr√≥w
        filters_frame = self.setup_events_filters()
        events_layout.addWidget(filters_frame)

        # Tworzenie tabeli zdarze≈Ñ jako QTableView
        self.events_table = QTableView()
        self.events_table.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.events_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.events_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.events_table.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))

        # --- NOWA LOGIKA: Konfiguracja kolumn od razu po utworzeniu tabeli ---
        self.setup_events_table_columns()

        # Dodaj tabelƒô zdarze≈Ñ do panelu
        events_layout.addWidget(self.events_table)

        return events_frame

    def setup_events_filters(self):
        """Konfiguruje filtry dla tabeli zdarze≈Ñ"""
        events_filter_frame = QFrame()
        events_filter_layout = QHBoxLayout(events_filter_frame)
        events_filter_layout.setContentsMargins(0, 0, 0, 0)

        # Filtry daty od-do
        date_from_label = QLabel("Data od:")
        self.date_from = QDateEdit()
        self.date_from.setDisplayFormat("dd.MM.yyyy")
        self.date_from.setDate(QDate.currentDate().addDays(-30))
        self.date_from.setCalendarPopup(True)
        self.date_from.setStyleSheet(AppStyles.get_date_edit_style("dark" if self.is_dark_theme else "light"))

        date_to_label = QLabel("Data do:")
        self.date_to = QDateEdit()
        self.date_to.setDisplayFormat("dd.MM.yyyy")
        self.date_to.setDate(QDate.currentDate())
        self.date_to.setCalendarPopup(True)
        self.date_to.setStyleSheet(AppStyles.get_date_edit_style("dark" if self.is_dark_theme else "light"))

        # Filtr tematu
        topic_label = QLabel("Temat:")
        self.topic_filter = QLineEdit()
        self.topic_filter.setPlaceholderText("Filtruj po temacie...")
        self.topic_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))

        # Filtr nazwy
        name_label = QLabel("Nazwa:")
        self.name_filter = QLineEdit()
        self.name_filter.setPlaceholderText("Filtruj po nazwie...")
        self.name_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))

        # Checkboxy do filtrowania typ√≥w zdarze≈Ñ
        self.meetings_checkbox = QCheckBox("Spotkania")
        self.meetings_checkbox.setChecked(True)
        self.meetings_checkbox.stateChanged.connect(self.filter_events_table)

        self.trainings_checkbox = QCheckBox("Szkolenia")
        self.trainings_checkbox.setChecked(True)
        self.trainings_checkbox.stateChanged.connect(self.filter_events_table)

        self.overtime_checkbox = QCheckBox("Nadgodziny")
        self.overtime_checkbox.setChecked(True)
        self.overtime_checkbox.stateChanged.connect(self.filter_events_table)

        # Pod≈ÇƒÖcz sygna≈Çy zmiany daty bezpo≈õrednio do filtrowania
        self.date_from.dateChanged.connect(self.filter_events_table)
        self.date_to.dateChanged.connect(self.filter_events_table)
        self.topic_filter.textChanged.connect(self.filter_events_table)
        self.name_filter.textChanged.connect(self.filter_events_table)

        # Dodaj kontrolki do layoutu filtr√≥w zdarze≈Ñ
        events_filter_layout.addWidget(date_from_label)
        events_filter_layout.addWidget(self.date_from)
        events_filter_layout.addWidget(date_to_label)
        events_filter_layout.addWidget(self.date_to)
        events_filter_layout.addWidget(topic_label)
        events_filter_layout.addWidget(self.topic_filter)
        events_filter_layout.addWidget(name_label)
        events_filter_layout.addWidget(self.name_filter)
        events_filter_layout.addWidget(self.meetings_checkbox)
        events_filter_layout.addWidget(self.trainings_checkbox)
        events_filter_layout.addWidget(self.overtime_checkbox)
        events_filter_layout.addStretch()

        return events_filter_frame

    def setup_events_table_columns(self):
        """Konfiguruje kolumny dla tabeli zdarze≈Ñ"""
        header = self.events_table.horizontalHeader()

        # Ta jedna linia ustawia tryb rozciƒÖgania dla WSZYSTKICH kolumn.
        header.setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        # self.events_table.setColumnCount(10)
        # self.events_table.setHorizontalHeaderLabels([
        #     "Id", "Typ", "Temat", "Nazwa", "U≈ºytkownik", "Data", "Od", "Do", "Status", "Akcje"
        # ])
        #
        # # Ustaw szeroko≈õƒá kolumn
        # self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        # self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        # self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        # self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        # self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # U≈ºytkownik
        # self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        # self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        # self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        # self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        # self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

    def setup_table_properties(self):
        """Konfiguruje w≈Ça≈õciwo≈õci tabel i tworzy delegat√≥w z ustawieniami."""
        self.events_table.setSortingEnabled(True)
        self.events_table.sortByColumn(0, Qt.AscendingOrder)

        if hasattr(self.table, 'employees_view'):
            self.table.employees_view.setSortingEnabled(True)
            self.table.employees_view.sortByColumn(0, Qt.AscendingOrder)

        self.last_sort_column = 0
        self.last_sort_order = Qt.AscendingOrder

        if hasattr(self.table, 'employees_view') and hasattr(self.table.employees_view, 'horizontalHeader'):
            self.table.employees_view.horizontalHeader().sortIndicatorChanged.connect(self.on_sort_changed)

        if hasattr(self.events_table, 'horizontalHeader'):
            self.events_table.horizontalHeader().sortIndicatorChanged.connect(self.on_events_sort_changed)

        view_settings = {
            'show_special_symbol': self.user_settings.get('show_special_symbol', True),
            'show_location_symbol': self.user_settings.get('show_location_symbol', True),
            'special_symbol_position': self.user_settings.get('special_symbol_position', 'top_left'),
            'location_symbol_position': self.user_settings.get('location_symbol_position', 'bottom_left')
        }

        overtime_delegate = OvertimeItemDelegate(settings=view_settings)
        self.table.schedule_view.setItemDelegate(overtime_delegate)

        button_delegate = ButtonDelegate(parent=self, button_text="Usu≈Ñ", is_dark_theme=self.is_dark_theme)

        # --- KLUCZOWA POPRAWKA: Po≈ÇƒÖczenie sygna≈Çu z akcjƒÖ usuwania ---
        button_delegate.button_clicked.connect(self.delete_event_from_row)
        # --- KONIEC POPRAWKI ---

        self.events_table.setItemDelegateForColumn(9, button_delegate)

    def toggle_left_panel(self):
        """Prze≈ÇƒÖcza widoczno≈õƒá lewego panelu filtr√≥w"""
        if self.left_panel_visible:
            # Ukryj panel
            self.left_panel_width = self._left_panel.width()  # Zapamiƒôtaj bie≈ºƒÖcƒÖ szeroko≈õƒá
            self._left_panel.setFixedWidth(0)
            self._left_panel.setVisible(False)  # WA≈ªNE: Ukryj panel ca≈Çkowicie
            self.left_panel_visible = False
            self.toggle_menu_button.setText("‚ò≤")  # Zmie≈Ñ ikonƒô na "poka≈º menu"
            self.toggle_menu_button.setToolTip("Poka≈º panel filtr√≥w")
        else:
            # Poka≈º panel
            self._left_panel.setVisible(True)  # WA≈ªNE: Najpierw poka≈º panel
            self._left_panel.setMinimumWidth(200)
            self._left_panel.setMaximumWidth(250)

            # Sprawd≈∫ czy mamy zapamiƒôtanƒÖ szeroko≈õƒá
            if hasattr(self, 'left_panel_width'):
                self._left_panel.setFixedWidth(self.left_panel_width)
            else:
                self._left_panel.setFixedWidth(200)  # Domy≈õlna szeroko≈õƒá

            self.left_panel_visible = True
            self.toggle_menu_button.setText("‚ò∞")  # Przywr√≥ƒá ikonƒô "burger menu"
            self.toggle_menu_button.setToolTip("Poka≈º/ukryj panel filtr√≥w (F1)")

        # DODANE: Wymu≈õ ponowne roz≈Ço≈ºenie splittera
        current_sizes = self.main_splitter.sizes()
        if not self.left_panel_visible:
            # Gdy ukrywamy panel, dajemy ca≈ÇƒÖ przestrze≈Ñ prawemu panelowi
            self.main_splitter.setSizes([0, sum(current_sizes)])
        else:
            # Gdy pokazujemy panel, przywracamy proporcje
            if hasattr(self, 'left_panel_width'):
                right_size = sum(current_sizes) - self.left_panel_width
                self.main_splitter.setSizes([self.left_panel_width, right_size])
            else:
                # Domy≈õlnie 20% - 80%
                total = sum(current_sizes)
                self.main_splitter.setSizes([int(total * 0.2), int(total * 0.8)])

        # Wymu≈õ aktualizacjƒô widoku
        self.main_splitter.update()

        # DODANE: Od≈õwie≈º uk≈Çad ca≈Çego okna
        QApplication.processEvents()
        self.update()

    def toggle_events_panel(self):
        """Prze≈ÇƒÖcza widoczno≈õƒá panelu zdarze≈Ñ (dolny panel)"""
        # Znajd≈∫ splitter, kt√≥ry organizuje uk≈Çad prawy (grafik | zdarzenia)
        right_splitter = None

        # Szukamy w rodzicu prawego panelu, kt√≥ry zawiera splitter
        for widget in self.findChildren(QSplitter):
            # Sprawd≈∫, czy to pionowy splitter zawierajƒÖcy panel zdarze≈Ñ
            if widget.orientation() == Qt.Vertical and widget.count() > 1:
                right_splitter = widget
                break

        if right_splitter:
            # Pobierz rozmiary paneli
            sizes = right_splitter.sizes()

            # Je≈õli panel zdarze≈Ñ jest widoczny, ukryj go
            if sizes[1] > 0:
                # Zapisz obecny rozmiar panelu zdarze≈Ñ przed ukryciem
                self.events_panel_size = sizes[1]

                # Ustaw nowe rozmiary - ca≈Ça przestrze≈Ñ dla grafiku, 0 dla zdarze≈Ñ
                right_splitter.setSizes([sizes[0] + sizes[1], 0])

                # Zmie≈Ñ tekst przycisku
                self.toggle_events_panel_button.setText("Poka≈º zdarzenia‚Üë")
                self.toggle_events_panel_button.setToolTip("Poka≈º panel zdarze≈Ñ‚Üë (F2)")
            else:
                # Je≈õli panel zdarze≈Ñ jest ukryty, poka≈º go
                # U≈ºyj zapisanego wcze≈õniej rozmiaru lub domy≈õlnego (300)
                events_size = getattr(self, 'events_panel_size', 300)

                # Oblicz nowy rozmiar dla panelu grafiku
                schedule_size = sizes[0] - events_size
                if schedule_size < 200:  # Minimalny rozmiar dla grafiku
                    schedule_size = 200
                    events_size = sizes[0] - schedule_size

                # Ustaw nowe rozmiary
                right_splitter.setSizes([schedule_size, events_size])

                # Zmie≈Ñ tekst przycisku
                self.toggle_events_panel_button.setText("Ukryj zdarzenia‚Üì")
                self.toggle_events_panel_button.setToolTip("Ukryj panel zdarze≈Ñ (dla wiƒôkszego widoku grafiku)")

    def show_column_select_dialog(self):
        """Wy≈õwietla dialog wyboru kolumn, obs≈ÇugujƒÖc nowƒÖ opcjƒô komentarza."""
        try:
            if not hasattr(self, 'schedule_model'):
                QMessageBox.warning(self, "B≈ÇƒÖd", "Model danych nie jest zainicjalizowany.", QMessageBox.Ok)
                return

            dialog = ColumnSelectDialog(
                self,
                self.employee_columns,
                self.visible_columns,
                self.default_visible_columns,
                user_role=self.current_user_role,
                is_comment_column_checked=self.show_comment_column
            )

            if dialog.exec() == QDialog.Accepted:
                selected_columns = dialog.get_selected_columns()

                # U≈ºywamy nowej, poprawnej nazwy metody
                self.show_comment_column = dialog.get_comment_column_state()

                self.schedule_model.set_visible_columns(selected_columns)
                self.schedule_model.set_show_comment_column(self.show_comment_column)

                self.visible_columns = selected_columns

                # Zapisujemy wszystkie ustawienia do bazy
                self.settings_db.save_settings(
                    "dark" if self.is_dark_theme else "light",
                    self.current_font,
                    self.current_font_size,
                    getattr(self, 'load_all_events', True),
                    selected_columns,
                    self.show_comment_column
                )
                debug_print(
                    f"Zapisano ustawienia: widoczne kolumny={selected_columns}, poka≈º komentarz={self.show_comment_column}")

                self.refresh_column_configuration()
                if hasattr(self, 'table'):
                    self.table.set_model(self.schedule_model)
                    self.table.adjust_employees_table_width()
                    self._apply_dynamic_sizes()

        except Exception as e:
            log_error(f"B≈ÇƒÖd w show_column_select_dialog: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas zmiany kolumn: {str(e)}", QMessageBox.Ok)

    def _apply_dynamic_sizes(self):
        """
        Ustawia dynamiczne rozmiary (szeroko≈õƒá kolumn, wysoko≈õƒá wierszy i nag≈Ç√≥wk√≥w)
        w zale≈ºno≈õci od wybranego rozmiaru czcionki.
        """
        if not hasattr(self, 'table') or not self.table.employees_view.model():
            return

        # Wykonuj dopasowanie tylko, je≈õli model zawiera ju≈º dane (ma wiersze).
        if self.schedule_model.rowCount() == 0:
            debug_print("POMIJAM _apply_dynamic_sizes, poniewa≈º model jest pusty.")
            return

        # --- Konfiguracja dynamicznych rozmiar√≥w ---
        font_size = self.current_font_size

        # 1. Mapa dla szeroko≈õci kolumn dni
        width_map = {7: 35, 8: 40, 9: 45, 10: 50, 11: 55, 12: 60}
        day_column_width = width_map.get(font_size, 40)

        # 2. Mapa dla wysoko≈õci wierszy
        height_map = {7: 25, 8: 25, 9: 25, 10: 28, 11: 28, 12: 30}
        row_height = height_map.get(font_size, 25)

        # 3. NOWA MAPA: Mapa dla wysoko≈õci nag≈Ç√≥wk√≥w
        header_height_map = {7: 30, 8: 35, 9: 35, 10: 38, 11: 40, 12: 42}
        header_height = header_height_map.get(font_size, 35)

        # --- Zastosowanie ustawie≈Ñ ---

        # Ustawienie wysoko≈õci nag≈Ç√≥wka
        self.table.set_header_height(header_height)

        # Reszta metody bez zmian...
        header = self.table.schedule_view.horizontalHeader()
        model = self.table.employees_view.model()

        special_widths = {"Suma\nRBH": 45, "Bilans\nRBH": 45, "Komentarz": 300}

        for logical_index in range(model.columnCount()):
            header_text = model.headerData(logical_index, Qt.Horizontal, Qt.DisplayRole)
            width_to_set = special_widths.get(header_text, day_column_width)
            header.resizeSection(logical_index, width_to_set)

        days_in_month = model._days_in_month
        employee_cols_count = len(model.get_visible_columns())

        for day in range(1, 32):
            logical_index = employee_cols_count + (day - 1)
            if logical_index < model.columnCount():
                header.setSectionHidden(logical_index, day > days_in_month)

        self.table._force_sync_heights(row_height)
        # self.table.adjust_employees_table_width()

    def showEvent(self, event):
        """
        Ta metoda jest automatycznie wywo≈Çywana przez Qt, gdy okno jest pokazywane po raz pierwszy.
        To idealne miejsce na jednorazowe ustawienie poczƒÖtkowego layoutu.
        """
        # Wywo≈Çaj domy≈õlnƒÖ implementacjƒô, aby okno zachowywa≈Ço siƒô normalnie
        super().showEvent(event)

        # U≈ºywamy flagi, aby mieƒá pewno≈õƒá, ≈ºe ten kod wykona siƒô tylko raz
        if not hasattr(self, '_initial_layout_done'):
            debug_print("Wykryto showEvent - jednorazowe ustawianie szeroko≈õci splittera.")
            # Wywo≈Çujemy naszƒÖ metodƒô dopasowujƒÖcƒÖ szeroko≈õƒá
            self.table.adjust_employees_table_width()
            # Ustawiamy flagƒô, aby uniknƒÖƒá ponownego wywo≈Çania
            self._initial_layout_done = True

    def delete_event_from_row(self, row):
        """
        POPRAWIONA WERSJA: Usuwa zdarzenie na podstawie indeksu wiersza w tabeli zdarze≈Ñ
        z pe≈Çnym od≈õwie≈ºaniem ikon
        """
        # Sprawd≈∫ czy model istnieje
        if not hasattr(self, 'events_model') or not self.events_model:
            return

        # Pobierz zdarzenie z modelu
        event = self.events_model.get_event(row)
        if not event:
            debug_print(f"Nie znaleziono zdarzenia w wierszu {row}")
            return

        # Pobierz dane zdarzenia
        event_id = event.get('id')
        event_type = event.get('type')

        debug_print(f"Usuwanie zdarzenia z wiersza {row}: ID={event_id}, typ={event_type}")

        if not event_id or not event_type:
            debug_print(f"Niepe≈Çne dane zdarzenia: ID={event_id}, typ={event_type}")
            return

        # KLUCZOWA ZMIANA: U≈ºyj metody delete_event kt√≥ra ju≈º ma pe≈ÇnƒÖ logikƒô od≈õwie≈ºania
        self.delete_event(event_id, event_type)

    def on_sort_changed(self, logical_index, order):
        """Obs≈Çuguje zmianƒô sortowania w tabeli grafiku"""
        self.last_sort_column = logical_index
        self.last_sort_order = order
        debug_print(
            f"Tabela grafiku: Sortowanie po kolumnie {logical_index}, kolejno≈õƒá: {'rosnƒÖco' if order == Qt.AscendingOrder else 'malejƒÖco'}")

    def on_events_sort_changed(self, logical_index, order):
        """Obs≈Çuguje zmianƒô sortowania w tabeli zdarze≈Ñ"""
        debug_print(
            f"Tabela zdarze≈Ñ: Sortowanie po kolumnie {logical_index}, kolejno≈õƒá: {'rosnƒÖco' if order == Qt.AscendingOrder else 'malejƒÖco'}")

    def update_buttons_visibility(self):
        """Aktualizuje widoczno≈õƒá przycisk√≥w na podstawie roli u≈ºytkownika"""
        is_next_month_selected = False
        current_data = self.date_combo.currentData()
        if current_data:
            selected_year, selected_month = current_data

            today = QDate.currentDate()
            # Oblicz datƒô dla nastƒôpnego miesiƒÖca
            next_month_date = today.addMonths(1)

            # Sprawd≈∫, czy wybrany rok i miesiƒÖc zgadzajƒÖ siƒô z nastƒôpnym miesiƒÖcem
            if selected_year == next_month_date.year() and selected_month == next_month_date.month():
                is_next_month_selected = True

        if hasattr(self, 'add_overtime_button') and hasattr(self, 'current_user_role'):
            self.add_overtime_button.setVisible(self.current_user_role == "Pracownik WPR")

        # Ustaw widoczno≈õƒá przycisku "Obsada" tylko dla roli "Pracownik WPR"
        if hasattr(self, 'staffing_details_button') and hasattr(self, 'current_user_role'):
            self.staffing_details_button.setVisible(self.current_user_role == "Pracownik WPR")

        if hasattr(self, 'current_user_role') and self.current_user_role == "Pracownik WPR":
            debug_print("Edycja klawiatury w≈ÇƒÖczona: cyfry 0-9 = godzina start, Delete/Backspace = usu≈Ñ symbol")

        if hasattr(self, 'show_audit_button') and hasattr(self, 'current_user_role'):
            self.show_audit_button.setVisible(self.current_user_role == "Pracownik WPR")

        if hasattr(self, 'schedule_control_button') and hasattr(self, 'current_user_role'):
            allowed_roles = ["Pracownik WPR", "Lider OUT"]
            # Przycisk jest widoczny TYLKO, gdy rola siƒô zgadza ORAZ wybrany jest nastƒôpny miesiƒÖc
            is_visible = self.current_user_role in allowed_roles and is_next_month_selected
            self.schedule_control_button.setVisible(is_visible)

    def show_audit_log_window(self):
        """
        Tworzy i pokazuje okno historii zmian, z limitem do 50, je≈õli nic nie zaznaczono.
        """
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Proszƒô najpierw wybraƒá miesiƒÖc.")
            return

        year, month = current_data

        def _get_filtered_audit_data():
            # Krok 1: Pobierz wszystkie dane audytowe dla miesiƒÖca (wykorzysta cache)
            full_data = self.data_provider.get_schedule_audit_data(year, month)
            selected_cells = self.table.get_data_for_selected_cells()

            if selected_cells:
                # --- Logika dla zaznaczonych kom√≥rek ---
                allowed_users_dates = set()
                for cell in selected_cells:
                    if (user_id := cell.get('uzytkownik_id')) and (date_str := cell.get('date_str')):
                        date_obj = QDate.fromString(date_str, "yyyy-MM-dd").toPython()
                        allowed_users_dates.add((user_id, date_obj))

                # Zwr√≥ƒá wszystkie zmiany dla zaznaczonych kom√≥rek
                return [row for row in full_data if
                        row.get('Data') and (int(row.get('Uzytkownik')), row.get('Data').date()) in allowed_users_dates]
            else:
                # --- Logika, gdy nie ma zaznaczenia ---
                # 1. Filtruj dane tylko dla pracownik√≥w widocznych w g≈Ç√≥wnym oknie
                visible_user_ids = {key[3] for key in self.schedule_model._keys}
                filtered_by_visibility = [row for row in full_data if
                                          row.get('Uzytkownik') is not None and int(
                                              row.get('Uzytkownik')) in visible_user_ids]

                # 2. Sortuj dane od najnowszych do najstarszych
                sorted_data = sorted(filtered_by_visibility, key=lambda x: x.get('DataModyfikacji'), reverse=True)

                # 3. Zwr√≥ƒá tylko 50 ostatnich zmian
                return sorted_data[:50]

        # Sprawd≈∫, czy widok jest ograniczony (czy nie ma zaznaczenia)
        selected_cells = self.table.get_data_for_selected_cells()
        is_limited = not selected_cells
        limit_count = 50

        # Pobierz dane poczƒÖtkowe z u≈ºyciem nowej logiki
        initial_filtered_data = _get_filtered_audit_data()
        if not initial_filtered_data:
            QMessageBox.information(self, "Informacja", "Brak historii zmian dla wybranych filtr√≥w / zaznaczenia.")
            return

        # Utw√≥rz okno dialogowe, przekazujƒÖc nowe parametry
        from audit_log_window import AuditLogWindow
        dialog = AuditLogWindow(
            initial_filtered_data,
            self.is_dark_theme,
            self,
            is_limited_view=is_limited,
            year=year,
            month=month,
            limit=limit_count
        )

        # Zdefiniuj slot do obs≈Çugi od≈õwie≈ºania
        def on_refresh_requested():
            debug_print("Otrzymano ≈ºƒÖdanie od≈õwie≈ºenia historii zmian.")
            self.data_provider.clear_audit_cache(year, month)
            fresh_filtered_data = _get_filtered_audit_data()
            dialog.update_model_data(fresh_filtered_data)
            QMessageBox.information(dialog, "Od≈õwie≈ºono", "Historia zmian zosta≈Ça zaktualizowana.")

        # Pod≈ÇƒÖcz sygna≈Ç z dialogu do nowo utworzonego slotu
        dialog.refresh_requested.connect(on_refresh_requested)

        # Poka≈º okno
        dialog.exec()

    def check_user_permissions(self):
        """Sprawdza uprawnienia u≈ºytkownika i zapisuje je w atrybutach klasy."""
        # Pobieramy 5 warto≈õci, w tym wydzia≈Ç u≈ºytkownika
        user_id, user_app_id, user_app_role, visible_next_month, user_department = get_modifier_id()

        self.current_user_id = user_id
        self.current_user_app_id = user_app_id
        self.current_user_role = user_app_role
        self.can_see_next_month = visible_next_month
        self.current_user_department = user_department  # NOWY ATRYBUT

        self.update_buttons_visibility()

        # Reszta logiki bez zmian...
        allowed_roles = ["Pracownik WPR", "Lider", "Menad≈ºer", "Lider OUT"]
        if user_app_role not in allowed_roles:
            QMessageBox.critical(
                self, "Brak uprawnie≈Ñ",
                f"Nie masz uprawnie≈Ñ do korzystania z tej aplikacji.\n\nTwoja rola: {user_app_role}",
                QMessageBox.Ok
            )
            return False

        debug_print(f"Zalogowano jako: {user_app_id} ({user_app_role}), Wydzia≈Ç: {self.current_user_department}")
        return True

    def _can_modify_cells(self, selected_cells_data: list) -> bool:
        """
        Sprawdza, czy bie≈ºƒÖcy u≈ºytkownik (Lider) ma uprawnienia do modyfikacji
        grafiku dla pracownik√≥w w zaznaczonych kom√≥rkach.
        """
        # Regu≈Ça dotyczy tylko r√≥l Lider IN i Lider OUT
        leader_roles = ["Lider", "Lider OUT"]  # Za≈Ço≈ºy≈Çem, ≈ºe "Lider IN" to po prostu "Lider"
        if self.current_user_role not in leader_roles:
            return True  # Inne role nie majƒÖ tego ograniczenia

        if not self.current_user_department:
            QMessageBox.warning(self, "B≈ÇƒÖd konfiguracji",
                                "Nie mo≈ºna zweryfikowaƒá Twojego wydzia≈Çu. Edycja niemo≈ºliwa.")
            return False

        unauthorized_employees = set()
        leader_dept = self.current_user_department

        for cell_data in selected_cells_data:
            employee_dept = cell_data.get('wydzial')
            if not employee_dept:
                continue  # Pomi≈Ñ kom√≥rki bez informacji o wydziale

            # Sprawd≈∫, czy wydzia≈Ç lidera zawiera siƒô w wydziale pracownika
            if leader_dept not in employee_dept:
                unauthorized_employees.add(cell_data.get('uzytkownik_dane', 'Nieznany'))

        if unauthorized_employees:
            QMessageBox.warning(
                self,
                "Brak uprawnie≈Ñ",
                "Nie posiadasz uprawnie≈Ñ do edycji grafiku tej osoby.\n\n"
                f"Twoja jednostka: '{leader_dept}'\n"
                "Problem dotyczy pracownik√≥w:\n - " + "\n - ".join(sorted(list(unauthorized_employees)))
            )
            return False

        return True  # Walidacja pomy≈õlna

    def show_insert_symbol_dialog(self):
        """
        Pokazuje okno dialogowe do wstawiania symbolu nieobecno≈õci.
        NOWA WERSJA z procedurƒÖ p_P_ZZ_ImportZmianyNaSerwer_v3
        """
        dialog = InsertSymbolDialog(self)
        if dialog.exec():
            selected_symbol = dialog.get_selected_symbol()

            # Pobierz zaznaczone kom√≥rki z modelu
            selected_cells_data = self.get_selected_cells_data()

            if not self._can_modify_cells(selected_cells_data):
                return

            if not selected_cells_data:
                QMessageBox.warning(
                    self,
                    "Brak zaznaczenia",
                    "Nie zaznaczono ≈ºadnych kom√≥rek do edycji.",
                    QMessageBox.Ok
                )
                return

            # Filtruj tylko kom√≥rki grafiku (nie kolumny pracownik√≥w) i pomijaj puste kom√≥rki
            schedule_cells = []
            for cell_data in selected_cells_data:
                if isinstance(cell_data, dict) and 'date_str' in cell_data and 'uzytkownik_id' in cell_data:
                    # NOWE: Sprawd≈∫ czy kom√≥rka nie jest pusta
                    current_symbol = cell_data.get('symbol', '').strip()
                    if current_symbol:  # Pomijaj puste kom√≥rki
                        schedule_cells.append(cell_data)

            if not schedule_cells:
                QMessageBox.warning(
                    self,
                    "Brak kom√≥rek do edycji",
                    "Nie zaznaczono ≈ºadnych kom√≥rek grafiku z symbolami do edycji.\n\n" +
                    "Uwaga: Puste kom√≥rki sƒÖ pomijane.",
                    QMessageBox.Ok
                )
                return

            # Pogrupuj kom√≥rki dla lepszego komunikatu
            grouped_changes = self._group_cells_for_symbol_changes(schedule_cells)

            # Przygotuj komunikat potwierdzenia
            changes_info = self._prepare_symbol_changes_description(grouped_changes, selected_symbol)

            # Sprawd≈∫ czy sƒÖ zdarzenia do odwo≈Çania
            user_date_pairs = set()
            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    user_date_pairs.add((user_id, date_str))

            events_to_cancel = self._find_events_to_cancel(user_date_pairs)
            delegations_info = ""
            if events_to_cancel:
                grouped_events = self._group_events_by_user_date(events_to_cancel)
                delegations_info = self._prepare_delegations_description(grouped_events)

            # Poka≈º komunikat potwierdzenia
            complete_info = f"Czy na pewno chcesz wprowadziƒá nastƒôpujƒÖce zmiany?\n\n{changes_info}"
            if delegations_info:
                complete_info += f"\n{delegations_info}"
            complete_info += f"\n≈ÅƒÖcznie: {len(schedule_cells)} kom√≥rek zmieni symbol"
            if events_to_cancel:
                complete_info += f", {len(events_to_cancel)} delegacji zostanie odwo≈Çanych"

            reply = QMessageBox.question(
                self,
                "Potwierdzenie wstawienia nieobecno≈õci",
                complete_info,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )

            if reply == QMessageBox.Yes:
                self._apply_absence_symbol_changes(schedule_cells, selected_symbol, events_to_cancel)

    def _group_cells_for_symbol_changes(self, schedule_cells):
        """
        Grupuje kom√≥rki wed≈Çug u≈ºytkownika i daty dla komunikatu potwierdzenia

        Args:
            schedule_cells (list): Lista kom√≥rek do modyfikacji

        Returns:
            dict: Pogrupowane zmiany
        """
        grouped_changes = {}
        for cell_data in schedule_cells:
            user_id = cell_data.get('uzytkownik_id')
            user_name = cell_data.get('uzytkownik_dane', '')
            date_str = cell_data.get('date_str')
            current_symbol = cell_data.get('symbol', '')

            # Formatuj datƒô
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            user_key = (user_id, user_name)
            if user_key not in grouped_changes:
                grouped_changes[user_key] = {}

            if formatted_date not in grouped_changes[user_key]:
                grouped_changes[user_key][formatted_date] = []

            grouped_changes[user_key][formatted_date].append({
                'current_symbol': current_symbol,
                'cell_data': cell_data
            })

        return grouped_changes

    def _prepare_symbol_changes_description(self, grouped_changes, new_special_symbol):
        """
        Przygotowuje opis zmian symboli do komunikatu potwierdzenia

        Args:
            grouped_changes (dict): Pogrupowane zmiany
            new_special_symbol (str): Nowy symbol specjalny

        Returns:
            str: Opis zmian
        """
        changes_info = ""
        for (user_id, user_name), dates in grouped_changes.items():
            changes_info += f"\nüë§ {user_name}:\n"

            for date, cells in dates.items():
                changes_info += f"   üìÖ {date}: "

                # Poka≈º przyk≈Çad jak bƒôdzie wyglƒÖda≈Ç nowy symbol
                example_cell = cells[0]['cell_data']
                current_symbol = cells[0]['current_symbol']

                # Przewiduj jak bƒôdzie wyglƒÖda≈Ç nowy symbol
                predicted_symbol = self._predict_new_symbol(current_symbol, new_special_symbol, example_cell)

                if len(cells) == 1:
                    changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                else:
                    # Je≈õli wiele kom√≥rek w tym dniu
                    current_symbols = [cell['current_symbol'] for cell in cells]
                    unique_symbols = set(current_symbols)
                    if len(unique_symbols) == 1:
                        changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                    else:
                        symbols_str = ", ".join([f"{s}" for s in unique_symbols])
                        changes_info += f"[{symbols_str}] -> {predicted_symbol}\n"

        return changes_info

    def _predict_new_symbol(self, current_symbol, special_symbol, cell_data):
        """
        Przewiduje jak bƒôdzie wyglƒÖda≈Ç nowy symbol po modyfikacji

        Args:
            current_symbol (str): Obecny symbol (nigdy pusty - puste sƒÖ filtrowane)
            special_symbol (str): Nowy symbol specjalny
            cell_data (dict): Dane kom√≥rki

        Returns:
            str: Przewidywany nowy symbol
        """
        from symbol_parser import parse_symbol, build_symbol

        # Sprawd≈∫ czy symbol istnieje (zabezpieczenie dodatkowe)
        if not current_symbol or current_symbol.strip() == '':
            debug_print("Ostrze≈ºenie: _predict_new_symbol otrzyma≈Ç pusty symbol")
            return special_symbol

        # Parsuj obecny symbol
        parsed = parse_symbol(current_symbol)

        # Zachowaj lokalizacjƒô i godziny, zmie≈Ñ tylko symbol specjalny
        new_symbol = build_symbol(
            location=parsed.get('location'),
            start_hour=parsed.get('start_hour'),
            work_hours=parsed.get('work_hours'),
            special_symbol=special_symbol
        )

        return new_symbol if new_symbol else special_symbol

    def _find_events_to_cancel(self, user_date_pairs):
        """
        Znajduje zdarzenia do odwo≈Çania dla podanych par u≈ºytkownik-data

        Args:
            user_date_pairs (set): Pary (user_id, date_str)

        Returns:
            list: Lista zdarze≈Ñ do odwo≈Çania
        """
        events_to_cancel = []

        for user_id, date_str in user_date_pairs:
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

            for event in user_events:
                event_type = event.get('type', '')
                event_id = event.get('id')
                event_status = event.get('status')

                if not event_type or event_id is None:
                    continue

                if event_status is not None:
                    event_status = str(event_status)

                # Dodaj zdarzenia do odwo≈Çania (spotkania, szkolenia, nadgodziny)
                if event_type in ['Spotkanie', 'Szkolenie', 'Nadgodziny'] and event_status != '0':
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),
                    })

        return events_to_cancel

    def _group_events_by_user_date(self, events_to_cancel):
        """
        Grupuje zdarzenia wed≈Çug u≈ºytkownika i daty

        Args:
            events_to_cancel (list): Lista zdarze≈Ñ do odwo≈Çania

        Returns:
            dict: Pogrupowane zdarzenia
        """
        grouped_events = {}
        for event in events_to_cancel:
            key = (event['user_id'], event['date'])
            if key not in grouped_events:
                grouped_events[key] = []
            grouped_events[key].append(event)

        return grouped_events

    def _apply_absence_symbol_changes(self, schedule_cells, special_symbol, events_to_cancel):
        try:
            canceled_count = 0
            if events_to_cancel:
                canceled_count = self._cancel_delegations(events_to_cancel)
                debug_print(f"Odwo≈Çano {canceled_count} delegacji przed wstawieniem nieobecno≈õci.")

            successful_symbol_updates = 0
            failed_symbol_updates = 0
            error_messages_symbol = []
            # Ta lista musi zawieraƒá krotki 3-elementowe
            affected_pairs_for_symbol_change = []

            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                nr_kadrowy = cell_data.get('nr_kadrowy')
                current_symbol = cell_data.get('symbol', '')

                if not user_id or not date_str or not nr_kadrowy:
                    failed_symbol_updates += 1
                    error_messages_symbol.append(f"Brak danych dla kom√≥rki: U:{user_id} D:{date_str} NRK:{nr_kadrowy}")
                    continue

                new_symbol = self._build_new_symbol_with_absence_fixed(current_symbol, special_symbol, cell_data)

                try:
                    year_val, month_val, day_val = map(int, date_str.split('-'))

                    result = self._call_import_changes_procedure(
                        nr_kadrowy=nr_kadrowy,
                        rok=year_val,
                        miesiac=month_val,
                        data=date_str,
                        symbol=new_symbol
                    )

                    if result['success']:
                        successful_symbol_updates += 1
                        # --- KLUCZOWA POPRAWKA ---
                        # Upewniamy siƒô, ≈ºe zawsze dodajemy 3 elementy do krotki
                        affected_pairs_for_symbol_change.append(
                            (user_id, date_str, result.get('returned_symbol'))
                        )
                        debug_print(
                            f"Sukces wstawienia symbolu nieobecno≈õci: {user_id}, {date_str}, symbol: {result.get('returned_symbol', new_symbol)}")
                    else:
                        failed_symbol_updates += 1
                        error_msg = result.get('message', 'Nieznany b≈ÇƒÖd')
                        error_messages_symbol.append(f"{nr_kadrowy} ({date_str}): {error_msg}")
                except Exception as e_proc:
                    failed_symbol_updates += 1
                    error_messages_symbol.append(f"{nr_kadrowy} ({date_str}): {str(e_proc)}")
                    log_error(f"B≈ÇƒÖd procedury importu dla {user_id}, {date_str}: {e_proc}", exception=e_proc)

            # Od≈õwie≈º symbole w grafiku, przekazujƒÖc listƒô z poprawnymi danymi
            if successful_symbol_updates > 0:
                self._update_cells_with_new_symbols(affected_pairs_for_symbol_change)

            # Poka≈º wyniki operacji
            self._show_symbol_change_results(successful_symbol_updates, failed_symbol_updates, error_messages_symbol,
                                             events_to_cancel if canceled_count > 0 else [])

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas wstawiania nieobecno≈õci: {e}", exception=e)
            QMessageBox.critical(
                self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas wstawiania nieobecno≈õci: {str(e)}", QMessageBox.Ok
            )

    def clear_special_symbol_from_selected_cells(self):
        """Usuwa symbol specjalny (F12) i obs≈Çuguje b≈Çƒôdy."""
        if self.current_user_role != "Pracownik WPR":
            self.statusBar().showMessage("Brak uprawnie≈Ñ do wykonania tej operacji.", 3000)
            return

        selected_cells_data = self.table.get_data_for_selected_cells()
        if not self._can_modify_cells(selected_cells_data): return
        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono kom√≥rek do modyfikacji.")
            return

        cells_to_modify = [cell for cell in selected_cells_data if
                           cell.get('symbol') and parse_symbol(cell.get('symbol')).get('special_symbol')]
        if not cells_to_modify:
            QMessageBox.information(self, "Brak zmian",
                                    "W zaznaczonych kom√≥rkach nie ma symboli specjalnych do usuniƒôcia.")
            return

        reply = QMessageBox.question(self, "Potwierdzenie operacji",
                                     f"Czy na pewno chcesz usunƒÖƒá symbole specjalne z {len(cells_to_modify)} kom√≥rek?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if reply != QMessageBox.Yes: return

        updated_info = []
        error_messages = []
        for cell_data in cells_to_modify:
            parsed = parse_symbol(cell_data.get('symbol', ''))
            final_location = parsed.get('location') or cell_data.get('lokalizacja_domyslna', 'h')
            new_symbol = build_symbol(location=final_location, start_hour=parsed.get('start_hour'),
                                      work_hours=parsed.get('work_hours'), special_symbol=None)

            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"üë§ {cell_data.get('uzytkownik_dane')}: {result.get('message', 'B≈ÇƒÖd zapisu.')}")
            except Exception as e:
                log_error(f"B≈ÇƒÖd w clear_special_symbol_from_selected_cells: {e}")
                error_messages.append(f"üë§ {cell_data.get('uzytkownik_dane')}: B≈ÇƒÖd aplikacji: {e}")

        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Pomy≈õlnie usuniƒôto symbole specjalne z {len(updated_info)} kom√≥rek.", 4000)
            self.schedule_model.layoutChanged.emit()

        if error_messages:
            QMessageBox.warning(self, "B≈Çƒôdy podczas zapisu",
                                "WystƒÖpi≈Çy nastƒôpujƒÖce b≈Çƒôdy:\n\n" + "\n".join(error_messages))

    def _build_new_symbol_with_absence_fixed(self, current_symbol, special_symbol, cell_data):
        """
        POPRAWIONA WERSJA: Buduje nowy symbol z absencjƒÖ, poprawnie obs≈ÇugujƒÖc
        zar√≥wno puste, jak i wype≈Çnione kom√≥rki.
        """
        from symbol_parser import parse_symbol, build_symbol

        # Inicjalizacja zmiennych
        location = None
        start_hour = None
        work_hours = None

        if current_symbol and current_symbol.strip():
            # Kom√≥rka NIE JEST pusta: parsujemy istniejƒÖcy symbol
            debug_print(f"Kom√≥rka niepusta. Parsowanie symbolu: '{current_symbol}'")
            parsed = parse_symbol(current_symbol)
            location = parsed.get('location')
            start_hour = parsed.get('start_hour')
            work_hours = parsed.get('work_hours')
        else:
            # --- NOWA, POPRAWNA LOGIKA DLA PUSTEJ KOM√ìRKI ---
            debug_print("Kom√≥rka pusta. U≈ºywam danych domy≈õlnych.")
            # Pobierz domy≈õlnƒÖ lokalizacjƒô i godziny z etatu
            location = cell_data.get('lokalizacja_domyslna')
            work_hours = cell_data.get('etat')
            # Dla absencji w dzie≈Ñ wolny, domy≈õlna godzina rozpoczƒôcia to 8
            start_hour = 8

        # Budujemy nowy symbol z nowym symbolem specjalnym, ale zachowujƒÖc godziny/lokalizacjƒô
        new_symbol = build_symbol(
            location=location,
            start_hour=start_hour,
            work_hours=work_hours,
            special_symbol=special_symbol
        )

        debug_print(f"Zbudowano nowy symbol: '{new_symbol}'")
        return new_symbol

    def _call_import_changes_procedure(self, nr_kadrowy, rok, miesiac, data, symbol):
        """
        POPRAWIONA WERSJA: Wywo≈Çuje procedurƒô i bardziej niezawodnie interpretuje jej wyniki.
        Ka≈ºdy komunikat tekstowy, kt√≥ry nie jest nowym symbolem, jest traktowany jako b≈ÇƒÖd.
        """
        try:
            from db_connector import DatabaseConnector

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            debug_print(
                f"Wywo≈Çanie procedury: nr_kadrowy={nr_kadrowy}, rok={rok}, miesiac={miesiac}, data={data}, symbol={symbol}")

            cursor.execute("""
                EXEC [dbo].[p_P_ZZ_ImportZmianyNaSerwer_v3] 
                    @NumerKadrowy = ?, @Rok = ?, @Miesiac = ?, @Data = ?, @Symbol = ?, @CzyPobieranieSugestii = ?
            """, (nr_kadrowy, rok, miesiac, data, symbol, None))

            all_results = []
            while True:
                try:
                    rows = cursor.fetchall()
                    if rows:
                        all_results.extend(rows)
                    if not cursor.nextset():
                        break
                except Exception:
                    break

            conn.commit()
            conn.close()

            returned_symbol = symbol
            success = True
            message = "Operacja zako≈Ñczona pomy≈õlnie"

            for row in all_results:
                if row and len(row) > 0 and row[0] is not None:
                    raw_value = row[0]

                    # --- NOWA, KLUCZOWA ZMIANA ---
                    # Sprawdzamy, czy procedura nie zwr√≥ci≈Ça numerycznego 0,
                    # kt√≥re traktujemy jako sygna≈Ç sukcesu i ignorujemy.
                    if isinstance(raw_value, int) and raw_value == 0:
                        continue  # Przejd≈∫ do nastƒôpnego wyniku

                    value_str = str(raw_value).strip()
                    if not value_str:
                        continue

                    # Sprawdzamy r√≥wnie≈º dla tekstowego "0"
                    if value_str == "0":
                        continue
                    # --- KONIEC KLUCZOWEJ ZMIANY ---

                    is_likely_a_symbol = ' ' not in value_str and len(value_str) <= 50

                    if is_likely_a_symbol:
                        returned_symbol = value_str
                        debug_print(f"Procedura zwr√≥ci≈Ça nowy symbol: {value_str}")
                    else:
                        success = False
                        message = value_str
                        debug_print(f"Procedura zwr√≥ci≈Ça komunikat (traktowany jako b≈ÇƒÖd): {value_str}")
                        break

            if success:
                self._update_modification_date()

            return {
                "success": success,
                "message": message,
                "returned_symbol": returned_symbol
            }

        except Exception as e:
            log_error(f"B≈ÇƒÖd procedury p_P_ZZ_ImportZmianNaSerwer_v4: {e}")
            return {
                "success": False,
                "message": f"B≈ÇƒÖd bazy danych: {str(e)}",
                "returned_symbol": symbol
            }

    def _process_and_apply_changes(self, change_requests: list, success_message_template: str):
        """
        NOWA, CENTRALNA METODA: Przetwarza listƒô ≈ºƒÖda≈Ñ zmian, wywo≈Çuje procedurƒô,
        a nastƒôpnie zbiera i wy≈õwietla wyniki (sukcesy na pasku statusu, b≈Çƒôdy w oknie).

        Args:
            change_requests (list): Lista s≈Çownik√≥w, ka≈ºdy z kluczami:
                                    nr_kadrowy, rok, miesiac, data, symbol, user_id, user_name.
            success_message_template (str): Szablon wiadomo≈õci o sukcesie, np. "Zastosowano symbol dla {} kom√≥rek."
        """
        if not change_requests:
            return

        updated_info = []
        error_messages = []

        for req in change_requests:
            try:
                result = self._call_import_changes_procedure(
                    nr_kadrowy=req['nr_kadrowy'],
                    rok=req['rok'],
                    miesiac=req['miesiac'],
                    data=req['data'],
                    symbol=req['symbol']
                )
                if result.get('success'):
                    updated_info.append((req['user_id'], req['data'], result.get('returned_symbol')))
                else:
                    error_msg = result.get('message', 'Nieznany b≈ÇƒÖd')
                    error_messages.append(f"üë§ {req.get('user_name', req['nr_kadrowy'])} ({req['data']}): {error_msg}")
            except Exception as e:
                log_error(f"B≈ÇƒÖd krytyczny podczas przetwarzania ≈ºƒÖdania zmiany: {req}", exception=e)
                error_messages.append(f"üë§ {req.get('user_name', req['nr_kadrowy'])} ({req['data']}): {e}")

        # Aktualizuj UI dla udanych operacji
        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(success_message_template.format(len(updated_info)), 4000)
            self.schedule_model.layoutChanged.emit()  # Wymu≈õ od≈õwie≈ºenie sum i bilansu

        # Wy≈õwietl jedno okno ze wszystkimi b≈Çƒôdami
        if error_messages:
            QMessageBox.warning(
                self,
                "B≈Çƒôdy podczas zapisu",
                "WystƒÖpi≈Çy nastƒôpujƒÖce b≈Çƒôdy i niekt√≥re zmiany nie zosta≈Çy zapisane:\n\n" + "\n".join(error_messages),
                QMessageBox.Ok
            )

    def _update_cells_with_new_symbols(self, updated_cells_info: list):
        """
        Aktualizuje kom√≥rki w modelu na podstawie danych zwr√≥conych przez procedurƒô,
        bez ponownego odpytywania bazy danych.

        Args:
            updated_cells_info: Lista krotek (user_id, date_str, new_symbol)
        """
        if not updated_cells_info or not hasattr(self, 'schedule_model'):
            return

        for user_id, date_str, new_symbol in updated_cells_info:
            if new_symbol is not None:
                self._update_single_cell_in_model(user_id, date_str, new_symbol, self.year, self.month)

        debug_print(f"Zaktualizowano {len(updated_cells_info)} kom√≥rek w modelu na podstawie danych zwrotnych.")

    def _update_single_cell_in_model(self, user_id, date_str, new_symbol, year, month):
        """
        NOWA PROSTA METODA: Aktualizuje jednƒÖ kom√≥rkƒô w modelu i wymusza jej od≈õwie≈ºenie
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return False

            # Znajd≈∫ pozycjƒô kom√≥rki
            row_index = -1
            for idx, key in enumerate(self.schedule_model._keys):
                if str(key[3]) == str(user_id):
                    row_index = idx
                    break

            if row_index == -1:
                debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                return False

            # Oblicz kolumnƒô
            try:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)
                if int(year_str) != year or int(month_str) != month:
                    return False
            except:
                return False

            visible_columns_count = len(self.schedule_model.get_visible_columns())
            col_index = visible_columns_count + day - 1

            # KLUCZOWE: U≈ºyj setData aby model wiedzia≈Ç o zmianie
            model_index = self.schedule_model.index(row_index, col_index)
            if model_index.isValid():
                # Ustaw nowy symbol przez model - to wywo≈Ça automatyczne od≈õwie≈ºenie
                success = self.schedule_model.setData(model_index, new_symbol, Qt.EditRole)

                if success:
                    debug_print(f"SUKCES: Zaktualizowano kom√≥rkƒô [{row_index},{col_index}] = '{new_symbol}'")
                    return True
                else:
                    debug_print(f"B≈ÅƒÑD: Nie uda≈Ço siƒô zaktualizowaƒá kom√≥rki [{row_index},{col_index}]")

            return False

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji kom√≥rki {user_id}/{date_str}: {e}")
            return False

    def _update_model_with_new_symbols(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje symbole bezpo≈õrednio w modelu
        """
        try:
            if not updated_symbols or not hasattr(self, 'schedule_model'):
                return

            processed_data = self.schedule_model.get_processed_data()
            if not processed_data:
                return

            updated_count = 0
            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Znajd≈∫ klucz u≈ºytkownika w processed_data
                target_key = None
                for key in processed_data.keys():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        target_key = key
                        break

                if not target_key:
                    debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                    continue

                # Oblicz dzie≈Ñ z daty
                try:
                    year_str, month_str, day_str = date_str.split('-')
                    day = int(day_str)

                    if int(year_str) != year or int(month_str) != month:
                        continue

                except ValueError:
                    continue

                # Aktualizuj symbol w processed_data
                user_data = processed_data[target_key]
                days_data = user_data.setdefault('days', {})
                day_data = days_data.setdefault(day, {})

                old_symbol = day_data.get('symbol', '')
                day_data['symbol'] = new_symbol

                # Przelicz godziny na podstawie nowego symbolu
                from symbol_parser import parse_symbol
                parsed = parse_symbol(new_symbol)
                day_data['hours'] = parsed.get('work_hours', 0) or 0
                day_data['start_hour'] = parsed.get('start_hour')

                # Aktualizuj total_hours u≈ºytkownika
                old_hours = 0
                if old_symbol:
                    old_parsed = parse_symbol(old_symbol)
                    old_hours = old_parsed.get('work_hours', 0) or 0

                new_hours = day_data['hours']
                user_data['total_hours'] = (user_data.get('total_hours', 0) or 0) - old_hours + new_hours

                updated_count += 1
                debug_print(
                    f"Model: Zaktualizowano {user_id}/{day}: '{old_symbol}' -> '{new_symbol}' ({old_hours}h -> {new_hours}h)")

            debug_print(f"Zaktualizowano {updated_count} kom√≥rek w modelu")

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji modelu: {e}")

    def _fetch_single_cell_symbol(self, user_id, date_str, year, month):
        """
        NOWA METODA: Pobiera aktualny symbol dla pojedynczej kom√≥rki z bazy danych

        Args:
            user_id (int): ID u≈ºytkownika
            date_str (str): Data w formacie YYYY-MM-DD
            year (int): Rok
            month (int): MiesiƒÖc

        Returns:
            str|None: Aktualny symbol lub None je≈õli nie znaleziono
        """
        try:
            from db_connector import DatabaseConnector

            # Zapytanie do pobrania symbolu dla konkretnej kom√≥rki
            query = """
            SELECT Symbol 
            FROM [dbo].[fn_GetScheduleData](?, ?) 
            WHERE Uzytkownik = ? AND Data = ?
            """

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query, (year, month, user_id, date_str))
            result = cursor.fetchone()
            conn.close()

            if result and result[0] is not None:
                return str(result[0])

            return None

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas pobierania symbolu dla kom√≥rki {user_id}/{date_str}: {e}")
            return None

    def _update_data_provider_cache(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje cache w DataProvider
        """
        try:
            if not updated_symbols or not hasattr(self.data_provider, 'monthly_cache'):
                return

            month_key = (year, month)
            if month_key not in self.data_provider.monthly_cache:
                return

            container = self.data_provider.monthly_cache[month_key]

            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Aktualizuj processed_data w kontenerze
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):
                        try:
                            year_str, month_str, day_str = date_str.split('-')
                            day = int(day_str)

                            if int(year_str) == year and int(month_str) == month:
                                days_data = user_data.setdefault('days', {})
                                day_data = days_data.setdefault(day, {})
                                day_data['symbol'] = new_symbol

                                # Przelicz godziny
                                from symbol_parser import parse_symbol
                                parsed = parse_symbol(new_symbol)
                                day_data['hours'] = parsed.get('work_hours', 0) or 0
                                day_data['start_hour'] = parsed.get('start_hour')

                                debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")
                                break
                        except:
                            continue

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji DataProvider cache: {e}")

    def _force_full_refresh(self):
        """Fallback - pe≈Çne od≈õwie≈ºenie danych"""
        try:
            current_data = self.date_combo.currentData()
            if current_data:
                year, month = current_data
                self.data_provider.refresh_data(year, month)
                self.update_table_content()
        except Exception as e:
            log_error(f"B≈ÇƒÖd pe≈Çnego od≈õwie≈ºenia: {e}")

    def _force_refresh_specific_cells(self, affected_pairs, year, month):
        """
        POPRAWIONA METODA: Wymusza od≈õwie≈ºenie konkretnych kom√≥rek w widoku
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycjƒô kom√≥rki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajd≈∫ wiersz u≈ºytkownika w modelu
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnƒô dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymusza od≈õwie≈ºenie kom√≥rki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej kom√≥rki
                        self.schedule_model.dataChanged.emit(model_index, model_index,
                                                             [Qt.DisplayRole, Qt.BackgroundRole])

                        # Metoda 2: Wymu≈õ update widoku dla tej kom√≥rki
                        self.table.schedule_view.update(model_index)

                        refreshed_cells += 1
                        debug_print(f"Od≈õwie≈ºono kom√≥rkƒô tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"B≈ÇƒÖd od≈õwie≈ºania kom√≥rki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymu≈õ ca≈Ço≈õciowy update viewport je≈õli zmieniono jakie≈õ kom√≥rki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po od≈õwie≈ºeniu {refreshed_cells} kom√≥rek")

                # DODATKOWE: Wymu≈õ te≈º od≈õwie≈ºenie tabeli pracownik√≥w (dla sum RBH)
                if hasattr(self.table, 'employees_view'):
                    self.table.employees_view.viewport().update()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas wymuszania od≈õwie≈ºenia kom√≥rek tabeli: {e}")

    def _update_model_cells_directly(self, updated_symbols, year, month):
        """
        Aktualizuje symbole bezpo≈õrednio w modelu i DataProvider

        Args:
            updated_symbols (dict): S≈Çownik {(user_id, date_str): symbol}
            year (int): Rok
            month (int): MiesiƒÖc
        """
        try:
            if not updated_symbols:
                return

            updated_count = 0

            # AKTUALIZACJA 1: Schedule Model processed_data
            if hasattr(self, 'schedule_model') and self.schedule_model:
                processed_data = self.schedule_model.get_processed_data()

                if processed_data:
                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        if self._update_single_cell_in_processed_data(processed_data, user_id, date_str, new_symbol,
                                                                      year, month):
                            updated_count += 1

            # AKTUALIZACJA 2: DataProvider cache (je≈õli istnieje)
            if hasattr(self.data_provider, 'monthly_cache'):
                month_key = (year, month)
                if month_key in self.data_provider.monthly_cache:
                    container = self.data_provider.monthly_cache[month_key]

                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        self._update_single_cell_in_data_provider(container, user_id, date_str, new_symbol, year, month)

            debug_print(f"Zaktualizowano {updated_count} kom√≥rek w modelu")

        except Exception as e:
            log_error(f"B≈ÇƒÖd bezpo≈õredniej aktualizacji modelu: {e}")

    def _update_single_cell_in_processed_data(self, processed_data, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczƒÖ kom√≥rkƒô w processed_data

        Returns:
            bool: True je≈õli zaktualizowano
        """
        try:
            # Znajd≈∫ klucz u≈ºytkownika
            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if not target_key:
                debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                return False

            # Oblicz dzie≈Ñ
            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)

            if int(year_str) != year or int(month_str) != month:
                return False

            # Aktualizuj symbol
            user_data = processed_data[target_key]
            days_data = user_data.setdefault('days', {})
            day_data = days_data.setdefault(day, {})

            old_symbol = day_data.get('symbol', '')
            day_data['symbol'] = new_symbol

            # Przelicz godziny i inne parametry
            from symbol_parser import parse_symbol
            parsed = parse_symbol(new_symbol)
            day_data['hours'] = parsed.get('work_hours', 0) or 0
            day_data['start_hour'] = parsed.get('start_hour')

            debug_print(f"Model: {user_id}/{day} '{old_symbol}' -> '{new_symbol}'")
            return True

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji kom√≥rki processed_data {user_id}/{date_str}: {e}")
            return False

    def _update_single_cell_in_data_provider(self, container, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczƒÖ kom√≥rkƒô w DataProvider cache
        """
        try:
            if not hasattr(container, 'processed_data') or not container.processed_data:
                return

            # Podobna logika jak dla processed_data w modelu
            processed_data = container.processed_data

            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if target_key:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)

                if int(year_str) == year and int(month_str) == month:
                    user_data = processed_data[target_key]
                    days_data = user_data.setdefault('days', {})
                    day_data = days_data.setdefault(day, {})
                    day_data['symbol'] = new_symbol

                    # Przelicz godziny
                    from symbol_parser import parse_symbol
                    parsed = parse_symbol(new_symbol)
                    day_data['hours'] = parsed.get('work_hours', 0) or 0
                    day_data['start_hour'] = parsed.get('start_hour')

                    debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji DataProvider cache: {e}")

    def _force_refresh_table_cells(self, affected_pairs, year, month):
        """
        WYMUSZA od≈õwie≈ºenie konkretnych kom√≥rek w widoku tabeli

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
            year (int): Rok
            month (int): MiesiƒÖc
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycjƒô kom√≥rki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajd≈∫ wiersz u≈ºytkownika
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnƒô dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymu≈õ od≈õwie≈ºenie kom√≥rki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej kom√≥rki
                        self.schedule_model.dataChanged.emit(model_index, model_index, [])

                        # Metoda 2: Wymu≈õ update widoku (backup)
                        self.table.schedule_view.update(model_index)

                        # Metoda 3: Invalidate item (backup)
                        if hasattr(self.table.schedule_view, 'setDirtyRegion'):
                            rect = self.table.schedule_view.visualRect(model_index)
                            if not rect.isEmpty():
                                self.table.schedule_view.viewport().update(rect)

                        refreshed_cells += 1
                        debug_print(f"Od≈õwie≈ºono kom√≥rkƒô tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"B≈ÇƒÖd od≈õwie≈ºania kom√≥rki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymu≈õ ca≈Ço≈õciowy update viewport je≈õli zmieniono jakie≈õ kom√≥rki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po od≈õwie≈ºeniu {refreshed_cells} kom√≥rek")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas wymuszania od≈õwie≈ºenia kom√≥rek tabeli: {e}")

    def _find_user_row_in_model(self, user_id):
        """
        POPRAWIONA METODA: Znajduje indeks wiersza dla danego u≈ºytkownika w modelu
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return -1

            # Pobierz klucze z modelu
            if hasattr(self.schedule_model, '_keys'):
                keys = self.schedule_model._keys
            else:
                return -1

            user_id_str = str(user_id)

            for row_index, key in enumerate(keys):
                if len(key) > 3 and str(key[3]) == user_id_str:
                    return row_index

            return -1

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas szukania wiersza u≈ºytkownika {user_id}: {e}")
            return -1

    def _update_local_events_for_cells(self, affected_pairs):
        """
        Aktualizuje lokalny events_data tylko dla zmienionych kom√≥rek

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
        """
        try:
            if not hasattr(self, 'events_data'):
                return

            # Sprawd≈∫ czy jakie≈õ z zmienionych kom√≥rek sƒÖ obecnie zaznaczone
            if not hasattr(self, 'table'):
                return

            current_selection = self.table.get_data_for_selected_cells()
            selected_pairs = set()

            for cell_data in current_selection:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    selected_pairs.add((user_id, date_str))

            # Sprawd≈∫ czy kt√≥ra≈õ ze zmienionych kom√≥rek jest zaznaczona
            intersection = set(affected_pairs) & selected_pairs

            if intersection:
                debug_print(f"Zaktualizowano {len(intersection)} zmienionych kom√≥rek w events_data")
                # Je≈õli tak, od≈õwie≈º events_data tylko dla zaznaczonych kom√≥rek
                self.on_selection_changed()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji lokalnych events: {e}")

    def _show_symbol_change_results(self, successful_updates, failed_updates, error_messages, events_to_cancel):
        """
        Pokazuje wyniki operacji wstawiania symboli

        Args:
            successful_updates (int): Liczba udanych aktualizacji
            failed_updates (int): Liczba nieudanych aktualizacji
            error_messages (list): Lista komunikat√≥w b≈Çƒôd√≥w
            events_to_cancel (list): Lista odwo≈Çanych zdarze≈Ñ
        """
        if successful_updates > 0:
            message = f"Pomy≈õlnie zaktualizowano {successful_updates} kom√≥rek"

            if events_to_cancel:
                message += f" i odwo≈Çano {len(events_to_cancel)} delegacji"

            if failed_updates > 0:
                message += f"\n\n‚ö†Ô∏è {failed_updates} aktualizacji nie powiod≈Ço siƒô"
                if error_messages:
                    message += ":\n" + "\n".join(error_messages[:5])
                    if len(error_messages) > 5:
                        message += f"\n... i {len(error_messages) - 5} wiƒôcej b≈Çƒôd√≥w"

            if failed_updates == 0:
                QMessageBox.information(
                    self, "Sukces", message, QMessageBox.Ok
                )
            else:
                QMessageBox.warning(
                    self, "Czƒô≈õciowy sukces", message, QMessageBox.Ok
                )
        else:
            message = f"Nie uda≈Ço siƒô zaktualizowaƒá ≈ºadnej kom√≥rki"
            if error_messages:
                message += f"\n\nB≈Çƒôdy ({len(error_messages)}):\n"
                message += "\n".join(error_messages[:10])
                if len(error_messages) > 10:
                    message += f"\n... i {len(error_messages) - 10} wiƒôcej b≈Çƒôd√≥w"

            QMessageBox.critical(
                self, "B≈ÇƒÖd aktualizacji", message, QMessageBox.Ok
            )

    def _prepare_delegations_description(self, grouped_events, max_groups=10):
        """
        Przygotowuje opis delegacji do odwo≈Çania.

        Args:
            grouped_events: S≈Çownik zdarze≈Ñ pogrupowanych wed≈Çug u≈ºytkownika i daty
            max_groups: Maksymalna liczba grup do wy≈õwietlenia

        Returns:
            str: Opis delegacji do odwo≈Çania
        """
        delegations_info = ""

        if not grouped_events:
            return delegations_info

        delegations_info += "\nNastƒôpujƒÖce delegacje zostanƒÖ automatycznie odwo≈Çane:\n"

        # Licznik dla ograniczenia liczby wy≈õwietlanych grup
        group_count = 0

        for (user_id, date_str), events in grouped_events.items():
            # Ograniczenie liczby wy≈õwietlanych grup
            if group_count >= max_groups:
                delegations_info += f"\n...oraz wiƒôcej zdarze≈Ñ dla innych u≈ºytkownik√≥w/dni ({len(grouped_events) - max_groups} wiƒôcej grup)...\n"
                break

            # Pobierz nazwƒô u≈ºytkownika z pierwszego zdarzenia
            user_name = events[0].get('user_name', f"ID: {user_id}")

            # Przygotuj datƒô w ≈Çadniejszym formacie (DD.MM.YYYY)
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            delegations_info += f"   üë§ {user_name} - üìÖ {formatted_date}:\n"

            # Wy≈õwietl zdarzenia dla tego u≈ºytkownika i daty
            for i, event in enumerate(events):
                delegations_info += f"      {i + 1}. {event['type']}: {event['name']}\n"

            group_count += 1

        return delegations_info

    def filter_processed_data(self):
        """
        Filtruje przetworzone dane na podstawie wszystkich filtr√≥w, w tym nowego filtra "Grupa".
        """
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return {}

        # Pobierz wyb√≥r ze wszystkich filtr√≥w
        selected_wydzialy = set(self.wydzial_combo.get_selected_items())
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)
        selected_dtn = self.dtn_combo.get_selected_items()
        selected_role = self.rola_combo.get_selected_items()
        selected_jezyki = self.jezyk_combo.get_selected_items()
        selected_etaty = self.etat_combo.get_selected_items()
        selected_scp = self.system_czasu_pracy_combo.get_selected_items()

        # --- NOWA LOGIKA FILTROWANIA GRUP ---
        selected_grupy = self.grupa_main_filter_combo.get_selected_items()
        selected_locations = self.default_location_combo.get_selected_items()

        allowed_depts_from_groups = set()

        if selected_grupy:
            group_mapping = self.data_provider.get_department_to_group_mapping()
            for group_name in selected_grupy:
                # Rozszerz zbi√≥r dozwolonych wydzia≈Ç√≥w o te z wybranej grupy
                allowed_depts_from_groups.update(group_mapping.get(group_name, set()))

            # Je≈ºeli u≈ºytkownik wybra≈Ç te≈º konkretne wydzia≈Çy, znajd≈∫ czƒô≈õƒá wsp√≥lnƒÖ
            if selected_wydzialy:
                selected_wydzialy = selected_wydzialy.intersection(allowed_depts_from_groups)
            else:  # Je≈ºeli nie wybra≈Ç wydzia≈Ç√≥w, u≈ºyj tych wynikajƒÖcych z wyboru grupy
                selected_wydzialy = allowed_depts_from_groups

        filtered_data = {}
        for key, data in self.processed_data.items():
            wydzial, przelozony, uzytkownik_dane, _ = key

            # Warunki filtrowania - teraz selected_wydzialy jest ju≈º odpowiednio zawƒô≈ºone
            if (not selected_locations or data.get('lokalizacja_domyslna') in selected_locations) and \
                    (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni) and \
                    (not selected_uzytkownicy or str(uzytkownik_dane) in selected_uzytkownicy) and \
                    (not selected_dtn or str(data.get('dtn', '')) in selected_dtn) and \
                    (not selected_role or data.get('rola_nazwa', '') in selected_role) and \
                    (not selected_jezyki or data.get('jezyk', '') in selected_jezyki) and \
                    (not selected_etaty or str(data.get('etat', '')) in selected_etaty) and \
                    (not selected_scp or data.get('system_czasu_pracy', '') in selected_scp):
                filtered_data[key] = data

        return filtered_data

    def _cancel_delegations(self, events_to_cancel_input: List[Dict]):
        debug_print(f"Rozpoczynam _cancel_delegations dla {len(events_to_cancel_input)} zdarze≈Ñ.")
        if not events_to_cancel_input:
            return 0

        successful_db_updates = 0
        # Lista par (user_id, date_key) dla zdarze≈Ñ, kt√≥re zosta≈Çy pomy≈õlnie zaktualizowane w DB
        affected_user_date_pairs_for_refresh = set()

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            _, user_app_id, _, _, _ = get_modifier_id()

            for event_details in events_to_cancel_input:
                event_id = event_details.get('id')
                event_type = event_details.get('type')
                user_id_for_event = event_details.get('user_id')  # U≈ºyj user_id z event_details
                date_key_for_event = event_details.get('date_key', event_details.get('date'))

                if not event_id or not event_type or not user_id_for_event or not date_key_for_event:
                    log_warning(f"Pominiƒôto zdarzenie z niepe≈Çnymi danymi w _cancel_delegations: {event_details}")
                    continue

                table_name = ""
                if event_type == "Spotkanie":
                    table_name = "p_t_zz_Spotkania"
                elif event_type == "Szkolenie":
                    table_name = "p_t_zz_Szkolenia"
                elif event_type == "Nadgodziny":
                    table_name = "p_t_zz_Nadgodziny"

                if not table_name:
                    log_warning(f"Nieznany typ zdarzenia w _cancel_delegations: {event_type}")
                    continue

                try:
                    if event_type in ["Spotkanie", "Szkolenie"]:
                        update_query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                        cursor.execute(update_query, (user_app_id, event_id))
                    else:  # Nadgodziny
                        delete_query = f"DELETE FROM {table_name} WHERE Id = ?"
                        cursor.execute(delete_query, (event_id,))

                    if cursor.rowcount > 0:
                        successful_db_updates += 1
                        affected_user_date_pairs_for_refresh.add((user_id_for_event, date_key_for_event))
                        debug_print(f"DB: Pomy≈õlnie zaktualizowano/usuniƒôto {event_type} ID {event_id}")
                    else:
                        log_warning(f"DB: Nie znaleziono {event_type} ID {event_id} do aktualizacji/usuniƒôcia.")

                except Exception as db_err:
                    log_error(f"B≈ÇƒÖd DB podczas odwo≈Çywania {event_type} ID {event_id}: {db_err}", exception=db_err)

            if successful_db_updates > 0:
                conn.commit()
                debug_print(f"DB: Zatwierdzono {successful_db_updates} zmian.")
                # Rejestrujemy, ≈ºe to my dokonali≈õmy zmiany w bazie danych
                self._update_modification_date()
            conn.close()

        except Exception as e:
            log_error(f"Generalny b≈ÇƒÖd w _cancel_delegations podczas operacji DB: {e}", exception=e)
            return 0  # Zwr√≥ƒá 0 je≈õli wystƒÖpi≈Ç b≈ÇƒÖd przed aktualizacjƒÖ UI

        # Je≈õli by≈Çy jakiekolwiek udane aktualizacje w DB
        if affected_user_date_pairs_for_refresh:
            debug_print(
                f"_cancel_delegations: Uruchamiam od≈õwie≈ºanie DataProvider dla {len(affected_user_date_pairs_for_refresh)} par.")
            # Krok 1: Uniewa≈ºnij i od≈õwie≈º cache DataProvider dla dotkniƒôtych zdarze≈Ñ/miesiƒôcy
            self.data_provider.invalidate_complete_cache_for_pairs(list(affected_user_date_pairs_for_refresh))

            # Krok 2: Od≈õwie≈º tabelƒô zdarze≈Ñ - on_selection_changed u≈ºyje ≈õwie≈ºych danych z DataProvider
            # Ta metoda zaktualizuje self.events_data i self.events_model
            debug_print(f"_cancel_delegations: Uruchamiam on_selection_changed() w celu od≈õwie≈ºenia tabeli zdarze≈Ñ.")
            selected_cells_data = self.table.get_data_for_selected_cells()  # Pobierz aktualnie zaznaczone kom√≥rki
            if selected_cells_data:
                self.on_selection_changed()  # To powinno teraz poprawnie wyczy≈õciƒá zdarzenia
            else:  # Je≈õli nic nie jest zaznaczone, wyczy≈õƒá tabelƒô zdarze≈Ñ rƒôcznie
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])
                debug_print("_cancel_delegations: Brak zaznaczenia, wyczyszczono tabelƒô zdarze≈Ñ.")

            # Krok 3: Zaktualizuj ikony w tabeli grafiku na podstawie ≈õwie≈ºych danych z DataProvider
            if hasattr(self, 'schedule_model'):
                debug_print(
                    f"_cancel_delegations: Uruchamiam aktualizacjƒô ikon grafiku dla {len(affected_user_date_pairs_for_refresh)} par.")
                for user_id, date_str in affected_user_date_pairs_for_refresh:
                    # Pobierz aktualne aktywne zdarzenia dla tej kom√≥rki z DataProvider
                    # DataProvider powinien teraz mieƒá ≈õwie≈ºe dane po invalidate_complete_cache_for_pairs
                    remaining_active_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                    has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_active_events)
                    has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_active_events)
                    has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_active_events)

                    self.schedule_model.update_cell_icons_directly(
                        user_id, date_str, has_meetings, has_trainings, has_overtime
                    )

            # Wymu≈õ od≈õwie≈ºenie widok√≥w tabel, je≈õli to konieczne
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        debug_print(f"_cancel_delegations: Zako≈Ñczono, pomy≈õlnie przetworzono w DB: {successful_db_updates} zdarze≈Ñ.")
        return successful_db_updates

    def update_filter_dates(self):
        """Aktualizuje daty filtrowania do pierwszego i ostatniego dnia wybranego miesiƒÖca"""
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # KLUCZOWA POPRAWKA: Blokuj sygna≈Çy przed zmianƒÖ dat
        self.date_from.blockSignals(True)
        self.date_to.blockSignals(True)

        try:
            # Pierwszy dzie≈Ñ miesiƒÖca
            first_day = QDate(year, month, 1)
            self.date_from.setDate(first_day)

            # Ostatni dzie≈Ñ miesiƒÖca
            if month == 12:
                next_month = QDate(year + 1, 1, 1)
            else:
                next_month = QDate(year, month + 1, 1)

            last_day = next_month.addDays(-1)
            self.date_to.setDate(last_day)

        finally:
            # ZAWSZE odblokuj sygna≈Çy
            self.date_from.blockSignals(False)
            self.date_to.blockSignals(False)

        # Wywo≈Çaj filtrowanie tylko RAZ po wszystkich zmianach
        self.filter_events_table()

    def on_date_combo_changed(self):
        """
        ZMODYFIKOWANA: Zmiana miesiƒÖca z async loading
        """
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            if self.staffing_details_win and not self.staffing_details_win.isHidden():
                self.staffing_details_win.update_for_new_month_or_filters(year, month)

            if hasattr(self.data_provider, 'on_month_change'):
                self.data_provider.on_month_change(year, month)

            self.update_data(year, month, use_async=True)
            self.update_filter_dates()

            # --- DODAJ Tƒò LINIƒò ---
            self.update_buttons_visibility()

    def update_data(self, year, month, use_async=True):
        """
        NOWA WERSJA: ≈Åadowanie danych z opcjƒÖ async

        Args:
            year: Rok
            month: MiesiƒÖc
            use_async: Czy u≈ºyƒá asynchronicznego ≈Çadowania (domy≈õlnie True)
        """
        debug_print(f"Rozpoczynam ≈Çadowanie danych dla {year}-{month} (async={use_async})")

        self.year = year
        self.month = month

        # Sprawd≈∫ czy modele zosta≈Çy zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            debug_print("Tworzƒô nowy model grafiku")
            self.schedule_model = ScheduleTableModel(self)
            self.schedule_model.set_theme(self.is_dark_theme)

            ui_columns = self.column_definitions.get_ui_display_columns()
            visible_cols = self.visible_columns
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

        if not hasattr(self, 'events_model') or not self.events_model:
            debug_print("Tworzƒô nowy model zdarze≈Ñ")
            self.events_model = EventsTableModel(self)
            self.events_model.set_theme(self.is_dark_theme)

        # KLUCZOWA ZMIANA: U≈ºyj async loading dla du≈ºych zbior√≥w danych
        if use_async:
            self._load_data_async(year, month)
        else:
            self._load_data_sync(year, month)

    def _load_data_sync(self, year, month):
        """
        Synchroniczne ≈Çadowanie danych (fallback), teraz sp√≥jne z logikƒÖ asynchronicznƒÖ.
        """
        debug_print(f"≈Åadowanie synchroniczne dla {year}-{month}")

        try:
            if hasattr(self, 'statusBar'):
                self.statusBar().showMessage(f"≈Åadowanie danych {year}-{month}...")

            # Krok 1: Pobierz kontener z danymi bazowymi
            container = self.data_provider._get_or_load_monthly_data(
                year, month, self.import_grupa, self.import_funkcja, use_cache=False
            )

            if container:
                # Krok 2: Pobierz przetworzone dane z na≈Ço≈ºonymi ikonami
                processed_data_with_icons = self.data_provider.get_processed_data(
                    year, month, self.import_grupa, self.import_funkcja
                )

                # Krok 3: Zastosuj wszystkie dane
                self._apply_loaded_data({
                    'schedule_data': container.schedule_data,
                    'events_data': container.events_data,
                    'processed_data': processed_data_with_icons,  # U≈ºywamy danych z ikonami
                    'year': year,
                    'month': month
                })
            else:
                log_error("Nie uda≈Ço siƒô pobraƒá danych z DataProvider w trybie synchronicznym.")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas synchronicznego ≈Çadowania: {e}", exception=e)

        finally:
            if hasattr(self, 'statusBar'):
                self.statusBar().clearMessage()

    def _load_data_async(self, year, month):
        """
        NOWA METODA: Asynchroniczne ≈Çadowanie danych z progress dialog
        """
        debug_print(f"Uruchamiam async ≈Çadowanie dla {year}-{month}")

        # Poka≈º dialog ≈Çadowania
        self.loading_dialog = LoadingProgressDialog(
            self, self.data_provider, year, month, self.import_grupa, self.import_funkcja
        )

        # Pod≈ÇƒÖcz sygna≈Çy
        self.loading_dialog.loading_completed.connect(self._on_async_data_loaded)
        self.loading_dialog.loading_cancelled.connect(self._on_async_loading_cancelled)
        self.loading_dialog.loading_failed.connect(self._on_async_loading_failed)

        # Poka≈º dialog
        result = self.loading_dialog.exec()

        # SprzƒÖtanie
        if hasattr(self, 'loading_dialog'):
            self.loading_dialog.deleteLater()
            delattr(self, 'loading_dialog')

    def _on_async_data_loaded(self, data):
        """
        NOWA METODA: Obs≈Çuguje pomy≈õlne za≈Çadowanie danych async
        """
        debug_print("Otrzymano dane z async loading")

        try:
            self._apply_loaded_data(data)
            debug_print("Pomy≈õlnie zastosowano dane z async loading")
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas stosowania za≈Çadowanych danych: {e}")

    def _on_async_loading_cancelled(self):
        """
        NOWA METODA: Obs≈Çuguje anulowanie ≈Çadowania
        """
        debug_print("Async loading zosta≈Ç anulowany przez u≈ºytkownika")
        # Mo≈ºna dodaƒá logikƒô powrotu do poprzedniego stanu

    def _on_async_loading_failed(self, error_message):
        """
        NOWA METODA: Obs≈Çuguje b≈Çƒôdy async loading
        """
        debug_print(f"Async loading failed: {error_message}")

        # Poka≈º komunikat b≈Çƒôdu u≈ºytkownikowi
        from PySide6.QtWidgets import QMessageBox
        QMessageBox.critical(
            self,
            "B≈ÇƒÖd ≈Çadowania danych",
            f"Nie uda≈Ço siƒô za≈Çadowaƒá danych:\n{error_message}\n\nSpr√≥buj ponownie lub skontaktuj siƒô z administratorem.",
            QMessageBox.Ok
        )

        # Fallback - spr√≥buj za≈Çadowaƒá synchronicznie
        try:
            debug_print("Pr√≥bujƒô fallback do synchronicznego ≈Çadowania")
            self._load_data_sync(self.year, self.month)
        except Exception as e:
            log_error(f"Fallback loading te≈º nie powi√≥d≈Ç siƒô: {e}")

    def _apply_loaded_data(self, data):
        """
        Aplikuje nowo za≈Çadowane dane do modeli i UI, decydujƒÖc, czy przywr√≥ciƒá
        zapisany stan filtr√≥w, czy za≈Çadowaƒá je od nowa.
        """
        debug_print("Otrzymano dane z async loading")

        try:
            # Upewnij siƒô, ≈ºe dane zosta≈Çy za≈Çadowane poprawnie
            if data is None:
                log_error("B≈ÇƒÖd: _apply_loaded_data otrzyma≈Ço puste dane (None).")
                return

            # Rozpakuj dane
            schedule_data = data.get('schedule_data', [])
            events_data = data.get('events_data', [])
            processed_data = data.get('processed_data', {})
            year = data.get('year')
            month = data.get('month')

            if not all([processed_data, year, month]):
                log_error(f"Niekompletne dane przekazane do _apply_loaded_data: rok={year}, miesiac={month}")
                return

            debug_print(f"Aplikujƒô dane: {len(schedule_data)} wierszy grafiku, "
                        f"{len(events_data)} zdarze≈Ñ, {len(processed_data)} u≈ºytkownik√≥w")

            # Zaktualizuj atrybuty klasy nowymi danymi
            self.raw_data = schedule_data
            self.all_events_data = events_data
            self.processed_data = processed_data

            # Zaktualizuj model grafiku nowymi danymi
            self.schedule_model.update_data(self.processed_data, year, month)

            # Wyczy≈õƒá tabelƒô zdarze≈Ñ (zostanie wype≈Çniona po zaznaczeniu kom√≥rek)
            self.events_data = []
            if hasattr(self, 'events_model'):
                self.events_model.update_data([])

            # Zaktualizuj liczniki zdarze≈Ñ, je≈õli istniejƒÖ
            if hasattr(self, 'update_event_counts'):
                self.update_event_counts()

            # KLUCZOWA LOGIKA: Sprawd≈∫, czy od≈õwie≈ºamy i mamy zapisany stan filtr√≥w
            if hasattr(self, '_preserved_filter_state') and self._preserved_filter_state:
                # Je≈õli tak, przywr√≥ƒá stan filtr√≥w i wyczy≈õƒá zapisanƒÖ warto≈õƒá
                self.restore_filters_state(self._preserved_filter_state)
                self._preserved_filter_state = None
            else:
                # W przeciwnym wypadku (pierwsze ≈Çadowanie), uruchom standardowƒÖ procedurƒô
                self.update_filters()
                self.filter_data()  # U≈ºyj g≈Ç√≥wnej metody filtrujƒÖcej

            # Zastosuj dynamiczne rozmiary (wysoko≈õƒá wierszy, nag≈Ç√≥wk√≥w i szeroko≈õƒá splittera)
            self._apply_dynamic_sizes()
            debug_print("Pomy≈õlnie zastosowano dane z async loading")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas stosowania za≈Çadowanych danych: {e}", exception=e)
        finally:
            # Zawsze upewnij siƒô, ≈ºe UI jest ponownie w≈ÇƒÖczone
            if hasattr(self, 'loading_dialog') and self.loading_dialog.isVisible():
                self.loading_dialog.accept()
            if hasattr(self, 'set_filters_enabled'):
                self.set_filters_enabled(True)

    def clear_events_cache(self, year, month):
        """
        Czy≈õci cache zdarze≈Ñ dla danego miesiƒÖca - UPROSZCZONA WERSJA

        Args:
            year: Rok
            month: MiesiƒÖc
        """
        # POPRAWKA: Deleguj TYLKO do DataProvider, bez dodatkowych akcji
        if hasattr(self.data_provider, 'invalidate_icons_cache'):
            self.data_provider.invalidate_icons_cache(year, month)
            debug_print(f"Wyczyszczono cache zdarze≈Ñ dla {year}-{month}")
        else:
            debug_print(f"DataProvider nie ma metody invalidate_icons_cache")

    def get_events_for_user_date(self, user_id, date_str):
        """
        UPROSZCZONA METODA: Deleguje do DataProvider
        """
        return self.data_provider.get_events_for_user_date(user_id, date_str)

    def refresh_column_configuration(self):
        """Od≈õwie≈ºa konfiguracjƒô kolumn z ColumnDefinitions"""
        # ZMODYFIKOWANE: U≈ºywaj self.column_definitions zamiast column_manager
        # Pobierz zaktualizowane dane kolumn
        ui_columns = self.column_definitions.get_ui_display_columns()
        visible_cols = self.visible_columns

        # Aktualizuj referencje w g≈Ç√≥wnej klasie
        self.employee_columns = ui_columns

        # Aktualizuj model
        if hasattr(self, 'schedule_model') and self.schedule_model:
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

            # Je≈õli tabela ju≈º istnieje, zaktualizuj widok
            if hasattr(self, 'table') and self.table:
                self.table.set_model(self.schedule_model)
                # Dostosuj szeroko≈õƒá tabeli pracownik√≥w
                self.table.adjust_employees_table_width()

    def setup_event_table_columns(self):
        """
        Konfiguruje szeroko≈õci kolumn tabeli zdarze≈Ñ.
        Wyodrƒôbnione z metody update_data dla lepszej czytelno≈õci.
        """
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # U≈ºytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

    def show_loading_indicator(self, message="≈Åadowanie..."):
        """
        Pokazuje wska≈∫nik ≈Çadowania w UI
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().showMessage(message)

        # Wy≈ÇƒÖcz niekt√≥re kontrolki podczas ≈Çadowania
        self.date_combo.setEnabled(False)
        self.refresh_button.setEnabled(False)

        if hasattr(self, 'left_panel_visible') and self.left_panel_visible:
            self._left_panel.setEnabled(False)

    def hide_loading_indicator(self):
        """
        Ukrywa wska≈∫nik ≈Çadowania
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().clearMessage()

        # W≈ÇƒÖcz z powrotem kontrolki
        self.date_combo.setEnabled(True)
        self.refresh_button.setEnabled(True)

        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(True)

    def get_loading_preferences(self):
        """
        Zwraca preferencje u≈ºytkownika dotyczƒÖce ≈Çadowania
        """
        # Mo≈ºna dodaƒá ustawienia w settings_db dla kontroli async loading
        # Na razie zawsze async dla du≈ºych zbior√≥w danych
        return {
            'use_async_threshold': 1000,  # U≈ºyj async dla >1000 wierszy
            'show_progress_dialog': True,
            'auto_fallback_to_sync': True
        }

    def check_for_new_data(self):
        """
        Sprawdza, czy w bazie pojawi≈Çy siƒô nowe dane grafiku lub zdarze≈Ñ,
        i tworzy szczeg√≥≈Çowe powiadomienie.
        """
        try:
            current_date_data = self.date_combo.currentData()
            if not current_date_data:
                return

            year, month = current_date_data

            if not hasattr(self, 'last_modification_date') or not self.last_modification_date:
                self._update_modification_date()
                debug_print(f"Zainicjowano datƒô ostatniej modyfikacji: {self.last_modification_date}")
                return

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # 1. Sprawd≈∫ najnowszƒÖ modyfikacjƒô w grafiku
            cursor.execute("SELECT MAX(DataModyfikacji) FROM [dbo].[p_T_ZZ_GrafikiPracy] WHERE Rok = ? AND Miesiac = ?",
                           (year, month))
            schedule_max_date = cursor.fetchone()[0]

            # 2. Sprawd≈∫ najnowszƒÖ modyfikacjƒô w zdarzeniach
            cursor.execute("SELECT MAX(DataModyfikacji) FROM [dbo].[fn_GetEventsData](?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]

            conn.close()

            # --- NOWA LOGIKA: Oddzielna analiza obu ≈∫r√≥de≈Ç ---

            new_data_types = []

            # Sprawd≈∫, czy dane grafiku sƒÖ nowsze
            if schedule_max_date and schedule_max_date > self.last_modification_date:
                new_data_types.append("grafiku")

            # Sprawd≈∫, czy dane zdarze≈Ñ sƒÖ nowsze
            if events_max_date and events_max_date > self.last_modification_date:
                new_data_types.append("zdarze≈Ñ")

            # Je≈õli wykryto jakiekolwiek zmiany, sprawd≈∫, czy nie sƒÖ to zmiany w≈Çasne
            if new_data_types:
                latest_overall_modification = max(d for d in [schedule_max_date, events_max_date] if d)

                is_self_change = False
                if hasattr(self, 'last_self_modification_date') and self.last_self_modification_date:
                    time_diff = abs(latest_overall_modification - self.last_self_modification_date)
                    if time_diff < timedelta(seconds=2):
                        is_self_change = True

                # Je≈õli zmiana nie jest naszƒÖ w≈ÇasnƒÖ, wy≈õwietl szczeg√≥≈Çowe powiadomienie
                if not is_self_change:
                    change_type_text = " i ".join(new_data_types)

                    debug_print(f"Wykryto nowe dane w sekcji: {change_type_text}.")
                    self.refresh_button.setText(f"Nowe dane {change_type_text}!")
                    self.refresh_button.setToolTip(
                        f"Wykryto zmiany w sekcji: {change_type_text}. Kliknij, aby za≈Çadowaƒá.")

                    new_data_style = """
                        QPushButton {
                            background-color: #f39c12; color: white; font-weight: bold;
                            border: 1px solid #e67e22;
                        }
                        QPushButton:hover { background-color: #e67e22; }
                    """
                    self.refresh_button.setStyleSheet(new_data_style)
                    self.check_timer.stop()
                else:
                    # To nasza w≈Çasna zmiana, wiƒôc tylko aktualizujemy datƒô w tle
                    self.last_modification_date = latest_overall_modification
                    debug_print("Wykryto w≈ÇasnƒÖ zmianƒô, powiadomienie zignorowane.")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas sprawdzania nowych danych: {e}", exception=e)

    def refresh_data(self):
        """
        Wymusza od≈õwie≈ºenie danych z bazy poprzez wyczyszczenie cache i ponowne za≈Çadowanie.
        """
        # Resetuje wyglƒÖd przycisku "Od≈õwie≈º"
        button_style = AppStyles.get_button_style("dark" if self.is_dark_theme else "light")
        self.refresh_button.setText("Od≈õwie≈º dane")
        self.refresh_button.setStyleSheet(button_style)
        self.refresh_button.setToolTip("Od≈õwie≈º dane")

        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            # Krok 1: Zapisz aktualny stan filtr√≥w do p√≥≈∫niejszego u≈ºycia
            self._preserved_filter_state = self.get_current_filters_state()

            # Krok 2: Wyczy≈õƒá cache
            debug_print(f"Wymuszone od≈õwie≈ºenie: czyszczƒô cache dla {year}-{month}")
            self.data_provider.clear_monthly_cache(year, month)

            # Krok 3: Uruchom ≈Çadowanie danych. Zapisany stan zostanie u≈ºyty po za≈Çadowaniu.
            self.update_data(year, month, use_async=True)

            # Krok 4: Zaktualizuj datƒô ostatniej modyfikacji i zrestartuj timer
            self._update_modification_date()
            if hasattr(self, 'check_timer'):
                self.check_timer.start(60000)
                debug_print("Dane od≈õwie≈ºone przez u≈ºytkownika, wznowiono automatyczne sprawdzanie.")

    def _update_modification_date(self):
        """
        Aktualizuje datƒô ostatniej modyfikacji po dokonaniu zmian,
        sprawdzajƒÖc oba ≈∫r√≥d≈Ça danych (grafik i zdarzenia).
        """
        try:
            current_date_data = self.date_combo.currentData()
            if not current_date_data:
                return

            year, month = current_date_data

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # 1. Sprawd≈∫ najnowszƒÖ modyfikacjƒô w grafiku
            cursor.execute("SELECT MAX(DataModyfikacji) FROM [dbo].[p_T_ZZ_GrafikiPracy] WHERE Rok = ? AND Miesiac = ?",
                           (year, month))
            schedule_max_date = cursor.fetchone()[0]

            # 2. Sprawd≈∫ najnowszƒÖ modyfikacjƒô w zdarzeniach
            cursor.execute("SELECT MAX(DataModyfikacji) FROM [dbo].[fn_GetEventsData](?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]

            conn.close()

            all_dates = [d for d in [schedule_max_date, events_max_date] if d is not None]
            if not all_dates:
                return

            latest_modification = max(all_dates)

            # Zapisz jako ostatniƒÖ modyfikacjƒô w≈ÇasnƒÖ ORAZ jako og√≥lnƒÖ ostatniƒÖ znanƒÖ modyfikacjƒô
            self.last_self_modification_date = latest_modification
            self.last_modification_date = latest_modification
            debug_print(f"Zarejestrowano w≈ÇasnƒÖ modyfikacjƒô z datƒÖ: {self.last_self_modification_date}")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji daty modyfikacji: {e}", exception=e)

    def filter_data(self):
        """
        Filtruje dane grafiku i aktualizuje widok.
        ZMIENIONA WERSJA z wzajemnym filtrowaniem.
        """
        # Sprawd≈∫ czy model istnieje
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # POPRAWKA: Sprawd≈∫ czy nie jeste≈õmy ju≈º w trakcie filtrowania
        if getattr(self, '_updating_filters', False):
            return

        self._updating_filters = True

        try:
            # NOWE: Najpierw aktualizuj cross-filtry
            self.update_cross_filters()

            # Pobierz przefiltrowane dane
            filtered_data = self.filter_processed_data()

            # Aktualizuj model z przefiltrowanymi danymi
            self.schedule_model.update_filtered_data(filtered_data)

        finally:
            self._updating_filters = False
            current_data = self.date_combo.currentData()
            if current_data and self.staffing_details_win and not self.staffing_details_win.isHidden():
                year, month = current_data
                self.staffing_details_win.update_for_new_month_or_filters(year, month)

    def update_cross_filters(self):
        """
        Aktualizuje filtry wzajemnie, ale zamiast przebudowywaƒá listy,
        jedynie ukrywa/pokazuje istniejƒÖce elementy, aby zachowaƒá pozycjƒô przewijania.
        """
        if not getattr(self, '_cross_filtering_enabled', True):
            return

        if not hasattr(self, 'processed_data') or not self.processed_data:
            return

        if getattr(self, '_updating_cross_filters', False):
            return

        self._updating_cross_filters = True
        try:
            # Pobranie aktualnych wybor√≥w (logika bez zmian)
            selected_wydzialy = self.wydzial_combo.get_selected_items()
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

            # === AKTUALIZACJA LISTY PRZE≈ÅO≈ªONYCH ===
            if hasattr(self, 'przelozony_list'):
                # Oblicz, kt√≥rzy prze≈Ço≈ºeni powinni byƒá widoczni (logika bez zmian)
                available_przelozeni = set()
                if selected_wydzialy:
                    for key in self.processed_data.keys():
                        if key[0] in selected_wydzialy and key[1]:
                            available_przelozeni.add(key[1])
                else:
                    for key in self.processed_data.keys():
                        if key[1]: available_przelozeni.add(key[1])

                # NOWA LOGIKA: Poka≈º/ukryj elementy zamiast przebudowywaƒá listƒô
                for i in range(self.przelozony_list.count()):
                    item = self.przelozony_list.item(i)
                    item.setHidden(item.text() not in available_przelozeni)

            # === AKTUALIZACJA LISTY U≈ªYTKOWNIK√ìW ===
            if hasattr(self, 'uzytkownik_list'):
                # Oblicz, kt√≥rzy u≈ºytkownicy powinni byƒá widoczni (logika bez zmian)
                available_uzytkownicy = set()
                for key in self.processed_data.keys():
                    wydzial, przelozony, uzytkownik_dane, _ = key
                    if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                            (not selected_przelozeni or przelozony in selected_przelozeni):
                        if uzytkownik_dane: available_uzytkownicy.add(str(uzytkownik_dane))

                # NOWA LOGIKA: Poka≈º/ukryj elementy zamiast przebudowywaƒá listƒô
                for i in range(self.uzytkownik_list.count()):
                    item = self.uzytkownik_list.item(i)
                    item.setHidden(item.text() not in available_uzytkownicy)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas cross-filtrowania: {e}", exception=e)
        finally:
            self._updating_cross_filters = False

    def update_list_safely(self, list_widget, items, selected_items):
        """
        Bezpiecznie aktualizuje QListWidget, blokujƒÖc sygna≈Çy na czas modyfikacji.
        """
        if not list_widget:
            return

        list_widget.blockSignals(True)
        try:
            # Zapamiƒôtanie, co jest aktualnie widoczne z pola wyszukiwania
            search_text = ""
            if list_widget is self.przelozony_list:
                search_text = self.przelozony_filter.text().lower()
            elif list_widget is self.uzytkownik_list:
                search_text = self.uzytkownik_filter.text().lower()

            list_widget.clear()
            for item_text in sorted(items):
                item = QListWidgetItem(item_text)
                list_widget.addItem(item)
                if item_text in selected_items:
                    item.setSelected(True)

                # Przywr√≥cenie ukrycia na podstawie filtra wyszukiwania
                if search_text and search_text not in item_text.lower():
                    item.setHidden(True)

        finally:
            list_widget.blockSignals(False)

    def get_current_filters_state(self):
        """Zapisuje aktualnie wybrane warto≈õci ze wszystkich ISTNIEJƒÑCYCH filtr√≥w do s≈Çownika."""
        state = {
            'grupa': self.grupa_main_filter_combo.currentText(),
            'wydzial': self.wydzial_combo.get_selected_items(),
            'przelozony': self.get_list_selected_items(self.przelozony_list),
            'uzytkownik': self.get_list_selected_items(self.uzytkownik_list),
            'lokalizacja_domyslna': self.default_location_combo.get_selected_items(),
            'system_czasu_pracy': self.system_czasu_pracy_combo.get_selected_items(),
            'rola': self.rola_combo.get_selected_items(),
            'jezyk': self.jezyk_combo.get_selected_items(),
            'etat': self.etat_combo.get_selected_items(),
            'dtn': self.dtn_combo.get_selected_items(),
        }
        debug_print(f"Zapisano stan filtr√≥w: {state}")
        return state

    def restore_filters_state(self, state):
        """
        Przywraca zapisany stan filtr√≥w po za≈Çadowaniu nowych danych.
        """
        debug_print("Rozpoczynam przywracanie stanu filtr√≥w...")

        self._cross_filtering_enabled = False

        try:
            self.update_filters()

            self.grupa_main_filter_combo.blockSignals(True)
            self.grupa_main_filter_combo.setCurrentText(state.get('grupa', '(Wszyscy)'))
            self.grupa_main_filter_combo.blockSignals(False)

            self.wydzial_combo.select_items(state.get('wydzial', []))
            self.default_location_combo.select_items(state.get('lokalizacja_domyslna', []))
            self.system_czasu_pracy_combo.select_items(state.get('system_czasu_pracy', []))
            self.rola_combo.select_items(state.get('rola', []))
            self.jezyk_combo.select_items(state.get('jezyk', []))
            self.etat_combo.select_items(state.get('etat', []))
            self.dtn_combo.select_items(state.get('dtn', []))

            przelozeni_items = self._get_unique_values_for_filter('przelozony')
            uzytkownicy_items = self._get_unique_values_for_filter('uzytkownik_dane')
            self.update_list_safely(self.przelozony_list, przelozeni_items, state.get('przelozony', []))
            self.update_list_safely(self.uzytkownik_list, uzytkownicy_items, state.get('uzytkownik', []))

        finally:
            self._cross_filtering_enabled = True
            debug_print("Zako≈Ñczono przywracanie stanu filtr√≥w.")

        debug_print("Uruchamiam filtrowanie po przywr√≥ceniu stanu.")
        self.filter_data()

    def _get_unique_values_for_filter(self, filter_key):
        """
        Pobiera unikalne warto≈õci dla danego filtra z aktualnie za≈Çadowanych,
        pe≈Çnych danych w self.processed_data.
        """
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return set()

        unique_values = set()

        key_map = {
            'wydzial': 0,
            'przelozony': 1,
            'uzytkownik_dane': 2
        }

        if filter_key in key_map:
            key_index = key_map[filter_key]
            for key_tuple in self.processed_data.keys():
                if len(key_tuple) > key_index and key_tuple[key_index]:
                    unique_values.add(str(key_tuple[key_index]))
        else:
            for data_dict in self.processed_data.values():
                value = data_dict.get(filter_key)
                # --- POPRAWIONY WARUNEK ---
                # Sprawdzamy, czy warto≈õƒá nie jest None, co poprawnie uwzglƒôdni zero.
                if value is not None and value != '':
                    unique_values.add(str(value))

        return unique_values

    def clear_filters(self):
        """Czy≈õci wszystkie filtry i aktualizuje model."""
        self._cross_filtering_enabled = False
        try:
            combo_names_to_clear = [
                'grupa_main_filter_combo', 'wydzial_combo', 'dtn_combo',
                'rola_combo', 'jezyk_combo', 'etat_combo',
                'system_czasu_pracy_combo',
                'default_location_combo'
            ]
            for combo_name in combo_names_to_clear:
                if hasattr(self, combo_name):
                    getattr(self, combo_name).clear_selection()

            # reszta metody bez zmian...
            if hasattr(self, 'przelozony_list'): self.przelozony_list.clearSelection()
            if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.clearSelection()
            if hasattr(self, 'przelozony_filter'): self.przelozony_filter.clear()
            if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.clear()

            self._cross_filtering_enabled = True
            self.update_filters()
            self.filter_data()

        finally:
            self._cross_filtering_enabled = True

    def filter_przelozony_list(self, text):
        """
        Filtruje listƒô prze≈Ço≈ºonych na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'przelozony_list'):
            return

        text = text.lower()
        for i in range(self.przelozony_list.count()):
            item = self.przelozony_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_uzytkownik_list(self, text):
        """
        Filtruje listƒô u≈ºytkownik√≥w na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'uzytkownik_list'):
            return

        text = text.lower()
        for i in range(self.uzytkownik_list.count()):
            item = self.uzytkownik_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def update_filtered_table(self):
        """
        Aktualizuje widok tabeli na podstawie zaznaczonych filtr√≥w
        """
        # Bezpo≈õrednio aktualizuj ca≈ÇƒÖ tabelƒô z przefiltrowanymi danymi
        self.update_table_content()

    def get_list_selected_items(self, list_widget):
        """
        Zwraca teksty zaznaczonych element√≥w z listy.
        POPRAWKA: Zmieniono nazwƒô metody z get_selected_items na get_list_selected_items,
        aby uniknƒÖƒá konfliktu z metodƒÖ get_selected_items w CustomMultiComboBox.

        Args:
            list_widget: QListWidget do pobrania zaznaczonych element√≥w

        Returns:
            list: Lista zaznaczonych tekst√≥w
        """
        if not list_widget:
            return []

        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item and item.isSelected():
                selected.append(item.text())
        return selected

    def update_filters(self):
        """
        Wype≈Çnia wszystkie filtry na podstawie za≈Çadowanych danych.
        WERSJA POPRAWIONA: Zawiera kompletnƒÖ logikƒô dla wszystkich filtr√≥w.
        """
        try:
            if not hasattr(self, 'processed_data') or not self.processed_data:
                debug_print("Brak danych do wype≈Çnienia filtr√≥w, pomijam.")
                return

            debug_print("Rozpoczynam pe≈ÇnƒÖ aktualizacjƒô filtr√≥w...")

            # Zapamiƒôtanie bie≈ºƒÖcych wybor√≥w, aby je przywr√≥ciƒá po od≈õwie≈ºeniu list
            selected_grupy = self.grupa_main_filter_combo.get_selected_items()
            selected_wydzialy = self.wydzial_combo.get_selected_items()
            selected_dtn = self.dtn_combo.get_selected_items()
            selected_role = self.rola_combo.get_selected_items()
            selected_jezyki = self.jezyk_combo.get_selected_items()
            selected_etaty = self.etat_combo.get_selected_items()
            selected_scp = self.system_czasu_pracy_combo.get_selected_items()
            selected_locations = self.default_location_combo.get_selected_items()

            # Filtr "Grupa"
            group_mapping = self.data_provider.get_department_to_group_mapping()
            self.grupa_main_filter_combo.add_items(sorted(group_mapping.keys()))
            self.grupa_main_filter_combo.select_items(selected_grupy)

            # Filtr "Wydzia≈Ç"
            wydzialy = sorted(set(key[0] for key in self.processed_data.keys() if key[0]))
            self.wydzial_combo.add_items(wydzialy)
            self.wydzial_combo.select_items(selected_wydzialy)

            # Filtr "Lokalizacja Domy≈õlna"
            locations = sorted(set(data.get('lokalizacja_domyslna', '') for data in self.processed_data.values() if
                                   data.get('lokalizacja_domyslna')))
            self.default_location_combo.add_items(locations)
            self.default_location_combo.select_items(selected_locations)

            # Filtr "System Pracy"
            scp_values = sorted(set(data.get('system_czasu_pracy', '') for data in self.processed_data.values() if
                                    data.get('system_czasu_pracy', '')))
            self.system_czasu_pracy_combo.add_items(scp_values)
            self.system_czasu_pracy_combo.select_items(selected_scp)

            # Filtr "Rola"
            role_values = sorted(
                set(data.get('rola_nazwa', '') for data in self.processed_data.values() if data.get('rola_nazwa', '')))
            self.rola_combo.add_items(role_values)
            self.rola_combo.select_items(selected_role)

            # Filtr "Jƒôzyk"
            jezyki_values = sorted(
                set(data.get('jezyk', '') for data in self.processed_data.values() if data.get('jezyk', '')))
            self.jezyk_combo.add_items(jezyki_values)
            self.jezyk_combo.select_items(selected_jezyki)

            # Filtr "Etat"
            etaty_values = set(str(data.get('etat', '')) for data in self.processed_data.values() if
                               data.get('etat') is not None and str(data.get('etat', '')))
            sorted_etaty = sorted(etaty_values, key=lambda x: float(x) if x.replace('.', '', 1).isdigit() else 0)
            self.etat_combo.add_items(sorted_etaty)
            self.etat_combo.select_items(selected_etaty)

            # Filtr "DTN"
            dtn_values = sorted(set(str(data['dtn']) for data in self.processed_data.values() if data.get('dtn') is not None), key=int)
            self.dtn_combo.add_items(dtn_values)
            self.dtn_combo.select_items(selected_dtn)

            # Aktualizacja list dynamicznych (Prze≈Ço≈ºony, U≈ºytkownik)
            self.update_przelozony_filter()
            self.update_uzytkownik_filter()

            debug_print("Zako≈Ñczono pe≈ÇnƒÖ aktualizacjƒô wszystkich filtr√≥w.")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji filtr√≥w: {e}", exception=e)

    def update_przelozony_filter(self, selected_przelozeni=None):
        """
        Aktualizuje listƒô prze≈Ço≈ºonych na podstawie wybranych wydzia≈Ç√≥w.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_przelozeni: Lista zaznaczonych prze≈Ço≈ºonych (opcjonalnie)
        """
        if not hasattr(self, 'przelozony_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiƒôtaj bie≈ºƒÖcƒÖ selekcjƒô je≈õli nie podano
        if selected_przelozeni is None:
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)

        self.przelozony_list.clear()

        # Pobierz wybrane wydzia≈Çy
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []

        # Zbi√≥r unikalnych prze≈Ço≈ºonych
        przelozeni = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, _, _ = key

            # Je≈õli nie wybrano wydzia≈Ç√≥w lub wydzia≈Ç pasuje do filtra
            if not selected_wydzialy or wydzial in selected_wydzialy:
                # Dodaj prze≈Ço≈ºonego do zbioru (tylko niepuste warto≈õci)
                if przelozony:
                    przelozeni.add(przelozony)

        # Dodaj posortowanych prze≈Ço≈ºonych do listy
        for przelozony in sorted(przelozeni):
            item = QListWidgetItem(przelozony)
            self.przelozony_list.addItem(item)

            # Przywr√≥ƒá zaznaczenie je≈õli by≈Ço
            if przelozony in selected_przelozeni:
                item.setSelected(True)

    def update_uzytkownik_filter(self, selected_uzytkownicy=None):
        """
        Aktualizuje listƒô u≈ºytkownik√≥w na podstawie wybranych wydzia≈Ç√≥w i prze≈Ço≈ºonych.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_uzytkownicy: Lista zaznaczonych u≈ºytkownik√≥w (opcjonalnie)
        """
        if not hasattr(self, 'uzytkownik_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiƒôtaj bie≈ºƒÖcƒÖ selekcjƒô je≈õli nie podano
        if selected_uzytkownicy is None:
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

        self.uzytkownik_list.clear()

        # Pobierz wybrane wydzia≈Çy i prze≈Ço≈ºonych
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self,
                                                                                            'przelozony_list') else []

        # Zbi√≥r unikalnych u≈ºytkownik√≥w (u≈ºyj stringa jako tekstowej reprezentacji)
        uzytkownicy = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, uzytkownik_dane, _ = key

            # Sprawd≈∫ czy dane pasujƒÖ do filtr√≥w
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni):
                # Dodaj u≈ºytkownika do zbioru (tylko niepuste warto≈õci)
                if uzytkownik_dane:
                    # Konwertuj do stringa dla sp√≥jno≈õci
                    uzytkownicy.add(str(uzytkownik_dane))

        # Dodaj posortowanych u≈ºytkownik√≥w do listy
        for uzytkownik in sorted(uzytkownicy):
            item = QListWidgetItem(uzytkownik)
            self.uzytkownik_list.addItem(item)

            # Przywr√≥ƒá zaznaczenie je≈õli by≈Ço
            if uzytkownik in selected_uzytkownicy:
                item.setSelected(True)

    def update_table_content(self):
        """
        Aktualizuje zawarto≈õƒá tabeli grafiku u≈ºywajƒÖc modelu danych.
        Zoptymalizowana wersja wykorzystujƒÖca precyzyjne aktualizacje.
        """
        # Sprawd≈∫ czy modele zosta≈Çy zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # Pobierz aktualny rok i miesiƒÖc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # Ustaw rok i miesiƒÖc w modelu (je≈õli jeszcze nie sƒÖ ustawione)
        if self.schedule_model._year != year or self.schedule_model._month != month:
            # Pobierz dane dla wybranego roku i miesiƒÖca
            schedule_data = self.data_provider.get_schedule_data(year, month, self.import_grupa, self.import_funkcja)

            # Aktualizuj model - to wywo≈Ça zoptymalizowanƒÖ metodƒô update_data
            self.schedule_model.update_data(schedule_data, year, month)
            self._apply_dynamic_sizes()
        else:
            # Je≈õli rok i miesiƒÖc nie uleg≈Çy zmianie, tylko zastosuj filtry
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

    def get_cell_color_by_time(self, hour):
        """
        Zwraca kolor t≈Ça kom√≥rki na podstawie godziny rozpoczƒôcia.
        Godziny sƒÖ mapowane na kolory w bardziej czytelnej palecie.

        Args:
            hour (int): Godzina rozpoczƒôcia zmiany (0-23)

        Returns:
            QColor: Kolor t≈Ça kom√≥rki
        """
        # Domy≈õlny kolor (przezroczysty) gdy godzina nie jest zdefiniowana
        if hour is None or hour < 0 or hour > 23:
            return QColor(255, 255, 255, 0)  # Przezroczysty

        # Mapowanie godzin na kolory - zharmonizowana paleta
        if hour == 5:
            return QColor(204, 255, 255)  # Jasny b≈Çƒôkit (bardzo jasny cyjan)
        elif hour == 6:
            return QColor(204, 255, 255)  # Jasny b≈Çƒôkit (bardzo jasny cyjan)
        elif hour == 7:
            return QColor(0, 255, 255)  # Cyjan (akwamaryna)
        elif hour == 8:
            return QColor(0, 204, 255)  # Jasny b≈Çƒôkit (niebieskozielony)
        elif hour == 9:
            return QColor(0, 255, 0)  # Limonkowy (czysty zielony)
        elif hour == 10:
            return QColor(153, 204, 0)  # Oliwkowy (≈º√≥≈Çtozielony)
        elif hour == 11:
            return QColor(204, 255, 204)  # Bardzo jasny zielony (miƒôtowy)
        elif hour == 12:
            return QColor(255, 255, 153)  # Bardzo jasny ≈º√≥≈Çty (kremowy)
        elif hour == 13:
            return QColor(255, 204, 153)  # Jasny ≈Çososiowy (brzoskwiniowy)
        elif hour == 14:
            return QColor(255, 153, 0)  # Ciemny pomara≈Ñczowy
        elif hour == 15:
            return QColor(255, 0, 255)  # Magenta (fuksja)
        elif hour == 16:
            return QColor(204, 0, 0)  # Ciemnoczerwony
        elif hour == 17:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 18:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 19:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 20:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 21:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 22:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 23:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 0:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour in [1, 2, 3, 4]:
            return QColor(51, 51, 51)  # Ciemny szary

        # Domy≈õlny kolor dla innych warto≈õci
        return QColor(255, 255, 255, 0)  # Przezroczysty

    def on_selection_changed(self):
        """
        POPRAWIONA WERSJA: Debounced selection handling
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # DODANE: Sprawd≈∫ czy nie jeste≈õmy w trakcie aktualizacji
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        # NOWE: Zastop poprzedni timer i uruchom nowy (debouncing)
        if hasattr(self, '_selection_timer'):
            self._selection_timer.stop()
            self._selection_timer.start(self._selection_debounce_delay)

    def _handle_selection_change(self):
        """
        NOWA METODA: Faktyczna obs≈Çuga zmiany zaznaczenia (wywo≈Çywana po debounce)
        """
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        self._updating_selection = True

        try:
            debug_print("Zmiana zaznaczenia - aktualizujƒô tabelƒô zdarze≈Ñ...")

            # Pobierz dane dla zaznaczonych kom√≥rek
            selected_cells_data = self.table.get_data_for_selected_cells()
            debug_print(f"Zaznaczono {len(selected_cells_data)} kom√≥rek")

            if selected_cells_data and len(selected_cells_data) > 0:
                # MAMY ZAZNACZONE KOM√ìRKI - poka≈º zdarzenia
                events = []

                for cell_data in selected_cells_data:
                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')

                    if user_id and date_str:
                        # --- ZMIANA: Usuwamy przekazywanie self.import_grupa i self.import_funkcja ---
                        user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                        for event in user_events:
                            local_event = self._convert_dp_event_to_local(event)
                            events.append(local_event)

                debug_print(f"Pobrano {len(events)} aktywnych zdarze≈Ñ dla zaznaczonych kom√≥rek")

                # Zaktualizuj events_data
                self.events_data = events

                # Aktualizuj model zdarze≈Ñ
                if hasattr(self, 'events_model'):
                    self.events_model.update_data(self.events_data)

                    # WA≈ªNE: Zastosuj filtry po aktualizacji danych
                    self.filter_events_table()
            else:
                # BRAK ZAZNACZENIA - wyczy≈õƒá tabelƒô zdarze≈Ñ
                debug_print("Brak zaznaczenia - czyszczƒô tabelƒô zdarze≈Ñ")
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])

            # DODANE: Wymu≈õ od≈õwie≈ºenie widoku tabeli zdarze≈Ñ
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        finally:
            self._updating_selection = False

    def clear_events_on_startup(self):
        """
        NOWA METODA: Czy≈õci tabelƒô zdarze≈Ñ przy starcie aplikacji
        """
        debug_print("Czyszczƒô tabelƒô zdarze≈Ñ przy starcie aplikacji")

        # Wyczy≈õƒá dane zdarze≈Ñ
        self.events_data = []

        # Wyczy≈õƒá model zdarze≈Ñ je≈õli istnieje
        if hasattr(self, 'events_model') and self.events_model:
            self.events_model.update_data([])

        # Od≈õwie≈º widok tabeli zdarze≈Ñ
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

    def _convert_dp_event_to_local(self, dp_event):
        """
        NOWA METODA: Konwertuje format zdarzenia z DataProvider na lokalny format UI
        """
        try:
            # Skonwertuj datƒô z YYYY-MM-DD na DD.MM.YYYY
            date_key = dp_event.get('date_key', dp_event.get('date', ''))
            if date_key and '-' in date_key:
                year, month, day = date_key.split('-')
                display_date = f"{day}.{month}.{year}"
            else:
                display_date = dp_event.get('date_display', date_key)

            # Skonwertuj czas z formatu bazy na HH:MM
            time_from = dp_event.get('time_from', '')
            time_to = dp_event.get('time_to', '')

            if time_from and 'T' in time_from:
                time_from = time_from.split('T')[1].split(':')[0] + ':' + time_from.split('T')[1].split(':')[1]
            elif time_from and ' ' in time_from:
                time_from = time_from.split(' ')[1][:5]

            if time_to and 'T' in time_to:
                time_to = time_to.split('T')[1].split(':')[0] + ':' + time_to.split('T')[1].split(':')[1]
            elif time_to and ' ' in time_to:
                time_to = time_to.split(' ')[1][:5]

            # Pobierz nazwƒô u≈ºytkownika
            user_name = dp_event.get('user_name', '')
            if not user_name:
                user_id = dp_event.get('user_id')
                if user_id and hasattr(self, 'user_info_map') and user_id in self.user_info_map:
                    user_name = self.user_info_map[user_id].get('uzytkownik_dane', f"ID: {user_id}")
                else:
                    user_name = f"ID: {user_id}"

            # Utw√≥rz zdarzenie w lokalnym formacie
            local_event = {
                'type': dp_event.get('event_type', dp_event.get('type', '')),
                'topic': dp_event.get('topic', ''),
                'name': dp_event.get('name', ''),
                'user_id': dp_event.get('user_id'),
                'user_name': user_name,
                'date': display_date,
                'date_key': date_key,
                'time_from': time_from,
                'time_to': time_to,
                'status': dp_event.get('status', ''),
                'id': dp_event.get('event_id', dp_event.get('id'))
            }

            return local_event

        except Exception as e:
            log_error(f"B≈ÇƒÖd konwersji zdarzenia: {e}")
            # Zwr√≥ƒá zdarzenie w oryginalnym formacie w przypadku b≈Çƒôdu
            return dp_event

    def temporarily_disable_filters(self):
        """Tymczasowo wy≈ÇƒÖcza filtry zdarze≈Ñ aby zapewniƒá wy≈õwietlenie wszystkich danych"""
        # Zapamiƒôtaj obecny stan filtr√≥w
        self._saved_filters = {
            'meetings': self.meetings_checkbox.isChecked() if hasattr(self, 'meetings_checkbox') else True,
            'trainings': self.trainings_checkbox.isChecked() if hasattr(self, 'trainings_checkbox') else True,
            'overtime': self.overtime_checkbox.isChecked() if hasattr(self, 'overtime_checkbox') else True,
            'topic': self.topic_filter.text() if hasattr(self, 'topic_filter') else "",
            'name': self.name_filter.text() if hasattr(self, 'name_filter') else "",
            'date_from': self.date_from.date() if hasattr(self, 'date_from') else None,
            'date_to': self.date_to.date() if hasattr(self, 'date_to') else None
        }

        # Ustaw wszystkie filtry na warto≈õci, kt√≥re pokazujƒÖ wszystkie dane
        if hasattr(self, 'meetings_checkbox'):
            self.meetings_checkbox.setChecked(True)
        if hasattr(self, 'trainings_checkbox'):
            self.trainings_checkbox.setChecked(True)
        if hasattr(self, 'overtime_checkbox'):
            self.overtime_checkbox.setChecked(True)
        if hasattr(self, 'topic_filter'):
            self.topic_filter.setText("")
        if hasattr(self, 'name_filter'):
            self.name_filter.setText("")

        # Daty zostawiamy bez zmian, filtrowanie bƒôdzie nadpisane przez model

        debug_print("Tymczasowo wy≈ÇƒÖczono filtry zdarze≈Ñ")

    def restore_filters(self):
        """Przywraca filtry zdarze≈Ñ do ich poprzedniego stanu"""
        if not hasattr(self, '_saved_filters'):
            return

        # Przywr√≥ƒá filtry do ich poprzedniego stanu
        if hasattr(self, 'meetings_checkbox') and 'meetings' in self._saved_filters:
            self.meetings_checkbox.setChecked(self._saved_filters['meetings'])
        if hasattr(self, 'trainings_checkbox') and 'trainings' in self._saved_filters:
            self.trainings_checkbox.setChecked(self._saved_filters['trainings'])
        if hasattr(self, 'overtime_checkbox') and 'overtime' in self._saved_filters:
            self.overtime_checkbox.setChecked(self._saved_filters['overtime'])
        if hasattr(self, 'topic_filter') and 'topic' in self._saved_filters:
            self.topic_filter.setText(self._saved_filters['topic'])
        if hasattr(self, 'name_filter') and 'name' in self._saved_filters:
            self.name_filter.setText(self._saved_filters['name'])

        # Nie przywracamy dat, aby zapewniƒá sp√≥jno≈õƒá z zaznaczonymi kom√≥rkami

        debug_print("Przywr√≥cono filtry zdarze≈Ñ")

        # Wymu≈õ od≈õwie≈ºenie z nowymi filtrami
        self.filter_events_table()

    def filter_events_table(self):
        """
        Filtruje tabelƒô zdarze≈Ñ na podstawie zaznaczonych filtr√≥w i zakres√≥w dat.
        Zoptymalizowana wersja wykorzystujƒÖca model danych.
        """
        try:
            # Sprawd≈∫ czy model istnieje
            if not hasattr(self, 'events_model') or not self.events_model:
                return

            # KLUCZOWA ZMIANA: Najpierw sprawd≈∫, czy w og√≥le mamy dane do filtrowania
            if not hasattr(self, 'events_data') or not self.events_data:
                # Je≈õli nie ma danych, po prostu wyczy≈õƒá model
                self.events_model.update_data([])
                return

            # NAJWA≈ªNIEJSZE: U≈ºyj lokalnych danych events_data zamiast wszystkich zdarze≈Ñ
            # To zapewni, ≈ºe filtrujemy tylko zdarzenia dla zaznaczonych kom√≥rek
            base_data = self.events_data.copy()
            filtered_data = base_data.copy()

            # Przygotuj parametry filtrowania
            allowed_types = []
            if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
                allowed_types.append('Spotkanie')
            if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
                allowed_types.append('Szkolenie')
            if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
                allowed_types.append('Nadgodziny')

            # Filtruj po typach zdarze≈Ñ
            if allowed_types:
                filtered_data = [e for e in filtered_data if e.get('type') in allowed_types]

            # Filtruj po temacie
            topic_filter = self.topic_filter.text().lower() if hasattr(self, 'topic_filter') else ""
            if topic_filter:
                filtered_data = [e for e in filtered_data if topic_filter in str(e.get('topic', '')).lower()]

            # Filtruj po nazwie
            name_filter = self.name_filter.text().lower() if hasattr(self, 'name_filter') else ""
            if name_filter:
                filtered_data = [e for e in filtered_data if name_filter in str(e.get('name', '')).lower()]

            # Filtruj po datach (tylko je≈õli nie sƒÖ ustawione na zakres wybranego miesiƒÖca)
            date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
            date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

            if date_from_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') >= date_from_str]
            if date_to_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') <= date_to_str]

            # Aktualizuj model po filtrowaniu
            debug_print(f"Filtrowanie lokalne: z {len(base_data)} zdarze≈Ñ po filtrach zosta≈Ço {len(filtered_data)}")
            self.events_model.filtered_update(filtered_data)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas filtrowania zdarze≈Ñ: {str(e)}")
            import traceback
            traceback.print_exc()

    def diagnose_events_table(self):
        """Metoda diagnostyczna do sprawdzenia stanu tabeli zdarze≈Ñ"""
        debug_print("\n=== DIAGNOSTYKA TABELI ZDARZE≈É ===")

        if not hasattr(self, 'events_table') or not self.events_table:
            log_error("ERROR: Brak obiektu events_table!")
            return

        if not hasattr(self, 'events_model') or not self.events_model:
            log_error("ERROR: Brak obiektu events_model!")
            return

        # Sprawd≈∫ model
        debug_print(
            f"events_model ma {self.events_model.rowCount()} wierszy i {self.events_model.columnCount()} kolumn")
        debug_print(f"Dane w events_model: {len(self.events_model._data)} zdarze≈Ñ")
        debug_print(f"Przefiltrowane dane w events_model: {len(self.events_model._filtered_data)} zdarze≈Ñ")

        # Sprawd≈∫ filtry
        debug_print("\nAktualne filtry:")
        if hasattr(self, 'meetings_checkbox'):
            debug_print(f"Spotkania: {self.meetings_checkbox.isChecked()}")
        if hasattr(self, 'trainings_checkbox'):
            debug_print(f"Szkolenia: {self.trainings_checkbox.isChecked()}")
        if hasattr(self, 'overtime_checkbox'):
            debug_print(f"Nadgodziny: {self.overtime_checkbox.isChecked()}")
        if hasattr(self, 'topic_filter'):
            debug_print(f"Filtr tematu: '{self.topic_filter.text()}'")
        if hasattr(self, 'name_filter'):
            debug_print(f"Filtr nazwy: '{self.name_filter.text()}'")

        # Sprawd≈∫ przyk≈Çadowe dane
        if self.events_model._data:
            debug_print("\nPrzyk≈Çadowe zdarzenie z danych (przed filtrowaniem):")
            debug_print(self.events_model._data[0])

        if self.events_model._filtered_data:
            debug_print("\nPrzyk≈Çadowe zdarzenie z danych po filtrowaniu:")
            debug_print(self.events_model._filtered_data[0])

        # Sprawd≈∫ widok
        debug_print(f"\nWidok events_table: {self.events_table.model().rowCount()} wierszy")

        debug_print("=== KONIEC DIAGNOSTYKI TABELI ZDARZE≈É ===\n")

    def standardize_date(self, date_obj):
        """
        Standaryzuje format daty do 'YYYY-MM-DD' dla por√≥wna≈Ñ
        """
        if not date_obj:
            return ''

        # Je≈õli to ju≈º string, wyciƒÖgnij tylko datƒô
        if isinstance(date_obj, str):
            # Obs≈Çuga r√≥≈ºnych format√≥w
            if 'T' in date_obj:  # Format ISO 'YYYY-MM-DDThh:mm:ss'
                return date_obj.split('T')[0]
            elif ' ' in date_obj:  # Format 'YYYY-MM-DD hh:mm:ss'
                return date_obj.split(' ')[0]
            elif len(date_obj) == 10 and date_obj.count('-') == 2:  # Format 'YYYY-MM-DD'
                return date_obj
            # Je≈õli nie dopasowano do ≈ºadnego formatu, zwr√≥ƒá oryginalny string
            return date_obj

        # Je≈õli to obiekt datetime, skonwertuj na string
        if hasattr(date_obj, 'strftime'):
            return date_obj.strftime('%Y-%m-%d')

        # W przypadku nieznanego typu, zwr√≥ƒá pusty string
        return ''

    def diagnose_table_view(self):
        """Metoda diagnostyczna do sprawdzenia stanu SplitTableView"""
        if not hasattr(self, 'table') or not self.table:
            log_error("ERROR: Brak obiektu table!")
            return

        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            log_error("ERROR: Brak obiektu schedule_model!")
            return

        debug_print("\n=== DIAGNOSTYKA TABELI ===")

        # Sprawd≈∫ model
        debug_print(f"Model ma {self.schedule_model.rowCount()} wierszy i {self.schedule_model.columnCount()} kolumn")
        debug_print(f"Widoczne kolumny: {self.schedule_model.get_visible_columns()}")

        # Sprawd≈∫ widoki
        debug_print(
            f"Employees view ma {self.table.employees_view.model().rowCount()} wierszy i {self.table.employees_view.model().columnCount()} kolumn")
        debug_print(
            f"Schedule view ma {self.table.schedule_view.model().rowCount()} wierszy i {self.table.schedule_view.model().columnCount()} kolumn")

        # Sprawd≈∫ kolumny w employees_view
        for col in range(self.table.employees_view.model().columnCount()):
            hidden = self.table.employees_view.isColumnHidden(col)
            width = self.table.employees_view.columnWidth(col)
            debug_print(f"Kolumna {col} w employees_view: ukryta={hidden}, szeroko≈õƒá={width}px")

        # Sprawd≈∫ przyk≈Çadowe dane w pierwszym wierszu
        if self.schedule_model.rowCount() > 0:
            debug_print("\nPrzyk≈Çadowe dane z pierwszego wiersza:")
            for col in range(len(self.schedule_model.get_visible_columns())):
                index = self.schedule_model.index(0, col)
                text = self.schedule_model.data(index, Qt.DisplayRole)
                debug_print(f"Kolumna {col}: '{text}'")

        debug_print("=== KONIEC DIAGNOSTYKI ===\n")

    def diagnose_application_state(self):
        """Wykonuje pe≈ÇnƒÖ diagnostykƒô stanu aplikacji i wy≈õwietla szczeg√≥≈Çowe informacje"""
        try:
            debug_print("\n===== DIAGNOSTYKA STANU APLIKACJI =====")

            # 1. Sprawd≈∫ tabele i dane
            debug_print("\n--- TABELA GRAFIKU ---")
            debug_print(f"Liczba wierszy: {self.table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.table.columnCount()}")

            # Sprawd≈∫ pierwsze 3 wiersze i kolumny dla przyk≈Çadu
            debug_print("\nPrzyk≈Çadowe kom√≥rki z tabeli grafiku:")
            for row in range(min(3, self.table.rowCount())):
                for col in range(min(6, self.table.columnCount())):
                    item = self.table.item(row, col)
                    if item:
                        debug_print(f"[{row},{col}] Tekst: {item.text()}")
                        user_role_data = item.data(Qt.UserRole)
                        user_role_2 = item.data(Qt.UserRole + 2)
                        user_role_3 = item.data(Qt.UserRole + 3)
                        debug_print(
                            f"  UserRole: {type(user_role_data)}, UserRole+2: {user_role_2}, UserRole+3: {user_role_3}")
                        if isinstance(user_role_data, dict):
                            debug_print(f"  Zawarto≈õƒá: {user_role_data}")
                    else:
                        debug_print(f"[{row},{col}] Brak elementu")

            debug_print("\n--- TABELA ZDARZE≈É ---")
            debug_print(f"Liczba wierszy: {self.events_table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.events_table.columnCount()}")

            # Sprawd≈∫ zawarto≈õƒá events_data
            debug_print(
                f"\nLiczba zdarze≈Ñ w events_data: {len(self.events_data) if hasattr(self, 'events_data') else 'Brak'}")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print("Pierwsze zdarzenie:")
                for key, value in self.events_data[0].items():
                    debug_print(f"  {key}: {value}")

            # Sprawd≈∫ pierwsze 3 wiersze tabeli zdarze≈Ñ
            debug_print("\nPrzyk≈Çadowe wiersze z tabeli zdarze≈Ñ:")
            for row in range(min(3, self.events_table.rowCount())):
                row_data = []
                for col in range(self.events_table.columnCount() - 1):  # Pomijamy ostatniƒÖ kolumnƒô z przyciskami
                    item = self.events_table.item(row, col)
                    if item:
                        row_data.append(f"{col}:{item.text()}")
                debug_print(f"Wiersz {row}: {', '.join(row_data)}")

            # 2. Sprawd≈∫ delegaty i style
            debug_print("\n--- DELEGATY I STYLE ---")
            item_delegate = self.table.itemDelegate()
            debug_print(f"Delegat tabeli grafiku: {item_delegate.__class__.__name__}")
            if isinstance(item_delegate, OvertimeItemDelegate):
                debug_print("  Delegat OvertimeItemDelegate poprawnie przypisany")
            else:
                debug_print("  UWAGA: Delegat OvertimeItemDelegate nie jest przypisany!")

            # 3. Sprawd≈∫ filtrowanie danych
            debug_print("\n--- FILTROWANIE DANYCH ---")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print(f"Liczba zdarze≈Ñ przed filtrowaniem: {len(self.events_data)}")
                # Sprawd≈∫, czy metoda filter_events_table jest wywo≈Çywana
                debug_print("Spr√≥buj wykonaƒá filter_events_table:")
                try:
                    self.filter_events_table()
                    debug_print("  Metoda filter_events_table wykonana bez b≈Çƒôd√≥w")
                except Exception as e:
                    debug_print(f"  B≈ÅƒÑD podczas wykonywania filter_events_table: {e}")

            debug_print("\n===== KONIEC DIAGNOSTYKI =====\n")

        except Exception as e:
            debug_print(f"B≈ÅƒÑD podczas diagnostyki: {e}")
            import traceback
            traceback.print_exc()

    def show_schedule_control_dialog(self):
        """Pokazuje odpowiednie okno dialogowe w zale≈ºno≈õci od roli u≈ºytkownika."""
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Proszƒô najpierw wybraƒá miesiƒÖc.")
            return

        year, month = current_data

        # Importuj klasy dialogowe
        from schedule_control_dialog import ScheduleControlDialog, SuggestionsOutDialog

        # Sprawd≈∫ rolƒô i otw√≥rz odpowiednie okno
        if self.current_user_role == "Pracownik WPR":
            dialog = ScheduleControlDialog(self, year, month)
            dialog.data_refresh_needed.connect(self.refresh_data)
            dialog.exec()
        elif self.current_user_role == "Lider OUT":
            dialog = SuggestionsOutDialog(self, year, month)
            dialog.data_refresh_needed.connect(self.refresh_data)
            dialog.exec()
        else:
            QMessageBox.information(self, "Brak uprawnie≈Ñ", "Twoja rola nie ma dostƒôpu do tej funkcji.")

    def _get_current_event_filter_params(self):
        """
        Pobiera bie≈ºƒÖce parametry filtrowania zdarze≈Ñ.

        Returns:
            dict: Parametry filtrowania
        """
        filter_params = {}

        # Dodaj filtr typ√≥w zdarze≈Ñ
        allowed_types = []
        if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
            allowed_types.append('Spotkanie')
        if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
            allowed_types.append('Szkolenie')
        if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
            allowed_types.append('Nadgodziny')

        if allowed_types:
            filter_params['allowed_types'] = allowed_types

        # Dodaj filtry tematu i nazwy
        topic_filter = self.topic_filter.text().lower() if hasattr(self,
                                                                   'topic_filter') and self.topic_filter.text() else None
        name_filter = self.name_filter.text().lower() if hasattr(self,
                                                                 'name_filter') and self.name_filter.text() else None

        if topic_filter:
            filter_params['topic'] = topic_filter
        if name_filter:
            filter_params['name'] = name_filter

        # Dodaj filtry zakresu dat
        date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
        date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

        if date_from_str:
            filter_params['date_from'] = date_from_str
        if date_to_str:
            filter_params['date_to'] = date_to_str

        return filter_params

    def find_cell_position(self, user_id, date_str):
        """
        Znajduje pozycjƒô kom√≥rki dla podanego u≈ºytkownika i daty, korzystajƒÖc z modelu.

        Args:
            user_id: ID u≈ºytkownika
            date_str: Data w formacie YYYY-MM-DD

        Returns:
            tuple: (wiersz, dzie≈Ñ) lub (-1, -1) je≈õli nie znaleziono
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return -1, -1

        # Pobierz dzie≈Ñ z daty
        try:
            year, month, day_str = date_str.split('-')
            day = int(day_str)
        except:
            return -1, -1

        # Pobierz liczbƒô wierszy w modelu
        row_count = self.schedule_model.rowCount()

        # Dla ka≈ºdego wiersza sprawd≈∫, czy odpowiada szukanemu u≈ºytkownikowi
        for row in range(row_count):
            # Pobierz ID u≈ºytkownika z pierwszej kolumny
            index = self.schedule_model.index(row, 0)
            user_data = self.schedule_model.data(index, Qt.UserRole)

            if isinstance(user_data, dict) and str(user_data.get('uzytkownik_id', '')) == str(user_id):
                return row, day

        return -1, -1

    def _get_cell_data_for_user_date_pairs(self, user_date_pairs: list) -> list:
        """
        Na podstawie listy par (user_id, date_str) odnajduje i zwraca
        pe≈Çne dane kom√≥rek z modelu grafiku.
        """
        if not self.schedule_model or not user_date_pairs:
            return []

        cells_data_to_return = []
        user_row_map = {str(key[3]): idx for idx, key in enumerate(self.schedule_model._keys)}

        for user_id, date_str in user_date_pairs:
            row = user_row_map.get(str(user_id))
            if row is not None:
                try:
                    day = int(date_str.split('-')[2])
                    col_offset = len(self.schedule_model.get_visible_columns())
                    col = col_offset + day - 1

                    index = self.schedule_model.index(row, col)

                    # --- ZMIANA: Poprawne odwo≈Çanie do ROLE_DATA ---
                    cell_data = self.schedule_model.data(index, ROLE_DATA)

                    if isinstance(cell_data, dict):
                        cells_data_to_return.append(cell_data)
                except (ValueError, IndexError) as e:
                    log_warning(f"Nie uda≈Ço siƒô znale≈∫ƒá danych dla kom√≥rki ({user_id}, {date_str}): {e}")

        return cells_data_to_return

    def cancel_delegations(self):
        """
        POPRAWIONA WERSJA: Odwo≈Çuje delegacje z pe≈Çnym od≈õwie≈ºaniem ikon i tabeli zdarze≈Ñ
        """
        debug_print("\n=== ROZPOCZYNAM OPERACJƒò ODWO≈ÅYWANIA DELEGACJI ===")

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Brak danych",
                "Nie wybrano miesiƒÖca lub brak dostƒôpnych danych do wy≈õwietlenia.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone kom√≥rki
        selected_cells_data = self.get_selected_cells_data()

        if not self._can_modify_cells(selected_cells_data):
            return  # Zatrzymaj operacjƒô, je≈õli u≈ºytkownik nie ma uprawnie≈Ñ

        if not selected_cells_data:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono ≈ºadnych kom√≥rek. Zaznacz kom√≥rki, dla kt√≥rych chcesz odwo≈Çaƒá delegacje.",
                QMessageBox.Ok
            )
            return

        # Zbierz pary (user_id, date_str) z zaznaczonych kom√≥rek
        user_date_pairs = []
        for cell_data in selected_cells_data:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if user_id and date_str:
                user_date_pairs.append((user_id, date_str))

        if not user_date_pairs:
            QMessageBox.information(
                self,
                "Brak danych",
                "Nie znaleziono danych dla zaznaczonych kom√≥rek.",
                QMessageBox.Ok
            )
            return

        debug_print(f"Sprawdzam delegacje dla {len(user_date_pairs)} par (u≈ºytkownik, data)")

        # Znajd≈∫ delegacje do odwo≈Çania
        events_to_cancel = []
        grouped_events = {}

        for user_id, date_str in user_date_pairs:
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

            for event in user_events:
                event_type = event.get('type', '')
                event_id = event.get('id')
                event_status = event.get('status')

                if not event_type or event_id is None:
                    continue

                if event_status is not None:
                    event_status = str(event_status)

                if event_type in ['Spotkanie', 'Szkolenie', 'Nadgodziny'] and event_status != '0':
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),
                    })

                    key = (user_id, date_str)
                    if key not in grouped_events:
                        grouped_events[key] = []
                    grouped_events[key].append(event)

        debug_print(f"Znaleziono {len(events_to_cancel)} delegacji do odwo≈Çania")

        if not events_to_cancel:
            QMessageBox.information(
                self,
                "Brak delegacji",
                "Nie znaleziono delegacji do odwo≈Çania dla zaznaczonych kom√≥rek.",
                QMessageBox.Ok
            )
            return

        # Poka≈º potwierdzenie
        delegations_info = self._prepare_delegations_description(grouped_events)
        confirm_message = f"Czy na pewno chcesz odwo≈Çaƒá nastƒôpujƒÖce delegacje?\n\n{delegations_info}\n"
        confirm_message += f"≈ÅƒÖcznie: {len(events_to_cancel)} delegacji dla {len(user_date_pairs)} kom√≥rek"

        reply = QMessageBox.question(
            self,
            "Potwierdzenie odwo≈Çania delegacji",
            confirm_message,
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply != QMessageBox.Yes:
            debug_print("=== OPERACJA ANULOWANA PRZEZ U≈ªYTKOWNIKA ===")
            return

        try:
            # Odwo≈Çaj delegacje w bazie danych
            canceled_count = self._cancel_delegations(events_to_cancel)

            if canceled_count > 0:
                # KLUCZOWA ZMIANA 1: Usu≈Ñ zdarzenia z lokalnych danych
                affected_pairs = []
                for event in events_to_cancel:
                    user_id = event.get('user_id')
                    date_str = event.get('date_key', event.get('date'))
                    if user_id and date_str:
                        affected_pairs.append((user_id, date_str))

                    # Usu≈Ñ z events_data (tabela zdarze≈Ñ)
                    if hasattr(self, 'events_data'):
                        self.events_data = [e for e in self.events_data
                                            if not (e.get('id') == event.get('id') and
                                                    e.get('type') == event.get('type'))]

                    # Usu≈Ñ z all_events_data
                    if hasattr(self, 'all_events_data'):
                        self.all_events_data = [e for e in self.all_events_data
                                                if not (e.get('id') == event.get('id') and
                                                        e.get('type') == event.get('type'))]

                # KLUCZOWA ZMIANA 2: Od≈õwie≈º model zdarze≈Ñ
                if hasattr(self, 'events_model') and hasattr(self, 'events_data'):
                    self.events_model.update_data(self.events_data)
                    debug_print(f"Zaktualizowano model zdarze≈Ñ - pozosta≈Ço {len(self.events_data)} zdarze≈Ñ")

                # KLUCZOWA ZMIANA 3: Wyczy≈õƒá cache i od≈õwie≈º ikony
                affected_pairs = list(set(affected_pairs))  # Usu≈Ñ duplikaty

                # Wyczy≈õƒá cache zdarze≈Ñ w DataProvider
                self.data_provider.invalidate_icons_cache(year, month)

                # Od≈õwie≈º konkretne ikony
                self.data_provider.invalidate_specific_icons(affected_pairs)
                debug_print(f"Od≈õwie≈ºono ikony dla {len(affected_pairs)} zmienionych kom√≥rek")

                # KLUCZOWA ZMIANA 4: Od≈õwie≈º model grafiku dla zmienionych kom√≥rek
                if hasattr(self, 'schedule_model'):
                    for user_id, date_str in affected_pairs:
                        # Aktualizuj wska≈∫niki zdarze≈Ñ w modelu
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', False)
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', False)
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', False)

                # KLUCZOWA ZMIANA 5: Wymu≈õ od≈õwie≈ºenie widok√≥w
                if hasattr(self, 'table'):
                    if hasattr(self.table, 'schedule_view'):
                        self.table.schedule_view.viewport().update()
                    if hasattr(self.table, 'employees_view'):
                        self.table.employees_view.viewport().update()

                if hasattr(self, 'events_table'):
                    self.events_table.viewport().update()

                # KLUCZOWA ZMIANA 6: Kompleksowe od≈õwie≈ºenie po odwo≈Çaniu delegacji
                # 1. Kompletne czyszczenie cache
                if hasattr(self.data_provider, 'invalidate_complete_cache_for_pairs'):
                    self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)

                # 2. Aktualizuj ikony w modelu grafiku
                if hasattr(self, 'schedule_model'):
                    for user_id, date_str in affected_pairs:
                        # Sprawd≈∫ pozosta≈Çe zdarzenia w lokalnych danych
                        remaining_events = [e for e in self.events_data
                                            if e.get('user_id') == user_id and e.get('date_key') == date_str]

                        # Oblicz ikony na podstawie pozosta≈Çych zdarze≈Ñ
                        has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                        has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                        has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)

                        # Aktualizuj ikony w modelu
                        self.schedule_model.update_cell_icons_directly(
                            user_id, date_str, has_meetings, has_trainings, has_overtime
                        )

                # 3. Od≈õwie≈º tabelƒô zdarze≈Ñ dla zaznaczonych kom√≥rek
                selected_cells = self.table.get_data_for_selected_cells()
                if selected_cells:
                    self.on_selection_changed()
                else:
                    self.events_data = []
                    if hasattr(self, 'events_model'):
                        self.events_model.update_data([])

                QMessageBox.information(
                    self,
                    "Sukces",
                    f"Pomy≈õlnie odwo≈Çano {canceled_count} delegacji z {len(events_to_cancel)} znalezionych.",
                    QMessageBox.Ok
                )

                debug_print(f"=== ZAKO≈ÉCZONO POMY≈öLNIE - ODWO≈ÅANO {canceled_count} DELEGACJI ===")
            else:
                QMessageBox.warning(
                    self,
                    "Brak zmian",
                    "Nie uda≈Ço siƒô odwo≈Çaƒá ≈ºadnej delegacji. Sprawd≈∫ logi aplikacji.",
                    QMessageBox.Ok
                )


        except Exception as e:

            log_error(f"B≈ÇƒÖd podczas odwo≈Çywania delegacji: {e}")

            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas odwo≈Çywania delegacji: {str(e)}", QMessageBox.Ok)

    def delete_events_for_cells(self, cells_data: list):
        """
        Wyszukuje wszystkie zdarzenia dla podanych kom√≥rek, prosi o potwierdzenie
        i odwo≈Çuje je. Zwraca True, je≈õli u≈ºytkownik potwierdzi≈Ç usuniƒôcie.
        """
        if not cells_data:
            return False

        # Zbierz unikalne pary (u≈ºytkownik, data) z zaznaczonych kom√≥rek
        user_date_pairs = set()
        for cell_data in cells_data:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if user_id and date_str:
                user_date_pairs.add((user_id, date_str))

        # Znajd≈∫ wszystkie zdarzenia do odwo≈Çania dla tych par
        events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        if not events_to_cancel:
            # Je≈õli nie ma zdarze≈Ñ do usuniƒôcia, nic wiƒôcej nie r√≥b
            return False

        # Przygotuj i poka≈º okno dialogowe z potwierdzeniem
        grouped_events = self._group_events_by_user_date(events_to_cancel)
        delegations_info = self._prepare_delegations_description(grouped_events)

        reply = QMessageBox.question(
            self,
            "Potwierdzenie usuniƒôcia zdarze≈Ñ",
            f"Wstawienie tego symbolu wymaga odwo≈Çania istniejƒÖcych zdarze≈Ñ (spotka≈Ñ, nadgodzin itp.).\n\n{delegations_info}\nCzy chcesz kontynuowaƒá?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply == QMessageBox.Yes:
            # Je≈õli u≈ºytkownik siƒô zgodzi, odwo≈Çaj delegacje
            self._cancel_delegations(events_to_cancel)
            return True
        else:
            # Je≈õli u≈ºytkownik anuluje, zwr√≥ƒá informacjƒô o tym
            self.statusBar().showMessage("Operacja anulowana przez u≈ºytkownika.", 3000)
            return False

    def get_data_from_model(self, row, col):
        """
        Pobiera dane z kom√≥rki modelu na podstawie wierszy i kolumn.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny

        Returns:
            dict: Dane kom√≥rki lub pusty s≈Çownik
        """
        if not hasattr(self, 'schedule_model'):
            return {}

        # Pobierz dane z modelu
        index = self.schedule_model.index(row, col)
        cell_data = self.schedule_model.data(index, Qt.UserRole)

        # Upewnij siƒô, ≈ºe dane sƒÖ s≈Çownikiem
        if not isinstance(cell_data, dict):
            return {}

        return cell_data

    def get_selected_cells_data(self):
        """
        Pobiera dane dla zaznaczonych kom√≥rek z modelu.

        Returns:
            list: Lista danych zaznaczonych kom√≥rek
        """
        if not hasattr(self, 'table') or not self.table:
            return []

        # Deleguj do metody w SplitTableView, kt√≥ra ju≈º obs≈Çuguje model
        return self.table.get_data_for_selected_cells()

    def update_model_after_data_change(self, user_id, date_str):
        """
        Aktualizuje dane w modelu po zmianach w bazie danych.

        Args:
            user_id: ID u≈ºytkownika
            date_str: Data w formacie YYYY-MM-DD
        """
        if not user_id or not date_str:
            return

        # Pobierz rok i miesiƒÖc z daty
        if date_str.count('-') != 2:
            return

        year, month, _ = date_str.split('-')
        try:
            year = int(year)
            month = int(month)
        except ValueError:
            return

        # Pobierz aktualne dane z DataProvider - wymu≈õ od≈õwie≈ºenie cache
        self.data_provider.clear_cache()
        schedule_data = self.data_provider.get_schedule_data(year, month, use_cache=False)

        # Aktualizuj model
        if schedule_data and hasattr(self, 'schedule_model'):
            # Aktualizuj model bezpo≈õrednio
            self.schedule_model.update_data(schedule_data, year, month)

            # Zaktualizuj przefiltrowane dane
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

            # Od≈õwie≈º widok
            if hasattr(self, 'table'):
                self.table.update()

    def setup_model_connections(self):
        """
        ≈ÅƒÖczy sygna≈Çy modeli z obs≈ÇugƒÖ interfejsu u≈ºytkownika.
        """
        # Po≈ÇƒÖcz zmiany w modelach z aktualizacjƒÖ interfejsu
        if hasattr(self, 'schedule_model'):
            self.schedule_model.dataChanged.connect(self.on_schedule_data_changed)

        if hasattr(self, 'events_model'):
            self.events_model.dataChanged.connect(self.on_events_data_changed)

    def on_schedule_data_changed(self, topLeft, bottomRight):
        """
        Obs≈Çuguje zmianƒô danych w modelu grafiku.

        Args:
            topLeft: Indeks g√≥rnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Od≈õwie≈º widok
        if hasattr(self, 'table'):
            self.table.update()

        # Je≈õli zmieni≈Ço siƒô zaznaczenie, zaktualizuj tabelƒô zdarze≈Ñ
        if self.table.selection_changed.receivers() > 0:
            selected_rows = self.table.get_selected_rows()
            if selected_rows:
                self.on_selection_changed()

    def on_events_data_changed(self, topLeft, bottomRight):
        """
        Obs≈Çuguje zmianƒô danych w modelu zdarze≈Ñ.

        Args:
            topLeft: Indeks g√≥rnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Od≈õwie≈º tabelƒô zdarze≈Ñ
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

    def show_insert_change_dialog(self):
        """Pokazuje okno dialogowe do wstawiania zmian w grafiku"""
        # Pobierz aktualnƒÖ datƒô z tabeli grafiku
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "B≈ÇƒÖd",
                "Nie wybrano miesiƒÖca. Nie mo≈ºna dodaƒá zmiany grafiku.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # ZMIANA: U≈ºyj metody get_data_for_selected_cells z SplitTableView
        selected_cells = self.table.get_data_for_selected_cells()

        if not self._can_modify_cells(selected_cells):
            return

        if not selected_cells:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono ≈ºadnych kom√≥rek do edycji.",
                QMessageBox.Ok
            )
            return

        # Grupuj kom√≥rki wed≈Çug u≈ºytkownika i dnia dla ≈Çatwiejszej edycji
        grouped_cells = self.group_cells_by_user_and_day(selected_cells)

        # Utw√≥rz dialog
        dialog = ScheduleChangeDialog(self, grouped_cells, year, month)
        dialog.exec()

    def get_selected_schedule_cells(self):
        """Zwraca listƒô zaznaczonych kom√≥rek z siatki grafiku"""
        selected_cells = []
        selected_ranges = self.table.selectedRanges()

        for range_item in selected_ranges:
            for row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawd≈∫ czy to kom√≥rka z grafikiem
                    if col >= 3:
                        # Pobierz element tabeli
                        cell_item = self.table.item(row, col)
                        if not cell_item:
                            continue

                        # Pobierz dane z kom√≥rki
                        cell_data = self.get_cell_data(cell_item)
                        if not cell_data:
                            continue

                        # Dodaj dane do listy wybranych kom√≥rek
                        selected_cells.append(cell_data)

        return selected_cells

    def group_cells_by_user_and_day(self, cells):
        """Grupuje kom√≥rki wed≈Çug u≈ºytkownika i dnia dla ≈Çatwiejszej edycji"""
        grouped = {}
        for cell in cells:
            # ZMIANA: Dostosuj do nowej struktury danych z modelu
            user_id = cell.get('uzytkownik_id')  # Zmieniono z 'user_id'
            date_str = cell.get('date_str')  # Zmieniono z 'date'

            if not user_id or not date_str:
                continue

            if user_id not in grouped:
                grouped[user_id] = {}

            if date_str not in grouped[user_id]:
                grouped[user_id][date_str] = []

            grouped[user_id][date_str].append(cell)

        return grouped

    def delete_event(self, event_id, event_type):
        """Wersja z weryfikacjƒÖ uprawnie≈Ñ przed usuniƒôciem."""
        # Krok 1: Znajd≈∫ kom√≥rki, kt√≥rych dotyczy zmiana
        affected_pairs = []
        event_to_delete = None
        # Przeszukujemy dane zdarze≈Ñ (te aktualnie wy≈õwietlane w tabeli)
        for event in (self.events_data or []):
            if event.get('id') == event_id and event.get('type') == event_type:
                user_id = event.get('user_id')
                date_key = event.get('date_key')
                if user_id and date_key:
                    affected_pairs.append((user_id, date_key))
                    event_to_delete = event
                    break  # Zak≈Çadamy unikalne ID, wiƒôc mo≈ºemy przerwaƒá

        if not event_to_delete:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Nie mo≈ºna odnale≈∫ƒá zdarzenia do usuniƒôcia.")
            return

        # Krok 2: Pobierz pe≈Çne dane kom√≥rek i przeprowad≈∫ walidacjƒô uprawnie≈Ñ
        cells_to_check = self._get_cell_data_for_user_date_pairs(affected_pairs)
        if not self._can_modify_cells(cells_to_check):
            return  # Zatrzymaj, je≈õli brak uprawnie≈Ñ

        # Krok 3: Popro≈õ o potwierdzenie (je≈õli walidacja przesz≈Ça pomy≈õlnie)
        reply = QMessageBox.question(
            self, "Potwierdzenie",
            f"Czy na pewno chcesz usunƒÖƒá {event_type.lower()} o ID {event_id}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.Yes
        )

        if reply != QMessageBox.StandardButton.Yes:
            return

        # Krok 4: Wykonaj operacjƒô usuniƒôcia (istniejƒÖca logika)
        try:
            _, user_app_id, _, _, _ = get_modifier_id()
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            table_name = ""
            if event_type == "Spotkanie":
                table_name = "p_t_zz_Spotkania"
            elif event_type == "Szkolenie":
                table_name = "p_t_zz_Szkolenia"
            elif event_type == "Nadgodziny":
                table_name = "p_t_zz_Nadgodziny"
            else:
                return

            if event_type in ["Spotkanie", "Szkolenie"]:
                query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                cursor.execute(query, (user_app_id, event_id))
            else:
                query = f"DELETE FROM {table_name} WHERE Id = ?"
                cursor.execute(query, (event_id,))

            conn.commit()
            conn.close()
            self._update_modification_date()

            self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)

            if hasattr(self, 'schedule_model'):
                for user_id, date_str in affected_pairs:
                    remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                    has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                    has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                    has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)
                    self.schedule_model.update_cell_icons_directly(
                        user_id, date_str, has_meetings, has_trainings, has_overtime
                    )
            self.statusBar().showMessage(f"Usuniƒôto zdarzenie o ID {event_id}.", 3000)

            self.on_selection_changed()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas usuwania zdarzenia: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas usuwania zdarzenia: {str(e)}",
                                 QMessageBox.StandardButton.Ok)

    def show_add_overtime_dialog(self):
        """
        Pokazuje okno dialogowe do dodawania nadgodzin.
        POPRAWIONA WERSJA - bez duplikacji zdarze≈Ñ i z prawid≈Çowym ustawianiem ikon.
        """
        # Pobierz bie≈ºƒÖcƒÖ datƒô z tabeli grafiku
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "B≈ÇƒÖd",
                "Nie wybrano miesiƒÖca. Nie mo≈ºna dodaƒá nadgodzin.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone kom√≥rki z modelu
        selected_cells_data = self.table.get_data_for_selected_cells()

        if not self._can_modify_cells(selected_cells_data):
            return

        # Sprawd≈∫ liczbƒô zaznaczonych kom√≥rek
        if not selected_cells_data:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono ≈ºadnej kom√≥rki. Zaznacz dok≈Çadnie jednƒÖ kom√≥rkƒô, aby dodaƒá nadgodziny.",
                QMessageBox.Ok
            )
            return

        # Je≈õli zaznaczono wiƒôcej ni≈º jednƒÖ kom√≥rkƒô, wy≈õwietl komunikat i zako≈Ñcz
        if len(selected_cells_data) > 1:
            QMessageBox.warning(
                self,
                "Zbyt wiele zaznaczonych kom√≥rek",
                "Zaznaczono zbyt wiele kom√≥rek. Zaznacz dok≈Çadnie jednƒÖ kom√≥rkƒô, aby dodaƒá nadgodziny.",
                QMessageBox.Ok
            )
            return

        # Pobierz dane pierwszej (i jedynej) zaznaczonej kom√≥rki
        cell_data = selected_cells_data[0]

        # Pobierz podstawowe informacje o kom√≥rce
        selected_user_id = cell_data.get('uzytkownik_id')
        selected_user_name = cell_data.get('uzytkownik_dane')
        day = cell_data.get('day')
        date_str = cell_data.get('date_str')
        nr_kadrowy = cell_data.get('nr_kadrowy')
        start_hour = cell_data.get('start_hour')
        current_symbol = cell_data.get('symbol', '')

        # NOWE: Pobierz lokalizacjƒô domy≈õlnƒÖ z danych u≈ºytkownika
        lokalizacja_domyslna = cell_data.get('lokalizacja_domyslna', 'h')

        if not selected_user_id or not day or not date_str:
            QMessageBox.warning(
                self,
                "B≈ÇƒÖd",
                "Brak wymaganych danych w zaznaczonej kom√≥rce.",
                QMessageBox.Ok
            )
            return

        # Utw√≥rz datƒô QDate
        selected_date = QDate.fromString(date_str, "yyyy-MM-dd")

        # Flaga okre≈õlajƒÖca, czy to dzie≈Ñ wolny (brak danych lub pusty symbol)
        is_day_off = not current_symbol or current_symbol.strip() == ''

        # Je≈õli nr_kadrowy jest None, spr√≥buj znale≈∫ƒá go w danych u≈ºytkownika
        if nr_kadrowy is None and selected_user_id in self.user_info_map:
            nr_kadrowy = self.user_info_map[selected_user_id].get('nr_kadrowy')

        # Ustaw domy≈õlnƒÖ godzinƒô rozpoczƒôcia
        if start_hour is None:
            start_hour = 9 if is_day_off else 8

        # POPRAWIONE: Pobierz lokalizacjƒô z symbolu lub u≈ºyj domy≈õlnej
        current_location = lokalizacja_domyslna  # Domy≈õlna z danych u≈ºytkownika

        if current_symbol and ';' in current_symbol:
            from symbol_parser import parse_symbol
            parsed_symbol = parse_symbol(current_symbol)
            if parsed_symbol['location']:
                current_location = parsed_symbol['location']

        # Utw√≥rz okno dialogowe
        dialog = QDialog(self)

        # Nazwy miesiƒôcy po polsku
        polish_months = [
            "stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca",
            "lipca", "sierpnia", "wrze≈õnia", "pa≈∫dziernika", "listopada", "grudnia"
        ]

        month_name = polish_months[selected_date.month() - 1]
        dialog.setWindowTitle(f"Dodaj nadgodziny w dniu {selected_date.day()} {month_name} {selected_date.year()}")
        dialog.setMinimumWidth(300)

        layout = QVBoxLayout(dialog)

        # Informacja o pracowniku
        user_info_label = QLabel(f"Pracownik: {selected_user_name}")
        user_info_label.setStyleSheet("font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(user_info_label)

        # Informacja o numerze kadrowym
        if nr_kadrowy:
            kadrowy_info_label = QLabel(f"Numer kadrowy: {nr_kadrowy}")
            kadrowy_info_label.setStyleSheet("margin-bottom: 10px;")
            layout.addWidget(kadrowy_info_label)

        # Informacja o miesiƒÖcu rozliczenia
        settlement_month = month
        settlement_year = year
        settlement_info = QLabel(f"MiesiƒÖc rozliczenia: {settlement_month:02d}.{settlement_year}")
        settlement_info.setStyleSheet("margin-bottom: 10px;")
        layout.addWidget(settlement_info)

        # Informacja o dniu wolnym (je≈õli to dzie≈Ñ wolny)
        if is_day_off:
            day_off_info = QLabel("Zaznaczony dzie≈Ñ jest dniem wolnym pracownika.")
            day_off_info.setStyleSheet("color: blue; font-weight: bold; margin-bottom: 10px;")
            layout.addWidget(day_off_info)

        # Formularz wprowadzania
        form_frame = QFrame()
        form_frame.setFrameShape(QFrame.StyledPanel)
        form_frame.setFrameShadow(QFrame.Raised)
        form_layout = QGridLayout(form_frame)

        # Etykiety
        od_label = QLabel("od kiedy")
        ile_label = QLabel("ile godzin")
        typ_label = QLabel("typ")
        ld_label = QLabel("LD")
        zalegle_label = QLabel("czy zaleg≈Çe")

        # Kontrolki wprowadzania
        time_combo = QComboBox()
        time_combo.setMinimumWidth(60)

        # Ustal domy≈õlny czas
        if is_day_off:
            default_time = "09:00"  # Dla dnia wolnego
        else:
            # Oblicz koniec zmiany (godzina rozpoczƒôcia + 8 godzin)
            end_hour = (start_hour + 8) % 24
            default_time = f"{end_hour:02d}:00"

        # Dodaj opcje czasu
        for hour in range(0, 24):
            for minute in [0, 30]:
                time_combo.addItem(f"{hour:02d}:{minute:02d}", f"{hour:02d}:{minute:02d}")

        # Ustaw domy≈õlny czas
        index = time_combo.findText(default_time)
        if index != -1:
            time_combo.setCurrentIndex(index)
        else:
            time_combo.setCurrentText(default_time)

        # Combo z liczbƒÖ godzin do 13.0
        hours_combo = QComboBox()
        hours_combo.setMinimumWidth(50)
        for hours in [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5,
                      10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0]:
            hours_combo.addItem(f"{hours:.1f}", hours)
        hours_combo.setCurrentIndex(1)  # Domy≈õlnie 1.0

        # Typ: wyp≈Çata, odbi√≥r, odpracowanie
        type_combo = QComboBox()
        type_combo.addItem("wyp≈Çata", "wyp≈Çata")
        type_combo.addItem("odbi√≥r", "odbi√≥r")
        type_combo.addItem("odpracowanie", "odpracowanie")

        # LD (lokalizacja): h, p, s
        ld_combo = QComboBox()
        ld_combo.addItem("h", "h")  # Hybrydowa
        ld_combo.addItem("p", "p")  # Praca zdalna
        ld_combo.addItem("s", "s")  # Stacjonarna

        # POPRAWIONE: Ustaw domy≈õlnƒÖ lokalizacjƒô na podstawie symbolu lub domy≈õlnej u≈ºytkownika
        if current_location == 'h':
            ld_combo.setCurrentIndex(0)
        elif current_location == 'p':
            ld_combo.setCurrentIndex(1)
        elif current_location == 's':
            ld_combo.setCurrentIndex(2)
        else:
            ld_combo.setCurrentIndex(0)  # Domy≈õlnie 'h'

        # Czy zaleg≈Çe
        overdue_combo = QComboBox()
        overdue_combo.addItem("nie", 0)
        overdue_combo.addItem("tak", 1)

        # Przycisk dodawania
        add_button = QPushButton("Dodaj")
        add_button.setStyleSheet("background-color: #333; color: white; font-weight: bold;")

        # Dodaj kontrolki do layoutu
        form_layout.addWidget(od_label, 0, 0)
        form_layout.addWidget(time_combo, 0, 1)
        form_layout.addWidget(ile_label, 0, 2)
        form_layout.addWidget(hours_combo, 0, 3)
        form_layout.addWidget(typ_label, 0, 4)
        form_layout.addWidget(type_combo, 0, 5)
        form_layout.addWidget(ld_label, 0, 6)
        form_layout.addWidget(ld_combo, 0, 7)
        form_layout.addWidget(zalegle_label, 0, 8)
        form_layout.addWidget(overdue_combo, 0, 9)
        form_layout.addWidget(add_button, 0, 10)

        # Dodaj formularz do g≈Ç√≥wnego layoutu
        layout.addWidget(form_frame)

        def add_overtime():
            try:
                result = self.call_add_overtime_procedure_fixed(
                    selected_user_id, selected_date.year(), selected_date.month(),
                    selected_date.toString("yyyy-MM-dd"), time_combo.currentText(),
                    float(hours_combo.currentData()), f"{year}-{month:02d}-01",
                    overdue_combo.currentIndex(), type_combo.currentText(),
                    ld_combo.currentText(), nr_kadrowy
                )

                if result["success"]:
                    # ZMIANA: Usuniƒôto okno z informacjƒÖ o sukcesie
                    # QMessageBox.information(dialog, "Sukces", result["message"], QMessageBox.Ok)
                    self.statusBar().showMessage("Pomy≈õlnie dodano nadgodziny.", 3000)
                    dialog.accept()
                else:
                    QMessageBox.warning(dialog, "B≈ÇƒÖd", result["message"], QMessageBox.Ok)

            except Exception as e:
                QMessageBox.critical(dialog, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd: {str(e)}", QMessageBox.Ok)

        # Pod≈ÇƒÖcz funkcjƒô do przycisku
        add_button.clicked.connect(add_overtime)

        # Poka≈º dialog
        dialog.exec()

    def _update_overtime_icon_single(self, user_id, date_str, year, month):
        """
        NOWA METODA: Aktualizuje ikonƒô nadgodzin bez wp≈Çywania na cache innych danych.
        """
        try:
            # 1. Aktualizuj bezpo≈õrednio w modelu grafiku
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonƒô nadgodzin w modelu dla ({user_id}, {date_str})")

            # 2. Wyczy≈õƒá tylko cache ikon dla tej konkretnej kom√≥rki w DataProvider
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla kom√≥rki ({user_id}, {date_str})")

            # 3. Od≈õwie≈º widok grafiku
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji ikony nadgodzin: {e}")

    def connect_model_signals(self):
        """Pod≈ÇƒÖcz sygna≈Çy modelu - DODAJ TO DO METODY setup_ui lub __init__"""
        if hasattr(self, 'data_provider'):
            self.data_provider.data_changed.connect(self.on_data_changed)

            # NOWE: Pod≈ÇƒÖcz sygna≈Ç od≈õwie≈ºania konkretnych ikon
            if hasattr(self.data_provider, 'data_changed'):
                self.data_provider.data_changed.connect(self._handle_specific_icons_refresh)

    def _handle_specific_icons_refresh(self, data_type, year, month):
        """NOWA METODA: Obs≈Çuguje sygna≈Ç od≈õwie≈ºenia konkretnych ikon"""
        if data_type == "icons" and hasattr(self, 'schedule_model') and self.schedule_model:
            # Model sam od≈õwie≈ºy ikony przy nastƒôpnym dostƒôpie - nie r√≥b nic wiƒôcej
            debug_print(f"Otrzymano sygna≈Ç od≈õwie≈ºenia ikon dla {year}-{month}")

    def call_add_overtime_procedure_fixed(self, user_id, year, month, date_str, start_time, hours,
                                          settlement_date, is_overdue, overtime_type, location,
                                          nr_kadrowy):
        """
        Dodaje nadgodziny i zapewnia natychmiastowƒÖ, niezawodnƒÖ aktualizacjƒô
        tabeli zdarze≈Ñ oraz ikony w grafiku.
        """
        try:
            # Krok 1: Dodanie rekordu do bazy danych
            location_map = {'h': 1, 'p': 2, 's': 3}
            location_value = location_map.get(location, 1)
            param_value = 1 if overtime_type == 'odpracowanie' else None
            odebrane_value = 1 if overtime_type == 'odbi√≥r' else 0

            from datetime import datetime, timedelta
            start_datetime = datetime.strptime(f"{date_str} {start_time}", "%Y-%m-%d %H:%M")
            end_datetime = start_datetime + timedelta(hours=float(hours))
            end_time = end_datetime.strftime("%H:%M")

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            params = [
                nr_kadrowy, year, month, date_str, start_time, end_time,
                settlement_date, is_overdue, odebrane_value, location_value,
                param_value
            ]
            sql = f"{{CALL [dbo].[p_P_ZZ_NadgodzinyWstawienie_v3] ({', '.join(['?'] * len(params))})}}"
            cursor.execute(sql, params)
            conn.commit()
            conn.close()

            # Krok 2: Rejestracja w≈Çasnej zmiany i uniewa≈ºnienie cache
            self._update_modification_date()
            self.data_provider.invalidate_complete_cache_for_pairs([(user_id, date_str)])

            # --- NOWA, KLUCZOWA LOGIKA (skopiowana z `delete_event`) ---
            # Krok 3: Bezpo≈õrednia aktualizacja ikony w modelu
            if hasattr(self, 'schedule_model'):
                # Sprawdzamy, jakie zdarzenia istniejƒÖ dla kom√≥rki PO dodaniu nowego
                remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)

                # Bezpo≈õrednio aktualizujemy stan ikon w modelu
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_meetings, has_trainings, has_overtime
                )

            # Krok 4: Od≈õwie≈ºenie dolnej tabeli zdarze≈Ñ
            self.on_selection_changed()

            # Zwracamy sukces
            return {
                "success": True,
                "message": "Nadgodziny zosta≈Çy pomy≈õlnie dodane."
            }

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas dodawania nadgodzin: {e}", exception=e)
            return {
                "success": False,
                "message": f"WystƒÖpi≈Ç b≈ÇƒÖd podczas dodawania nadgodzin: {str(e)}"
            }

    def _refresh_data_after_overtime_addition(self, new_id, user_id, date_str, year, month):
        """
        NOWA METODA: Od≈õwie≈ºa dane z bazy po dodaniu nadgodzin
        """
        try:
            debug_print(f"Od≈õwie≈ºam dane po dodaniu nadgodzin ID={new_id}")

            # Upewnij siƒô, ≈ºe column_mapper jest dostƒôpny
            if not hasattr(self, 'column_mapper'):
                from column_mapper import ColumnMapper
                self.column_mapper = ColumnMapper()

            # 1. POBIERZ NOWE ZDARZENIE Z BAZY DANYCH
            new_event = self._fetch_specific_event_from_db(year, month, new_id, 'Nadgodziny')

            if not new_event:
                log_error(f"Nie znaleziono dodanych nadgodzin o ID {new_id} w bazie danych")
                return

            debug_print(f"Pobrano nowe zdarzenie z bazy: {new_event}")

            # 2. AKTUALIZUJ CACHE DATAPROVIDER
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]

                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data")

                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []

                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in
                           container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache")

                # Aktualizuj processed_data - ustaw ikonƒô nadgodzin
                try:
                    day = int(date_str.split('-')[2])
                    for key, user_data in container.processed_data.items():
                        if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonƒô nadgodzin w processed_data")
                            break
                except Exception as e:
                    log_error(f"B≈ÇƒÖd aktualizacji processed_data: {e}")

            # 3. AKTUALIZUJ LOKALNE DANE
            # Konwertuj na lokalny format
            local_event = self._convert_dp_event_to_local(new_event)

            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(local_event)
                    debug_print(f"Dodano nadgodziny do all_events_data")

            # 4. AKTUALIZUJ events_data TYLKO JE≈öLI KOM√ìRKA JEST ZAZNACZONA
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )

                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(local_event)
                        debug_print(f"Dodano nadgodziny do events_data")

                        # Aktualizuj model zdarze≈Ñ
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # 5. AKTUALIZUJ MODEL GRAFIKU
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_overtime=True
                )
                debug_print(f"Zaktualizowano ikony w schedule_model")

            # 6. WYCZY≈öƒÜ CACHE IKON
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon")

            # 7. OD≈öWIE≈ª WIDOKI
            if hasattr(self, 'table'):
                if hasattr(self.table, 'schedule_view'):
                    self.table.schedule_view.viewport().update()

            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

            debug_print(f"=== OD≈öWIE≈ªENIE DANYCH ZAKO≈ÉCZONE ===")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas od≈õwie≈ºania danych: {e}")
            import traceback
            traceback.print_exc()

    def _fetch_specific_event_from_db(self, year, month, event_id, event_type):
        """
        NOWA METODA: Pobiera konkretne zdarzenie z bazy danych
        """
        try:
            # Zapytanie do pobrania konkretnego zdarzenia
            query = """
            SELECT * FROM [dbo].[fn_GetEventsData](?, ?) 
            WHERE EventType = ? AND ID = ?
            """

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query, (year, month, event_type, event_id))
            result = cursor.fetchone()
            conn.close()

            if not result:
                return None

            # Konwertuj na format DataProvider u≈ºywajƒÖc column_mapper
            event_dict = self.column_mapper.map_events_row_to_dict(result)

            # Dodaj pola wymagane przez DataProvider
            if 'event_type' in event_dict:
                event_dict['type'] = event_dict['event_type']
            if 'event_id' in event_dict:
                event_dict['id'] = event_dict['event_id']

            # Formatuj daty
            raw_date = event_dict.get('date', '')
            if hasattr(raw_date, 'strftime'):
                event_dict['date_display'] = raw_date.strftime('%d.%m.%Y')
                event_dict['date_key'] = raw_date.strftime('%Y-%m-%d')
            elif isinstance(raw_date, str) and raw_date:
                event_dict['date_display'] = self.data_provider._format_date_display(raw_date)
                event_dict['date_key'] = self.data_provider._standardize_date(raw_date)

            # Formatuj czasy
            time_from = event_dict.get('time_from')
            time_to = event_dict.get('time_to')

            if hasattr(time_from, 'strftime'):
                event_dict['time_from'] = time_from.strftime('%H:%M')
            elif isinstance(time_from, str) and 'T' in time_from:
                event_dict['time_from'] = time_from.split(' ')[1][:5]

            if hasattr(time_to, 'strftime'):
                event_dict['time_to'] = time_to.strftime('%H:%M')
            elif isinstance(time_to, str) and 'T' in time_to:
                event_dict['time_to'] = time_to.split(' ')[1][:5]

            debug_print(f"Skonwertowano zdarzenie z bazy: {event_dict}")
            return event_dict

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas pobierania zdarzenia z bazy: {e}")
            return None

    def _add_event_to_data_provider(self, new_id, user_id, user_name, date_str, start_time,
                                    end_time, overtime_type, is_overdue, year, month):
        """
        NOWA METODA: Dodaje zdarzenie bezpo≈õrednio do DataProvider i wszystkich cache'y
        """
        try:
            # Utw√≥rz obiekt zdarzenia w formacie DataProvider
            display_date = ".".join(reversed(date_str.split("-")))

            # Status na podstawie typu i flagi zaleg≈Ço≈õci
            if overtime_type == 'wyp≈Çata':
                status = "Wyp≈Çata - zaleg≈Çe" if is_overdue else "Wyp≈Çata"
            elif overtime_type == 'odbi√≥r':
                status = "Odbi√≥r"
            elif overtime_type == 'odpracowanie':
                status = "Odpracowanie"
            else:
                status = "Aktywne"

            # Utw√≥rz zdarzenie w formacie zgodnym z DataProvider
            new_event_dp_format = {
                'event_type': 'Nadgodziny',
                'event_id': new_id,
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'date': date_str,  # DataProvider oczekuje YYYY-MM-DD
                'time_from': f"1900-01-01 {start_time}:00",  # Format z bazy
                'time_to': f"1900-01-01 {end_time}:00",
                'status': 'Wstawione',  # Status w formacie bazy
                'type': 'Nadgodziny',
                'id': new_id,
                'date_display': display_date,
                'date_key': date_str
            }

            # Utw√≥rz zdarzenie w formacie lokalnym
            new_event_local_format = {
                'type': 'Nadgodziny',
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'user_name': user_name,
                'date': display_date,
                'date_key': date_str,
                'time_from': start_time,
                'time_to': end_time,
                'status': status,
                'id': new_id
            }

            # KLUCZOWA ZMIANA 1: Dodaj do cache DataProvider
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]

                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data (ID: {new_id})")

                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []

                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in
                           container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache (ID: {new_id})")

                # Aktualizuj processed_data - dodaj ikonƒô nadgodzin
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        try:
                            day = int(date_str.split('-')[2])
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonƒô nadgodzin w processed_data dla {user_id}, dzie≈Ñ {day}")
                            break
                        except:
                            pass

            # KLUCZOWA ZMIANA 2: Dodaj do lokalnych danych
            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(new_event_local_format)
                    debug_print(f"Dodano nadgodziny do all_events_data (ID: {new_id})")

            # KLUCZOWA ZMIANA 3: Dodaj do events_data tylko je≈õli kom√≥rka jest zaznaczona
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )

                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(new_event_local_format)
                        debug_print(f"Dodano nadgodziny do events_data (ID: {new_id})")

                        # Aktualizuj model zdarze≈Ñ
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # KLUCZOWA ZMIANA 4: Aktualizuj ikonƒô w modelu
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonƒô nadgodzin w modelu dla ({user_id}, {date_str})")

            # KLUCZOWA ZMIANA 5: Wyczy≈õƒá tylko cache ikon dla tej kom√≥rki (nie ca≈Çy cache)
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla kom√≥rki ({user_id}, {date_str})")

            # Od≈õwie≈º widok
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas dodawania zdarzenia do DataProvider: {e}")

    def debug_check_event_in_index(self, event_id, event_type='Nadgodziny'):
        """
        Sprawdza, czy zdarzenie o podanym ID istnieje w indeksie zdarze≈Ñ
        i wy≈õwietla informacje diagnostyczne.

        Args:
            event_id: ID zdarzenia
            event_type: Typ zdarzenia (domy≈õlnie 'Nadgodziny')

        Returns:
            bool: True je≈õli znaleziono zdarzenie, False w przeciwnym wypadku
        """
        debug_print(f"\n--- DIAGNOSTYKA INDEKSU ZDARZE≈É ---")
        debug_print(f"Szukam zdarzenia o ID {event_id} i typie {event_type}")

        # Sprawd≈∫ w indeksie zdarze≈Ñ DataProvider
        if hasattr(self.data_provider, 'events_index'):
            # Sprawd≈∫ bezpo≈õrednio przez indeks ID
            event = self.data_provider.events_index.get_event_by_id(event_id)
            if event:
                debug_print(f"ZNALEZIONO w indeksie ID: {event}")
                return True

            # Alternatywnie, przeszukaj wszystkie zdarzenia
            found_in_all = False
            for e in self.data_provider.events_index.all_events:
                if e.get('id') == event_id and e.get('type') == event_type:
                    debug_print(f"ZNALEZIONO w all_events: {e}")
                    found_in_all = True

            # Przeszukaj indeks typ√≥w
            found_in_type_index = False
            type_events = self.data_provider.events_index.type_index.get(event_type, [])
            for e in type_events:
                if e.get('id') == event_id:
                    debug_print(f"ZNALEZIONO w type_index: {e}")
                    found_in_type_index = True

            if not found_in_all and not found_in_type_index:
                debug_print("NIE ZNALEZIONO w indeksie zdarze≈Ñ")
                return False

            return found_in_all or found_in_type_index
        else:
            debug_print("BRAK indeksu zdarze≈Ñ w data_provider")
            return False

    def show_settings_dialog(self):
        """Otwiera nowe, kompleksowe okno ustawie≈Ñ."""
        dialog = AppSettingsDialog(self, settings=self.user_settings)

        # Pod≈ÇƒÖczamy sygna≈Ç "na ≈ºywo" z dialogu do metody aplikujƒÖcej motyw w g≈Ç√≥wnym oknie.
        dialog.live_theme_changed.connect(self.apply_theme_settings)

        if dialog.exec() == QDialog.Accepted:
            new_settings = dialog.get_current_settings()

            # Zaktualizuj g≈Ç√≥wny s≈Çownik ustawie≈Ñ w aplikacji
            self.user_settings = new_settings

            # Zaktualizuj poszczeg√≥lne atrybuty dla wygody
            self.is_dark_theme = self.user_settings.get('theme') == 'dark'
            self.current_font = self.user_settings.get('font_family')
            self.current_font_size = self.user_settings.get('font_size')
            self.import_grupa = self.user_settings.get('import_grupa')
            self.import_funkcja = self.user_settings.get('import_funkcja')

            # Zastosuj motyw i czcionkƒô dla ca≈Çej aplikacji
            self.apply_theme_settings(
                'dark' if self.is_dark_theme else 'light',
                self.current_font,
                self.current_font_size
            )

            # --- OSTATECZNA, NAJBARDZIEJ NIEZAWODNA LOGIKA OD≈öWIE≈ªANIA ---

            # 1. Stw√≥rz delegata NA NOWO z aktualnymi ustawieniami
            self.setup_table_properties()

            # 2. Wymu≈õ pe≈Çne przerysowanie ca≈Çego widoku tabeli.
            #    To zmusi QTableView do ponownego u≈ºycia nowego delegata dla ka≈ºdej kom√≥rki.
            self.table.schedule_view.viewport().update()

            # --- KONIEC OSTATECZNEJ LOGIKI ---

            # Zapisz ustawienia do bazy, je≈õli u≈ºytkownik sobie tego ≈ºyczy
            if self.user_settings.get('save_to_db'):
                self.settings_db.save_settings(
                    theme=self.user_settings.get('theme'),
                    font_family=self.user_settings.get('font_family'),
                    font_size=self.user_settings.get('font_size'),
                    visible_columns=self.visible_columns,
                    show_schedule_comment=self.user_settings.get('show_schedule_comment', False),
                    import_grupa=self.user_settings.get('import_grupa'),
                    import_funkcja=self.user_settings.get('import_funkcja'),
                    show_special_symbol=self.user_settings.get('show_special_symbol'),
                    show_location_symbol=self.user_settings.get('show_location_symbol'),
                    special_symbol_position=self.user_settings.get('special_symbol_position'),
                    location_symbol_position=self.user_settings.get('location_symbol_position')
                )

            # Od≈õwie≈º dane, je≈õli zmieni≈Çy siƒô parametry importu
            self.refresh_data()

    def update_cell_data(self, user_id, date_str, event_type=None, action="update"):
        """
        Aktualizuje dane kom√≥rki i ikony po r√≥≈ºnych operacjach.
        Zoptymalizowana wersja wykorzystujƒÖca precyzyjne aktualizacje.

        Args:
            user_id: ID u≈ºytkownika
            date_str: Data w formacie 'YYYY-MM-DD'
            event_type: Typ zdarzenia (Spotkanie, Szkolenie, Nadgodziny lub None)
            action: Rodzaj operacji - "update", "add", "delete"

        Returns:
            bool: True je≈õli operacja siƒô powiod≈Ça, False w przeciwnym wypadku
        """
        if not user_id or not date_str:
            return False

        # Standardyzuj format daty
        date_str = self.data_provider._standardize_date(date_str)

        # Wyczy≈õƒá cache dla miesiƒÖca tej daty
        if date_str and date_str.count('-') == 2:
            year, month, _ = date_str.split('-')
            self.clear_events_cache(int(year), int(month))

        # Pobierz zdarzenia dla tej pary (u≈ºytkownik, data)
        events = self.data_provider.get_events_for_user_date(user_id, date_str)

        # Sprawd≈∫ typy zdarze≈Ñ
        has_meeting = any(
            e.get('type') == 'Spotkanie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_training = any(
            e.get('type') == 'Szkolenie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_overtime = any(e.get('type') == 'Nadgodziny' for e in events)

        # Aktualizuj wska≈∫niki w modelu - u≈ºywajƒÖc zoptymalizowanej metody
        if hasattr(self, 'schedule_model'):
            if event_type == 'Spotkanie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Szkolenie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Nadgodziny':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny',
                                                                  is_active=(action != "delete"))
            else:
                # Aktualizuj wszystkie wska≈∫niki
                result1 = self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', has_meeting)
                result2 = self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', has_training)
                result3 = self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', has_overtime)
                return result1 or result2 or result3

        return False

    def get_all_valid_symbols(self) -> set:
        """Zwraca zbi√≥r wszystkich prawid≈Çowych symboli specjalnych."""
        # Definicje skopiowane z InsertSymbolDialog dla centralizacji
        symbol_lists = [
            ("U", "Urlop wypoczynkowy"), ("UZ", "Urlop na ≈ºƒÖdanie"), ("CO", "Zwolnienie lekarskie"),
            ("CR", "Zwolnienie lekarskie na innƒÖ osobƒô"), ("UB", "Urlop bezp≈Çatny"),
            ("UD", "Urlop dodatkowy z tytu≈Çu niepe≈Çnosprawno≈õci"), ("UM", "Urlop macierzy≈Ñski"),
            ("UO", "Urlop okoliczno≈õciowy"), ("UOD", "Opieka nad dzieckiem"),
            ("US", "Urlop szkolny"), ("UT", "Urlop ojcowski"), ("UW", "Urlop wychowawczy"),
            ("UOP", "Urlop opieku≈Ñczy (5 dni)"), ("CRW", "Zwolnienie na opiekƒô (wyjƒÖtkowe)"),
            ("CSR", "≈öwiadczenie rehabilitacyjne"), ("ZO", "Zwolnienie z obowiƒÖzku ≈õwiadczenia pracy"),
            ("ZS", "Zwolnienie z obowiƒÖzku ≈õwiadczenia pracy (wyjƒÖtkowe)"),
            ("DK", "Delegacja krajowa"), ("DZ", "Delegacja zagraniczna"),
            ("HO", "Home Office"), ("P", "Czasowe oddelegowanie"), ("PD", "Prace dodatkowe"),
            ("BC", "Backup"), ("BK", "Badanie kontrolne"), ("BO", "Badanie okresowe"),
            ("CW", "ƒÜwiczenia wojskowe"), ("DYS", "Dyspozycja"), ("MW", "mWolne"),
            ("NN", "Nieobecno≈õƒá nieusprawiedliwiona"), ("NU", "Nieobecno≈õƒá usprawiedliwiona"),
            ("NW", "Nieobecno≈õƒá do wyja≈õnienia"), ("O", "Odbi√≥r godzin"),
            ("OS", "Odbi√≥r dnia wolnego za ≈õwiƒôto"), ("S", "Szkolenie"), ("T", "Testy"),
            ("USW", "Zwolnienie z powodu si≈Çy wy≈ºszej (2 dni)"), ("Z", "RozwiƒÖzanie umowy")
        ]
        return {symbol for symbol, desc in symbol_lists}

    def apply_symbol_from_keyboard(self, special_symbol: str):
        """Aplikuje symbol z klawiatury, z obs≈ÇugƒÖ b≈Çƒôd√≥w i usuwania zdarze≈Ñ."""
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not selected_cells_data: return

        ABSENCE_SYMBOLS = {'U', 'UZ', 'UOP', 'CO', 'CR', 'UB', 'UM', 'UO', 'UOD', 'US', 'UT', 'UW', 'CRW', 'CSR', 'ZO',
                           'ZS', 'NN', 'NU', 'NW', 'O', 'OS', 'USW', 'Z'}

        if special_symbol.upper() in ABSENCE_SYMBOLS:
            if self._find_events_to_cancel({(c.get('uzytkownik_id'), c.get('date_str')) for c in selected_cells_data if
                                            c.get('uzytkownik_id') and c.get('date_str')}):
                if not self.delete_events_for_cells(selected_cells_data):
                    return

        updated_info = []
        error_messages = []
        for cell_data in selected_cells_data:
            new_symbol = self._predict_new_symbol(cell_data.get('symbol', ''), special_symbol, cell_data)
            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"üë§ {cell_data.get('uzytkownik_dane')}: {result.get('message', 'B≈ÇƒÖd zapisu.')}")
            except Exception as e:
                log_error(f"B≈ÇƒÖd w apply_symbol_from_keyboard: {e}")
                error_messages.append(f"üë§ {cell_data.get('uzytkownik_dane')}: B≈ÇƒÖd aplikacji: {e}")

        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Zastosowano symbol '{special_symbol}' dla {len(updated_info)} kom√≥rek.",
                                         4000)
            self.schedule_model.layoutChanged.emit()

        if error_messages:
            QMessageBox.warning(self, "B≈Çƒôdy podczas zapisu",
                                "WystƒÖpi≈Çy nastƒôpujƒÖce b≈Çƒôdy:\n\n" + "\n".join(error_messages))

    def apply_theme_settings(self, theme, font_family, font_size):
        """Stosuje wybrane ustawienia motywu z wykorzystaniem centralnych styl√≥w"""
        # Zapamiƒôtaj wybrane ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Zastosuj czcionkƒô do ca≈Çej aplikacji
        font = QFont(font_family, font_size)
        QApplication.setFont(font)

        # Zastosuj g≈Ç√≥wny styl dla ca≈Çego okna aplikacji
        self.setStyleSheet(AppStyles.get_main_window_style(theme))

        # Definicje styl√≥w
        button_style = AppStyles.get_button_style(theme)
        combo_style = AppStyles.get_combobox_style(theme)
        line_edit_style = AppStyles.get_line_edit_style(theme)
        list_style = AppStyles.get_list_style(theme)
        date_edit_style = AppStyles.get_date_edit_style(theme)
        checkbox_style = AppStyles.get_checkbox_style(theme)
        table_style = AppStyles.get_table_style(theme)
        left_panel_style = AppStyles.get_left_panel_style(theme)

        # Przyciski
        if hasattr(self, 'settings_button'): self.settings_button.setStyleSheet(button_style)
        if hasattr(self, 'refresh_button'): self.refresh_button.setStyleSheet(button_style)
        if hasattr(self, 'toggle_menu_button'): self.toggle_menu_button.setStyleSheet(button_style)
        if hasattr(self, 'staffing_details_button'): self.staffing_details_button.setStyleSheet(button_style)
        if hasattr(self, 'show_audit_button'): self.show_audit_button.setStyleSheet(button_style)
        if hasattr(self, 'schedule_control_button'): self.schedule_control_button.setStyleSheet(button_style)
        if hasattr(self, 'clear_filters_button'): self.clear_filters_button.setStyleSheet(button_style)
        if hasattr(self, 'manage_columns_button'): self.manage_columns_button.setStyleSheet(button_style)
        if hasattr(self, 'toggle_events_panel_button'): self.toggle_events_panel_button.setStyleSheet(button_style)
        if hasattr(self, 'insert_change_button'): self.insert_change_button.setStyleSheet(button_style)
        if hasattr(self, 'insert_symbol_button'): self.insert_symbol_button.setStyleSheet(button_style)
        if hasattr(self, 'cancel_delegation_button'): self.cancel_delegation_button.setStyleSheet(button_style)
        if hasattr(self, 'add_overtime_button'): self.add_overtime_button.setStyleSheet(button_style)

        # Pola wyboru (ComboBox)
        if hasattr(self, 'date_combo'): self.date_combo.setStyleSheet(combo_style)
        if hasattr(self, 'grupa_main_filter_combo'): self.grupa_main_filter_combo.setStyleSheet(combo_style)
        if hasattr(self, 'wydzial_combo'): self.wydzial_combo.setStyleSheet(combo_style)
        if hasattr(self, 'default_location_combo'): self.default_location_combo.setStyleSheet(combo_style)
        if hasattr(self, 'system_czasu_pracy_combo'): self.system_czasu_pracy_combo.setStyleSheet(combo_style)
        if hasattr(self, 'rola_combo'): self.rola_combo.setStyleSheet(combo_style)
        if hasattr(self, 'jezyk_combo'): self.jezyk_combo.setStyleSheet(combo_style)
        if hasattr(self, 'etat_combo'): self.etat_combo.setStyleSheet(combo_style)
        if hasattr(self, 'dtn_combo'): self.dtn_combo.setStyleSheet(combo_style)

        # Inne kontrolki
        if hasattr(self, '_left_panel'): self._left_panel.setStyleSheet(left_panel_style)
        if hasattr(self, 'przelozony_filter'): self.przelozony_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'topic_filter'): self.topic_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'name_filter'): self.name_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'przelozony_list'): self.przelozony_list.setStyleSheet(list_style)
        if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.setStyleSheet(list_style)
        if hasattr(self, 'date_from'): self.date_from.setStyleSheet(date_edit_style)
        if hasattr(self, 'date_to'): self.date_to.setStyleSheet(date_edit_style)
        if hasattr(self, 'meetings_checkbox'): self.meetings_checkbox.setStyleSheet(checkbox_style)
        if hasattr(self, 'trainings_checkbox'): self.trainings_checkbox.setStyleSheet(checkbox_style)
        if hasattr(self, 'overtime_checkbox'): self.overtime_checkbox.setStyleSheet(checkbox_style)

        # Aktualizacja modeli i tabel
        if hasattr(self, 'schedule_model'): self.schedule_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'events_model'): self.events_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'table'):
            if hasattr(self.table, 'employees_view'): self.table.employees_view.setStyleSheet(table_style)
            if hasattr(self.table, 'schedule_view'): self.table.schedule_view.setStyleSheet(table_style)
        if hasattr(self, 'events_table'): self.events_table.setStyleSheet(table_style)

        # Dodatkowa, jawna aktualizacja styl√≥w dla etykiet w panelu filtr√≥w
        if hasattr(self, '_left_panel'):
            # Przygotuj style dla obu typ√≥w etykiet
            title_style = AppStyles.get_label_style(theme, is_title=True)
            regular_label_style = AppStyles.get_label_style(theme, is_title=False)

            # Znajd≈∫ wszystkie etykiety w lewym panelu i zastosuj odpowiedni styl
            for label in self._left_panel.findChildren(QLabel):
                if label.text() == "Filtry":
                    label.setStyleSheet(title_style)
                else:
                    label.setStyleSheet(regular_label_style)

        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            self.staffing_details_win.set_current_theme(self.is_dark_theme)

        if hasattr(self, 'table'):
            self._apply_dynamic_sizes()

    def closeEvent(self, event):
        """Obs≈Çuguje zamkniƒôcie aplikacji"""
        try:
            debug_print("=== ZAMYKANIE APLIKACJI TEAMFLOW ===")
            debug_print(f"Sesja trwa≈Ça od uruchomienia aplikacji")

            # NOWE: Wyczy≈õƒá filtr klawiatury
            self.cleanup_keyboard_filter()

            close_log_file()
        except:
            pass  # Ignoruj b≈Çƒôdy podczas zamykania
        finally:
            event.accept()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = WorkScheduleWindow()
    window.show()
    sys.exit(app.exec())
