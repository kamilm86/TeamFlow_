Tak, to zmienia postaƒá rzeczy. Je≈õli nie masz uprawnie≈Ñ do tworzenia tabel (nawet tymczasowych), to poprzednia metoda z MERGE i tabelƒÖ TEMP_... nie zadzia≈Ça (zwr√≥ci b≈ÇƒÖd ORA-01031: insufficient privileges).
Musimy zmieniƒá podej≈õcie na takie, kt√≥re operuje wy≈ÇƒÖcznie na docelowej tabeli. Mamy dwie g≈Ç√≥wne opcje:
 * Opcja SQL (Zalecana): Zmodyfikowanie zapytania INSERT tak, aby dla ka≈ºdego wiersza sprawdza≈Ço, czy rekord ju≈º istnieje (u≈ºywajƒÖc konstrukcji INSERT ... SELECT ... FROM DUAL WHERE NOT EXISTS). To dzia≈Ça w ramach executemany i nie wymaga tworzenia nowych obiekt√≥w.
 * Opcja Python (Alternatywna): Pobranie istniejƒÖcych kluczy do Pythona, przefiltrowanie DataFrame i wstawienie tylko "czystych" danych.
Zdecydowanie polecam Opcjƒô SQL, poniewa≈º jest bezpieczniejsza dla sp√≥jno≈õci danych i ≈Çatwiejsza do wdro≈ºenia w Twoim kodzie.
üõ†Ô∏è RozwiƒÖzanie: INSERT z warunkiem NOT EXISTS (bez tabeli tymczasowej)
Podmie≈Ñ funkcjƒô _custom_merge_insert na poni≈ºszƒÖ wersjƒô. Zosta≈Ça ona przepisana tak, aby nie tworzyƒá tabeli tymczasowej. Zamiast tego konstruuje sprytne zapytanie INSERT, kt√≥re samo pilnuje unikalno≈õci.
Zaktualizowany kod _custom_merge_insert
    def _custom_merge_insert(self, target_db: str, batch: pd.DataFrame, table: str, schema: str,
                             lookup_keys: List[str], conn) -> None:
        """
        Wstawia dane pomijajƒÖc duplikaty (Lookup) BEZ tworzenia tabel tymczasowych.
        U≈ºywa konstrukcji SQL 'INSERT ... WHERE NOT EXISTS'.
        """
        from sqlalchemy import text

        if not lookup_keys:
            # Standardowy insert je≈õli brak kluczy lookup
            batch.to_sql(table, conn, schema=schema, if_exists='append', index=False)
            return

        self.logger.info(f"Wstawianie z pominiƒôciem duplikat√≥w (metoda bez tabel tymczasowych).")

        # 1. Przygotowanie danych do wstawienia (lista s≈Çownik√≥w)
        # Zamieniamy NaN na None, aby baza przyjƒô≈Ça to jako NULL
        data_to_insert = batch.where(pd.notnull(batch), None).to_dict(orient='records')
        
        if not data_to_insert:
            return

        # 2. Budowanie zapytania SQL w zale≈ºno≈õci od bazy
        sql_query = ""

        # Pobranie nazw kolumn z DataFrame
        columns = list(batch.columns)
        quoted_cols = [f'"{col}"' for col in columns] # Nazwy kolumn w cudzys≈Çowach
        
        # Przygotowanie placeholder√≥w (bind variables)
        # W SQLAlchemy u≈ºywamy :nazwa_kolumny
        bind_vars = [f":{col}" for col in columns]

        if target_db.lower() == 'oracle':
            # --- ORACLE: INSERT SELECT FROM DUAL WHERE NOT EXISTS ---
            
            # Budujemy warunek WHERE (np. T."ID" = :ID AND T."DATA" = :DATA)
            where_clause_parts = []
            for key in lookup_keys:
                where_clause_parts.append(f'T."{key}" = :{key}')
            where_clause = " AND ".join(where_clause_parts)

            cols_str = ", ".join(quoted_cols)
            binds_str = ", ".join(bind_vars)

            # Magiczna konstrukcja dla Oracle:
            # Wstawiamy warto≈õci (:val1, :val2) pobierajƒÖc je z wirtualnej tabeli DUAL,
            # ale TYLKO JE≈öLI w tabeli docelowej NIE MA takiego klucza.
            sql_query = f"""
            INSERT INTO "{schema}"."{table}" T ({cols_str})
            SELECT {binds_str} FROM DUAL
            WHERE NOT EXISTS (
                SELECT 1 FROM "{schema}"."{table}" T
                WHERE {where_clause}
            )
            """

        elif target_db.lower() == 'sqlserver':
            # --- SQL SERVER: IF NOT EXISTS ... INSERT ---
            
            # Budujemy warunek (np. [ID] = @ID AND [DATA] = @DATA)
            # Uwaga: SQL Server u≈ºywa @ w T-SQL, ale SQLAlchemy mapuje :nazwa na parametry
            where_clause_parts = []
            for key in lookup_keys:
                where_clause_parts.append(f'TARGET.[{key}] = :{key}')
            where_clause = " AND ".join(where_clause_parts)
            
            cols_str = ", ".join([f"[{col}]" for col in columns])
            binds_str = ", ".join(bind_vars)

            sql_query = f"""
            IF NOT EXISTS (SELECT 1 FROM [{schema}].[{table}] AS TARGET WHERE {where_clause})
            BEGIN
                INSERT INTO [{schema}].[{table}] ({cols_str})
                VALUES ({binds_str})
            END
            """
            
        elif target_db.lower() == 'impala':
             # Impala nie obs≈Çuguje ≈Çatwo parametr√≥w w VALUES przy NOT EXISTS w ten spos√≥b.
             # Dla Impali bezpieczniej jest wr√≥ciƒá do standardowego append i liczyƒá na unikalno≈õƒá,
             # lub u≈ºyƒá metody filtrowania w Pythonie (kt√≥rƒÖ mogƒô opisaƒá, je≈õli u≈ºywasz Impali).
             self.logger.warning("Metoda lookup bez tabel tymczasowych dla Impali mo≈ºe byƒá wolna. U≈ºywam standardowego insert.")
             batch.to_sql(table, conn, schema=schema, if_exists='append', index=False)
             return

        # 3. Wykonanie masowe (Batch execution)
        try:
            # executemany w SQLAlchemy 2.0 robi siƒô przekazujƒÖc listƒô s≈Çownik√≥w jako drugi argument
            conn.execute(text(sql_query), data_to_insert)
            self.logger.info(f"Przetworzono partiƒô {len(data_to_insert)} rekord√≥w.")
            
        except Exception as e:
            self.logger.error(f"B≈ÇƒÖd podczas wstawiania warunkowego: {e}")
            raise

üí° Dlaczego to zadzia≈Ça?
 * Brak CREATE TABLE: Ca≈Ça operacja odbywa siƒô w jednym zapytaniu INSERT, do kt√≥rego masz uprawnienia (skoro mo≈ºesz wstawiaƒá dane).
 * Atomowo≈õƒá: Baza danych dla ka≈ºdego wiersza "w locie" sprawdza WHERE NOT EXISTS.
 * Wydajno≈õƒá: Chocia≈º jest to nieco wolniejsze ni≈º MERGE na ca≈Çej tabeli, przy executemany (kt√≥re SQLAlchemy optymalizuje pod spodem u≈ºywajƒÖc tablic parametr√≥w Oracle), jest to bardzo wydajne rozwiƒÖzanie.
‚ö†Ô∏è Wa≈ºna uwaga wydajno≈õciowa
Aby to rozwiƒÖzanie dzia≈Ça≈Ço szybko, kolumny zdefiniowane w lookup_keys (np. INITIATEDDATETIME) POWINNY mieƒá za≈Ço≈ºony INDEKS na bazie docelowej Oracle. Bez indeksu baza bƒôdzie musia≈Ça skanowaƒá ca≈ÇƒÖ tabelƒô dla ka≈ºdego wstawianego wiersza, co przy milionach rekord√≥w bƒôdzie bardzo wolne.
Je≈õli masz uprawnienia tylko do INSERT/SELECT, ale nie mo≈ºesz tworzyƒá indeks√≥w, a tabela jest du≈ºa, ten proces mo≈ºe zwolniƒá. Wtedy jedynym ratunkiem jest "Opcja Python" (filtrowanie danych przed wys≈Çaniem do bazy).
Daj znaƒá, czy to rozwiƒÖzanie ruszy≈Ço!
