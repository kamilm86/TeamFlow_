Masz caÅ‚kowitÄ… racjÄ™. Funkcja _map_data_types jest kluczowa i musi zostaÄ‡ naprawiona, ale nie jest to jedyny problem.
Logika, ktÃ³rÄ… widaÄ‡ w map_data_types (linie 351-363), jest zaprojektowana tak, aby zwracaÄ‡ obiekty typÃ³w SQLAlchemy (np. CLOB, VARCHAR(length)), co jest poprawne dla create_table_if_not_exists.
JednakÅ¼e, bÅ‚Ä…d Cannot interpret 'VARCHAR(length=19)' pojawia siÄ™ w metodzie insert_data w linii 1153, przed wywoÅ‚aniem create_table_if_not_exists.
ğŸš¨ Analiza BÅ‚Ä™dnego PrzepÅ‚ywu Danych
 * Linia 363 (map_data_types): Zwraca sÅ‚ownik column_types zawierajÄ…cy obiekty SQL Alchemy (np. sqlalchemy.sql.sqltypes.VARCHAR(19)). To jest poprawne.
 * Linia 1151 (insert_data): Odbiera ten sÅ‚ownik: dtype_dict = self.map_data_types(...). dtype_dict zawiera obiekty SQL Alchemy.
 * Linia 1153 (insert_data): Wykonuje: df_to_load = df_to_load.astype(dtype_dict).
 * BÅÄ„D: Funkcja pd.DataFrame.astype() NIE MOÅ»E uÅ¼ywaÄ‡ obiektÃ³w typÃ³w SQL Alchemy. Kiedy Pandas prÃ³buje przeksztaÅ‚ciÄ‡ obiekt VARCHAR(19) na ciÄ…g znakÃ³w, by uÅ¼yÄ‡ go jako typ, otrzymuje ciÄ…g typu 'VARCHAR(length=19)', ktÃ³rego nie potrafi zinterpretowaÄ‡, co powoduje bÅ‚Ä…d.
ğŸ› ï¸ Podsumowanie i Konkretny Plan Naprawy
Musisz wprowadziÄ‡ to, co napisaÅ‚em wczeÅ›niej (podziaÅ‚ sÅ‚ownika), ale z jednÄ… kluczowÄ… poprawkÄ… w Twojej implementacji map_data_types.
Krok 1: Poprawa map_data_types (KoniecznoÅ›Ä‡!)
W Twojej funkcji map_data_types uÅ¼ywasz VARCHAR z domyÅ›lnego importu (lub z sqlalchemy):
# Linia 360: Wymaga importu 'VARCHAR' (np. z sqlalchemy.sql.sqltypes)
column_types[col] = CLOB() if target_db == 'Oracle' else VARCHAR(types.MAX)
# Linia 362: Wymaga importu 'VARCHAR'
column_types[col] = base_types.get(dtype, VARCHAR(100)) 

Musisz upewniÄ‡ siÄ™, Å¼e w pliku, gdzie jest DatabaseManager (lub map_data_types), masz zaimportowane wymagane typy z SQLAlchemy:
from sqlalchemy.sql.sqltypes import CLOB, VARCHAR, Integer, Float, DateTime, Date # itd.

Bez tego, kod w linii 360 i 362 rzuciÅ‚by bÅ‚Ä…d NameError. ZakÅ‚adam, Å¼e ten import masz, wiÄ™c ta funkcja jest poprawna dla generowania typÃ³w SQL.
Krok 2: Naprawa insert_data (Konkretna modyfikacja)
Naprawiamy liniÄ™ 1153, rozdzielajÄ…c logikÄ™. PoniewaÅ¼ map_data_types jest poprawna dla SQL, uÅ¼ywamy jej wyniku tylko do tworzenia tabeli.
# --- Fragment insert_data (Linia 1150 i dalej) ---

# 1. Mapowanie typÃ³w dla SQL (CREATE TABLE)
# Ten sÅ‚ownik zawiera obiekty SQL Alchemy: VARCHAR(19), CLOB, etc.
sqlalchemy_dtype_dict = self.map_data_types(df_to_load, target_db) 

# 2. Utworzenie sÅ‚ownika typÃ³w Pandasa/NumPy (do df.astype())
# Ta mapa (Linia 334) jest uÅ¼ywana do konwersji typÃ³w Pandasa/NumPy na inne typy Pandasa/NumPy.
# Tworzymy sÅ‚ownik przejÅ›ciowy dla astype(). 
# Musisz stworzyÄ‡ prosty sÅ‚ownik Pandas/NumPy na podstawie typu kolumny df.
numpy_dtype_dict = {}
for col_name in df_to_load.columns:
    # UÅ¼ywamy prostych typÃ³w Pandasa do konwersji
    original_dtype = df_to_load[col_name].dtype.name
    
    # PrÃ³bujemy znaleÅºÄ‡ odpowiednik w mapowaniu typÃ³w (Linia 334)
    if original_dtype in self.type_mappings[target_db]:
        # np. 'int64' -> 'int'
        numpy_dtype_dict[col_name] = self.type_mappings[target_db][original_dtype]
    # Dla stringÃ³w i dat, ktÃ³re zostaÅ‚y juÅ¼ wstÄ™pnie przeksztaÅ‚cone
    elif 'object' in original_dtype:
         # Obiekty powinny zostaÄ‡ jako 'object' lub 'str' 
         numpy_dtype_dict[col_name] = 'str' 
    elif 'datetime' in original_dtype:
         numpy_dtype_dict[col_name] = 'datetime64[ns]'
    # Inne typy pozostajÄ… jak sÄ… (np. float64)

self.logger.info(f"Wykonanie df_to_load.astype()")
# ğŸ’¥ POPRAWKA: UÅ¼ycie sÅ‚ownika typÃ³w, ktÃ³re Pandas rozumie
df_to_load = df_to_load.astype(numpy_dtype_dict) 
self.logger.info(f"df_to_load.astype(numpy_dtype_dict) - done")

# 3. Przekazanie TYPÃ“W SQLALCHEMY do tworzenia tabeli (poprawna sekwencja)
# UÅ¼ywamy tu sÅ‚ownika typÃ³w SQLALCHEMY!
if not self.create_table_if_not_exists(engine, sqlalchemy_dtype_dict, df_to_load, table_name, schema, target_db):
# ...

Wniosek: Zostaw funkcjÄ™ map_data_types takÄ…, jaka jest. Napraw insert_data, aby rozdzieliÅ‚a typy SQL Alchemy od typÃ³w Pandasa/NumPy, uÅ¼ywajÄ…c tych drugich w astype().
