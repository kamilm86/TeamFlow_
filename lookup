Absolutnie. Widz, 偶e masz dobrze zorganizowan klas DatabaseManager i u偶ywasz zaawansowanych technik takich jak batching, dynamiczne mapowanie typ贸w danych (map_data_types), obsug pocze i r贸偶ne strategie wstawiania (Oracle, SQL Server, Impala).
Poni偶ej przedstawiam peny kod metody insert_data, czcy Twoj oryginaln logik z proponowanym mechanizmem lookup/MERGE i korzystajcy z Twoich istniejcych pomocniczych metod (jak te, kt贸re wida na zdjciach).
Ze wzgldu na to, 偶e nie mam dostpu do penej klasy i wszystkich Twoich metod, zao偶yem istnienie i poprawno Twoich wewntrznych metod:
 * _get_engine
 * self.handle_nulls
 * self.standardize_column_names
 * self.map_data_types
 * self.check_column_size
 * self.create_table_if_not_exists
 * self._custom_merge_insert (wklejona w poprzedniej odpowiedzi)
З Peny kod metody insert_data (z Lookup/Merge)
import pandas as pd
import numpy as np
import gc
from typing import List, Optional

# Zao偶enie: Poni偶sza funkcja znajduje si w klasie DatabaseManager
def insert_data(self, df: pd.DataFrame, target_db: str, table_name: str, 
                schema: str, if_exists: str = 'append', batch_size: int = 1000000, 
                verbose: bool = True, use_fast_executemany: bool = True, 
                lookup_keys: Optional[List[str]] = None) -> None:
    
    """
    Wstawia dane z DataFrame do bazy docelowej (target_db).
    Obsuguje batching, czyszczenie danych, mapowanie typ贸w oraz opcjonalny lookup (MERGE/NOT EXISTS).
    
    Args:
        df (pd.DataFrame): DataFrame do wstawienia.
        target_db (str): Nazwa bazy docelowej (np. 'Oracle', 'SQLServer', 'Impala').
        table_name (str): Nazwa tabeli docelowej.
        schema (str): Nazwa schematu docelowego.
        if_exists (str): Jak obsu偶y istniejc tabel ('append', 'replace').
        batch_size (int): Liczba rekord贸w w pojedynczej partii.
        verbose (bool): Czy logowa postp.
        use_fast_executemany (bool): U偶ycie optymalizacji dla SQL Server.
        lookup_keys (Optional[List[str]]): Lista kluczy kolumn do u偶ycia w lookup (INSERT WHERE NOT EXISTS).
                                           Jeli None, u偶ywa standardowego INSERT/APPEND.
    """

    self.logger.info(f"Rozpoczynanie wstawiania do {target_db}.{schema}.{table_name} (Liczba wierszy: {len(df)})")

    # 1. Przygotowanie: Pobranie Engine i Poczenie
    engine = self._get_engine(target_db) # Zakadam, 偶e ta metoda dziaa
    
    try:
        with engine.connect() as connection:
            self.logger.info("Pomylnie utworzone poczenie z baz docelow.")
            
            # Ustawienia transakcyjne (jak wida na Twoim zdjciu)
            # W SQL Server, te ustawienia mog by wa偶ne
            if target_db == 'SQLServer':
                connection.execute("SET LOCK_TIMEOUT 1200000")
                connection.execute("SET TEXTSIZE 66000000")
                connection.execute("SET TRANSACTION ISOLATION LEVEL READ COMMITTED")
                connection.execute("SET XACT_ABORT ON") # Wa偶ne dla transakcji

            # 2. Czyszczenie i transformacje DataFrame
            df_to_load = df.copy() # Pracujemy na kopii

            # Czyszczenie nazw kolumn i typ贸w (jak na zdjciach)
            df_to_load = self.standardize_column_names(df_to_load) 
            df_to_load = self.handle_nulls(df_to_load)
            df_to_load = df_to_load.astype(str).replace({pd.NaT: None, 'nan': None}) # Typowe czyszczenie przed konwersj
            
            # Mapowanie typ贸w i pobranie kolumn_def dla CREATE TABLE
            dtype_dict = self.map_data_types(df_to_load, target_db) 
            df_to_load = df_to_load.astype(dtype_dict)
            
            # 3. Zarzdzanie schematem i tabel
            if not self.create_table_if_not_exists(self, engine, df_to_load, table_name, schema, target_db):
                 # Mo偶liwo obsugi 'replace' lub 'append' przez drop/truncate jeli if_exists != 'append'
                 if if_exists == 'replace':
                     connection.execute(f'DROP TABLE "{schema}"."{table_name}"')
                     self.create_table_if_not_exists(self, engine, df_to_load, table_name, schema, target_db)
                 elif if_exists == 'truncate':
                     connection.execute(f'TRUNCATE TABLE "{schema}"."{table_name}"')
            
            # Upewnienie si, 偶e rozmiary kolumn VARCHAR s wystarczajce
            self.check_column_size(engine, df_to_load, table_name, schema, target_db)
            
            # 4. adowanie partii (Batching)
            total_rows = len(df_to_load)
            if total_rows == 0:
                self.logger.warning("DataFrame jest pusty. Zakoczenie wstawiania.")
                return

            full_batches = total_rows // batch_size
            last_batch_size = total_rows % batch_size
            last_batch = None
            
            loaded_rows = 0
            
            # Przetwarzanie penych partii
            for batch_num in range(full_batches):
                start = batch_num * batch_size
                end = start + batch_size
                batch = df_to_load.iloc[start:end].copy()
                
                # Opcjonalne zbieranie mieci
                if verbose and batch_num % 10 == 0:
                    gc.collect()

                if verbose:
                    current_progress = (end / total_rows) * 100
                    self.logger.info(f"Wstawianie partii {batch_num+1}/{full_batches+1} ({len(batch)} wierszy) do {schema}.{table_name}. Postp: {current_progress:.2f}%")
                
                # --- WACIWE WSTAWIANIE PARTII Z U呕YCIEM NOWEJ METODY ---
                # U偶ywamy metody merge/insert, kt贸ra obsu偶y zar贸wno standardowy INSERT, jak i INSERT WHERE NOT EXISTS (lookup)
                self._custom_merge_insert(
                    target_db=target_db,
                    batch=batch,
                    table=table_name,
                    schema=schema,
                    lookup_keys=lookup_keys, # Klucze lookup s tu przekazywane
                    conn=connection
                )
                
                loaded_rows += len(batch)
                del batch
                gc.collect()


            # 5. Przetwarzanie ostatniej partii (jeli istnieje)
            if last_batch_size > 0:
                start = full_batches * batch_size
                last_batch = df_to_load.iloc[start:total_rows].copy()

                self.logger.info(f"Rozpoczynam przetwarzanie ostatniej partii (Liczba wierszy: {len(last_batch)})")
                gc.collect()
                
                # --- WACIWE WSTAWIANIE OSTATNIEJ PARTII Z U呕YCIEM NOWEJ METODY ---
                self._custom_merge_insert(
                    target_db=target_db,
                    batch=last_batch,
                    table=table_name,
                    schema=schema,
                    lookup_keys=lookup_keys, # Klucze lookup s tu przekazywane
                    conn=connection
                )
                
                loaded_rows += len(last_batch)
                del last_batch
                gc.collect()
            
            # 6. Kontrola i Logowanie Sukcesu
            self.logger.info(f"Zaadowano {loaded_rows} z {total_rows} wierszy.")
            if loaded_rows != total_rows:
                self.logger.warning(f"R贸偶nica w zaadowanej liczbie wierszy: {total_rows - loaded_rows} wierszy.")
            else:
                self.logger.info(f"Pomylnie zaadowano wszystkie {loaded_rows} wierszy do {schema}.{table_name}.")

    except Exception as e:
        self.logger.error(f"Krytyczny bd w metodzie insert_data: {e}")
        # Mo偶esz doda rollback, jeli u偶ywasz rcznych transakcji, ale przy with engine.connect() jest to czsto automatyczne.
        raise
    finally:
        if 'engine' in locals():
            self.logger.info("Zamykanie puli pocze dla bazy docelowej.")
            # engine.dispose() - zale偶y od Twojej implementacji get_engine

 Implementacja _custom_merge_insert
Pamitaj, aby wklei r贸wnie偶 kod funkcji _custom_merge_insert, kt贸r przedstawiem wczeniej, poniewa偶 jest ona kluczowa dla obsugi klucza lookup_keys:
# --- Implementacja funkcji z poprzedniej odpowiedzi (skr贸t) ---
def _custom_merge_insert(self, target_db: str, batch: pd.DataFrame, table: str, schema: str,
                         lookup_keys: List[str], conn) -> None:
    # ... (kod, kt贸ry tworzy tabel tymczasow, wykonuje MERGE/NOT EXISTS INSERT i usuwa tabel)
    pass # Pamitaj, aby wklei tu faktyczn implementacj

Oczywicie, oto peny kod dla funkcji _custom_merge_insert, kt贸ry implementuje logik INSERT WHERE NOT EXISTS (lookup) z u偶yciem tabeli tymczasowej.
Funkcja ta dynamicznie generuje i wykonuje kwerendy SQL (MERGE dla Oracle, INSERT INTO ... NOT EXISTS dla innych) po wczytaniu partii danych do tymczasowej tabeli w bazie docelowej.
import pandas as pd
import uuid
from typing import List

# --- Funkcja _custom_merge_insert (w klasie DatabaseManager) ---

def _custom_merge_insert(self, target_db: str, batch: pd.DataFrame, table: str, schema: str,
                         lookup_keys: List[str], conn) -> None:
    
    """
    Realizuje wstawienie rekord贸w, kt贸re nie istniej (lookup)
    z u偶yciem tabeli tymczasowej i kwerendy MERGE/NOT EXISTS.
    Jeli lookup_keys jest puste, u偶ywa standardowego INSERT (poprzez to_sql).
    
    Args:
        target_db (str): Nazwa bazy docelowej (np. 'Oracle', 'SQLServer', 'Impala').
        batch (pd.DataFrame): Partia danych do wstawienia.
        table (str): Nazwa tabeli docelowej.
        schema (str): Nazwa schematu docelowego.
        lookup_keys (List[str]): Lista kluczy kolumn do u偶ycia w lookup.
        conn: Aktywne poczenie SQLAlchemy (z engine.connect()).
    """
    
    # 1. Sprawdzenie, czy ma by u偶yty lookup
    if not lookup_keys:
        self.logger.info("Brak kluczy lookup. U偶ycie standardowego wstawiania (to_sql).")
        # Mo偶esz tutaj zastpi to_sql swoimi niestandardowymi funkcjami insertujcymi,
        # np. self._custom_insert_oracle(...)
        batch.to_sql(table, conn, schema=schema, if_exists='append', index=False)
        return

    # 2. Przygotowanie: Tabela tymczasowa
    # U偶ycie UUID gwarantuje unikalno nazwy tymczasowej tabeli
    temp_table_name = f"TEMP_{uuid.uuid4().hex}"
    
    self.logger.info(f"Tworzenie tymczasowej tabeli {temp_table_name} dla partii ({len(batch)} rekord贸w).")
    
    try:
        # U偶ycie to_sql do szybkiego utworzenia tabeli tymczasowej z danymi
        batch.to_sql(temp_table_name, conn, schema=schema, if_exists='replace', index=False)
        
        # Przygotowanie listy kolumn i nazw tabel w formacie SQL z cudzysowami
        # Zakadamy, 偶e u偶ywasz cudzysow贸w dla nazw kolumn generowanych przez to_sql i w bazie
        all_cols_quoted = [f'"{col}"' for col in batch.columns]
        all_cols_str = ", ".join(all_cols_quoted)
        
        # Przygotowanie warunku poczenia (JOIN)
        join_conditions = " AND ".join([f"T.\"{key}\" = S.\"{key}\"" for key in lookup_keys])
        
        sql_query = ""
        
        if target_db == 'Oracle':
            # --- Oracle: U偶ycie MERGE ---
            
            # W MERGE VALUES musimy odwoa si do kolumn w tabeli 藕r贸dowej (S)
            values_cols = ', '.join([f"S.{col}" for col in all_cols_quoted])
            
            sql_query = f"""
            MERGE INTO "{schema}"."{table}" T
            USING "{schema}"."{temp_table_name}" S
            ON ({join_conditions})
            WHEN NOT MATCHED THEN
                INSERT ({all_cols_str})
                VALUES ({values_cols})
            """
            
        elif target_db in ['SQLServer', 'Impala']:
            # --- SQL Server / Impala: U偶ycie NOT EXISTS (bezpieczna alternatywa) ---
            
            # Warunek NOT EXISTS
            where_not_exists = " AND ".join([f"T.\"{key}\" = S.\"{key}\"" for key in lookup_keys])
            
            # Wyb贸r kolumn z tabeli 藕r贸dowej (S)
            select_cols = ', '.join([f"S.{col}" for col in all_cols_quoted])
            
            sql_query = f"""
            INSERT INTO "{schema}"."{table}" ({all_cols_str})
            SELECT
                {select_cols}
            FROM
                "{schema}"."{temp_table_name}" S
            WHERE NOT EXISTS (
                SELECT 1
                FROM "{schema}"."{table}" T
                WHERE {where_not_exists}
            )
            """
        else:
            raise NotImplementedError(f"Lookup/MERGE nie jest zaimplementowany dla bazy danych: {target_db}")

        self.logger.info("Wykonanie operacji MERGE/NOT EXISTS INSERT.")
        conn.execute(sql_query)
        
    finally:
        # 3. Czyszczenie: Usunicie tabeli tymczasowej (ZAWSZE musi si wykona)
        self.logger.info(f"Usuwanie tymczasowej tabeli {temp_table_name}.")
        
        try:
            # U偶ycie parametru 'schema' jest wa偶ne
            conn.execute(f'DROP TABLE "{schema}"."{temp_table_name}"')
        except Exception as e:
            self.logger.error(f"Nie udao si usun tabeli tymczasowej {temp_table_name}: {e}")

Pamitaj, aby t funkcj umieci wewntrz Twojej klasy DatabaseManager i upewni si, 偶e ma dostp do:
 * self.logger (do logowania).
 * Bibliotek pandas, uuid oraz typing.
 * Aktywnego poczenia conn przekazanego z funkcji insert_data.

Aby w peni zaimplementowa zadanie z lookup_keys w pliku importy.py, musisz doda definicj klucza do sownika zadania oraz zaktualizowa metod handle_task w klasie TaskManager, tak aby przekazywaa ten klucz do db_manager.insert_data.
Poni偶ej przedstawiam, jak nale偶y zmodyfikowa kluczowe sekcje w pliku importy.py.
1. Modyfikacja klasy TaskManager (handle_task)
Musimy upewni si, 偶e w metodzie handle_task jest pobierany i przekazywany parametr lookup_keys. Zgodnie ze struktur Twojego kodu, ta modyfikacja dotyczy miejsca, w kt贸rym wywoywana jest funkcja db_manager.insert_data (okolice linii 157 na jednym z Twoich zdj).
# --- Fragment klasy TaskManager w pliku importy.py ---

def handle_task(self, task: dict):
    # ... (Tw贸j istniejcy kod: logowanie 'Running', pobieranie delete_temp, delete_query, fetch_sql, itp.)
    
    try:
        # ... (Tw贸j istniejcy kod: obsuga delete_temp, delete_query, fetch_sql)
        
        df = self.db_manager.fetch_data(
            source_db=task['source_db'],
            fetch_sql=fetch_sql,
            params=fetch_params,
            split_by_semicolon=True if task.get('split_by_semicolon') is not False else False
        )
        
        # ... (Tw贸j istniejcy kod: obsuga task.get('insert_missing') i 'merge')
        
        # --- SEKCJA WSTAWIANIA DANYCH (LINIA ~157) ---
        if 'destination_db' in task:
            self.logger.info(f"Wstawianie danych do bazy {task['destination_db']}...")
            
            #  NOWO: POBIERAMY KLUCZE LOOKUP Z DEFINICJI ZADANIA
            lookup_keys = task.get('lookup_keys', None)
            
            self.db_manager.insert_data(
                df=df,
                target_db=task['destination_db'],
                table_name=task['sql_table'],
                schema=task['schema'],
                batch_size=task.get('batch_size', 1500000), # U偶ycie Twojego domylnego batch_size
                if_exists=task.get('if_exists', 'append'),
                #  PRZEKAZANIE KLUCZY LOOKUP DO db_manager.insert_data
                lookup_keys=lookup_keys 
            )

        # ... (Tw贸j istniejcy kod: obsuga 'procedure' i 'merge')
        
        end_time = datetime.now()
        self.logger.info(f"Zakoczono pomylnie zadanie {task['name']}. Trwao: {end_time - start_time}")
        return True
        
    except Exception as e:
    # ... (Tw贸j istniejcy kod obsugi bd贸w)

2. Dodanie lookup_keys w definicji zadania (tasks)
W sekcji tasks = [...] (okolice linii 278), wystarczy teraz doda parametr lookup_keys do sownik贸w, dla kt贸rych chcesz wczy mechanizm insert-if-not-exists.
Przykad modyfikacji dla zadania 'KDD_CALL_ID_TEL' (linia 334):
# --- Fragment z definicji zada w pliku importy.py (metoda main) ---

tasks = [
    # ... Twoje istniejce zadania (BOX_CALL, OUT_CALL, itd.) ...
    
    {
        'name': 'KDD_CALL_ID_TEL',
        'delete_query': 'truncate table KDD_CALL_ID_TEL drop storage',
        'fetch_sql': f"SELECT * FROM [Korytko].[dbo].[KDD_CALL_ID_TEL]",
        'source_db': 'Korytko',
        'destination_db': 'Oracle',
        'sql_table': 'KDD_CALL_ID_TEL',
        'schema': 'UI_KRMBS67', # Zmienione na przykad
        'if_exists': 'append',
        
        #  DODAJ KLUCZ LOOKUP: ID_TEL i DATA s kluczami unikalnoci
        'lookup_keys': ['ID_TEL', 'INITIATEDDATETIME'], 
        
    },
    
    # ... pozostae zadania ...
]

Podsumowanie
Po wdro偶eniu sekcji 1 i 2, system bdzie dziaa nastpujco:
 * TaskManager.handle_task pobierze list kluczy (['ID_TEL', 'INITIATEDDATETIME']) ze sownika zadania.
 * Przeka偶e j do metody db_manager.insert_data.
 * db_manager.insert_data przeka偶e klucze dalej do _custom_merge_insert.
 * _custom_merge_insert u偶yje kluczy do utworzenia tymczasowej tabeli, a nastpnie wykona optymaln kwerend MERGE/INSERT WHERE NOT EXISTS w celu wstawienia tylko nowych rekord贸w.


