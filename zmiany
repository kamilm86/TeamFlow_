# W pliku db_m.py, w klasie DatabaseManager

def fetch_data(self, source_db: str, sql: str, params: Optional[Dict] = None) -> pd.DataFrame:
    """
    Wykonuje kompletny skrypt SQL: najpierw wszystkie polecenia modyfikujące 
    (DELETE, INSERT, etc.), a na końcu ostatnie polecenie SELECT, 
    którego wynik jest zwracany jako Pandas DataFrame.
    """
    engine = None
    self.logger.info(f"Rozpoczynam zadanie 'fetch_data' na bazie '{source_db}'...")
    try:
        # Krok 1: Przygotuj i podziel na części cały skrypt SQL
        all_commands = self.prepare_queries(sql, params, split_by_semicolon=True)
        if not all_commands:
            self.logger.warning("Brak poleceń SQL do wykonania.")
            return pd.DataFrame()

        # Krok 2: Rozdziel polecenia przygotowawcze od finalnego zapytania SELECT
        commands_to_execute = all_commands[:-1]
        select_query = all_commands[-1]
        
        # Krok 3: Pobierz silnik z puli połączeń
        engine = self.get_engine(source_db)

        # Krok 4: Wykonaj polecenia przygotowawcze (jeśli istnieją)
        if commands_to_execute:
            self.logger.info(f"Wykonywanie {len(commands_to_execute)} poleceń przygotowawczych...")
            with engine.connect() as connection:
                with connection.begin() as transaction: # Rozpocznij transakcję
                    try:
                        for command in commands_to_execute:
                            self.logger.info(f"Wykonywanie: {command[:100]}...")
                            connection.execute(text(command))
                        transaction.commit()
                        self.logger.info("Polecenia przygotowawcze wykonane pomyślnie.")
                    except Exception:
                        self.logger.error("Błąd podczas wykonywania poleceń przygotowawczych. Wycofuję zmiany (rollback)...")
                        transaction.rollback()
                        raise # Rzuć błąd dalej, aby zatrzymać cały proces
        else:
            self.logger.info("Brak poleceń przygotowawczych do wykonania.")

        # Krok 5: Wykonaj finalne zapytanie SELECT i pobierz dane w porcjach
        self.logger.info("Wykonywanie finalnego zapytania SELECT...")
        self.logger.info(f"Treść zapytania:\n{select_query}")
        
        df_list = []
        for chunk_df in pd.read_sql(select_query, engine, chunksize=50000):
            self.logger.info(f"Pobrano porcję {len(chunk_df)} wierszy.")
            df_list.append(chunk_df)

        if not df_list:
            self.logger.warning("Finalne zapytanie SELECT nie zwróciło żadnych danych.")
            return pd.DataFrame()
        
        final_df = pd.concat(df_list, ignore_index=True)
        self.logger.info(f"Pobrano łącznie {len(final_df)} wierszy.")
        return final_df

    except Exception as e:
        self.logger.error(f"Błąd krytyczny w metodzie fetch_data dla bazy {source_db}.", exc_info=True)
        raise
    finally:
        if engine:
            engine.dispose()
            self.logger.info(f"Zwolniono pulę połączeń dla silnika {source_db}.")
