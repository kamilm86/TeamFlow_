To wspaniała wiadomość! Skoro plik .exe ma teraz poprawnie "wrytą" wersję w zakładce Szczegóły (FileVersion), możemy użyć najbardziej profesjonalnej i niezawodnej metody weryfikacji.
Oto finalny kod, który realizuje dokładnie Twoje wymagania:
 * Skrypt skanuje katalog sieciowy w poszukiwaniu folderu z najwyższym numerem (np. 1.0.17).
 * Odczytuje wersję zaszytą w pliku lokalnym (TeamFlowApp.exe w Temp).
 * Porównuje numer folderu z numerem wewnątrz pliku.
 * Jeśli się różnią (lub pliku brak) -> Pobiera zawartość najnowszego folderu do Temp.
 * Uruchamia aplikację.
Instrukcja struktury folderów
Upewnij się, że na serwerze struktura wygląda tak (plik exe musi być wewnątrz folderu z numerem):
 * ...\USER_APP\TeamFlowApp\ (tu leży plik .bat)
   * 1.0.17\ -> w środku: TeamFlowApp.exe (i inne pliki jeśli są)
   * 1.0.18\ -> w środku: TeamFlowApp.exe
Finalny kod (Zapisz jako .bat)
@echo off
setlocal

:: --- 1. KONFIGURACJA ---
:: Mapujemy dysk sieciowy tymczasowo, aby uniknąć problemów ze ścieżkami UNC
pushd "%~dp0"

:: Nazwa Twojej aplikacji
set "APP_NAME=TeamFlowApp.exe"

:: Katalog sieciowy (tam gdzie leży ten skrypt .bat i foldery z wersjami)
set "NET_ROOT=%~dp0"
:: Usuwamy ewentualny backslash na końcu
if "%NET_ROOT:~-1%"=="\" set "NET_ROOT=%NET_ROOT:~0,-1%"

:: Ścieżka lokalna (TEMP) - zgodnie z Twoim życzeniem
set "LOCAL_DIR=%TEMP%\TeamFlowApp"
set "LOCAL_EXE=%LOCAL_DIR%\%APP_NAME%"

:: Plik tymczasowy dla skryptu PowerShell
set "PS_SCRIPT=%TEMP%\TeamFlow_Updater_Final.ps1"

:: --- 2. GENEROWANIE SKRYPTU POWERSHELL ---
:: Usuwamy stary skrypt pomocniczy jeśli istnieje
if exist "%PS_SCRIPT%" del "%PS_SCRIPT%"

:: Tworzymy kod PowerShell linijka po linijce
echo $ErrorActionPreference = 'Stop' >> "%PS_SCRIPT%"
echo $netRoot = $env:NET_ROOT >> "%PS_SCRIPT%"
echo $localDir = $env:LOCAL_DIR >> "%PS_SCRIPT%"
echo $localExe = $env:LOCAL_EXE >> "%PS_SCRIPT%"
echo $appName = $env:APP_NAME >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo try { >> "%PS_SCRIPT%"
echo     # 1. Znajdz folder z najwyzsza wersja na serwerze >> "%PS_SCRIPT%"
echo     $latestFolder = Get-ChildItem -Path $netRoot -Directory ^| Where-Object { $_.Name -match '^\d+\.\d+\.\d+$' } ^| Sort-Object { [version]$_.Name } -Descending ^| Select-Object -First 1 >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo     if (-not $latestFolder) { >> "%PS_SCRIPT%"
echo         Write-Host "[BLAD] Nie znaleziono folderow z wersjami na serwerze!" -ForegroundColor Red >> "%PS_SCRIPT%"
echo         exit 1 >> "%PS_SCRIPT%"
echo     } >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo     $latestVersion = $latestFolder.Name >> "%PS_SCRIPT%"
echo     Write-Host "Najnowsza wersja na serwerze (folder): $latestVersion" >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo     # 2. Sprawdz wersje pliku lokalnego (WYRYTA WERSJA) >> "%PS_SCRIPT%"
echo     $localVersion = "0.0.0" >> "%PS_SCRIPT%"
echo     if (Test-Path $localExe) { >> "%PS_SCRIPT%"
echo         try { >> "%PS_SCRIPT%"
echo             $localVersion = (Get-Item $localExe).VersionInfo.FileVersion >> "%PS_SCRIPT%"
echo             if (-not $localVersion) { $localVersion = "0.0.0" } >> "%PS_SCRIPT%"
echo         } catch { $localVersion = "0.0.0" } >> "%PS_SCRIPT%"
echo     } >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo     Write-Host "Zainstalowana wersja (plik exe):     $localVersion" >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo     # 3. Porownanie >> "%PS_SCRIPT%"
echo     $needsUpdate = $false >> "%PS_SCRIPT%"
echo     if ([version]$latestVersion -gt [version]$localVersion) { >> "%PS_SCRIPT%"
echo         $needsUpdate = $true >> "%PS_SCRIPT%"
echo         Write-Host "Wykryto nowsza wersje!" -ForegroundColor Yellow >> "%PS_SCRIPT%"
echo     } elseif (-not (Test-Path $localExe)) { >> "%PS_SCRIPT%"
echo         $needsUpdate = $true >> "%PS_SCRIPT%"
echo         Write-Host "Brak pliku lokalnie." -ForegroundColor Yellow >> "%PS_SCRIPT%"
echo     } else { >> "%PS_SCRIPT%"
echo         Write-Host "Aplikacja jest aktualna." -ForegroundColor Green >> "%PS_SCRIPT%"
echo     } >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo     # 4. Aktualizacja (jesli wymagana) >> "%PS_SCRIPT%"
echo     if ($needsUpdate) { >> "%PS_SCRIPT%"
echo         Write-Host "--- Pobieranie wersji $latestVersion ---" -ForegroundColor Cyan >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo         # Sprawdzenie zrodla >> "%PS_SCRIPT%"
echo         $sourcePath = $latestFolder.FullName >> "%PS_SCRIPT%"
echo         # Czy w folderze wersji jest bezposrednio plik EXE, czy podfolder? >> "%PS_SCRIPT%"
echo         # Skrypt zaklada, ze pliki leza bezposrednio w folderze '1.0.17' >> "%PS_SCRIPT%"
echo         if (-not (Test-Path (Join-Path $sourcePath $appName))) { >> "%PS_SCRIPT%"
echo              # Opcjonalnie: sprawdz czy nie ma tam podfolderu TeamFlowApp (dla kompilacji --onedir) >> "%PS_SCRIPT%"
echo              if (Test-Path (Join-Path $sourcePath "TeamFlowApp\$appName")) { >> "%PS_SCRIPT%"
echo                  $sourcePath = Join-Path $sourcePath "TeamFlowApp" >> "%PS_SCRIPT%"
echo              } else { >> "%PS_SCRIPT%"
echo                  throw "Nie znaleziono pliku $appName w folderze wersji $latestVersion" >> "%PS_SCRIPT%"
echo              } >> "%PS_SCRIPT%"
echo         } >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo         # Zabij proces >> "%PS_SCRIPT%"
echo         Stop-Process -Name "TeamFlowApp" -ErrorAction SilentlyContinue >> "%PS_SCRIPT%"
echo         Start-Sleep -Seconds 1 >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo         # Utworz katalog >> "%PS_SCRIPT%"
echo         if (-not (Test-Path $localDir)) { New-Item -ItemType Directory -Path $localDir ^| Out-Null } >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo         # Kopiowanie (Zastapienie) >> "%PS_SCRIPT%"
echo         # Kopiujemy WSZYSTKO z folderu wersji (wazne dla --onedir) >> "%PS_SCRIPT%"
echo         Copy-Item -Path "$sourcePath\*" -Destination $localDir -Recurse -Force >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo         # Odblokowanie pliku (Kluczowe dla CyberArk/Windows) >> "%PS_SCRIPT%"
echo         Get-ChildItem -Path $localDir -Recurse ^| Unblock-File >> "%PS_SCRIPT%"
echo         Write-Host "Aktualizacja zakonczona." -ForegroundColor Green >> "%PS_SCRIPT%"
echo     } >> "%PS_SCRIPT%"
echo } catch { >> "%PS_SCRIPT%"
echo     Write-Host "[BLAD KRYTYCZNY] $($_.Exception.Message)" -ForegroundColor Red >> "%PS_SCRIPT%"
echo     exit 1 >> "%PS_SCRIPT%"
echo } >> "%PS_SCRIPT%"

:: --- 3. URUCHOMIENIE SKRYPTU POWERSHELL ---
powershell -NoProfile -ExecutionPolicy Bypass -File "%PS_SCRIPT%"

:: Obsługa błędu skryptu
if %errorlevel% NEQ 0 (
    echo.
    echo [ERROR] Wystapil blad podczas aktualizacji.
    pause
)

:: Sprzątanie po sobie
del "%PS_SCRIPT%" >nul 2>&1

:: --- 4. START APLIKACJI ---
echo.
if exist "%LOCAL_EXE%" (
    echo [INFO] Uruchamianie aplikacji...
    :: start "" uruchamia aplikację w tle i zamyka okno CMD
    start "" "%LOCAL_EXE%"
) else (
    echo [BLAD] Plik aplikacji nie zostal odnaleziony: %LOCAL_EXE%
    pause
)

popd
endlocal

Najważniejsze cechy tego rozwiązania:
 * Czyta prawdziwą wersję: Używa komendy (Get-Item ...).VersionInfo.FileVersion, więc sprawdza to, co faktycznie jest w pliku .exe na dysku lokalnym.
 * Porównuje z folderem: Porównuje to z nazwą folderu na serwerze (np. 1.0.17). Jeśli folder ma wyższy numer -> aktualizuje.
 * Inteligentne ścieżki: Skrypt sam sprawdza, czy plik exe leży bezpośrednio w folderze 1.0.17, czy może w podfolderze 1.0.17\TeamFlowApp (co zdarza się przy kompilacji folderowej), i kopiuje odpowiednie pliki.
 * Bezpiecznik CyberArk: Zawiera Unblock-File, który jest niezbędny, by system pozwolił uruchomić plik po pobraniu.
