import sys
import time
from datetime import datetime, timedelta, date
from PySide6.QtWidgets import (QApplication, QMainWindow, QTableWidget, QTableWidgetItem, QTableView, QItemDelegate,
                              QVBoxLayout, QHBoxLayout, QWidget, QLabel, QComboBox, QCompleter,
                              QPushButton, QHeaderView, QAbstractItemView, QListWidget,
                              QListWidgetItem, QLineEdit, QDialog, QCheckBox, QFrame, QDateEdit,
                              QFormLayout, QDialogButtonBox, QMessageBox, QSplitter, QStyledItemDelegate, QStyle,
                              QGridLayout, QSizePolicy, QTableWidgetSelectionRange)
from PySide6.QtCore import Qt, QThread, Signal, QDate, QTimer, QPoint, QModelIndex, QRect, QEvent, QItemSelectionModel, QAbstractTableModel, QObject
from PySide6.QtGui import QShortcut, QKeySequence, QFont, QColor, QIcon, QPixmap, QPainter, QPolygon, QBrush, QPen, QLinearGradient, QRadialGradient, QStandardItem, QStandardItemModel

from db_connector import DatabaseConnector, get_modifier_id
from theme_dialog import ThemeSettingsDialog, InsertSymbolDialog, ScheduleChangeDialog
from settings_db import SettingsDatabase
from data_provider_v2 import DataProviderV2
from styles import AppStyles
from progress_dialog import LoadingProgressDialog, show_loading_dialog_async
from column_select_dialog import ColumnSelectDialog
from column_definitions import ColumnDefinitions

from schedule_model import ScheduleTableModel
from events_model import EventsTableModel
from split_table_view import SplitTableView
from schedule_delegates import OvertimeItemDelegate
from events_delegates import ButtonDelegate

# POPRAWKA: Dodaj import funkcji debug
from debug_utils import debug_print, log_warning, log_error, setup_logging, close_log_file

from symbol_parser import parse_symbol, build_symbol, get_symbol_description
import atexit

# Konfiguracja logowania - dostosuj wedug potrzeb
def configure_logging():
    """Konfiguruje system logowania aplikacji"""
    setup_logging(
        log_to_file=True,           # Zapisuj do pliku
        log_to_console=True,        # Wywietlaj w konsoli
        log_file_path=None,         # Automatyczna cie偶ka (logs/teamflow_YYYY-MM-DD.log)
        max_file_size=10*1024*1024, # 10MB maksymalny rozmiar pliku
        max_files=5                 # Maksymalnie 5 plik贸w archiwanych
    )
    
    # Automatyczne zamknicie pliku log贸w przy wyjciu z aplikacji
    atexit.register(close_log_file)

# Wywoaj konfiguracj na pocztku
configure_logging()


class ScheduleKeyboardFilter(QObject):
    """
    Dedykowany filtr zdarze klawiatury dla tabeli grafiku
    z obsug dwucyfrowych godzin
    """

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window

        # NOWE: Bufor dla dwucyfrowych godzin
        self._digit_buffer = ""
        self._buffer_timer = QTimer()
        self._buffer_timer.setSingleShot(True)
        self._buffer_timer.timeout.connect(self._clear_buffer)
        self._buffer_timeout = 1500  # 1.5 sekundy na wpisanie drugiej cyfry

    def eventFilter(self, obj, event):
        """
        Filtr zdarze dla edycji klawiatury kom贸rek grafiku
        z obsug dwucyfrowych godzin
        """
        # Sprawd藕 czy to nasza tabela grafiku i zdarzenie klawiatury
        if (hasattr(self.main_window, 'table') and
                hasattr(self.main_window.table, 'schedule_view') and
                obj == self.main_window.table.schedule_view and
                event.type() == QEvent.KeyPress):

            # Sprawd藕 uprawnienia u偶ytkownika
            if (not hasattr(self.main_window, 'current_user_role') or
                    self.main_window.current_user_role != "Pracownik WPR"):
                return False

            key = event.key()

            # KLUCZOWE ZABEZPIECZENIE: Sprawd藕 czy zaznaczone kom贸rki s edytowalne
            if not self._validate_selected_cells():
                # Zablokuj WSZYSTKIE klawisze jeli kom贸rki nie s edytowalne
                if (Qt.Key_0 <= key <= Qt.Key_9 or
                        key == Qt.Key_Delete or
                        key == Qt.Key_Backspace or
                        key == Qt.Key_Space or
                        key == Qt.Key_Enter or
                        key == Qt.Key_Return or
                        (Qt.Key_A <= key <= Qt.Key_Z)):
                    return True  # Zablokuj zdarzenie

            # NOWA LOGIKA: Obsuga cyfr z buforem
            if Qt.Key_0 <= key <= Qt.Key_9:
                digit = key - Qt.Key_0
                self._handle_digit_input(digit)
                return True  # Zdarzenie zostao obsu偶one

            # Obsu偶 klawisze specjalne
            elif key == Qt.Key_Delete or key == Qt.Key_Backspace:
                # Usu symbol z zaznaczonych kom贸rek
                self.main_window.clear_selected_cells()
                self._clear_buffer()  # Wyczy bufor
                return True

            elif key == Qt.Key_Escape:
                # Wyczy zaznaczenie i bufor
                self._clear_buffer_silent()  # Zatrzymaj timer bez wykonywania akcji
                if hasattr(self.main_window.table, 'schedule_view'):
                    self.main_window.table.schedule_view.clearSelection()
                return True

            # BLOKUJ WSZYSTKIE INNE KLAWISZE w kom贸rkach grafiku
            elif (Qt.Key_A <= key <= Qt.Key_Z or
                  key == Qt.Key_Space or
                  key == Qt.Key_Enter or
                  key == Qt.Key_Return or
                  key == Qt.Key_Tab):
                return True  # Zablokuj zdarzenie

        # Przeka偶 zdarzenie dalej
        return False

    def _handle_digit_input(self, digit):
        """
        POPRAWIONA METODA: Obsuguje wprowadzanie cyfr bez podw贸jnych dialog贸w
        """
        # Dodaj cyfr do bufora
        self._digit_buffer += str(digit)

        debug_print(f"Wprowadzono cyfr: {digit}, bufor: '{self._digit_buffer}'")

        # Sprawd藕 czy mamy kompletn godzin
        hour = None
        should_execute = False

        if len(self._digit_buffer) == 1:
            # Pierwsza cyfra - sprawd藕 czy to mo偶e by jednocyfrowa godzina (0-9)
            # lub pocztek dwucyfrowej (1 lub 2)
            first_digit = int(self._digit_buffer)

            if first_digit >= 3:
                # 3-9: Na pewno jednocyfrowa godzina - wykonaj natychmiast
                hour = first_digit
                should_execute = True
                self._clear_buffer_silent()  # Wyczy bez wykonywania akcji
            else:
                # 0, 1, 2: Mo偶e by jednocyfrowa lub pocztek dwucyfrowej
                # Czekaj na drug cyfr przez okrelony czas
                self._buffer_timer.start(self._buffer_timeout)
                return  # Nie wykonuj jeszcze akcji

        elif len(self._digit_buffer) == 2:
            # Druga cyfra - zatrzymaj timer i sprawd藕 czy tworzy prawidow godzin
            self._buffer_timer.stop()  # KLUCZOWE: Zatrzymaj timer!

            potential_hour = int(self._digit_buffer)

            if 0 <= potential_hour <= 23:
                hour = potential_hour
            else:
                # Nieprawidowa godzina - u偶yj tylko pierwsz cyfr
                hour = int(self._digit_buffer[0])

            should_execute = True
            self._clear_buffer_silent()  # Wyczy bez wykonywania akcji

        else:
            # Bufor za dugi - wyczy i u偶yj ostatni cyfr
            self._buffer_timer.stop()  # Zatrzymaj timer
            hour = digit
            should_execute = True
            self._clear_buffer_silent()

        # Wykonaj akcj tylko jeli powinnimy
        if should_execute and hour is not None:
            debug_print(f"Wykonuj edycj dla godziny: {hour}")
            self.main_window.quick_edit_selected_cells(hour)

    def _clear_buffer_silent(self):
        """
        NOWA METODA: Czyci bufor bez wykonywania akcji
        """
        self._digit_buffer = ""
        if self._buffer_timer.isActive():
            self._buffer_timer.stop()

    def _clear_buffer(self):
        """
        POPRAWIONA METODA: Czyci bufor cyfr (wywoywana przez timer)
        """
        if self._digit_buffer:
            # Timer wygas - u偶yj pierwsz cyfr z bufora
            hour = int(self._digit_buffer[0])
            debug_print(f"Timeout bufora - u偶ywam pierwsz cyfr: {hour}")

            # Wyczy bufor PRZED wykonaniem akcji
            self._digit_buffer = ""
            self._buffer_timer.stop()

            # Wykonaj akcj
            self.main_window.quick_edit_selected_cells(hour)
        else:
            # Bufor pusty - po prostu wyczy
            self._digit_buffer = ""
            self._buffer_timer.stop()

    def _validate_selected_cells(self):
        """
        Sprawdza czy zaznaczone kom贸rki mo偶na edytowa
        (zachowana bez zmian)
        """
        try:
            # Pobierz zaznaczone kom贸rki
            selected_cells_data = self.main_window.table.get_data_for_selected_cells()

            if not selected_cells_data:
                return False

            editable_cells = 0
            invalid_cells = []

            for cell_data in selected_cells_data:
                if not isinstance(cell_data, dict):
                    continue

                # Sprawd藕 czy to kom贸rka grafiku (ma date_str i uzytkownik_id)
                if 'date_str' not in cell_data or 'uzytkownik_id' not in cell_data:
                    continue

                # Sprawd藕 czy kom贸rka nie jest zablokowana
                user_name = cell_data.get('uzytkownik_dane', 'Nieznany')
                date_str = cell_data.get('date_str', '')

                # Sformatuj dat dla czytelnoci
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str

                # Sprawd藕 warunki edytowalnoci
                is_valid = self._is_cell_editable(cell_data)

                if is_valid:
                    editable_cells += 1
                else:
                    invalid_cells.append(f"{user_name} - {formatted_date}")

            # Jeli s niejedytowalne kom贸rki, poka偶 komunikat
            if invalid_cells and editable_cells == 0:
                # Wszystkie kom贸rki s nieedytowalne
                QMessageBox.warning(
                    self.main_window,
                    "Kom贸rki nieedytowalne",
                    f"Wybrane kom贸rki nie mog by edytowane z klawiatury:\n\n" +
                    "\n".join(invalid_cells[:10]) +  # Poka偶 max 10 przykad贸w
                    (f"\n... i {len(invalid_cells) - 10} wicej" if len(invalid_cells) > 10 else ""),
                    QMessageBox.Ok
                )
                return False

            elif invalid_cells and editable_cells > 0:
                # Czciowo edytowalne
                QMessageBox.information(
                    self.main_window,
                    "Czciowa edycja",
                    f"Edycja zostanie zastosowana tylko do {editable_cells} edytowalnych kom贸rek.\n\n" +
                    f"Pomijane kom贸rki ({len(invalid_cells)}):\n" +
                    "\n".join(invalid_cells[:5]) +  # Poka偶 max 5 przykad贸w
                    (f"\n... i {len(invalid_cells) - 5} wicej" if len(invalid_cells) > 5 else ""),
                    QMessageBox.Ok
                )
                return True

            return editable_cells > 0

        except Exception as e:
            debug_print(f"Bd walidacji kom贸rek: {e}")
            return False

    def _is_cell_editable(self, cell_data):
        """
        Sprawdza czy pojedyncza kom贸rka mo偶e by edytowana
        (zachowana bez zmian)
        """
        try:
            # Sprawd藕 czy kom贸rka ma wymagane dane
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')

            if not user_id or not date_str:
                return False

            # Sprawd藕 czy u偶ytkownik istnieje w active data
            if not str(user_id).isdigit():
                return False

            # Wszystkie sprawdzenia przeszy
            return True

        except Exception as e:
            debug_print(f"Bd sprawdzania edytowalnoci kom贸rki: {e}")
            return False


class CustomMultiComboBox(QComboBox):
    """Niestandardowy ComboBox z obsug wielokrotnego wyboru"""

    def __init__(self, parent=None):
        super().__init__(parent)

        # Inicjalizacja wszystkich zmiennych
        self._selected_items = set()
        self._select_all_text = "-Wszystkie-"
        self._popup_visible = False
        self._block_hide = False

        # Konfiguracja modelu
        self.setModel(QStandardItemModel(self))

        # Konfiguracja wygldu
        self.setEditable(True)
        self.lineEdit().setReadOnly(True)
        self.setEditText("-Wszystkie-")  # Pocztkowy tekst
        self.setStyleSheet("QComboBox::drop-down { border: none; }")
        self.setSizeAdjustPolicy(QComboBox.AdjustToContents)
        self.view().setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.view().setItemDelegate(QStyledItemDelegate())

        # Konfiguracja timera
        self._reopen_timer = QTimer(self)
        self._reopen_timer.setSingleShot(True)
        self._reopen_timer.setInterval(5)  # 5ms wystarczy
        self._reopen_timer.timeout.connect(self._reopen_popup)

        # Zainstaluj filtry zdarze i pocz sygnay
        self.lineEdit().installEventFilter(self)
        self.view().pressed.connect(self.handle_item_pressed)
        QApplication.instance().installEventFilter(self)

    def _reopen_popup(self):
        """Ponownie otwiera popup jeli powinien by otwarty"""
        if self._block_hide:
            self._block_hide = False
            self.showPopup()

    def eventFilter(self, obj, event):
        """
        Obserwuje zdarzenia dla r贸偶nych obiekt贸w:
        1. Dla lineEdit przechwytuje kliknicia mysz
        2. Dla aplikacji wykrywa kliknicie poza list
        """
        # Obsuga klikni w pole tekstowe (lineEdit)
        if obj == self.lineEdit() and event.type() == QEvent.MouseButtonPress:
            # Przekieruj kliknicie do g贸wnej kontrolki ComboBox
            self.mousePressEvent(event)
            return True  # Zatrzymaj dalsze przetwarzanie

        # Obsuga klikni poza list (dla caej aplikacji)
        if self._popup_visible and event.type() == QEvent.MouseButtonPress:
            # U偶ywaj globalPosition() zamiast przestarzaego globalPos()
            pos = event.globalPosition().toPoint()

            # Pobierz geometri listy i comboboxa
            view_rect = QRect(self.view().mapToGlobal(QPoint(0, 0)), self.view().size())
            combo_rect = QRect(self.mapToGlobal(QPoint(0, 0)), self.size())

            # Sprawd藕, czy kliknicie byo poza list i poza samym comboboxem
            if not view_rect.contains(pos) and not combo_rect.contains(pos):
                self._popup_visible = False
                self._block_hide = False  # Pozw贸l na zamknicie popupu
                super().hidePopup()
                return True  # Pochomy zdarzenie, jeli faktycznie zamknlimy popup

        return False  # Przeka偶 zdarzenie dalej

    def mousePressEvent(self, event):
        """Obsuga kliknicia na ComboBox - otwiera lub zamyka list"""
        if self._popup_visible:
            self._popup_visible = False
            self._block_hide = False  # Pozw贸l na zamknicie popupu
            self.hidePopup()
        else:
            self._popup_visible = True
            self.showPopup()

        # Nie przekazuj zdarzenia do QComboBox
        event.accept()

    def handle_item_pressed(self, index):
        """Obsuga nacinicia na element listy"""
        item = self.model().itemFromIndex(index)

        if not item:
            return

        # Jeli to element "Zaznacz wszystkie"
        if item.text() == self._select_all_text:
            all_checked = all(self.model().item(i).checkState() == Qt.Checked
                            for i in range(1, self.model().rowCount()))

            # Przecz stan - jeli wszystkie s zaznaczone, odznacz wszystkie
            new_state = Qt.Unchecked if all_checked else Qt.Checked

            # Ustaw stan dla wszystkich element贸w (poza "Zaznacz wszystkie")
            for i in range(1, self.model().rowCount()):
                self.model().item(i).setCheckState(new_state)
                text = self.model().item(i).text()
                if new_state == Qt.Checked:
                    self._selected_items.add(text)
                else:
                    self._selected_items.discard(text)
        else:
            # Przecz stan zaznaczenia dla zwykego elementu
            if item.checkState() == Qt.Checked:
                item.setCheckState(Qt.Unchecked)
                self._selected_items.discard(item.text())
            else:
                item.setCheckState(Qt.Checked)
                self._selected_items.add(item.text())

            # Aktualizuj stan elementu "Zaznacz wszystkie"
            if self.model().rowCount() > 0:
                all_checked = all(self.model().item(i).checkState() == Qt.Checked
                                for i in range(1, self.model().rowCount()))
                if self.model().item(0).text() == self._select_all_text:
                    self.model().item(0).setCheckState(Qt.Checked if all_checked else Qt.Unchecked)

        # KLUCZOWA ZMIANA: Przebudowa _selected_items na podstawie aktualnego stanu modelu
        self._rebuild_selected_items()

        # Aktualizuj wywietlany tekst
        self.update_display_text()

        # Odwie偶 widok
        self.view().viewport().update()

        # KLUCZOWA CZ: Zablokuj zamykanie popupu i zaplanuj jego przywr贸cenie
        self._block_hide = True
        self._reopen_timer.start()

        # Zatrzymaj dalsze przetwarzanie
        return True

    def _rebuild_selected_items(self):
        """Przebudowuje zbi贸r _selected_items na podstawie aktualnego stanu modelu"""
        self._selected_items.clear()
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item and item.checkState() == Qt.Checked:
                self._selected_items.add(item.text())

    def showPopup(self):
        """Poka偶 menu rozwijane"""
        # Ustawiamy flag PRZED pokazaniem popupu
        self._popup_visible = True

        # Ustaw szeroko widoku
        width = self.view().sizeHintForColumn(0) + 20  # Dodaj troch miejsca na margines
        width = min(width, 250)  # Ogranicz szeroko do maksymalnie 250 pikseli
        self.view().setMinimumWidth(width)

        # Pokazujemy popup
        super().showPopup()

    def hidePopup(self):
        """Ukryj popup z zabezpieczeniem przed automatycznym zamykaniem"""
        # Jeli ustawiona jest blokada, nie zamykaj popupu
        if self._block_hide:
            # Wykonaj tylko ukrycie, a potem zaplanuj ponowne pokazanie
            super().hidePopup()
            return

        # Normalny przypadek - ukryj popup i ustaw flag
        self._popup_visible = False
        super().hidePopup()

        # WA呕NE: Aktualizuj tekst po zamkniciu popupu
        self.update_display_text()

    # WA呕NE: Metoda, kt贸ra powstrzymuje automatyczne zamykanie popupu po klikniciu
    def setCurrentIndex(self, index):
        """Nadpisana metoda, aby zapobiec zamykaniu popupu"""
        if self._popup_visible:
            # Nie zmieniaj indeksu i nie zamykaj popupu
            pass
        else:
            # Standardowe zachowanie
            super().setCurrentIndex(index)

    def add_items(self, items):
        """Dodaje elementy do ComboBoxa"""
        self.clear()

        # Dodaj element "Zaznacz wszystkie"
        select_all_item = QStandardItem(self._select_all_text)
        select_all_item.setCheckState(Qt.Unchecked)
        select_all_item.setCheckable(True)
        self.model().appendRow(select_all_item)

        # Dodaj pozostae elementy
        for item_text in items:
            item = QStandardItem(item_text)
            item.setCheckState(Qt.Unchecked)
            item.setCheckable(True)
            self.model().appendRow(item)

        # Ustaw wywietlany tekst
        self.update_display_text()

    def clear(self):
        """Czyci list element贸w"""
        super().clear()
        self._selected_items.clear()
        self.setEditText("-Wszystkie-")  # Zmieniony tekst

    def clear_selection(self):
        """Czyci zaznaczenie"""
        self._selected_items.clear()
        for i in range(self.model().rowCount()):
            if i < self.model().rowCount():  # Dodatkowe sprawdzenie
                item = self.model().item(i)
                if item:
                    item.setCheckState(Qt.Unchecked)
        self.update_display_text()

    def get_selected_items(self):
        """
        Zwraca list zaznaczonych element贸w (poza 'Zaznacz wszystkie').
        POPRAWKA: Usunito niepotrzebny argument list_widget.

        Returns:
            list: Lista zaznaczonych element贸w
        """
        # WA呕NE: Przebuduj _selected_items dla pewnoci
        self._rebuild_selected_items()

        # Zwr贸 list z element贸w zbioru
        return list(self._selected_items)

    def select_items(self, items):
        """Zaznacza okrelone elementy"""
        self._selected_items = set(items)
        all_selected = True

        for i in range(1, self.model().rowCount()):  # Pomijamy pierwszy element
            if i < self.model().rowCount():  # Dodatkowe sprawdzenie
                item = self.model().item(i)
                if item:
                    if item.text() in items:
                        item.setCheckState(Qt.Checked)
                    else:
                        item.setCheckState(Qt.Unchecked)
                        all_selected = False

        # Ustaw stan dla elementu "Zaznacz wszystkie"
        if self.model().rowCount() > 0:
            item0 = self.model().item(0)
            if item0 and item0.text() == self._select_all_text:
                item0.setCheckState(Qt.Checked if all_selected else Qt.Unchecked)

        self.update_display_text()

    def update_display_text(self):
        """
        Aktualizuje tekst wywietlany w comboboxie na podstawie zaznaczonych element贸w.

        Wywietla:
        - "--- Wszystkie ---" gdy nie ma zaznaczonych element贸w lub gdy s zaznaczone wszystkie
        - "Wybrano {len(selected)} element贸w" gdy jest zaznaczona tylko cz element贸w
        """
        # WA呕NE: Przebuduj _selected_items dla pewnoci
        self._rebuild_selected_items()

        selected = list(self._selected_items)
        total_items = self.model().rowCount() - 1  # Odejmujemy element "Zaznacz wszystkie"

        # Sprawd藕, czy nie ma zaznaczonych element贸w lub wszystkie s zaznaczone
        if not selected or len(selected) == total_items:
            self.setEditText("-Wszystkie-")
        else:
            self.setEditText(f"Wybrano {len(selected)} element贸w")

class OvertimeItemDelegate(QStyledItemDelegate):
    """
    Niestandardowy delegat do rysowania kom贸rek tabeli.
    Wywietla subtelne znaczniki w prawym dolnym rogu:
    - Czerwony tr贸jkt dla nadgodzin
    - Biae k贸ko dla spotka/szkole

    Zoptymalizowana wersja, kt贸ra korzysta z dedykowanych flag zamiast deserializacji JSON.
    """

    def paint(self, painter, option, index):
        """
        Maluje kom贸rk z dodatkowymi ikonami dla nadgodzin, spotka i szkole.
        Bezpieczna wersja z obsug wszystkich typ贸w danych.
        """
        try:
            # Najpierw spr贸buj narysowa standardow kom贸rk
            super().paint(painter, option, index)

            # Bezpieczne pobieranie flag - u偶ywaj metody get() lub defaultowego konwertowania na bool
            from schedule_model import ROLE_HAS_MEETING, ROLE_HAS_OVERTIME
            has_overtime = bool(index.data(ROLE_HAS_OVERTIME))
            has_meeting_or_training = bool(index.data(ROLE_HAS_MEETING))

            # Jeli element ma jakiekolwiek oznaczenia
            if has_overtime or has_meeting_or_training:
                painter.save()
                # Wcz antyaliasing dla gadkich krawdzi
                painter.setRenderHint(QPainter.Antialiasing)

                # Okrel szeroko i pozycj znacznik贸w
                marker_width = 8  # Rozmiar znacznika
                marker_height = 8

                # Rysuj znacznik spotka/szkole (biae k贸ko) w g贸rnym prawym rogu
                if has_meeting_or_training:
                    # Oblicz pozycj w g贸rnym prawym rogu
                    top_right_x = option.rect.right() - marker_width - 2  # -2 to margines
                    top_right_y = option.rect.top() + 2  # +2 to margines

                    # Rysujemy k贸ko z biaym wypenieniem i czarn obw贸dk
                    painter.setBrush(QBrush(QColor(255, 255, 255, 240)))  # Biae wypenienie
                    painter.setPen(QPen(QColor(0, 0, 0, 220), 1.0))  # Czarna obw贸dka
                    painter.drawEllipse(
                        top_right_x,
                        top_right_y,
                        marker_width,
                        marker_height
                    )

                # Rysuj znacznik nadgodzin (czerwony tr贸jkt) w dolnym prawym rogu
                if has_overtime:
                    # Oblicz pozycj w dolnym prawym rogu
                    bottom_right_x = option.rect.right() - marker_width - 2  # -2 to margines
                    bottom_right_y = option.rect.bottom() - marker_height - 2  # -2 to margines

                    # Czerwony tr贸jkt z czarn obw贸dk
                    painter.setBrush(QBrush(QColor(220, 0, 0, 220)))  # Czerwone wypenienie
                    painter.setPen(QPen(Qt.black, 1.0))  # Czarna obw贸dka

                    triangle = QPolygon()
                    triangle.append(QPoint(bottom_right_x, bottom_right_y + marker_height))
                    triangle.append(QPoint(bottom_right_x + marker_width, bottom_right_y + marker_height))
                    triangle.append(QPoint(bottom_right_x + marker_width, bottom_right_y))
                    painter.drawPolygon(triangle)

                painter.restore()
        except Exception as e:
            # W przypadku bdu po prostu wywietl domylny wygld kom贸rki
            log_error(f"Bd podczas rysowania delegata: {e}")
            QStyledItemDelegate.paint(self, painter, option, index)

class WorkScheduleWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # Inicjalizacja bazy danych ustawie
        self.settings_db = SettingsDatabase()

        # Zaaduj ustawienia u偶ytkownika
        user_settings = self.settings_db.load_settings()

        # Zapisz ustawienia motywu z bazy danych
        self.is_dark_theme = user_settings['theme'] == 'dark'
        self.current_font = user_settings['font_family']
        self.current_font_size = user_settings['font_size']

        # Inicjalizacja DataProvider
        # self.data_provider = DataProvider()
        # ZMIANA: U偶ywaj nowego DataProvider
        from data_provider_v2 import DataProviderV2
        self.data_provider = DataProviderV2()

        self.statusBar().showMessage("Gotowy")

        # ZMODYFIKOWANE: U偶ywaj nowych definicji kolumn
        self.column_definitions = ColumnDefinitions()
        self.employee_columns = self.column_definitions.get_ui_display_columns()
        self.default_visible_columns = self.column_definitions.DEFAULT_VISIBLE_COLUMNS

        # Sprawd藕, czy mamy zapisane widoczne kolumny w ustawieniach
        saved_columns = user_settings.get('visible_columns')
        if saved_columns:
            # U偶ytkownik ma zapisane preferencje
            self.visible_columns = saved_columns
            debug_print(f"Zaadowano zapisane widoczne kolumny: {saved_columns}")
        else:
            # Pierwsze uruchomienie - u偶yj domylnych
            self.visible_columns = self.default_visible_columns.copy()
            debug_print(f"U偶ywam domylnych widocznych kolumn: {self.default_visible_columns}")

        # Podcz sygna zmiany danych
        self.data_provider.data_changed.connect(self.on_data_changed)

        self.setWindowTitle("TeamFlowApp")
        self.setGeometry(100, 100, 1200, 600)

        # Inicjalizacji zmiennej left_panel_visible
        self.left_panel_visible = True  # Domylnie panel jest widoczny

        # Flaga zabezpieczajca przed rekurencj w on_selection_changed
        self._updating_selection = False

        # Flaga kontrolujca cross-filtering
        self._cross_filtering_enabled = True

        # Zastosuj czcionk globalnie dla caej aplikacji
        font = QFont(self.current_font, self.current_font_size)
        QApplication.setFont(font)

        # Dane
        self.raw_data = []
        self.processed_data = {}
        self.last_modification_date = None
        self.all_events_data = []  # Bufor na wszystkie zdarzenia
        self.user_info_map = {}  # Mapowanie u偶ytkownik贸w na ich dane (wydzia, przeo偶ony, nazwa)

        # Inicjalizacja modeli danych
        self.schedule_model = ScheduleTableModel(self)
        self.events_model = EventsTableModel(self)

        # Ustawienie motywu dla modeli
        self.schedule_model.set_theme(self.is_dark_theme)
        self.events_model.set_theme(self.is_dark_theme)

        # Utworzenie interfejsu
        self.setup_ui()

        # Teraz, gdy interfejs jest ju偶 utworzony, mo偶emy poczy model z widokiem
        if hasattr(self, 'table') and hasattr(self, 'schedule_model'):
            # Ustaw model dla g贸wnej tabeli, jeli nie zosta jeszcze ustawiony
            if hasattr(self.table, '_model') and not self.table._model:
                self.table.set_model(self.schedule_model)

        if hasattr(self, 'events_table') and hasattr(self, 'events_model'):
            # Ustaw model dla tabeli zdarze
            self.events_table.setModel(self.events_model)

        # Konfiguracja delegat贸w
        from schedule_model import ROLE_HAS_MEETING, ROLE_HAS_OVERTIME
        overtime_delegate = OvertimeItemDelegate()
        self.table.schedule_view.setItemDelegate(overtime_delegate)

        button_delegate = ButtonDelegate()
        self.events_table.setItemDelegateForColumn(9, button_delegate)
        button_delegate.button_clicked.connect(self.delete_event_from_row)

        # Pobieranie pocztkowych danych
        self.current_date = QDate.currentDate()
        self.update_data(self.current_date.year(), self.current_date.month())

        # Ustaw daty filtrowania po inicjalizacji danych
        self.update_filter_dates()

        button_delegate = ButtonDelegate(parent=self, button_text="Usu", is_dark_theme=self.is_dark_theme)
        self.events_table.setItemDelegateForColumn(9, button_delegate)
        button_delegate.button_clicked.connect(self.delete_event_from_row)
        # Sprawd藕 uprawnienia u偶ytkownika - jeli zwr贸ci False, aplikacja si zamknie
        if not self.check_user_permissions():
            return
        # Konfiguruj edycj klawiatury (tylko dla Pracownik WPR)
        self.setup_keyboard_editing()
        # Zastosuj bazowy styl dla motywu ciemnego/jasnego przed utworzeniem UI
        self.apply_theme_settings(
            'dark' if self.is_dark_theme else 'light',
            self.current_font,
            self.current_font_size
        )

        # Wyczy tabel zdarze przy starcie
        self.clear_events_on_startup()

        # NOWE: Timer do debounce selection changes
        self._selection_timer = QTimer()
        self._selection_timer.setSingleShot(True)
        self._selection_timer.timeout.connect(self._handle_selection_change)
        self._selection_debounce_delay = 50  # 50ms delay

        debug_print("=== APLIKACJA TEAMFLOW URUCHOMIONA ===")
        debug_print(f"U偶ytkownik: {self.current_user_app_id} ({self.current_user_role})")
        debug_print(f"Motyw: {'ciemny' if self.is_dark_theme else 'jasny'}")
        debug_print(f"Czcionka: {self.current_font} {self.current_font_size}pt")

    def setup_keyboard_editing(self):
        """Konfiguruje edycj klawiatury dla kom贸rek grafiku"""
        # Sprawd藕 czy u偶ytkownik ma uprawnienia do edycji klawiatury
        if not hasattr(self, 'current_user_role') or self.current_user_role != "Pracownik WPR":
            debug_print("Edycja klawiatury wyczona - brak uprawnie")
            return

        # Utw贸rz dedykowany filtr klawiatury
        self.keyboard_filter = ScheduleKeyboardFilter(self)

        # Zainstaluj filtr zdarze dla tabeli grafiku
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            self.table.schedule_view.installEventFilter(self.keyboard_filter)
            debug_print("Wczono edycj klawiatury dla roli Pracownik WPR")

    def cleanup_keyboard_filter(self):
        """Czyci filtr klawiatury przy zamykaniu aplikacji"""
        if hasattr(self, 'keyboard_filter'):
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.removeEventFilter(self.keyboard_filter)
            del self.keyboard_filter
            debug_print("Wyczyszczono filtr klawiatury")

    def quick_edit_selected_cells(self, start_hour):
        """
        Szybka edycja zaznaczonych kom贸rek z klawiatury

        Args:
            start_hour (int): Godzina rozpoczcia (0-9)
        """
        try:
            # Sprawd藕 uprawnienia
            if not hasattr(self, 'current_user_role') or self.current_user_role != "Pracownik WPR":
                debug_print("Brak uprawnie do edycji klawiatury")
                return

            # Pobierz zaznaczone kom贸rki
            selected_cells_data = self.table.get_data_for_selected_cells()

            if not selected_cells_data:
                debug_print("Brak zaznaczonych kom贸rek do edycji")
                return

            # Filtruj tylko kom贸rki grafiku (nie kolumny pracownik贸w)
            schedule_cells = []
            for cell_data in selected_cells_data:
                if isinstance(cell_data, dict) and 'date_str' in cell_data and 'uzytkownik_id' in cell_data:
                    schedule_cells.append(cell_data)

            if not schedule_cells:
                debug_print("Brak kom贸rek grafiku do edycji")
                return

            debug_print(f"Szybka edycja: {len(schedule_cells)} kom贸rek, godzina start: {start_hour}")

            # Pogrupuj kom贸rki dla lepszego komunikatu potwierdzenia
            grouped_changes = {}
            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                user_name = cell_data.get('uzytkownik_dane', '')
                date_str = cell_data.get('date_str')

                # Formatuj dat
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str

                user_key = (user_id, user_name)
                if user_key not in grouped_changes:
                    grouped_changes[user_key] = []
                grouped_changes[user_key].append(formatted_date)

            # Przygotuj komunikat potwierdzenia
            changes_info = f"Zmiana godziny rozpoczcia na {start_hour}:00 dla:\n\n"
            for (user_id, user_name), dates in grouped_changes.items():
                changes_info += f" {user_name}:\n"
                dates_str = ", ".join(sorted(dates))
                changes_info += f"    {dates_str}\n\n"

            changes_info += f"cznie: {len(schedule_cells)} kom贸rek"

            # Poka偶 potwierdzenie
            reply = QMessageBox.question(
                self,
                "Potwierdzenie szybkiej edycji",
                changes_info,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )

            if reply == QMessageBox.Yes:
                self._apply_quick_changes(schedule_cells, start_hour)

        except Exception as e:
            log_error(f"Bd podczas szybkiej edycji: {e}")
            QMessageBox.critical(
                self,
                "Bd",
                f"Wystpi bd podczas edycji: {str(e)}",
                QMessageBox.Ok
            )

    def _apply_quick_changes(self, schedule_cells, start_hour):
        """
        UPROSZCZONA WERSJA: Przekazuje tylko cyfr do bazy i pobiera gotowy symbol
        """
        try:
            successful_updates = 0
            failed_updates = 0
            error_messages = []
            affected_pairs = []

            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                nr_kadrowy = cell_data.get('nr_kadrowy')

                if not user_id or not date_str or not nr_kadrowy:
                    failed_updates += 1
                    if not nr_kadrowy:
                        error_messages.append(f"Brak numeru kadrowego dla u偶ytkownika {user_id}")
                    continue

                try:
                    year, month, day = date_str.split('-')
                    date_obj = f"{year}-{month}-{day}"

                    # MAKSYMALNE UPROSZCZENIE: Przeka偶 tylko cyfr
                    result = self._call_import_changes_procedure(
                        nr_kadrowy=nr_kadrowy,
                        rok=int(year),
                        miesiac=int(month),
                        data=date_obj,
                        symbol=str(start_hour)  # TYLKO CYFRA!
                    )

                    if result['success']:
                        successful_updates += 1
                        affected_pairs.append((user_id, date_str))
                        debug_print(f"Sukces edycji klawiatury: {user_id}, {date_str}, cyfra: {start_hour}")
                    else:
                        failed_updates += 1
                        error_msg = result.get('message', 'Nieznany bd')
                        error_messages.append(f"{nr_kadrowy} ({date_str}): {error_msg}")
                        debug_print(f"Bd edycji klawiatury: {error_msg}")

                except Exception as e:
                    failed_updates += 1
                    error_messages.append(f"{nr_kadrowy} ({date_str}): {str(e)}")
                    log_error(f"Bd procedury dla {user_id}, {date_str}: {e}")

            # Odwie偶 zmienione kom贸rki
            if successful_updates > 0 and affected_pairs:
                self._refresh_data_after_symbol_changes(affected_pairs)

            # Poka偶 wyniki
            self._show_keyboard_edit_results(successful_updates, failed_updates, error_messages, start_hour)

        except Exception as e:
            log_error(f"Bd podczas edycji klawiatury: {e}")
            QMessageBox.critical(
                self,
                "Bd",
                f"Wystpi bd podczas edycji klawiatury: {str(e)}",
                QMessageBox.Ok
            )

    def _show_keyboard_edit_results(self, successful_updates, failed_updates, error_messages, start_hour):
        """
        Pokazuje wyniki edycji klawiatury - uproszczone komunikaty
        """
        if successful_updates > 0:
            message = f"Pomylnie zaktualizowano {successful_updates} kom贸rek (cyfra: {start_hour})"

            if failed_updates > 0:
                message += f"\n\n锔 {failed_updates} aktualizacji nie powiodo si"
                if error_messages:
                    message += ":\n" + "\n".join(error_messages[:3])  # Poka偶 tylko 3 bdy
                    if len(error_messages) > 3:
                        message += f"\n... i {len(error_messages) - 3} wicej bd贸w"

            QMessageBox.information(
                self,
                "Edycja klawiatury",
                message,
                QMessageBox.Ok
            )
        else:
            message = f"Nie udao si zaktualizowa 偶adnej kom贸rki (cyfra: {start_hour})"
            if error_messages:
                message += f"\n\nBdy:\n" + "\n".join(error_messages[:5])

            QMessageBox.warning(
                self,
                "Bd edycji klawiatury",
                message,
                QMessageBox.Ok
            )

    def clear_selected_cells(self):
        """
        POPRAWIONA WERSJA: Czyci symbole z zaznaczonych kom贸rek (Delete/Backspace)
        """
        try:
            # NOWE: Zatrzymaj timer bufora klawiatury jeli aktywny
            if hasattr(self, 'keyboard_filter') and hasattr(self.keyboard_filter, '_buffer_timer'):
                self.keyboard_filter._buffer_timer.stop()
                self.keyboard_filter._digit_buffer = ""

            # Sprawd藕 uprawnienia
            if not hasattr(self, 'current_user_role') or self.current_user_role != "Pracownik WPR":
                debug_print("Brak uprawnie do usuwania symboli klawiatury")
                return

            # Pobierz zaznaczone kom贸rki
            selected_cells_data = self.table.get_data_for_selected_cells()

            if not selected_cells_data:
                debug_print("Brak zaznaczonych kom贸rek do wyczyszczenia")
                return

            # Filtruj tylko kom贸rki grafiku
            schedule_cells = []
            for cell_data in selected_cells_data:
                if isinstance(cell_data, dict) and 'date_str' in cell_data and 'uzytkownik_id' in cell_data:
                    current_symbol = cell_data.get('symbol', '')
                    if current_symbol.strip():  # Tylko kom贸rki z symbolem
                        schedule_cells.append(cell_data)

            if not schedule_cells:
                debug_print("Brak kom贸rek z symbolami do wyczyszczenia")
                return

            # Poka偶 potwierdzenie
            reply = QMessageBox.question(
                self,
                "Potwierdzenie usunicia",
                f"Czy na pewno chcesz usun symbole z {len(schedule_cells)} zaznaczonych kom贸rek?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )

            if reply == QMessageBox.Yes:
                self._clear_cells_symbols(schedule_cells)

        except Exception as e:
            log_error(f"Bd podczas czyszczenia kom贸rek: {e}")

    # def _clear_cells_symbols(self, schedule_cells):
    #     """
    #     Usuwa symbole z podanych kom贸rek
    #
    #     Args:
    #         schedule_cells (list): Lista kom贸rek do wyczyszczenia
    #     """
    #     try:
    #         successful_updates = 0
    #         failed_updates = 0
    #
    #         for cell_data in schedule_cells:
    #             user_id = cell_data.get('uzytkownik_id')
    #             date_str = cell_data.get('date_str')
    #             nr_kadrowy = cell_data.get('nr_kadrowy')
    #
    #             if not user_id or not date_str:
    #                 failed_updates += 1
    #                 continue
    #
    #             try:
    #                 year, month, _ = date_str.split('-')
    #                 # Usu symbol (pusty string)
    #                 result = self.call_schedule_change_procedure(
    #                     user_id,
    #                     int(year),
    #                     int(month),
    #                     date_str,
    #                     "",  # Pusty symbol
    #                     nr_kadrowy
    #                 )
    #
    #                 if result.get("success", False):
    #                     successful_updates += 1
    #                 else:
    #                     failed_updates += 1
    #
    #             except Exception as e:
    #                 failed_updates += 1
    #                 log_error(f"Bd usuwania symbolu dla {user_id}, {date_str}: {e}")
    #
    #         # Odwie偶 dane
    #         if successful_updates > 0:
    #             current_data = self.date_combo.currentData()
    #             if current_data:
    #                 year, month = current_data
    #                 self.data_provider.refresh_data(year, month)
    #                 self.update_table_content()
    #
    #         # Poka偶 wyniki
    #         if successful_updates > 0:
    #             message = f"Usunito symbole z {successful_updates} kom贸rek"
    #             if failed_updates > 0:
    #                 message += f", {failed_updates} operacji nie powiodo si"
    #
    #             QMessageBox.information(
    #                 self,
    #                 "Wyniki usuwania",
    #                 message,
    #                 QMessageBox.Ok
    #             )
    #
    #     except Exception as e:
    #         log_error(f"Bd podczas usuwania symboli: {e}")

    # def call_schedule_change_procedure(self, user_id, year, month, date_str, new_symbol, nr_kadrowy):
    #     """
    #     Wywouje procedur skadowan do zmiany grafiku
    #
    #     Args:
    #         user_id (int): ID u偶ytkownika
    #         year (int): Rok
    #         month (int): Miesic
    #         date_str (str): Data w formacie YYYY-MM-DD
    #         new_symbol (str): Nowy symbol
    #         nr_kadrowy (str): Numer kadrowy
    #
    #     Returns:
    #         dict: Wynik operacji {"success": bool, "message": str}
    #     """
    #     try:
    #         from db_connector import DatabaseConnector, get_modifier_id
    #
    #         conn = DatabaseConnector.get_connection()
    #         cursor = conn.cursor()
    #
    #         # Pobierz identyfikator modyfikujcego
    #         _, user_app_id, _ = get_modifier_id()
    #
    #         # Wywoaj procedur skadowan (dostosuj nazw do rzeczywistej procedury)
    #         # To jest przykad - musisz u偶y waciwej nazwy procedury
    #         query = """
    #         EXEC [dbo].[p_P_ZZ_GrafikiPracyZmiana]
    #             @UzytkownikId = ?,
    #             @Rok = ?,
    #             @Miesiac = ?,
    #             @Data = ?,
    #             @NowySymbol = ?,
    #             @NumerKadrowy = ?,
    #             @Modyfikujacy = ?
    #         """
    #
    #         cursor.execute(query, (user_id, year, month, date_str, new_symbol, nr_kadrowy, user_app_id))
    #
    #         # Pobierz wynik procedury (jeli zwraca komunikat)
    #         result = cursor.fetchone()
    #
    #         conn.commit()
    #         conn.close()
    #
    #         # Aktualizuj dat modyfikacji
    #         self._update_modification_date()
    #
    #         return {
    #             "success": True,
    #             "message": f"Symbol zaktualizowany na: {new_symbol}" if new_symbol else "Symbol usunity"
    #         }
    #
    #     except Exception as e:
    #         log_error(f"Bd procedury zmiany grafiku: {e}")
    #         return {
    #             "success": False,
    #             "message": f"Bd bazy danych: {str(e)}"
    #         }

    def set_cell_data(self, row, col, data_dict):
        """
        Ustawia dane w kom贸rce modelu.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny
            data_dict: Sownik z danymi do zapisania

        Returns:
            bool: True jeli operacja si powioda, False w przeciwnym razie
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return False

        if not isinstance(data_dict, dict):
            log_error(f"Bd: data_dict nie jest sownikiem: {type(data_dict)}")
            return False

        # Utw贸rz indeks modelu dla podanej pozycji
        index = self.schedule_model.index(row, col)
        if not index.isValid():
            return False

        # Ustaw dane w modelu
        return self.schedule_model.setData(index, data_dict, Qt.UserRole)

    def on_data_changed(self, data_type, year, month):
        """Obsuguje powiadomienie o zmianie danych - POPRAWIONA"""
        current_data = self.date_combo.currentData()
        if current_data and current_data == (year, month):
            if data_type == "schedule":
                self.update_table_content()
            elif data_type == "events":
                self.filter_events_table()
            elif data_type == "icons":
                # ZMIANA: Usu wywoanie refresh_table_icons()
                debug_print("Otrzymano sygna odwie偶enia ikon - model automatycznie si zaktualizuje")
            


    def log_time(self, label, start_time):
        """Pomocnicza funkcja do logowania czasu"""
        end_time = time.time()
        elapsed = end_time - start_time
        debug_print(f"[CZAS] {label}: {elapsed:.3f} sekundy")
        return end_time

    def setup_ui(self):
        """Ustawia interfejs u偶ytkownika"""
        # G贸wny widget i layout
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)

        # WA呕NA ZMIANA: Usunicie marginesy g贸rnego i dolnego
        main_layout.setContentsMargins(10, 0, 10, 0)  # Lewy, G贸rny, Prawy, Dolny
        main_layout.setSpacing(0)  # Brak odstpu midzy elementami

        # Tworzenie poszczeg贸lnych czci interfejsu
        top_bar = self.setup_top_bar(main_layout)

        # Dodanie g贸rnego paska do g贸wnego layoutu
        main_layout.addWidget(top_bar)

        # Dodanie splittera rodkowego
        middle_splitter = self.setup_middle_section(main_layout)
        main_layout.addWidget(middle_splitter, 1)  # Dodaj z rozciganiem (waga 1)

        # Ustawienie g贸wnego widgetu
        self.setCentralWidget(central_widget)

        # Dodatkowe konfiguracje
        self.setup_table_properties()

        # ZMIANA: Podcz sygna selection_changed dopiero po utworzeniu wszystkich komponent贸w
        if hasattr(self, 'table'):
            # Odcz poprzednie poczenia jeli istniej
            try:
                self.table.selection_changed.disconnect()
            except:
                pass

            # Podcz nowe poczenie
            self.table.selection_changed.connect(self.on_selection_changed)

    def setup_top_bar(self, main_layout):
        """Tworzy g贸rny pasek z przyciskami i kontrolkami"""
        top_bar_frame = QFrame()
        top_bar_frame.setFrameShape(QFrame.StyledPanel)
        top_bar_frame.setFrameShadow(QFrame.Raised)
        top_bar_frame.setFixedHeight(50)  # Staa wysoko 50px

        # Zastosuj zerowe marginesy w wewntrznym layoucie
        top_bar_layout = QHBoxLayout(top_bar_frame)
        top_bar_layout.setContentsMargins(5, 5, 5, 5)

        # Ustaw polityk rozmiaru - staa wysoko, rozciganie szerokoci
        top_bar_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        # Przycisk menu (burger)
        self.toggle_menu_button = QPushButton()
        self.toggle_menu_button.setFixedSize(32, 32)
        self.toggle_menu_button.setText("")
        self.toggle_menu_button.setToolTip("Poka偶/ukryj panel filtr贸w")
        self.toggle_menu_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.toggle_menu_button.clicked.connect(self.toggle_left_panel)
        top_bar_layout.addWidget(self.toggle_menu_button)



        # Przycisk zmiany motywu
        self.theme_button = QPushButton("Zmie motyw")
        self.theme_button.clicked.connect(self.show_theme_settings)
        self.theme_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))

        # Etykieta i combobox na rok-miesic
        date_label = QLabel("Miesic:")
        self.date_combo = QComboBox()
        self.date_combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))

        # Skonfiguruj zawarto comboboxa dat
        self.setup_date_combo()

        # Podcz sygna zmiany comboboxa daty
        self.date_combo.currentIndexChanged.connect(self.on_date_combo_changed)

        # Przycisk odwie偶ania - ZMODYFIKOWANY z tooltipem
        self.refresh_button = QPushButton("Odwie偶 dane")
        self.refresh_button.clicked.connect(self.refresh_data)
        self.refresh_button.setToolTip("Odwie偶 dane (u偶ywa async loading dla lepszej wydajnoci)")
        self.refresh_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))

        # Dodanie widget贸w do layoutu g贸rnego paska
        top_bar_layout.addWidget(self.theme_button)
        top_bar_layout.addWidget(date_label)
        top_bar_layout.addWidget(self.date_combo)
        top_bar_layout.addWidget(self.refresh_button)
        top_bar_layout.addStretch()

        # Dodaj g贸rny pasek do g贸wnego layoutu
        main_layout.addWidget(top_bar_frame)

        return top_bar_frame

    def setup_date_combo(self):
        """Konfiguruje combobox z datami"""
        # Dodanie opcji dla 3 miesicy wstecz i 1 miesica do przodu od bie偶cego
        current_date = datetime.now()
        months_to_show = []

        # Zacznij od 3 miesicy wstecz
        year = current_date.year
        month = current_date.month

        # Generowanie 3 miesicy wstecz
        for i in range(3, 0, -1):
            # Oblicz rok i miesic dla i miesicy wstecz
            prev_month = month - i
            prev_year = year

            # Dostosuj rok, jeli trzeba
            while prev_month <= 0:
                prev_month += 12
                prev_year -= 1

            months_to_show.append((prev_year, prev_month))

        # Dodaj bie偶cy miesic
        months_to_show.append((year, month))

        # Dodaj 1 miesic do przodu
        next_month = month + 1
        next_year = year
        if next_month > 12:
            next_month = 1
            next_year += 1
        months_to_show.append((next_year, next_month))

        # Dodanie miesicy do comboboxa w formacie YYYY-MM
        self.date_combo.clear()  # Wyczy poprzednie pozycje
        for year, month in months_to_show:
            self.date_combo.addItem(f"{year}-{month:02d}", (year, month))

        # Ustawienie bie偶cego miesica (czwarty element, indeks 3)
        self.date_combo.setCurrentIndex(3)

    def setup_middle_section(self, main_layout):
        """Tworzy rodkow sekcj z filtrem i tabelami"""
        # G贸wny kontener na rodkow cz (filtry po lewej, tabela po prawej)
        main_splitter = QSplitter(Qt.Horizontal)

        # Ustaw polityk rozmiaru - aby element wypenia dostpn przestrze
        main_splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Tworzenie lewego panelu filtr贸w
        self.setup_left_panel()
        # Zapamitaj standardow szeroko lewego panelu
        self.left_panel_width = 200  # Domylna szeroko panelu

        # Tworzenie prawego panelu z tabelami
        right_panel = self.setup_right_panel()

        # Dodaj panele do g贸wnego splittera
        main_splitter.addWidget(self._left_panel)
        main_splitter.addWidget(right_panel)

        # Ustaw pocztkowe proporcje dla g贸wnego splittera (np. 25% lewy panel, 75% prawy panel)
        main_splitter.setSizes([250, 950])

        # Zapisz referencj do splittera
        self.main_splitter = main_splitter

        self.main_splitter.setStretchFactor(0, 0)  # Lewy panel (employees_view) nie jest rozcigany
        self.main_splitter.setStretchFactor(1, 1)  # Prawy panel (schedule_view) jest rozcigany

        # NIE dodawaj main_splitter do main_layout - zwr贸 go tylko
        return main_splitter

    def setup_left_panel(self):
        """Tworzy lewy panel z filtrami"""
        self._left_panel = QWidget()
        self._left_panel.setStyleSheet(AppStyles.get_left_panel_style("dark" if self.is_dark_theme else "light"))
        self._left_panel.setMinimumWidth(200)  # Zwikszamy minimaln szeroko panelu
        self._left_panel.setMaximumWidth(250)  # Zwikszamy maksymaln szeroko panelu

        filters_layout = QVBoxLayout(self._left_panel)
        filters_layout.setContentsMargins(10, 10, 10, 10)
        filters_layout.setSpacing(6)  # Zmniejsz odstpy midzy elementami

        # Tytu filtr贸w
        filters_title = QLabel("Filtry")
        filters_title.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light", is_title=True))
        filters_layout.addWidget(filters_title)

        # Kolejno zgodnie z oznaczeniami na zdjciu
        # 1. Wydzia
        self.add_horizontal_filter("Wydzia:", "wydzial_combo", filters_layout)

        # 2. Przeo偶ony - pole tekstowe i lista w ukadzie pionowym
        self.add_horizontal_search_filter("Przeo偶ony:", "przelozony_filter", filters_layout)
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)

        # Lista przeo偶onych
        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_list.setFixedHeight(120)
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.przelozony_list)

        # 3. U偶ytkownik
        self.add_horizontal_search_filter("U偶ytkownik:", "uzytkownik_filter", filters_layout)
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)

        # Lista u偶ytkownik贸w
        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_list.setFixedHeight(120)
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.uzytkownik_list)

        # 4. DTN
        self.add_horizontal_filter("DTN:", "dtn_combo", filters_layout)

        # 5. Etat
        self.add_horizontal_filter("Etat:", "etat_combo", filters_layout)

        # 6. Rola
        self.add_horizontal_filter("Rola:", "rola_combo", filters_layout)

        # 7. Jzyk
        self.add_horizontal_filter("Jzyk:", "jezyk_combo", filters_layout)

        # Przycisk wyczy filtry
        self.clear_filters_button = QPushButton("Wyczy filtry")
        self.clear_filters_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.clear_filters_button.clicked.connect(self.clear_filters)
        filters_layout.addStretch()
        filters_layout.addWidget(self.clear_filters_button)

    def add_horizontal_filter(self, label_text, combo_name, parent_layout):
        """Dodaje filtr w ukadzie poziomym (etykieta + kontrolka w jednej linii)"""
        # Ukad poziomy dla filtru
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)  # Minimalne marginesy
        filter_layout.setSpacing(4)  # Mniejszy odstp

        # Etykieta
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        filter_label.setFixedWidth(80)  # Ustaw sta szeroko etykiet
        filter_layout.addWidget(filter_label)

        # Kontrolka ComboBox
        combo = CustomMultiComboBox()
        combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        combo.setFixedHeight(24)  # Ustaw wysoko podobn do p贸l tekstowych
        combo.view().setMaximumWidth(250)  # Ograniczenie szerokoci rozwijanej listy
        combo.activated.connect(self.filter_data)  # Podcz sygna filtrowania

        # Zapisz referencj do kontrolki
        setattr(self, combo_name, combo)

        filter_layout.addWidget(combo, 1)  # Dodaj z rozciganiem
        parent_layout.addLayout(filter_layout)

    def add_horizontal_search_filter(self, label_text, filter_name, parent_layout):
        """Dodaje filtr wyszukiwania w ukadzie poziomym (etykieta + pole tekstowe w jednej linii)"""
        # Ukad poziomy dla filtru
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)  # Minimalne marginesy
        filter_layout.setSpacing(4)  # Mniejszy odstp

        # Etykieta
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        filter_label.setFixedWidth(80)  # Ustaw sta szeroko etykiet
        filter_layout.addWidget(filter_label)

        # Pole tekstowe
        text_edit = QLineEdit()
        text_edit.setPlaceholderText(f"Filtruj {label_text.lower()[:-1]}...")
        text_edit.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        text_edit.setFixedHeight(24)  # Ustaw sta wysoko

        # Zapisz referencj do kontrolki
        setattr(self, filter_name, text_edit)

        filter_layout.addWidget(text_edit, 1)  # Dodaj z rozciganiem
        parent_layout.addLayout(filter_layout)

    def setup_filter_combo(self, label_text, combo_name, parent_layout):
        """Konfiguruje filtr jako ComboBox z wielokrotnym wyborem"""
        # Etykieta filtru
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(filter_label)

        # ComboBox z wielokrotnym wyborem
        combo = CustomMultiComboBox()
        combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        combo.view().setMinimumWidth(200)  # Ustaw minimaln szeroko listy rozwijanej

        # Dodaj sygna zmiany stanu ComboBoxa
        combo.view().pressed.connect(self.filter_data)

        # Zapisz referencj do ComboBoxa
        setattr(self, combo_name, combo)

        parent_layout.addWidget(combo)
        parent_layout.addSpacing(10)  # Dodaj odstp midzy filtrami

    # Te metody pozostaj bez zmian, tylko przenosimy je do oddzielnych funkcji
    def setup_filter_przelozony(self, parent_layout):
        """Konfiguruje filtr przeo偶onego"""
        # Filtr przeo偶onego
        przelozony_label = QLabel("Przeo偶ony:")
        przelozony_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(przelozony_label)

        # Lista przeo偶onych
        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_list.setFixedHeight(120)

        # Dodaj pole wyszukiwania dla przeo偶onych
        self.przelozony_filter = QLineEdit()
        self.przelozony_filter.setPlaceholderText("Filtruj przeo偶onych...")
        self.przelozony_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)

        parent_layout.addWidget(self.przelozony_filter)
        parent_layout.addWidget(self.przelozony_list)

        # Podcz sygna zmiany filtru
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)

    def setup_filter_uzytkownik(self, parent_layout):
        """Konfiguruje filtr u偶ytkownika"""
        # Filtr u偶ytkownika
        uzytkownik_label = QLabel("U偶ytkownik:")
        uzytkownik_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(uzytkownik_label)

        # Lista u偶ytkownik贸w
        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_list.setFixedHeight(120)

        # Dodaj pole wyszukiwania dla u偶ytkownik贸w
        self.uzytkownik_filter = QLineEdit()
        self.uzytkownik_filter.setPlaceholderText("Filtruj u偶ytkownik贸w...")
        self.uzytkownik_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)

        parent_layout.addWidget(self.uzytkownik_filter)
        parent_layout.addWidget(self.uzytkownik_list)

        # Podcz sygna zmiany filtru
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)

    def setup_right_panel(self):
        """Tworzy prawy panel z tabelami"""
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)

        # Splitter pionowy dla prawego panelu (grafik | zdarzenia)
        right_splitter = QSplitter(Qt.Vertical)

        # Dodaj sekcje
        schedule_frame = self.setup_schedule_section()
        events_frame = self.setup_events_section()

        # Dodaj panele do pionowego splittera
        right_splitter.addWidget(schedule_frame)
        right_splitter.addWidget(events_frame)

        # Ustaw pocztkowe proporcje dla pionowego splittera (np. 60% grafik, 40% zdarzenia)
        right_splitter.setSizes([600, 400])

        # Dodaj pionowy splitter do layoutu prawego panelu
        right_layout.addWidget(right_splitter)

        return right_panel

    # W pliku main.py - klasa WorkScheduleWindow, metoda setup_schedule_section

    def setup_schedule_section(self):
        """
        Tworzy sekcj grafiku (g贸rna cz prawego panelu) u偶ywajc SplitTableView
        """
        schedule_frame = QFrame()
        schedule_layout = QVBoxLayout(schedule_frame)
        schedule_layout.setContentsMargins(5, 5, 5, 5)

        # NIE INICJALIZUJ employee_columns tutaj, u偶yj wartoci z inicjalizacji klasy

        # Tworzenie i konfiguracja SplitTableView
        self.table = SplitTableView()

        # Ustaw style dla obu tabel
        self.table.employees_view.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))
        self.table.schedule_view.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))

        # Dodaj przycisk zarzdzania kolumnami do przycisk贸w akcji
        self.manage_columns_button = QPushButton("Zarzdzaj kolumnami")
        self.manage_columns_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.manage_columns_button.clicked.connect(self.show_column_select_dialog)

        # Podcz sygna zmiany zaznaczenia do aktualizacji zdarze
        self.table.selection_changed.connect(self.on_selection_changed)

        # Dodaj tabel do layoutu
        schedule_layout.addWidget(self.table)

        # Dodaj przyciski akcji
        button_frame = self.setup_schedule_buttons()
        button_layout = button_frame.layout()

        # NOWE: Ustaw, aby panel z przyciskami zajmowa tylko tyle miejsca, ile potrzebuje
        schedule_layout.addWidget(button_frame, 0)  # 0 = minimum stretch factor

        # Dodaj przycisk zarzdzania kolumnami do przycisk贸w akcji
        if isinstance(button_layout, QHBoxLayout):
            button_layout.insertWidget(0, self.manage_columns_button)

        schedule_layout.addWidget(button_frame)

        return schedule_frame

    def setup_schedule_buttons(self):
        """Tworzy przyciski akcji dla sekcji grafiku"""
        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setContentsMargins(0, 0, 0, 0)

        # NOWE: Ustaw sta wysoko ramki przycisk贸w
        button_frame.setFixedHeight(40)  # Mo偶esz dostosowa wysoko wedug potrzeb

        # NOWE: Ustaw polityk rozmiaru, aby zapobiec rozciganiu
        button_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        # NOWO: Dodajemy przycisk do ukrywania/pokazywania panelu zdarze (po lewej stronie)
        self.toggle_events_panel_button = QPushButton("Ukryj zdarzenia")
        self.toggle_events_panel_button.setToolTip("Ukryj panel zdarze (dla wikszego widoku grafiku)")
        self.toggle_events_panel_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.toggle_events_panel_button.clicked.connect(self.toggle_events_panel)

        # Dodaj przycisk po lewej stronie
        button_layout.addWidget(self.toggle_events_panel_button)

        # Dodaj elastyczny odstp, aby rozdzieli przyciski
        button_layout.addStretch()

        # Przycisk "Wstaw zmian"
        self.insert_change_button = QPushButton("Wstaw zmian")
        self.insert_change_button.setShortcut("Ctrl+Z")  # Skr贸t klawiszowy
        self.insert_change_button.setToolTip("Wstaw zmian grafiku (Ctrl+Z)")
        self.insert_change_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.insert_change_button.clicked.connect(self.show_insert_change_dialog)
        button_layout.addWidget(self.insert_change_button)

        # Przycisk "Wstaw nieobecno"
        self.insert_symbol_button = QPushButton("Wstaw nieobecno")
        self.insert_symbol_button.setShortcut("Ctrl+I")  # Skr贸t klawiszowy Ctrl+I
        self.insert_symbol_button.setToolTip("Wstaw nieobecno (Ctrl+I)")  # Podpowied藕 z informacj o skr贸cie
        self.insert_symbol_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.insert_symbol_button.clicked.connect(self.show_insert_symbol_dialog)
        button_layout.addWidget(self.insert_symbol_button)

        # Przycisk "Odwoaj delegacje"
        self.cancel_delegation_button = QPushButton("Odwoaj delegacje")
        self.cancel_delegation_button.setShortcut("Ctrl+D")  # Skr贸t klawiszowy Ctrl+D
        self.cancel_delegation_button.setToolTip("Odwoaj delegacje dla zaznaczonych kom贸rek (Ctrl+D)")
        self.cancel_delegation_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.cancel_delegation_button.clicked.connect(self.cancel_delegations)
        button_layout.addWidget(self.cancel_delegation_button)

        # Przycisk "Dodaj nadgodziny"
        self.add_overtime_button = QPushButton("Dodaj nadgodziny")
        self.add_overtime_button.setShortcut("Ctrl+N")  # Skr贸t klawiszowy Ctrl+N
        self.add_overtime_button.setToolTip("Dodaj nadgodziny dla zaznaczonych kom贸rek (Ctrl+N)")
        self.add_overtime_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.add_overtime_button.clicked.connect(self.show_add_overtime_dialog)

        # ZMODYFIKOWANA LINIA: Zawsze dodawaj przycisk do layoutu
        button_layout.addWidget(self.add_overtime_button)

        # Ewentualnie ustaw widoczno przycisku na podstawie roli
        # Mo偶na to zrobi po inicjalizacji wszystkich komponent贸w
        if hasattr(self, 'current_user_role'):
            self.add_overtime_button.setVisible(self.current_user_role == "Pracownik WPR")
        else:
            # Domylnie widoczny, mo偶emy to zmieni p贸藕niej
            self.add_overtime_button.setVisible(True)

        return button_frame

    def setup_events_section(self):
        """
        Tworzy sekcj zdarze u偶ywajc QTableView zamiast QTableWidget
        """
        events_frame = QFrame()
        events_frame.setFrameShape(QFrame.StyledPanel)
        events_frame.setFrameShadow(QFrame.Raised)
        events_layout = QVBoxLayout(events_frame)
        events_layout.setContentsMargins(5, 5, 5, 5)

        # Dodaj kontrolki filtr贸w
        filters_frame = self.setup_events_filters()
        events_layout.addWidget(filters_frame)

        # Tworzenie tabeli zdarze jako QTableView
        self.events_table = QTableView()
        self.events_table.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.events_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.events_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.events_table.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))

        # Dodaj tabel zdarze do panelu
        events_layout.addWidget(self.events_table)

        return events_frame

    def setup_events_filters(self):
        """Konfiguruje filtry dla tabeli zdarze"""
        events_filter_frame = QFrame()
        events_filter_layout = QHBoxLayout(events_filter_frame)
        events_filter_layout.setContentsMargins(0, 0, 0, 0)

        # Filtry daty od-do
        date_from_label = QLabel("Data od:")
        self.date_from = QDateEdit()
        self.date_from.setDisplayFormat("dd.MM.yyyy")
        self.date_from.setDate(QDate.currentDate().addDays(-30))
        self.date_from.setCalendarPopup(True)
        self.date_from.setStyleSheet(AppStyles.get_date_edit_style("dark" if self.is_dark_theme else "light"))

        date_to_label = QLabel("Data do:")
        self.date_to = QDateEdit()
        self.date_to.setDisplayFormat("dd.MM.yyyy")
        self.date_to.setDate(QDate.currentDate())
        self.date_to.setCalendarPopup(True)
        self.date_to.setStyleSheet(AppStyles.get_date_edit_style("dark" if self.is_dark_theme else "light"))

        # Filtr tematu
        topic_label = QLabel("Temat:")
        self.topic_filter = QLineEdit()
        self.topic_filter.setPlaceholderText("Filtruj po temacie...")
        self.topic_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))

        # Filtr nazwy
        name_label = QLabel("Nazwa:")
        self.name_filter = QLineEdit()
        self.name_filter.setPlaceholderText("Filtruj po nazwie...")
        self.name_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))

        # Checkboxy do filtrowania typ贸w zdarze
        self.meetings_checkbox = QCheckBox("Spotkania")
        self.meetings_checkbox.setChecked(True)
        self.meetings_checkbox.stateChanged.connect(self.filter_events_table)

        self.trainings_checkbox = QCheckBox("Szkolenia")
        self.trainings_checkbox.setChecked(True)
        self.trainings_checkbox.stateChanged.connect(self.filter_events_table)

        self.overtime_checkbox = QCheckBox("Nadgodziny")
        self.overtime_checkbox.setChecked(True)
        self.overtime_checkbox.stateChanged.connect(self.filter_events_table)

        # Podcz sygnay zmiany daty bezporednio do filtrowania
        self.date_from.dateChanged.connect(self.filter_events_table)
        self.date_to.dateChanged.connect(self.filter_events_table)
        self.topic_filter.textChanged.connect(self.filter_events_table)
        self.name_filter.textChanged.connect(self.filter_events_table)

        # Dodaj kontrolki do layoutu filtr贸w zdarze
        events_filter_layout.addWidget(date_from_label)
        events_filter_layout.addWidget(self.date_from)
        events_filter_layout.addWidget(date_to_label)
        events_filter_layout.addWidget(self.date_to)
        events_filter_layout.addWidget(topic_label)
        events_filter_layout.addWidget(self.topic_filter)
        events_filter_layout.addWidget(name_label)
        events_filter_layout.addWidget(self.name_filter)
        events_filter_layout.addWidget(self.meetings_checkbox)
        events_filter_layout.addWidget(self.trainings_checkbox)
        events_filter_layout.addWidget(self.overtime_checkbox)
        events_filter_layout.addStretch()

        return events_filter_frame

    def setup_events_table_columns(self):
        """Konfiguruje kolumny dla tabeli zdarze"""
        self.events_table.setColumnCount(10)
        self.events_table.setHorizontalHeaderLabels([
            "Id", "Typ", "Temat", "Nazwa", "U偶ytkownik", "Data", "Od", "Do", "Status", "Akcje"
        ])

        # Ustaw szeroko kolumn
        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # U偶ytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

    def setup_table_properties(self):
        """Konfiguruje waciwoci tabel"""
        # Sortowanie
        self.events_table.setSortingEnabled(True)
        self.events_table.sortByColumn(0, Qt.AscendingOrder)

        # Dostosuj dla nowej klasy SplitTableView
        if hasattr(self.table, 'employees_view'):
            self.table.employees_view.setSortingEnabled(True)
            self.table.employees_view.sortByColumn(0, Qt.AscendingOrder)

        # Mo偶emy tak偶e zachowa informacj o ostatnim sortowaniu
        self.last_sort_column = 0
        self.last_sort_order = Qt.AscendingOrder

        # Podcz sygnay sortowania - POPRAWKA: odwouj si do konkretnego widoku
        if hasattr(self.table, 'employees_view') and hasattr(self.table.employees_view, 'horizontalHeader'):
            self.table.employees_view.horizontalHeader().sortIndicatorChanged.connect(self.on_sort_changed)

        if hasattr(self.events_table, 'horizontalHeader'):
            self.events_table.horizontalHeader().sortIndicatorChanged.connect(self.on_events_sort_changed)

        # Dodaj delegata do tabeli aby obsugiwa niestandardowe rysowanie
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            # Dla nowej klasy SplitTableView
            self.table.schedule_view.setItemDelegate(OvertimeItemDelegate())
        elif hasattr(self, 'table'):
            # Dla starej klasy SplitTableWidget
            self.table.setItemDelegate(OvertimeItemDelegate())

    def toggle_left_panel(self):
        """Przecza widoczno lewego panelu filtr贸w"""
        if self.left_panel_visible:
            # Ukryj panel
            self.left_panel_width = self._left_panel.width()  # Zapamitaj bie偶c szeroko
            self._left_panel.setFixedWidth(0)
            self._left_panel.setVisible(False)  # WA呕NE: Ukryj panel cakowicie
            self.left_panel_visible = False
            self.toggle_menu_button.setText("")  # Zmie ikon na "poka偶 menu"
            self.toggle_menu_button.setToolTip("Poka偶 panel filtr贸w")
        else:
            # Poka偶 panel
            self._left_panel.setVisible(True)  # WA呕NE: Najpierw poka偶 panel
            self._left_panel.setMinimumWidth(200)
            self._left_panel.setMaximumWidth(250)

            # Sprawd藕 czy mamy zapamitan szeroko
            if hasattr(self, 'left_panel_width'):
                self._left_panel.setFixedWidth(self.left_panel_width)
            else:
                self._left_panel.setFixedWidth(200)  # Domylna szeroko

            self.left_panel_visible = True
            self.toggle_menu_button.setText("")  # Przywr贸 ikon "burger menu"
            self.toggle_menu_button.setToolTip("Ukryj panel filtr贸w")

        # DODANE: Wymu ponowne rozo偶enie splittera
        current_sizes = self.main_splitter.sizes()
        if not self.left_panel_visible:
            # Gdy ukrywamy panel, dajemy ca przestrze prawemu panelowi
            self.main_splitter.setSizes([0, sum(current_sizes)])
        else:
            # Gdy pokazujemy panel, przywracamy proporcje
            if hasattr(self, 'left_panel_width'):
                right_size = sum(current_sizes) - self.left_panel_width
                self.main_splitter.setSizes([self.left_panel_width, right_size])
            else:
                # Domylnie 20% - 80%
                total = sum(current_sizes)
                self.main_splitter.setSizes([int(total * 0.2), int(total * 0.8)])

        # Wymu aktualizacj widoku
        self.main_splitter.update()

        # DODANE: Odwie偶 ukad caego okna
        QApplication.processEvents()
        self.update()

    def toggle_events_panel(self):
        """Przecza widoczno panelu zdarze (dolny panel)"""
        # Znajd藕 splitter, kt贸ry organizuje ukad prawy (grafik | zdarzenia)
        right_splitter = None

        # Szukamy w rodzicu prawego panelu, kt贸ry zawiera splitter
        for widget in self.findChildren(QSplitter):
            # Sprawd藕, czy to pionowy splitter zawierajcy panel zdarze
            if widget.orientation() == Qt.Vertical and widget.count() > 1:
                right_splitter = widget
                break

        if right_splitter:
            # Pobierz rozmiary paneli
            sizes = right_splitter.sizes()

            # Jeli panel zdarze jest widoczny, ukryj go
            if sizes[1] > 0:
                # Zapisz obecny rozmiar panelu zdarze przed ukryciem
                self.events_panel_size = sizes[1]

                # Ustaw nowe rozmiary - caa przestrze dla grafiku, 0 dla zdarze
                right_splitter.setSizes([sizes[0] + sizes[1], 0])

                # Zmie tekst przycisku
                self.toggle_events_panel_button.setText("Poka偶 zdarzenia")
                self.toggle_events_panel_button.setToolTip("Poka偶 panel zdarze")
            else:
                # Jeli panel zdarze jest ukryty, poka偶 go
                # U偶yj zapisanego wczeniej rozmiaru lub domylnego (300)
                events_size = getattr(self, 'events_panel_size', 300)

                # Oblicz nowy rozmiar dla panelu grafiku
                schedule_size = sizes[0] - events_size
                if schedule_size < 200:  # Minimalny rozmiar dla grafiku
                    schedule_size = 200
                    events_size = sizes[0] - schedule_size

                # Ustaw nowe rozmiary
                right_splitter.setSizes([schedule_size, events_size])

                # Zmie tekst przycisku
                self.toggle_events_panel_button.setText("Ukryj zdarzenia")
                self.toggle_events_panel_button.setToolTip("Ukryj panel zdarze (dla wikszego widoku grafiku)")

    def show_column_select_dialog(self):
        """
        Wywietla dialog wyboru kolumn tabeli pracownik贸w.
        """
        try:
            # Sprawd藕 czy model istnieje
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                QMessageBox.warning(self, "Bd", "Model danych nie jest zainicjalizowany.", QMessageBox.Ok)
                return

            # Utw贸rz dialog - ZMIENIONE: u偶ywaj self.visible_columns zamiast z modelu
            dialog = ColumnSelectDialog(
                self,
                self.employee_columns,
                self.visible_columns,
                self.default_visible_columns
            )

            # Wykonaj dialog
            if dialog.exec() == QDialog.Accepted:
                # Pobierz wybrane kolumny
                selected_columns = dialog.get_selected_columns()

                # Zaktualizuj widoczne kolumny w modelu
                self.schedule_model.set_visible_columns(selected_columns)

                # ZMODYFIKOWANE: Zaktualizuj lokalne widoczne kolumny
                self.visible_columns = selected_columns

                # Zapisz preferencje u偶ytkownika do bazy
                current_theme = "dark" if self.is_dark_theme else "light"
                font_family = self.current_font
                font_size = self.current_font_size
                load_all_events = getattr(self, 'load_all_events', True)

                # Zapisz ustawienia wraz z nowymi widocznymi kolumnami
                self.settings_db.save_settings(
                    current_theme,
                    font_family,
                    font_size,
                    load_all_events,
                    selected_columns
                )
                debug_print(f"Zapisano widoczne kolumny do bazy: {selected_columns}")

                # DODANE: Odwie偶 konfiguracj kolumn
                self.refresh_column_configuration()

                # Upewnij si, 偶e widok jest zaktualizowany
                if hasattr(self, 'table'):
                    self.table.set_model(self.schedule_model)

                    # Dostosuj szeroko tabeli pracownik贸w po zmianie kolumn
                    self.table.adjust_employees_table_width()

                    # Aktualizuj szerokoci kolumn w tabeli grafiku
                    self._set_schedule_columns_width()

        except Exception as e:
            import traceback
            traceback.print_exc()
            QMessageBox.critical(self, "Bd", f"Wystpi bd: {str(e)}", QMessageBox.Ok)

    def _set_schedule_columns_width(self):
        """
        Ustawia sta szeroko kolumn dni w tabeli grafiku.
        """
        if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
            return

        # Pobierz cakowit liczb kolumn w widoku (cznie z SumaRBH i BilansRBH)
        total_columns = self.table.schedule_view.model().columnCount()

        # Ustaw szeroko 60px dla wszystkich kolumn dni (wszystkie opr贸cz ostatnich dw贸ch)
        for col in range(total_columns - 2):
            self.table.schedule_view.setColumnWidth(col, 65)

        # Kolumna sumy RBH (przedostatnia kolumna) powinna by nieco szersza
        self.table.schedule_view.setColumnWidth(total_columns - 2, 50)

        # Kolumna bilansu RBH (ostatnia kolumna) r贸wnie偶 szersza
        self.table.schedule_view.setColumnWidth(total_columns - 1, 50)

    def _update_modification_date(self):
        """
        Aktualizuje dat ostatniej modyfikacji po dokonaniu zmian w bazie danych.
        """
        try:
            # Pobierz najnowsz dat modyfikacji z bazy danych
            query = """
                SELECT MAX(DataModyfikacji) as DataModyfikacji FROM p_v_zz_GrafikiPracy
            """
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query)
            result = cursor.fetchone()
            conn.close()

            if result and result[0]:
                # Zapisz jako wasn modyfikacj
                self.last_self_modification_date = result[0]
                self.last_modification_date = result[0]
                debug_print(f"Zarejestrowano wasn modyfikacj z dat: {self.last_self_modification_date}")
        except Exception as e:
            log_error(f"Bd podczas aktualizacji daty modyfikacji: {e}")
            import traceback
            traceback.print_exc()

    def delete_event_from_row(self, row):
        """
        POPRAWIONA WERSJA: Usuwa zdarzenie na podstawie indeksu wiersza w tabeli zdarze
        z penym odwie偶aniem ikon
        """
        # Sprawd藕 czy model istnieje
        if not hasattr(self, 'events_model') or not self.events_model:
            return

        # Pobierz zdarzenie z modelu
        event = self.events_model.get_event(row)
        if not event:
            debug_print(f"Nie znaleziono zdarzenia w wierszu {row}")
            return

        # Pobierz dane zdarzenia
        event_id = event.get('id')
        event_type = event.get('type')
        
        debug_print(f"Usuwanie zdarzenia z wiersza {row}: ID={event_id}, typ={event_type}")

        if not event_id or not event_type:
            debug_print(f"Niepene dane zdarzenia: ID={event_id}, typ={event_type}")
            return

        # KLUCZOWA ZMIANA: U偶yj metody delete_event kt贸ra ju偶 ma pen logik odwie偶ania
        self.delete_event(event_id, event_type)

    def on_sort_changed(self, logical_index, order):
        """Obsuguje zmian sortowania w tabeli grafiku"""
        self.last_sort_column = logical_index
        self.last_sort_order = order
        debug_print(
            f"Tabela grafiku: Sortowanie po kolumnie {logical_index}, kolejno: {'rosnco' if order == Qt.AscendingOrder else 'malejco'}")

    def on_events_sort_changed(self, logical_index, order):
        """Obsuguje zmian sortowania w tabeli zdarze"""
        debug_print(f"Tabela zdarze: Sortowanie po kolumnie {logical_index}, kolejno: {'rosnco' if order == Qt.AscendingOrder else 'malejco'}")

    def update_buttons_visibility(self):
        """Aktualizuje widoczno przycisk贸w na podstawie roli u偶ytkownika"""
        if hasattr(self, 'add_overtime_button') and hasattr(self, 'current_user_role'):
            self.add_overtime_button.setVisible(self.current_user_role == "Pracownik WPR")

        # NOWE: Informacja o edycji klawiatury
        if hasattr(self, 'current_user_role') and self.current_user_role == "Pracownik WPR":
            debug_print("Edycja klawiatury wczona: cyfry 0-9 = godzina start, Delete/Backspace = usu symbol")

    def check_user_permissions(self):
        """Sprawdza, czy u偶ytkownik ma odpowiednie uprawnienia do korzystania z aplikacji"""
        # Pobierz dane u偶ytkownika
        user_id, user_app_id, user_app_role = get_modifier_id()

        # Zapisz ID u偶ytkownika do wykorzystania w zapytaniach SQL
        self.current_user_id = user_id
        self.current_user_app_id = user_app_id
        self.current_user_role = user_app_role

        # Aktualizuj widoczno przycisk贸w na podstawie roli
        self.update_buttons_visibility()

        # Lista dozwolonych r贸l
        allowed_roles = ["Pracownik WPR", "Lider", "Menad偶er"]

        # Sprawd藕, czy rola u偶ytkownika jest na licie dozwolonych
        if user_app_role not in allowed_roles:
            # Poka偶 komunikat o braku uprawnie
            QMessageBox.critical(
                self,
                "Brak uprawnie",
                f"Nie masz uprawnie do korzystania z tej aplikacji.\n\n"
                f"Wymagana rola: Pracownik WPR, Lider lub Menad偶er\n"
                f"Twoja rola: {user_app_role}",
                QMessageBox.Ok
            )
            # Zamknij aplikacj
            self.close()
            return False

        debug_print(f"Zalogowano jako: {user_app_id} ({user_app_role})")
        return True

    def show_insert_symbol_dialog(self):
        """
        Pokazuje okno dialogowe do wstawiania symbolu nieobecnoci.
        NOWA WERSJA z procedur p_P_ZZ_ImportZmianNaSerwer_v4
        """
        dialog = InsertSymbolDialog(self)
        if dialog.exec():
            selected_symbol = dialog.get_selected_symbol()

            # Pobierz zaznaczone kom贸rki z modelu
            selected_cells_data = self.get_selected_cells_data()

            if not selected_cells_data:
                QMessageBox.warning(
                    self,
                    "Brak zaznaczenia",
                    "Nie zaznaczono 偶adnych kom贸rek do edycji.",
                    QMessageBox.Ok
                )
                return

            # Filtruj tylko kom贸rki grafiku (nie kolumny pracownik贸w) i pomijaj puste kom贸rki
            schedule_cells = []
            for cell_data in selected_cells_data:
                if isinstance(cell_data, dict) and 'date_str' in cell_data and 'uzytkownik_id' in cell_data:
                    # NOWE: Sprawd藕 czy kom贸rka nie jest pusta
                    current_symbol = cell_data.get('symbol', '').strip()
                    if current_symbol:  # Pomijaj puste kom贸rki
                        schedule_cells.append(cell_data)

            if not schedule_cells:
                QMessageBox.warning(
                    self,
                    "Brak kom贸rek do edycji",
                    "Nie zaznaczono 偶adnych kom贸rek grafiku z symbolami do edycji.\n\n" +
                    "Uwaga: Puste kom贸rki s pomijane.",
                    QMessageBox.Ok
                )
                return

            # Pogrupuj kom贸rki dla lepszego komunikatu
            grouped_changes = self._group_cells_for_symbol_changes(schedule_cells)

            # Przygotuj komunikat potwierdzenia
            changes_info = self._prepare_symbol_changes_description(grouped_changes, selected_symbol)

            # Sprawd藕 czy s zdarzenia do odwoania
            user_date_pairs = set()
            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    user_date_pairs.add((user_id, date_str))

            events_to_cancel = self._find_events_to_cancel(user_date_pairs)
            delegations_info = ""
            if events_to_cancel:
                grouped_events = self._group_events_by_user_date(events_to_cancel)
                delegations_info = self._prepare_delegations_description(grouped_events)

            # Poka偶 komunikat potwierdzenia
            complete_info = f"Czy na pewno chcesz wprowadzi nastpujce zmiany?\n\n{changes_info}"
            if delegations_info:
                complete_info += f"\n{delegations_info}"
            complete_info += f"\ncznie: {len(schedule_cells)} kom贸rek zmieni symbol"
            if events_to_cancel:
                complete_info += f", {len(events_to_cancel)} delegacji zostanie odwoanych"

            reply = QMessageBox.question(
                self,
                "Potwierdzenie wstawienia nieobecnoci",
                complete_info,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )

            if reply == QMessageBox.Yes:
                self._apply_absence_symbol_changes(schedule_cells, selected_symbol, events_to_cancel)

    def _group_cells_for_symbol_changes(self, schedule_cells):
        """
        Grupuje kom贸rki wedug u偶ytkownika i daty dla komunikatu potwierdzenia

        Args:
            schedule_cells (list): Lista kom贸rek do modyfikacji

        Returns:
            dict: Pogrupowane zmiany
        """
        grouped_changes = {}
        for cell_data in schedule_cells:
            user_id = cell_data.get('uzytkownik_id')
            user_name = cell_data.get('uzytkownik_dane', '')
            date_str = cell_data.get('date_str')
            current_symbol = cell_data.get('symbol', '')

            # Formatuj dat
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            user_key = (user_id, user_name)
            if user_key not in grouped_changes:
                grouped_changes[user_key] = {}

            if formatted_date not in grouped_changes[user_key]:
                grouped_changes[user_key][formatted_date] = []

            grouped_changes[user_key][formatted_date].append({
                'current_symbol': current_symbol,
                'cell_data': cell_data
            })

        return grouped_changes

    def _prepare_symbol_changes_description(self, grouped_changes, new_special_symbol):
        """
        Przygotowuje opis zmian symboli do komunikatu potwierdzenia

        Args:
            grouped_changes (dict): Pogrupowane zmiany
            new_special_symbol (str): Nowy symbol specjalny

        Returns:
            str: Opis zmian
        """
        changes_info = ""
        for (user_id, user_name), dates in grouped_changes.items():
            changes_info += f"\n {user_name}:\n"

            for date, cells in dates.items():
                changes_info += f"    {date}: "

                # Poka偶 przykad jak bdzie wyglda nowy symbol
                example_cell = cells[0]['cell_data']
                current_symbol = cells[0]['current_symbol']

                # Przewiduj jak bdzie wyglda nowy symbol
                predicted_symbol = self._predict_new_symbol(current_symbol, new_special_symbol, example_cell)

                if len(cells) == 1:
                    changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                else:
                    # Jeli wiele kom贸rek w tym dniu
                    current_symbols = [cell['current_symbol'] for cell in cells]
                    unique_symbols = set(current_symbols)
                    if len(unique_symbols) == 1:
                        changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                    else:
                        symbols_str = ", ".join([f"{s}" for s in unique_symbols])
                        changes_info += f"[{symbols_str}] -> {predicted_symbol}\n"

        return changes_info

    def _predict_new_symbol(self, current_symbol, special_symbol, cell_data):
        """
        Przewiduje jak bdzie wyglda nowy symbol po modyfikacji

        Args:
            current_symbol (str): Obecny symbol (nigdy pusty - puste s filtrowane)
            special_symbol (str): Nowy symbol specjalny
            cell_data (dict): Dane kom贸rki

        Returns:
            str: Przewidywany nowy symbol
        """
        from symbol_parser import parse_symbol, build_symbol

        # Sprawd藕 czy symbol istnieje (zabezpieczenie dodatkowe)
        if not current_symbol or current_symbol.strip() == '':
            debug_print("Ostrze偶enie: _predict_new_symbol otrzyma pusty symbol")
            return special_symbol

        # Parsuj obecny symbol
        parsed = parse_symbol(current_symbol)

        # Zachowaj lokalizacj i godziny, zmie tylko symbol specjalny
        new_symbol = build_symbol(
            location=parsed.get('location'),
            start_hour=parsed.get('start_hour'),
            work_hours=parsed.get('work_hours'),
            special_symbol=special_symbol
        )

        return new_symbol if new_symbol else special_symbol

    def _find_events_to_cancel(self, user_date_pairs):
        """
        Znajduje zdarzenia do odwoania dla podanych par u偶ytkownik-data

        Args:
            user_date_pairs (set): Pary (user_id, date_str)

        Returns:
            list: Lista zdarze do odwoania
        """
        events_to_cancel = []

        for user_id, date_str in user_date_pairs:
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

            for event in user_events:
                event_type = event.get('type', '')
                event_id = event.get('id')
                event_status = event.get('status')

                if not event_type or event_id is None:
                    continue

                if event_status is not None:
                    event_status = str(event_status)

                # Dodaj zdarzenia do odwoania (spotkania, szkolenia, nadgodziny)
                if event_type in ['Spotkanie', 'Szkolenie', 'Nadgodziny'] and event_status != '0':
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),
                    })

        return events_to_cancel

    def _group_events_by_user_date(self, events_to_cancel):
        """
        Grupuje zdarzenia wedug u偶ytkownika i daty

        Args:
            events_to_cancel (list): Lista zdarze do odwoania

        Returns:
            dict: Pogrupowane zdarzenia
        """
        grouped_events = {}
        for event in events_to_cancel:
            key = (event['user_id'], event['date'])
            if key not in grouped_events:
                grouped_events[key] = []
            grouped_events[key].append(event)

        return grouped_events

    def _apply_absence_symbol_changes(self, schedule_cells, special_symbol, events_to_cancel):
        """
        Stosuje zmiany symboli nieobecnoci z u偶yciem procedury p_P_ZZ_ImportZmianNaSerwer_v4
        POPRAWIONE: U偶ywa build_symbol z symbol_parser.py
        """
        try:
            # Najpierw odwoaj delegacje jeli s
            if events_to_cancel:
                canceled_count = self._cancel_delegations(events_to_cancel)
                debug_print(f"Odwoano {canceled_count} delegacji przed wstawieniem nieobecnoci")

            # Zbierz pary do p贸藕niejszego odwie偶enia
            affected_pairs = []
            successful_updates = 0
            failed_updates = 0
            error_messages = []

            # Przetw贸rz ka偶d kom贸rk
            for cell_data in schedule_cells:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                nr_kadrowy = cell_data.get('nr_kadrowy')
                current_symbol = cell_data.get('symbol', '')

                if not user_id or not date_str:
                    failed_updates += 1
                    continue

                if not nr_kadrowy:
                    failed_updates += 1
                    error_messages.append(f"Brak numeru kadrowego dla u偶ytkownika {user_id}")
                    continue

                # POPRAWIONE: Zbuduj nowy symbol u偶ywajc build_symbol
                new_symbol = self._build_new_symbol_with_absence_fixed(current_symbol, special_symbol, cell_data)

                try:
                    year, month, day = date_str.split('-')
                    date_obj = f"{year}-{month}-{day}"

                    # Wywoaj procedur p_P_ZZ_ImportZmianNaSerwer_v4
                    result = self._call_import_changes_procedure(
                        nr_kadrowy=nr_kadrowy,
                        rok=int(year),
                        miesiac=int(month),
                        data=date_obj,
                        symbol=new_symbol
                    )

                    if result['success']:
                        # Jeli procedura zwr贸cia nowy symbol, u偶yj go
                        final_symbol = result.get('returned_symbol', new_symbol)
                        successful_updates += 1
                        affected_pairs.append((user_id, date_str))

                        debug_print(f"Sukces wstawienia nieobecnoci: {user_id}, {date_str}, symbol: {final_symbol}")
                    else:
                        failed_updates += 1
                        error_msg = result.get('message', 'Nieznany bd')
                        error_messages.append(f"{nr_kadrowy} ({date_str}): {error_msg}")
                        debug_print(f"Bd wstawienia nieobecnoci: {error_msg}")

                except Exception as e:
                    failed_updates += 1
                    error_messages.append(f"{nr_kadrowy} ({date_str}): {str(e)}")
                    log_error(f"Bd procedury dla {user_id}, {date_str}: {e}")

            # Odwie偶 dane jeli byy successful updates
            if successful_updates > 0:
                self._refresh_data_after_symbol_changes(affected_pairs)

            # Poka偶 wyniki
            self._show_symbol_change_results(successful_updates, failed_updates, error_messages, events_to_cancel)

        except Exception as e:
            log_error(f"Bd podczas wstawiania nieobecnoci: {e}")
            QMessageBox.critical(
                self,
                "Bd",
                f"Wystpi bd podczas wstawiania nieobecnoci: {str(e)}",
                QMessageBox.Ok
            )

    def _build_new_symbol_with_absence_fixed(self, current_symbol, special_symbol, cell_data):
        """
        NOWA METODA: Buduje nowy symbol z nieobecnoci u偶ywajc build_symbol z symbol_parser.py

        Args:
            current_symbol (str): Obecny symbol w kom贸rce
            special_symbol (str): Symbol nieobecnoci (np. "CO", "UZ")
            cell_data (dict): Dane kom贸rki

        Returns:
            str: Nowy symbol z nieobecnoci
        """
        from symbol_parser import parse_symbol, build_symbol

        # Jeli nie ma obecnego symbolu, u偶yj tylko symbolu nieobecnoci
        if not current_symbol or current_symbol.strip() == '':
            debug_print(f"Pusta kom贸rka - wstawiam tylko symbol nieobecnoci: {special_symbol}")
            return special_symbol

        # Parsuj obecny symbol
        parsed = parse_symbol(current_symbol)
        debug_print(f"Parsed current symbol '{current_symbol}': {parsed}")

        # Pobierz lokalizacj domyln z danych kom贸rki jeli brak w symbolu
        location = parsed.get('location')
        if not location:
            location = cell_data.get('lokalizacja_domyslna', 'h')  # Domylnie 'h'

        # Zachowaj godziny z obecnego symbolu (jeli s)
        start_hour = parsed.get('start_hour')
        work_hours = parsed.get('work_hours')

        # Zbuduj nowy symbol z zachowaniem lokalizacji i godzin, ale z nowym symbolem specjalnym
        new_symbol = build_symbol(
            # location=location,
            start_hour=start_hour,
            work_hours=work_hours,
            special_symbol=special_symbol
        )

        # Jeli build_symbol zwr贸ci pusty string (mo偶e si zdarzy), u偶yj samego symbolu nieobecnoci
        if not new_symbol:
            new_symbol = special_symbol

        debug_print(f"Zbudowano nowy symbol: '{current_symbol}' -> '{new_symbol}'")
        return new_symbol

    def _call_import_changes_procedure(self, nr_kadrowy, rok, miesiac, data, symbol):
        """
        Wywouje procedur p_P_ZZ_ImportZmianNaSerwer_v4

        Args:
            nr_kadrowy (str): Numer kadrowy
            rok (int): Rok
            miesiac (int): Miesic
            data (str): Data w formacie YYYY-MM-DD
            symbol (str): Symbol do wstawienia

        Returns:
            dict: Wynik procedury {"success": bool, "message": str, "returned_symbol": str}
        """
        try:
            from db_connector import DatabaseConnector

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            debug_print(
                f"Wywoanie procedury: nr_kadrowy={nr_kadrowy}, rok={rok}, miesiac={miesiac}, data={data}, symbol={symbol}")

            # Wywoaj procedur skadowan
            cursor.execute("""
                EXEC [dbo].[p_P_ZZ_ImportZmianNaSerwer_v4] 
                    @NumerKadrowy = ?, 
                    @Rok = ?, 
                    @Miesiac = ?, 
                    @Data = ?, 
                    @Symbol = ?, 
                    @CzyPobieranieSugestii = ?
            """, (nr_kadrowy, rok, miesiac, data, symbol, None))

            # Pobierz wszystkie wyniki procedury
            all_results = []
            while True:
                try:
                    rows = cursor.fetchall()
                    if rows:
                        all_results.extend(rows)
                    if not cursor.nextset():
                        break
                except Exception:
                    break

            conn.commit()
            conn.close()

            # Analizuj wyniki procedury
            returned_symbol = symbol  # Domylnie zwr贸 oryginalny symbol
            success = True
            message = "Symbol zosta pomylnie wstawiony"

            # Sprawd藕 czy procedura zwr贸cia komunikat
            for row in all_results:
                if row and len(row) > 0:
                    for value in row:
                        value_str = str(value) if value is not None else ""

                        # Sprawd藕 czy to komunikat o bdzie
                        if any(keyword in value_str.lower() for keyword in
                               ['bd', 'error', 'nie mo偶na', 'nieprawidowy']):
                            success = False
                            message = value_str
                            debug_print(f"Procedura zwr贸cia bd: {value_str}")
                            break

                        # Sprawd藕 czy to nowy symbol (jeli r贸偶ni si od wejciowego)
                        elif value_str and value_str != symbol and len(value_str) <= 50:
                            returned_symbol = value_str
                            debug_print(f"Procedura zwr贸cia nowy symbol: {value_str}")

                    if not success:
                        break

            # Aktualizuj dat modyfikacji przy sukcesie
            if success:
                self._update_modification_date()

            return {
                "success": success,
                "message": message,
                "returned_symbol": returned_symbol
            }

        except Exception as e:
            log_error(f"Bd procedury p_P_ZZ_ImportZmianNaSerwer_v4: {e}")
            return {
                "success": False,
                "message": f"Bd bazy danych: {str(e)}",
                "returned_symbol": symbol
            }

    def _refresh_data_after_symbol_changes(self, affected_pairs):
        """
        UPROSZCZONA WERSJA: Odwie偶a tylko zmienione kom贸rki - bez nadmiernych komplikacji
        """
        try:
            if not affected_pairs:
                return

            debug_print(f"Odwie偶anie {len(affected_pairs)} zmienionych kom贸rek - PROSTO I SKUTECZNIE")

            # 1. Pobierz aktualny miesic
            current_data = self.date_combo.currentData()
            if not current_data:
                return
            year, month = current_data

            # 2. Dla ka偶dej zmienionej kom贸rki - pobierz nowy symbol i zaktualizuj model
            for user_id, date_str in affected_pairs:
                new_symbol = self._fetch_single_cell_symbol(user_id, date_str, year, month)
                if new_symbol is not None:
                    self._update_single_cell_in_model(user_id, date_str, new_symbol, year, month)

            # 3. Wyczy cache ikon dla zmienionych kom贸rek
            if hasattr(self.data_provider, 'invalidate_specific_icons'):
                self.data_provider.invalidate_specific_icons(affected_pairs)

            debug_print(f"Zakoczono proste odwie偶enie {len(affected_pairs)} kom贸rek")

        except Exception as e:
            log_error(f"Bd podczas prostego odwie偶ania: {e}")

    def _update_single_cell_in_model(self, user_id, date_str, new_symbol, year, month):
        """
        NOWA PROSTA METODA: Aktualizuje jedn kom贸rk w modelu i wymusza jej odwie偶enie
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return False

            # Znajd藕 pozycj kom贸rki
            row_index = -1
            for idx, key in enumerate(self.schedule_model._keys):
                if str(key[3]) == str(user_id):
                    row_index = idx
                    break

            if row_index == -1:
                debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                return False

            # Oblicz kolumn
            try:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)
                if int(year_str) != year or int(month_str) != month:
                    return False
            except:
                return False

            visible_columns_count = len(self.schedule_model.get_visible_columns())
            col_index = visible_columns_count + day - 1

            # KLUCZOWE: U偶yj setData aby model wiedzia o zmianie
            model_index = self.schedule_model.index(row_index, col_index)
            if model_index.isValid():
                # Ustaw nowy symbol przez model - to wywoa automatyczne odwie偶enie
                success = self.schedule_model.setData(model_index, new_symbol, Qt.EditRole)

                if success:
                    debug_print(f"SUKCES: Zaktualizowano kom贸rk [{row_index},{col_index}] = '{new_symbol}'")
                    return True
                else:
                    debug_print(f"BD: Nie udao si zaktualizowa kom贸rki [{row_index},{col_index}]")

            return False

        except Exception as e:
            log_error(f"Bd aktualizacji kom贸rki {user_id}/{date_str}: {e}")
            return False

    def _update_model_with_new_symbols(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje symbole bezporednio w modelu
        """
        try:
            if not updated_symbols or not hasattr(self, 'schedule_model'):
                return

            processed_data = self.schedule_model.get_processed_data()
            if not processed_data:
                return

            updated_count = 0
            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Znajd藕 klucz u偶ytkownika w processed_data
                target_key = None
                for key in processed_data.keys():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        target_key = key
                        break

                if not target_key:
                    debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                    continue

                # Oblicz dzie z daty
                try:
                    year_str, month_str, day_str = date_str.split('-')
                    day = int(day_str)

                    if int(year_str) != year or int(month_str) != month:
                        continue

                except ValueError:
                    continue

                # Aktualizuj symbol w processed_data
                user_data = processed_data[target_key]
                days_data = user_data.setdefault('days', {})
                day_data = days_data.setdefault(day, {})

                old_symbol = day_data.get('symbol', '')
                day_data['symbol'] = new_symbol

                # Przelicz godziny na podstawie nowego symbolu
                from symbol_parser import parse_symbol
                parsed = parse_symbol(new_symbol)
                day_data['hours'] = parsed.get('work_hours', 0) or 0
                day_data['start_hour'] = parsed.get('start_hour')

                # Aktualizuj total_hours u偶ytkownika
                old_hours = 0
                if old_symbol:
                    old_parsed = parse_symbol(old_symbol)
                    old_hours = old_parsed.get('work_hours', 0) or 0

                new_hours = day_data['hours']
                user_data['total_hours'] = (user_data.get('total_hours', 0) or 0) - old_hours + new_hours

                updated_count += 1
                debug_print(
                    f"Model: Zaktualizowano {user_id}/{day}: '{old_symbol}' -> '{new_symbol}' ({old_hours}h -> {new_hours}h)")

            debug_print(f"Zaktualizowano {updated_count} kom贸rek w modelu")

        except Exception as e:
            log_error(f"Bd aktualizacji modelu: {e}")

    def _fetch_single_cell_symbol(self, user_id, date_str, year, month):
        """
        NOWA METODA: Pobiera aktualny symbol dla pojedynczej kom贸rki z bazy danych

        Args:
            user_id (int): ID u偶ytkownika
            date_str (str): Data w formacie YYYY-MM-DD
            year (int): Rok
            month (int): Miesic

        Returns:
            str|None: Aktualny symbol lub None jeli nie znaleziono
        """
        try:
            from db_connector import DatabaseConnector

            # Zapytanie do pobrania symbolu dla konkretnej kom贸rki
            query = """
            SELECT Symbol 
            FROM [dbo].[fn_GetScheduleData](?, ?) 
            WHERE Uzytkownik = ? AND Data = ?
            """

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query, (year, month, user_id, date_str))
            result = cursor.fetchone()
            conn.close()

            if result and result[0] is not None:
                return str(result[0])

            return None

        except Exception as e:
            log_error(f"Bd podczas pobierania symbolu dla kom贸rki {user_id}/{date_str}: {e}")
            return None

    def _update_data_provider_cache(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje cache w DataProvider
        """
        try:
            if not updated_symbols or not hasattr(self.data_provider, 'monthly_cache'):
                return

            month_key = (year, month)
            if month_key not in self.data_provider.monthly_cache:
                return

            container = self.data_provider.monthly_cache[month_key]

            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Aktualizuj processed_data w kontenerze
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):
                        try:
                            year_str, month_str, day_str = date_str.split('-')
                            day = int(day_str)

                            if int(year_str) == year and int(month_str) == month:
                                days_data = user_data.setdefault('days', {})
                                day_data = days_data.setdefault(day, {})
                                day_data['symbol'] = new_symbol

                                # Przelicz godziny
                                from symbol_parser import parse_symbol
                                parsed = parse_symbol(new_symbol)
                                day_data['hours'] = parsed.get('work_hours', 0) or 0
                                day_data['start_hour'] = parsed.get('start_hour')

                                debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")
                                break
                        except:
                            continue

        except Exception as e:
            log_error(f"Bd aktualizacji DataProvider cache: {e}")

    def _force_full_refresh(self):
        """Fallback - pene odwie偶enie danych"""
        try:
            current_data = self.date_combo.currentData()
            if current_data:
                year, month = current_data
                self.data_provider.refresh_data(year, month)
                self.update_table_content()
        except Exception as e:
            log_error(f"Bd penego odwie偶enia: {e}")

    def _force_refresh_specific_cells(self, affected_pairs, year, month):
        """
        POPRAWIONA METODA: Wymusza odwie偶enie konkretnych kom贸rek w widoku
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycj kom贸rki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajd藕 wiersz u偶ytkownika w modelu
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumn dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymusza odwie偶enie kom贸rki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej kom贸rki
                        self.schedule_model.dataChanged.emit(model_index, model_index,
                                                             [Qt.DisplayRole, Qt.BackgroundRole])

                        # Metoda 2: Wymu update widoku dla tej kom贸rki
                        self.table.schedule_view.update(model_index)

                        refreshed_cells += 1
                        debug_print(f"Odwie偶ono kom贸rk tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"Bd odwie偶ania kom贸rki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymu caociowy update viewport jeli zmieniono jakie kom贸rki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po odwie偶eniu {refreshed_cells} kom贸rek")

                # DODATKOWE: Wymu te偶 odwie偶enie tabeli pracownik贸w (dla sum RBH)
                if hasattr(self.table, 'employees_view'):
                    self.table.employees_view.viewport().update()

        except Exception as e:
            log_error(f"Bd podczas wymuszania odwie偶enia kom贸rek tabeli: {e}")

    def _update_model_cells_directly(self, updated_symbols, year, month):
        """
        Aktualizuje symbole bezporednio w modelu i DataProvider

        Args:
            updated_symbols (dict): Sownik {(user_id, date_str): symbol}
            year (int): Rok
            month (int): Miesic
        """
        try:
            if not updated_symbols:
                return

            updated_count = 0

            # AKTUALIZACJA 1: Schedule Model processed_data
            if hasattr(self, 'schedule_model') and self.schedule_model:
                processed_data = self.schedule_model.get_processed_data()

                if processed_data:
                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        if self._update_single_cell_in_processed_data(processed_data, user_id, date_str, new_symbol,
                                                                      year, month):
                            updated_count += 1

            # AKTUALIZACJA 2: DataProvider cache (jeli istnieje)
            if hasattr(self.data_provider, 'monthly_cache'):
                month_key = (year, month)
                if month_key in self.data_provider.monthly_cache:
                    container = self.data_provider.monthly_cache[month_key]

                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        self._update_single_cell_in_data_provider(container, user_id, date_str, new_symbol, year, month)

            debug_print(f"Zaktualizowano {updated_count} kom贸rek w modelu")

        except Exception as e:
            log_error(f"Bd bezporedniej aktualizacji modelu: {e}")

    def _update_single_cell_in_processed_data(self, processed_data, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedyncz kom贸rk w processed_data

        Returns:
            bool: True jeli zaktualizowano
        """
        try:
            # Znajd藕 klucz u偶ytkownika
            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if not target_key:
                debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                return False

            # Oblicz dzie
            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)

            if int(year_str) != year or int(month_str) != month:
                return False

            # Aktualizuj symbol
            user_data = processed_data[target_key]
            days_data = user_data.setdefault('days', {})
            day_data = days_data.setdefault(day, {})

            old_symbol = day_data.get('symbol', '')
            day_data['symbol'] = new_symbol

            # Przelicz godziny i inne parametry
            from symbol_parser import parse_symbol
            parsed = parse_symbol(new_symbol)
            day_data['hours'] = parsed.get('work_hours', 0) or 0
            day_data['start_hour'] = parsed.get('start_hour')

            debug_print(f"Model: {user_id}/{day} '{old_symbol}' -> '{new_symbol}'")
            return True

        except Exception as e:
            log_error(f"Bd aktualizacji kom贸rki processed_data {user_id}/{date_str}: {e}")
            return False

    def _update_single_cell_in_data_provider(self, container, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedyncz kom贸rk w DataProvider cache
        """
        try:
            if not hasattr(container, 'processed_data') or not container.processed_data:
                return

            # Podobna logika jak dla processed_data w modelu
            processed_data = container.processed_data

            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if target_key:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)

                if int(year_str) == year and int(month_str) == month:
                    user_data = processed_data[target_key]
                    days_data = user_data.setdefault('days', {})
                    day_data = days_data.setdefault(day, {})
                    day_data['symbol'] = new_symbol

                    # Przelicz godziny
                    from symbol_parser import parse_symbol
                    parsed = parse_symbol(new_symbol)
                    day_data['hours'] = parsed.get('work_hours', 0) or 0
                    day_data['start_hour'] = parsed.get('start_hour')

                    debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")

        except Exception as e:
            log_error(f"Bd aktualizacji DataProvider cache: {e}")

    def _force_refresh_table_cells(self, affected_pairs, year, month):
        """
        WYMUSZA odwie偶enie konkretnych kom贸rek w widoku tabeli

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
            year (int): Rok
            month (int): Miesic
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycj kom贸rki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajd藕 wiersz u偶ytkownika
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumn dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymu odwie偶enie kom贸rki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej kom贸rki
                        self.schedule_model.dataChanged.emit(model_index, model_index, [])

                        # Metoda 2: Wymu update widoku (backup)
                        self.table.schedule_view.update(model_index)

                        # Metoda 3: Invalidate item (backup)
                        if hasattr(self.table.schedule_view, 'setDirtyRegion'):
                            rect = self.table.schedule_view.visualRect(model_index)
                            if not rect.isEmpty():
                                self.table.schedule_view.viewport().update(rect)

                        refreshed_cells += 1
                        debug_print(f"Odwie偶ono kom贸rk tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"Bd odwie偶ania kom贸rki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymu caociowy update viewport jeli zmieniono jakie kom贸rki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po odwie偶eniu {refreshed_cells} kom贸rek")

        except Exception as e:
            log_error(f"Bd podczas wymuszania odwie偶enia kom贸rek tabeli: {e}")

    def _find_user_row_in_model(self, user_id):
        """
        POPRAWIONA METODA: Znajduje indeks wiersza dla danego u偶ytkownika w modelu
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return -1

            # Pobierz klucze z modelu
            if hasattr(self.schedule_model, '_keys'):
                keys = self.schedule_model._keys
            else:
                return -1

            user_id_str = str(user_id)

            for row_index, key in enumerate(keys):
                if len(key) > 3 and str(key[3]) == user_id_str:
                    return row_index

            return -1

        except Exception as e:
            log_error(f"Bd podczas szukania wiersza u偶ytkownika {user_id}: {e}")
            return -1

    def _update_local_events_for_cells(self, affected_pairs):
        """
        Aktualizuje lokalny events_data tylko dla zmienionych kom贸rek

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
        """
        try:
            if not hasattr(self, 'events_data'):
                return

            # Sprawd藕 czy jakie z zmienionych kom贸rek s obecnie zaznaczone
            if not hasattr(self, 'table'):
                return

            current_selection = self.table.get_data_for_selected_cells()
            selected_pairs = set()

            for cell_data in current_selection:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    selected_pairs.add((user_id, date_str))

            # Sprawd藕 czy kt贸ra ze zmienionych kom贸rek jest zaznaczona
            intersection = set(affected_pairs) & selected_pairs

            if intersection:
                debug_print(f"Zaktualizowano {len(intersection)} zmienionych kom贸rek w events_data")
                # Jeli tak, odwie偶 events_data tylko dla zaznaczonych kom贸rek
                self.on_selection_changed()

        except Exception as e:
            log_error(f"Bd podczas aktualizacji lokalnych events: {e}")

    def _show_symbol_change_results(self, successful_updates, failed_updates, error_messages, events_to_cancel):
        """
        Pokazuje wyniki operacji wstawiania symboli

        Args:
            successful_updates (int): Liczba udanych aktualizacji
            failed_updates (int): Liczba nieudanych aktualizacji
            error_messages (list): Lista komunikat贸w bd贸w
            events_to_cancel (list): Lista odwoanych zdarze
        """
        if successful_updates > 0:
            message = f"Pomylnie zaktualizowano {successful_updates} kom贸rek"

            if events_to_cancel:
                message += f" i odwoano {len(events_to_cancel)} delegacji"

            if failed_updates > 0:
                message += f"\n\n锔 {failed_updates} aktualizacji nie powiodo si"
                if error_messages:
                    message += ":\n" + "\n".join(error_messages[:5])
                    if len(error_messages) > 5:
                        message += f"\n... i {len(error_messages) - 5} wicej bd贸w"

            if failed_updates == 0:
                QMessageBox.information(
                    self, "Sukces", message, QMessageBox.Ok
                )
            else:
                QMessageBox.warning(
                    self, "Czciowy sukces", message, QMessageBox.Ok
                )
        else:
            message = f"Nie udao si zaktualizowa 偶adnej kom贸rki"
            if error_messages:
                message += f"\n\nBdy ({len(error_messages)}):\n"
                message += "\n".join(error_messages[:10])
                if len(error_messages) > 10:
                    message += f"\n... i {len(error_messages) - 10} wicej bd贸w"

            QMessageBox.critical(
                self, "Bd aktualizacji", message, QMessageBox.Ok
            )

    def _prepare_delegations_description(self, grouped_events, max_groups=10):
        """
        Przygotowuje opis delegacji do odwoania.

        Args:
            grouped_events: Sownik zdarze pogrupowanych wedug u偶ytkownika i daty
            max_groups: Maksymalna liczba grup do wywietlenia

        Returns:
            str: Opis delegacji do odwoania
        """
        delegations_info = ""

        if not grouped_events:
            return delegations_info

        delegations_info += "\nNastpujce delegacje zostan automatycznie odwoane:\n"

        # Licznik dla ograniczenia liczby wywietlanych grup
        group_count = 0

        for (user_id, date_str), events in grouped_events.items():
            # Ograniczenie liczby wywietlanych grup
            if group_count >= max_groups:
                delegations_info += f"\n...oraz wicej zdarze dla innych u偶ytkownik贸w/dni ({len(grouped_events) - max_groups} wicej grup)...\n"
                break

            # Pobierz nazw u偶ytkownika z pierwszego zdarzenia
            user_name = events[0].get('user_name', f"ID: {user_id}")

            # Przygotuj dat w adniejszym formacie (DD.MM.YYYY)
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            delegations_info += f"    {user_name} -  {formatted_date}:\n"

            # Wywietl zdarzenia dla tego u偶ytkownika i daty
            for i, event in enumerate(events):
                delegations_info += f"      {i + 1}. {event['type']}: {event['name']}\n"

            group_count += 1

        return delegations_info

    def filter_processed_data(self):
        """
        Filtruje przetworzone dane na podstawie bie偶cych filtr贸w.
        Zwraca przefiltrowane dane w formacie sownikowym.

        Returns:
            dict: Przefiltrowane dane
        """
        # Pobierz wszystkie dane z processed_data
        all_data = self.processed_data.copy() if hasattr(self, 'processed_data') else {}

        # Jeli nie ma danych do filtrowania, zwr贸 pusty sownik
        if not all_data:
            return {}

        # Pobierz wybrane filtry
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self,
                                                                                            'przelozony_list') else []
        selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list) if hasattr(self,
                                                                                             'uzytkownik_list') else []
        selected_dtn = self.dtn_combo.get_selected_items() if hasattr(self, 'dtn_combo') else []
        selected_role = self.rola_combo.get_selected_items() if hasattr(self, 'rola_combo') else []
        selected_jezyki = self.jezyk_combo.get_selected_items() if hasattr(self, 'jezyk_combo') else []
        selected_etaty = self.etat_combo.get_selected_items() if hasattr(self, 'etat_combo') else []

        # Filtruj dane
        filtered_data = {}
        for key, data in all_data.items():
            wydzial, przelozony, uzytkownik_dane, uzytkownik = key

            # Pobierz wartoci p贸l do filtrowania
            dtn = str(data.get('dtn', ''))
            rola_nazwa = data.get('rola_nazwa', '')
            jezyk = data.get('jezyk', '')
            etat = str(data.get('etat', '')) if data.get('etat') is not None else ''

            # Sprawd藕, czy dane speniaj kryteria filtrowania
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni) and \
                    (not selected_uzytkownicy or str(uzytkownik_dane) in selected_uzytkownicy) and \
                    (not selected_dtn or dtn in selected_dtn) and \
                    (not selected_role or rola_nazwa in selected_role) and \
                    (not selected_jezyki or jezyk in selected_jezyki) and \
                    (not selected_etaty or etat in selected_etaty):
                # Dodaj dane do przefiltrowanych wynik贸w
                filtered_data[key] = data

        return filtered_data

    def _cancel_delegations(self, events_to_cancel):
        """
        Odwouje delegacje (spotkania, szkolenia i nadgodziny).

        Args:
            events_to_cancel: Lista zdarze do odwoania

        Returns:
            int: Liczba odwoanych delegacji
        """
        try:
            # Pobierz identyfikator u偶ytkownika
            _, user_app_id, _ = get_modifier_id()

            # Przygotuj zbi贸r do ledzenia par u偶ytkownik-data do aktualizacji
            affected_users_dates = set()

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            canceled_count = 0

            # Dla ka偶dego zdarzenia do odwoania
            for event in events_to_cancel:
                event_id = event.get('id')
                event_type = event.get('type')
                user_id = event.get('user_id')
                date_key = event.get('date_key')

                # KLUCZOWA POPRAWKA: Sprawd藕 czy mamy wszystkie wymagane dane
                if not event_id or not event_type or not user_id:
                    debug_print(
                        f"POMINITO zdarzenie z niepenymi danymi: id={event_id}, type={event_type}, user_id={user_id}")
                    continue

                # Okrel odpowiedni tabel i typ operacji
                table_name = ""
                if event_type == "Spotkanie":
                    table_name = "p_t_zz_Spotkania"
                elif event_type == "Szkolenie":
                    table_name = "p_t_zz_Szkolenia"
                elif event_type == "Nadgodziny":
                    table_name = "p_t_zz_Nadgodziny"

                if not table_name:
                    debug_print(f"Nieznany typ zdarzenia: {event_type}")
                    continue

                try:
                    # Aktualizuj status zdarzenia
                    if event_type in ["Spotkanie", "Szkolenie"]:
                        # Dla spotka i szkole zmieniamy status zamiast usuwa
                        update_query = f"""
                        UPDATE {table_name} 
                        SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? 
                        WHERE Id = ?
                        """
                        debug_print(f"UPDATE {table_name}: Status=0 dla ID={event_id}")
                        cursor.execute(update_query, (user_app_id, event_id))
                    else:
                        # Dla nadgodzin usuwamy rekord
                        delete_query = f"DELETE FROM {table_name} WHERE Id = ?"
                        debug_print(f"DELETE z {table_name}: ID={event_id}")
                        cursor.execute(delete_query, (event_id,))

                    # Sprawd藕 czy operacja si powioda
                    if cursor.rowcount > 0:
                        canceled_count += 1
                        affected_users_dates.add((user_id, date_key))

                        # Usu zdarzenie z indeksu zdarze
                        if hasattr(self.data_provider, 'events_index'):
                            self.data_provider.events_index.delete_event(event_id, event_type)

                        debug_print(
                            f"SUKCES: Odwoano {event_type} o ID {event_id} dla u偶ytkownika {user_id}, data {date_key}")
                    else:
                        debug_print(f"UWAGA: Nie znaleziono {event_type} o ID {event_id} w bazie danych")

                except Exception as e:
                    log_error(f"Bd podczas odwoywania {event_type} o ID {event_id}: {e}")
                    continue

            # Zatwierd藕 wszystkie zmiany
            conn.commit()
            conn.close()

            debug_print(f"Operacja zakoczona: odwoano {canceled_count} z {len(events_to_cancel)} delegacji")

            # Wyczy cache dla wszystkich zmienionych miesicy
            year_month_cache = {}
            for user_id, date_str in affected_users_dates:
                if date_str and date_str.count('-') == 2:
                    year, month, _ = date_str.split('-')
                    year_month_cache[(int(year), int(month))] = True

            for year, month in year_month_cache.keys():
                self.clear_events_cache(year, month)
                debug_print(f"Wyczyszczono cache dla {year}-{month}")

            return canceled_count

        except Exception as e:
            log_error(f"Bd podczas odwoywania delegacji: {e}")
            import traceback
            traceback.print_exc()
            return 0

    def update_filter_dates(self):
        """Aktualizuje daty filtrowania do pierwszego i ostatniego dnia wybranego miesica"""
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # KLUCZOWA POPRAWKA: Blokuj sygnay przed zmian dat
        self.date_from.blockSignals(True)
        self.date_to.blockSignals(True)
        
        try:
            # Pierwszy dzie miesica
            first_day = QDate(year, month, 1)
            self.date_from.setDate(first_day)

            # Ostatni dzie miesica
            if month == 12:
                next_month = QDate(year + 1, 1, 1)
            else:
                next_month = QDate(year, month + 1, 1)

            last_day = next_month.addDays(-1)
            self.date_to.setDate(last_day)
            
        finally:
            # ZAWSZE odblokuj sygnay
            self.date_from.blockSignals(False)
            self.date_to.blockSignals(False)

        # Wywoaj filtrowanie tylko RAZ po wszystkich zmianach
        self.filter_events_table()

    def on_date_combo_changed(self):
        """
        ZMODYFIKOWANA: Zmiana miesica z async loading
        """
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            # NOWE: Poinformuj DataProvider o zmianie miesica
            if hasattr(self.data_provider, 'on_month_change'):
                self.data_provider.on_month_change(year, month)

            # ZMIANA: U偶yj async loading dla zmiany miesica
            self.update_data(year, month, use_async=True)
            self.update_filter_dates()

    def update_data(self, year, month, use_async=True):
        """
        NOWA WERSJA: adowanie danych z opcj async

        Args:
            year: Rok
            month: Miesic
            use_async: Czy u偶y asynchronicznego adowania (domylnie True)
        """
        debug_print(f"Rozpoczynam adowanie danych dla {year}-{month} (async={use_async})")

        self.year = year
        self.month = month

        # Sprawd藕 czy modele zostay zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            debug_print("Tworz nowy model grafiku")
            self.schedule_model = ScheduleTableModel(self)
            self.schedule_model.set_theme(self.is_dark_theme)

            ui_columns = self.column_definitions.get_ui_display_columns()
            visible_cols = self.visible_columns
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

        if not hasattr(self, 'events_model') or not self.events_model:
            debug_print("Tworz nowy model zdarze")
            self.events_model = EventsTableModel(self)
            self.events_model.set_theme(self.is_dark_theme)

        # KLUCZOWA ZMIANA: U偶yj async loading dla du偶ych zbior贸w danych
        if use_async:
            self._load_data_async(year, month)
        else:
            self._load_data_sync(year, month)

    def _load_data_sync(self, year, month):
        """
        STARA METODA: Synchroniczne adowanie danych (fallback)
        """
        debug_print(f"adowanie synchroniczne dla {year}-{month}")

        try:
            # Poka偶 prost informacj o adowaniu
            if hasattr(self, 'statusBar'):
                self.statusBar().showMessage(f"adowanie danych {year}-{month}...")

            # Pobierz dane z DataProvider
            container = self.data_provider._get_or_load_monthly_data(year, month, use_cache=False)

            if container:
                self._apply_loaded_data({
                    'schedule_data': container.schedule_data,
                    'events_data': container.events_data,
                    'processed_data': container.processed_data,
                    'year': year,
                    'month': month
                })
            else:
                log_error("Nie udao si pobra danych z DataProvider")

        except Exception as e:
            log_error(f"Bd podczas synchronicznego adowania: {e}")

        finally:
            if hasattr(self, 'statusBar'):
                self.statusBar().clearMessage()

    def _load_data_async(self, year, month):
        """
        NOWA METODA: Asynchroniczne adowanie danych z progress dialog
        """
        debug_print(f"Uruchamiam async adowanie dla {year}-{month}")

        # Poka偶 dialog adowania
        self.loading_dialog = LoadingProgressDialog(self, self.data_provider, year, month)

        # Podcz sygnay
        self.loading_dialog.loading_completed.connect(self._on_async_data_loaded)
        self.loading_dialog.loading_cancelled.connect(self._on_async_loading_cancelled)
        self.loading_dialog.loading_failed.connect(self._on_async_loading_failed)

        # Poka偶 dialog
        result = self.loading_dialog.exec()

        # Sprztanie
        if hasattr(self, 'loading_dialog'):
            self.loading_dialog.deleteLater()
            delattr(self, 'loading_dialog')

    def _on_async_data_loaded(self, data):
        """
        NOWA METODA: Obsuguje pomylne zaadowanie danych async
        """
        debug_print("Otrzymano dane z async loading")

        try:
            self._apply_loaded_data(data)
            debug_print("Pomylnie zastosowano dane z async loading")
        except Exception as e:
            log_error(f"Bd podczas stosowania zaadowanych danych: {e}")

    def _on_async_loading_cancelled(self):
        """
        NOWA METODA: Obsuguje anulowanie adowania
        """
        debug_print("Async loading zosta anulowany przez u偶ytkownika")
        # Mo偶na doda logik powrotu do poprzedniego stanu

    def _on_async_loading_failed(self, error_message):
        """
        NOWA METODA: Obsuguje bdy async loading
        """
        debug_print(f"Async loading failed: {error_message}")

        # Poka偶 komunikat bdu u偶ytkownikowi
        from PySide6.QtWidgets import QMessageBox
        QMessageBox.critical(
            self,
            "Bd adowania danych",
            f"Nie udao si zaadowa danych:\n{error_message}\n\nSpr贸buj ponownie lub skontaktuj si z administratorem.",
            QMessageBox.Ok
        )

        # Fallback - spr贸buj zaadowa synchronicznie
        try:
            debug_print("Pr贸buj fallback do synchronicznego adowania")
            self._load_data_sync(self.year, self.month)
        except Exception as e:
            log_error(f"Fallback loading te偶 nie powi贸d si: {e}")

    def _apply_loaded_data(self, data):
        """
        NOWA METODA: Aplikuje zaadowane dane do modeli i UI
        """
        schedule_data = data['schedule_data']
        events_data = data['events_data']
        processed_data = data['processed_data']
        year = data['year']
        month = data['month']

        debug_print(f"Aplikuj dane: {len(schedule_data)} wierszy grafiku, "
                    f"{len(events_data)} zdarze, {len(processed_data)} u偶ytkownik贸w")

        # Aktualizuj model grafiku
        self.schedule_model.update_data(self.data_provider, year, month)

        # Wyczy model zdarze
        debug_print("Model zdarze pozostaje pusty - oczekuje na zaznaczenie kom贸rek")
        if not hasattr(self, 'events_data'):
            self.events_data = []
        if hasattr(self, 'events_model'):
            self.events_model.update_data([])  # Pusta tabela zdarze

        # Zachowaj dane dla kompatybilnoci
        self.raw_data = schedule_data
        self.all_events_data = events_data
        self.processed_data = processed_data

        # Filtruj dane grafiku
        debug_print("Filtruj dane grafiku...")
        filtered_data = self.filter_processed_data()
        self.schedule_model.update_filtered_data(filtered_data)

        # Aktualizuj widoki
        if hasattr(self, 'table') and self.table:
            debug_print("Aktualizuj widok grafiku...")
            self.table.set_model(self.schedule_model)

        if hasattr(self, 'events_table') and self.events_table:
            debug_print("Aktualizuj widok zdarze (pusty)...")
            self.events_table.setModel(self.events_model)
            self.setup_event_table_columns()

        # Aktualizuj filtry
        debug_print("Aktualizuj filtry...")
        self.update_filters()

        # Ustaw daty filtrowania BEZ emitowania sygna贸w
        if hasattr(self, 'date_from') and hasattr(self, 'date_to'):
            # Oblicz pierwszy i ostatni dzie miesica
            first_day = QDate(year, month, 1)

            # Ostatni dzie miesica
            if month == 12:
                next_month = QDate(year + 1, 1, 1)
            else:
                next_month = QDate(year, month + 1, 1)
            last_day = next_month.addDays(-1)

            # Blokuj sygnay przed zmian dat
            self.date_from.blockSignals(True)
            self.date_to.blockSignals(True)

            try:
                self.date_from.setDate(first_day)
                self.date_to.setDate(last_day)
            finally:
                # ZAWSZE odblokuj sygnay
                self.date_from.blockSignals(False)
                self.date_to.blockSignals(False)

        # Odwie偶 widoki
        if hasattr(self, 'table'):
            if hasattr(self.table, 'employees_view'):
                self.table.employees_view.viewport().update()
            if hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

        debug_print("Zakoczono aplikowanie danych")
        self._set_schedule_columns_width()

    def clear_events_cache(self, year, month):
        """
        Czyci cache zdarze dla danego miesica - UPROSZCZONA WERSJA
        
        Args:
            year: Rok
            month: Miesic
        """
        # POPRAWKA: Deleguj TYLKO do DataProvider, bez dodatkowych akcji
        if hasattr(self.data_provider, 'invalidate_icons_cache'):
            self.data_provider.invalidate_icons_cache(year, month)
            debug_print(f"Wyczyszczono cache zdarze dla {year}-{month}")
        else:
            debug_print(f"DataProvider nie ma metody invalidate_icons_cache")

    def get_events_for_user_date(self, user_id, date_str):
        """
        UPROSZCZONA METODA: Deleguje do DataProvider
        """
        return self.data_provider.get_events_for_user_date(user_id, date_str)

    def refresh_column_configuration(self):
        """Odwie偶a konfiguracj kolumn z ColumnDefinitions"""
        # ZMODYFIKOWANE: U偶ywaj self.column_definitions zamiast column_manager
        # Pobierz zaktualizowane dane kolumn
        ui_columns = self.column_definitions.get_ui_display_columns()
        visible_cols = self.visible_columns

        # Aktualizuj referencje w g贸wnej klasie
        self.employee_columns = ui_columns

        # Aktualizuj model
        if hasattr(self, 'schedule_model') and self.schedule_model:
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

            # Jeli tabela ju偶 istnieje, zaktualizuj widok
            if hasattr(self, 'table') and self.table:
                self.table.set_model(self.schedule_model)
                # Dostosuj szeroko tabeli pracownik贸w
                self.table.adjust_employees_table_width()

    def setup_event_table_columns(self):
        """
        Konfiguruje szerokoci kolumn tabeli zdarze.
        Wyodrbnione z metody update_data dla lepszej czytelnoci.
        """
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # U偶ytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

    def refresh_data(self):
        """
        ZMODYFIKOWANA: Pene odwie偶enie danych z async loading
        """
        # Resetuj stan przycisku
        self.refresh_button.setText("Odwie偶 dane")
        button_style = AppStyles.get_button_style("dark" if self.is_dark_theme else "light")
        self.refresh_button.setStyleSheet(button_style)

        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            # PENE odwie偶enie danych i ikon
            self.data_provider.refresh_data(year, month)

            # ZMIANA: U偶yj async loading dla odwie偶ania
            self.update_data(year, month, use_async=True)

    def show_loading_indicator(self, message="adowanie..."):
        """
        Pokazuje wska藕nik adowania w UI
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().showMessage(message)

        # Wycz niekt贸re kontrolki podczas adowania
        self.date_combo.setEnabled(False)
        self.refresh_button.setEnabled(False)

        if hasattr(self, 'left_panel_visible') and self.left_panel_visible:
            self._left_panel.setEnabled(False)

    def hide_loading_indicator(self):
        """
        Ukrywa wska藕nik adowania
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().clearMessage()

        # Wcz z powrotem kontrolki
        self.date_combo.setEnabled(True)
        self.refresh_button.setEnabled(True)

        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(True)

    def get_loading_preferences(self):
        """
        Zwraca preferencje u偶ytkownika dotyczce adowania
        """
        # Mo偶na doda ustawienia w settings_db dla kontroli async loading
        # Na razie zawsze async dla du偶ych zbior贸w danych
        return {
            'use_async_threshold': 1000,  # U偶yj async dla >1000 wierszy
            'show_progress_dialog': True,
            'auto_fallback_to_sync': True
        }

    def check_for_new_data(self):
        """Sprawdza czy s nowe dane w bazie danych, ignorujc wasne modyfikacje"""
        try:
            # Pobierz najnowsz dat modyfikacji z bazy danych
            query = """
                SELECT MAX(DataModyfikacji) as DataModyfikacji FROM p_v_zz_GrafikiPracy
            """
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query)
            result = cursor.fetchone()
            conn.close()

            if result and result[0]:
                latest_modification = result[0]
                debug_print(f"Ostatnia modyfikacja w bazie: {latest_modification}")

                # Jeli to pierwszy raz, zapamitaj dat i wyjd藕
                if not hasattr(self, 'last_modification_date') or not self.last_modification_date:
                    self.last_modification_date = latest_modification
                    debug_print("Zapamitano pocztkow dat modyfikacji")
                    return False

                # Sprawd藕 czy najnowsza modyfikacja jest wasn modyfikacj
                if hasattr(self, 'last_self_modification_date') and self.last_self_modification_date:
                    # Por贸wnaj daty jako string dla pewnoci
                    latest_str = str(latest_modification)
                    self_mod_str = str(self.last_self_modification_date)

                    # Jeli najnowsza modyfikacja to nasza wasna, ignoruj j
                    if latest_str == self_mod_str:
                        debug_print(f"Ignoruj wasn modyfikacj z dat: {latest_str}")
                        return False

                # Sprawd藕 czy s nowsze dane ni偶 ostatnio zapamitane (kt贸re nie s naszymi wasnymi)
                latest_str = str(latest_modification)
                last_str = str(self.last_modification_date)

                # Jeli znajdziesz nowe dane, odwie偶 cache w DataProvider
                if latest_str > last_str:
                    # Aktualizuj ostatni dat modyfikacji
                    self.last_modification_date = latest_modification

                    # Oznacz przycisk odwie偶ania
                    self.refresh_button.setText("Nowe dane!")

                    # Wyra藕ny styl przycisku z nowymi danymi
                    new_data_style = """
                        background-color: #f39c12; 
                        color: white;
                        font-weight: bold;
                        border: 2px solid #e67e22;
                        padding: 5px;
                        border-radius: 3px;
                    """
                    self.refresh_button.setStyleSheet(new_data_style)

                    # Zatrzymaj timer - nie musimy ju偶 sprawdza, czekamy na akcj u偶ytkownika
                    self.check_timer.stop()

                    return True
                else:
                    debug_print("Brak nowych danych")

            return False

        except Exception as e:
            debug_print(f"Bd podczas sprawdzania nowych danych: {e}")
            return False

    def filter_data(self):
        """
        Filtruje dane grafiku i aktualizuje widok.
        ZMIENIONA WERSJA z wzajemnym filtrowaniem.
        """
        # Sprawd藕 czy model istnieje
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # POPRAWKA: Sprawd藕 czy nie jestemy ju偶 w trakcie filtrowania
        if getattr(self, '_updating_filters', False):
            return
            
        self._updating_filters = True
        
        try:
            # NOWE: Najpierw aktualizuj cross-filtry
            self.update_cross_filters()

            # Pobierz przefiltrowane dane
            filtered_data = self.filter_processed_data()

            # Aktualizuj model z przefiltrowanymi danymi
            self.schedule_model.update_filtered_data(filtered_data)
            
        finally:
            self._updating_filters = False

    def update_cross_filters(self):
        """
        NOWA METODA: Aktualizuje filtry wzajemnie na podstawie aktualnych wybor贸w
        """
        # Sprawd藕 czy cross-filtering jest wczone
        if not getattr(self, '_cross_filtering_enabled', True):
            return
            
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return
        
        # KLUCZOWA POPRAWKA: Sprawd藕 czy ju偶 jestemy w trakcie aktualizacji
        if getattr(self, '_updating_cross_filters', False):
            return
            
        # Ustaw flag blokujc
        self._updating_cross_filters = True

        try:
            # Pobierz aktualne wybory
            selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self, 'przelozony_list') else []
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list) if hasattr(self, 'uzytkownik_list') else []

            debug_print(f"Cross-filter: Wydziay={len(selected_wydzialy)}, Przeo偶eni={len(selected_przelozeni)}, U偶ytkownicy={len(selected_uzytkownicy)}")

            # === AKTUALIZACJA WYDZIAW na podstawie przeo偶onych/u偶ytkownik贸w ===
            if hasattr(self, 'wydzial_combo'):
                available_wydzialy = set()
                
                # Jeli wybrano przeo偶onych, poka偶 tylko ich wydziay
                if selected_przelozeni:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        if przelozony in selected_przelozeni and wydzial:
                            available_wydzialy.add(wydzial)
                
                # Jeli wybrano u偶ytkownik贸w, poka偶 tylko ich wydziay
                elif selected_uzytkownicy:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        if str(uzytkownik_dane) in selected_uzytkownicy and wydzial:
                            available_wydzialy.add(wydzial)
                
                # Jeli nic nie wybrano, poka偶 wszystkie wydziay
                else:
                    for key in self.processed_data.keys():
                        wydzial = key[0]
                        if wydzial:
                            available_wydzialy.add(wydzial)
                
                # Zachowaj wybrane wydziay kt贸re s dostpne
                valid_selected_wydzialy = [w for w in selected_wydzialy if w in available_wydzialy]
                
                # Aktualizuj combo wydzia贸w
                self.wydzial_combo.clear()
                self.wydzial_combo.add_items(sorted(available_wydzialy))
                self.wydzial_combo.select_items(valid_selected_wydzialy)

            # === AKTUALIZACJA PRZEO呕ONYCH na podstawie wydzia贸w/u偶ytkownik贸w ===
            if hasattr(self, 'przelozony_list'):
                available_przelozeni = set()
                
                # Jeli wybrano wydziay, poka偶 tylko przeo偶onych z tych wydzia贸w
                if selected_wydzialy:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        if wydzial in selected_wydzialy and przelozony:
                            available_przelozeni.add(przelozony)
                
                # Jeli wybrano u偶ytkownik贸w, poka偶 tylko ich przeo偶onych
                elif selected_uzytkownicy:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        if str(uzytkownik_dane) in selected_uzytkownicy and przelozony:
                            available_przelozeni.add(przelozony)
                
                # Jeli nic nie wybrano, poka偶 wszystkich przeo偶onych
                else:
                    for key in self.processed_data.keys():
                        przelozony = key[1]
                        if przelozony:
                            available_przelozeni.add(przelozony)
                
                # Zachowaj wybranych przeo偶onych kt贸rzy s dostpni
                valid_selected_przelozeni = [p for p in selected_przelozeni if p in available_przelozeni]
                
                # Aktualizuj list przeo偶onych BEZPIECZNIE
                self.update_list_safely(self.przelozony_list, available_przelozeni, valid_selected_przelozeni)

            # === AKTUALIZACJA U呕YTKOWNIKW na podstawie wydzia贸w/przeo偶onych ===
            if hasattr(self, 'uzytkownik_list'):
                available_uzytkownicy = set()
                
                # Jeli wybrano wydziay i/lub przeo偶onych
                if selected_wydzialy or selected_przelozeni:
                    for key in self.processed_data.keys():
                        wydzial, przelozony, uzytkownik_dane, _ = key
                        
                        # Sprawd藕 czy pasuje do filtr贸w wydziau i przeo偶onego
                        wydzial_match = not selected_wydzialy or wydzial in selected_wydzialy
                        przelozony_match = not selected_przelozeni or przelozony in selected_przelozeni
                        
                        if wydzial_match and przelozony_match and uzytkownik_dane:
                            available_uzytkownicy.add(str(uzytkownik_dane))
                
                # Jeli nic nie wybrano, poka偶 wszystkich u偶ytkownik贸w
                else:
                    for key in self.processed_data.keys():
                        uzytkownik_dane = key[2]
                        if uzytkownik_dane:
                            available_uzytkownicy.add(str(uzytkownik_dane))
                
                # Zachowaj wybranych u偶ytkownik贸w kt贸rzy s dostpni
                valid_selected_uzytkownicy = [u for u in selected_uzytkownicy if u in available_uzytkownicy]
                
                # Aktualizuj list u偶ytkownik贸w BEZPIECZNIE
                self.update_list_safely(self.uzytkownik_list, available_uzytkownicy, valid_selected_uzytkownicy)

            debug_print("Cross-filter zakoczone")

        except Exception as e:
            log_error(f"Bd podczas cross-filtrowania: {e}")
            import traceback
            traceback.print_exc()
        finally:
            # KLUCZOWA POPRAWKA: Zawsze odblokuj flag
            self._updating_cross_filters = False

    def update_list_safely(self, list_widget, items, selected_items):
        """
        NOWA METODA: Bezpiecznie aktualizuje list bez wywoania sygna贸w
        """
        if not list_widget:
            return
            
        # Blokuj sygnay podczas aktualizacji
        list_widget.blockSignals(True)
        
        try:
            list_widget.clear()
            for item_text in sorted(items):
                item = QListWidgetItem(item_text)
                list_widget.addItem(item)
                if item_text in selected_items:
                    item.setSelected(True)
        finally:
            # Zawsze odblokuj sygnay
            list_widget.blockSignals(False)

    def clear_filters(self):
        """
        Czyci wszystkie filtry i aktualizuje model.
        ZMIENIONA WERSJA z penym resetem cross-filtr贸w.
        """
        # NOWE: Tymczasowo wycz cross-filtering podczas czyszczenia
        self._cross_filtering_enabled = False
        
        try:
            # Wyczy filtry ComboBox z wielokrotnym wyborem
            for combo_name in ['wydzial_combo', 'dtn_combo', 'rola_combo', 'jezyk_combo', 'etat_combo']:
                if hasattr(self, combo_name):
                    combo = getattr(self, combo_name)
                    combo.clear_selection()

            # Wyczy filtry list BEZPIECZNIE
            if hasattr(self, 'przelozony_list'):
                self.przelozony_list.blockSignals(True)
                self.przelozony_list.clearSelection()
                self.przelozony_list.blockSignals(False)

            if hasattr(self, 'uzytkownik_list'):
                self.uzytkownik_list.blockSignals(True)
                self.uzytkownik_list.clearSelection()
                self.uzytkownik_list.blockSignals(False)

            # Wyczy pola filtrowania
            if hasattr(self, 'przelozony_filter'):
                self.przelozony_filter.clear()

            if hasattr(self, 'uzytkownik_filter'):
                self.uzytkownik_filter.clear()

            # Poka偶 wszystkie elementy list
            if hasattr(self, 'przelozony_list'):
                for i in range(self.przelozony_list.count()):
                    self.przelozony_list.item(i).setHidden(False)

            if hasattr(self, 'uzytkownik_list'):
                for i in range(self.uzytkownik_list.count()):
                    self.uzytkownik_list.item(i).setHidden(False)

            # Resetuj zmienne ledzce filtry
            self._last_selected_wydzialy = []
            self._last_selected_przelozeni = []

            # NOWE: Wcz z powrotem cross-filtering
            self._cross_filtering_enabled = True

            # Flaga zabezpieczajca przed ptl w cross-filtering
            self._updating_cross_filters = False
            # Flaga zabezpieczajca przed ptl w filter_data
            self._updating_filters = False
            
            # Pene odwie偶enie filtr贸w po wyczyszczeniu
            self.update_filters()  # Przeaduj wszystkie dostpne opcje
            
            # Aktualizuj dane
            self.filter_data()
        
        finally:
            # Upewnij si 偶e cross-filtering jest wczone
            self._cross_filtering_enabled = True

    def filter_przelozony_list(self, text):
        """
        Filtruje list przeo偶onych na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'przelozony_list'):
            return

        text = text.lower()
        for i in range(self.przelozony_list.count()):
            item = self.przelozony_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_uzytkownik_list(self, text):
        """
        Filtruje list u偶ytkownik贸w na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'uzytkownik_list'):
            return

        text = text.lower()
        for i in range(self.uzytkownik_list.count()):
            item = self.uzytkownik_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def update_filtered_table(self):
        """
        Aktualizuje widok tabeli na podstawie zaznaczonych filtr贸w
        """
        # Bezporednio aktualizuj ca tabel z przefiltrowanymi danymi
        self.update_table_content()

    def get_list_selected_items(self, list_widget):
        """
        Zwraca teksty zaznaczonych element贸w z listy.
        POPRAWKA: Zmieniono nazw metody z get_selected_items na get_list_selected_items,
        aby unikn konfliktu z metod get_selected_items w CustomMultiComboBox.

        Args:
            list_widget: QListWidget do pobrania zaznaczonych element贸w

        Returns:
            list: Lista zaznaczonych tekst贸w
        """
        if not list_widget:
            return []

        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item and item.isSelected():
                selected.append(item.text())
        return selected

    def update_filters(self):
        """
        LEKKO ZMODYFIKOWANA: processed_data przychodzi gotowe
        """
        try:
            debug_print("Rozpoczynam aktualizacj filtr贸w...")

            # Sprawd藕 czy mamy processed_data (ju偶 gotowe z DataProvider)
            if not hasattr(self, 'processed_data') or not self.processed_data:
                debug_print("Brak processed_data - pomijam aktualizacj filtr贸w")
                return

            # Zapamitaj bie偶ce zaznaczenia
            selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
            selected_dtn = self.dtn_combo.get_selected_items() if hasattr(self, 'dtn_combo') else []
            selected_role = self.rola_combo.get_selected_items() if hasattr(self, 'rola_combo') else []
            selected_jezyki = self.jezyk_combo.get_selected_items() if hasattr(self, 'jezyk_combo') else []
            selected_etaty = self.etat_combo.get_selected_items() if hasattr(self, 'etat_combo') else []

            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

            # ZMIANA: Korzystaj z gotowego processed_data zamiast budowa je od nowa
            if hasattr(self, 'wydzial_combo'):
                wydzialy = set()
                for key in self.processed_data.keys():
                    wydzial = key[0]
                    if wydzial:
                        wydzialy.add(wydzial)
                self.wydzial_combo.add_items(sorted(wydzialy))
                self.wydzial_combo.select_items(selected_wydzialy)
                debug_print(f"Dodano {len(wydzialy)} wydzia贸w")

            # Reszta logiki bez zmian - wszystkie pozostae filtry
            if hasattr(self, 'dtn_combo'):
                dtn_values = set()
                for _, data in self.processed_data.items():
                    dtn = str(data.get('dtn', ''))
                    if dtn:
                        dtn_values.add(dtn)
                self.dtn_combo.add_items(sorted(dtn_values))
                self.dtn_combo.select_items(selected_dtn)

            if hasattr(self, 'rola_combo'):
                role = set()
                for _, data in self.processed_data.items():
                    rola = data.get('rola_nazwa', '')
                    if rola:
                        role.add(rola)
                self.rola_combo.add_items(sorted(role))
                self.rola_combo.select_items(selected_role)

            if hasattr(self, 'jezyk_combo'):
                jezyki = set()
                for _, data in self.processed_data.items():
                    jezyk = data.get('jezyk', '')
                    if jezyk:
                        jezyki.add(jezyk)
                self.jezyk_combo.add_items(sorted(jezyki))
                self.jezyk_combo.select_items(selected_jezyki)

            if hasattr(self, 'etat_combo'):
                etaty = set()
                for _, data in self.processed_data.items():
                    etat = str(data.get('etat', '')) if data.get('etat') is not None else ''
                    if etat:
                        etaty.add(etat)
                sorted_etaty = sorted(etaty, key=lambda x: float(x) if x.replace('.', '', 1).isdigit() else 0)
                self.etat_combo.add_items(sorted_etaty)
                self.etat_combo.select_items(selected_etaty)

            # Aktualizacja przeo偶onych i u偶ytkownik贸w
            self.update_przelozony_filter(selected_przelozeni)
            self.update_uzytkownik_filter(selected_uzytkownicy)

            debug_print("Zakoczono aktualizacj filtr贸w")

        except Exception as e:
            import traceback
            log_error(f"Bd podczas aktualizacji filtr贸w: {e}")
            traceback.print_exc()

    def update_przelozony_filter(self, selected_przelozeni=None):
        """
        Aktualizuje list przeo偶onych na podstawie wybranych wydzia贸w.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_przelozeni: Lista zaznaczonych przeo偶onych (opcjonalnie)
        """
        if not hasattr(self, 'przelozony_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamitaj bie偶c selekcj jeli nie podano
        if selected_przelozeni is None:
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)

        self.przelozony_list.clear()

        # Pobierz wybrane wydziay
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []

        # Zbi贸r unikalnych przeo偶onych
        przelozeni = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, _, _ = key

            # Jeli nie wybrano wydzia贸w lub wydzia pasuje do filtra
            if not selected_wydzialy or wydzial in selected_wydzialy:
                # Dodaj przeo偶onego do zbioru (tylko niepuste wartoci)
                if przelozony:
                    przelozeni.add(przelozony)

        # Dodaj posortowanych przeo偶onych do listy
        for przelozony in sorted(przelozeni):
            item = QListWidgetItem(przelozony)
            self.przelozony_list.addItem(item)

            # Przywr贸 zaznaczenie jeli byo
            if przelozony in selected_przelozeni:
                item.setSelected(True)

    def update_uzytkownik_filter(self, selected_uzytkownicy=None):
        """
        Aktualizuje list u偶ytkownik贸w na podstawie wybranych wydzia贸w i przeo偶onych.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_uzytkownicy: Lista zaznaczonych u偶ytkownik贸w (opcjonalnie)
        """
        if not hasattr(self, 'uzytkownik_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamitaj bie偶c selekcj jeli nie podano
        if selected_uzytkownicy is None:
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

        self.uzytkownik_list.clear()

        # Pobierz wybrane wydziay i przeo偶onych
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self,
                                                                                            'przelozony_list') else []

        # Zbi贸r unikalnych u偶ytkownik贸w (u偶yj stringa jako tekstowej reprezentacji)
        uzytkownicy = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, uzytkownik_dane, _ = key

            # Sprawd藕 czy dane pasuj do filtr贸w
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni):
                # Dodaj u偶ytkownika do zbioru (tylko niepuste wartoci)
                if uzytkownik_dane:
                    # Konwertuj do stringa dla sp贸jnoci
                    uzytkownicy.add(str(uzytkownik_dane))

        # Dodaj posortowanych u偶ytkownik贸w do listy
        for uzytkownik in sorted(uzytkownicy):
            item = QListWidgetItem(uzytkownik)
            self.uzytkownik_list.addItem(item)

            # Przywr贸 zaznaczenie jeli byo
            if uzytkownik in selected_uzytkownicy:
                item.setSelected(True)

    def update_table_content(self):
        """
        Aktualizuje zawarto tabeli grafiku u偶ywajc modelu danych.
        Zoptymalizowana wersja wykorzystujca precyzyjne aktualizacje.
        """
        # Sprawd藕 czy modele zostay zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # Pobierz aktualny rok i miesic
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # Ustaw rok i miesic w modelu (jeli jeszcze nie s ustawione)
        if self.schedule_model._year != year or self.schedule_model._month != month:
            # Pobierz dane dla wybranego roku i miesica
            schedule_data = self.data_provider.get_schedule_data(year, month)

            # Aktualizuj model - to wywoa zoptymalizowan metod update_data
            self.schedule_model.update_data(schedule_data, year, month)
            self._set_schedule_columns_width()
        else:
            # Jeli rok i miesic nie ulegy zmianie, tylko zastosuj filtry
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

    

    def get_cell_color_by_time(self, hour):
        """
        Zwraca kolor ta kom贸rki na podstawie godziny rozpoczcia.
        Godziny s mapowane na kolory w bardziej czytelnej palecie.

        Args:
            hour (int): Godzina rozpoczcia zmiany (0-23)

        Returns:
            QColor: Kolor ta kom贸rki
        """
        # Domylny kolor (przezroczysty) gdy godzina nie jest zdefiniowana
        if hour is None or hour < 0 or hour > 23:
            return QColor(255, 255, 255, 0)  # Przezroczysty

        # Mapowanie godzin na kolory - zharmonizowana paleta
        if hour == 5:
            return QColor(204, 255, 255)  # Jasny bkit (bardzo jasny cyjan)
        elif hour == 6:
            return QColor(204, 255, 255)  # Jasny bkit (bardzo jasny cyjan)
        elif hour == 7:
            return QColor(0, 255, 255)  # Cyjan (akwamaryna)
        elif hour == 8:
            return QColor(0, 204, 255)  # Jasny bkit (niebieskozielony)
        elif hour == 9:
            return QColor(0, 255, 0)  # Limonkowy (czysty zielony)
        elif hour == 10:
            return QColor(153, 204, 0)  # Oliwkowy (偶贸tozielony)
        elif hour == 11:
            return QColor(204, 255, 204)  # Bardzo jasny zielony (mitowy)
        elif hour == 12:
            return QColor(255, 255, 153)  # Bardzo jasny 偶贸ty (kremowy)
        elif hour == 13:
            return QColor(255, 204, 153)  # Jasny ososiowy (brzoskwiniowy)
        elif hour == 14:
            return QColor(255, 153, 0)  # Ciemny pomaraczowy
        elif hour == 15:
            return QColor(255, 0, 255)  # Magenta (fuksja)
        elif hour == 16:
            return QColor(204, 0, 0)  # Ciemnoczerwony
        elif hour == 17:
            return QColor(150, 150, 150)  # redni szary
        elif hour == 18:
            return QColor(150, 150, 150)  # redni szary
        elif hour == 19:
            return QColor(150, 150, 150)  # redni szary
        elif hour == 20:
            return QColor(150, 150, 150)  # redni szary
        elif hour == 21:
            return QColor(150, 150, 150)  # redni szary
        elif hour == 22:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 23:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 0:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour in [1, 2, 3, 4]:
            return QColor(51, 51, 51)  # Ciemny szary

        # Domylny kolor dla innych wartoci
        return QColor(255, 255, 255, 0)  # Przezroczysty

    def on_selection_changed(self):
        """
        POPRAWIONA WERSJA: Debounced selection handling
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # DODANE: Sprawd藕 czy nie jestemy w trakcie aktualizacji
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        # NOWE: Zastop poprzedni timer i uruchom nowy (debouncing)
        if hasattr(self, '_selection_timer'):
            self._selection_timer.stop()
            self._selection_timer.start(self._selection_debounce_delay)

    def _handle_selection_change(self):
        """
        NOWA METODA: Faktyczna obsuga zmiany zaznaczenia (wywoywana po debounce)
        """
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        self._updating_selection = True

        try:
            debug_print("Zmiana zaznaczenia - aktualizuj tabel zdarze...")

            # Pobierz dane dla zaznaczonych kom贸rek
            selected_cells_data = self.table.get_data_for_selected_cells()
            debug_print(f"Zaznaczono {len(selected_cells_data)} kom贸rek")

            if selected_cells_data and len(selected_cells_data) > 0:
                # MAMY ZAZNACZONE KOMRKI - poka偶 zdarzenia
                events = []

                for cell_data in selected_cells_data:
                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')

                    if user_id and date_str:
                        # Pobierz aktualne zdarzenia z DataProvider
                        user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                        # Filtruj tylko aktywne zdarzenia (status != '0')
                        active_events = []
                        for event in user_events:
                            status = str(event.get('status', '1'))  # Domylnie aktywne
                            if status != '0':  # Tylko aktywne zdarzenia
                                # DODANE: Skonwertuj format na lokalny format UI
                                local_event = self._convert_dp_event_to_local(event)
                                active_events.append(local_event)

                        events.extend(active_events)

                debug_print(f"Pobrano {len(events)} aktywnych zdarze dla zaznaczonych kom贸rek")

                # Zaktualizuj events_data
                self.events_data = events

                # Aktualizuj model zdarze
                if hasattr(self, 'events_model'):
                    self.events_model.update_data(self.events_data)

                    # WA呕NE: Zastosuj filtry po aktualizacji danych
                    self.filter_events_table()
            else:
                # BRAK ZAZNACZENIA - wyczy tabel zdarze
                debug_print("Brak zaznaczenia - czyszcz tabel zdarze")
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])

            # DODANE: Wymu odwie偶enie widoku tabeli zdarze
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        finally:
            self._updating_selection = False

    def clear_events_on_startup(self):
        """
        NOWA METODA: Czyci tabel zdarze przy starcie aplikacji
        """
        debug_print("Czyszcz tabel zdarze przy starcie aplikacji")

        # Wyczy dane zdarze
        self.events_data = []

        # Wyczy model zdarze jeli istnieje
        if hasattr(self, 'events_model') and self.events_model:
            self.events_model.update_data([])

        # Odwie偶 widok tabeli zdarze
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

    def _convert_dp_event_to_local(self, dp_event):
        """
        NOWA METODA: Konwertuje format zdarzenia z DataProvider na lokalny format UI
        """
        try:
            # Skonwertuj dat z YYYY-MM-DD na DD.MM.YYYY
            date_key = dp_event.get('date_key', dp_event.get('date', ''))
            if date_key and '-' in date_key:
                year, month, day = date_key.split('-')
                display_date = f"{day}.{month}.{year}"
            else:
                display_date = dp_event.get('date_display', date_key)

            # Skonwertuj czas z formatu bazy na HH:MM
            time_from = dp_event.get('time_from', '')
            time_to = dp_event.get('time_to', '')
            
            if time_from and 'T' in time_from:
                time_from = time_from.split('T')[1].split(':')[0] + ':' + time_from.split('T')[1].split(':')[1]
            elif time_from and ' ' in time_from:
                time_from = time_from.split(' ')[1][:5]
                
            if time_to and 'T' in time_to:
                time_to = time_to.split('T')[1].split(':')[0] + ':' + time_to.split('T')[1].split(':')[1]
            elif time_to and ' ' in time_to:
                time_to = time_to.split(' ')[1][:5]

            # Pobierz nazw u偶ytkownika
            user_name = dp_event.get('user_name', '')
            if not user_name:
                user_id = dp_event.get('user_id')
                if user_id and hasattr(self, 'user_info_map') and user_id in self.user_info_map:
                    user_name = self.user_info_map[user_id].get('uzytkownik_dane', f"ID: {user_id}")
                else:
                    user_name = f"ID: {user_id}"

            # Utw贸rz zdarzenie w lokalnym formacie
            local_event = {
                'type': dp_event.get('event_type', dp_event.get('type', '')),
                'topic': dp_event.get('topic', ''),
                'name': dp_event.get('name', ''),
                'user_id': dp_event.get('user_id'),
                'user_name': user_name,
                'date': display_date,
                'date_key': date_key,
                'time_from': time_from,
                'time_to': time_to,
                'status': dp_event.get('status', ''),
                'id': dp_event.get('event_id', dp_event.get('id'))
            }

            return local_event

        except Exception as e:
            log_error(f"Bd konwersji zdarzenia: {e}")
            # Zwr贸 zdarzenie w oryginalnym formacie w przypadku bdu
            return dp_event
    
    def temporarily_disable_filters(self):
        """Tymczasowo wycza filtry zdarze aby zapewni wywietlenie wszystkich danych"""
        # Zapamitaj obecny stan filtr贸w
        self._saved_filters = {
            'meetings': self.meetings_checkbox.isChecked() if hasattr(self, 'meetings_checkbox') else True,
            'trainings': self.trainings_checkbox.isChecked() if hasattr(self, 'trainings_checkbox') else True,
            'overtime': self.overtime_checkbox.isChecked() if hasattr(self, 'overtime_checkbox') else True,
            'topic': self.topic_filter.text() if hasattr(self, 'topic_filter') else "",
            'name': self.name_filter.text() if hasattr(self, 'name_filter') else "",
            'date_from': self.date_from.date() if hasattr(self, 'date_from') else None,
            'date_to': self.date_to.date() if hasattr(self, 'date_to') else None
        }

        # Ustaw wszystkie filtry na wartoci, kt贸re pokazuj wszystkie dane
        if hasattr(self, 'meetings_checkbox'):
            self.meetings_checkbox.setChecked(True)
        if hasattr(self, 'trainings_checkbox'):
            self.trainings_checkbox.setChecked(True)
        if hasattr(self, 'overtime_checkbox'):
            self.overtime_checkbox.setChecked(True)
        if hasattr(self, 'topic_filter'):
            self.topic_filter.setText("")
        if hasattr(self, 'name_filter'):
            self.name_filter.setText("")

        # Daty zostawiamy bez zmian, filtrowanie bdzie nadpisane przez model

        debug_print("Tymczasowo wyczono filtry zdarze")

    def restore_filters(self):
        """Przywraca filtry zdarze do ich poprzedniego stanu"""
        if not hasattr(self, '_saved_filters'):
            return

        # Przywr贸 filtry do ich poprzedniego stanu
        if hasattr(self, 'meetings_checkbox') and 'meetings' in self._saved_filters:
            self.meetings_checkbox.setChecked(self._saved_filters['meetings'])
        if hasattr(self, 'trainings_checkbox') and 'trainings' in self._saved_filters:
            self.trainings_checkbox.setChecked(self._saved_filters['trainings'])
        if hasattr(self, 'overtime_checkbox') and 'overtime' in self._saved_filters:
            self.overtime_checkbox.setChecked(self._saved_filters['overtime'])
        if hasattr(self, 'topic_filter') and 'topic' in self._saved_filters:
            self.topic_filter.setText(self._saved_filters['topic'])
        if hasattr(self, 'name_filter') and 'name' in self._saved_filters:
            self.name_filter.setText(self._saved_filters['name'])

        # Nie przywracamy dat, aby zapewni sp贸jno z zaznaczonymi kom贸rkami

        debug_print("Przywr贸cono filtry zdarze")

        # Wymu odwie偶enie z nowymi filtrami
        self.filter_events_table()

    def filter_events_table(self):
        """
        Filtruje tabel zdarze na podstawie zaznaczonych filtr贸w i zakres贸w dat.
        Zoptymalizowana wersja wykorzystujca model danych.
        """
        try:
            # Sprawd藕 czy model istnieje
            if not hasattr(self, 'events_model') or not self.events_model:
                return

            # KLUCZOWA ZMIANA: Najpierw sprawd藕, czy w og贸le mamy dane do filtrowania
            if not hasattr(self, 'events_data') or not self.events_data:
                # Jeli nie ma danych, po prostu wyczy model
                self.events_model.update_data([])
                return

            # NAJWA呕NIEJSZE: U偶yj lokalnych danych events_data zamiast wszystkich zdarze
            # To zapewni, 偶e filtrujemy tylko zdarzenia dla zaznaczonych kom贸rek
            base_data = self.events_data.copy()
            filtered_data = base_data.copy()

            # Przygotuj parametry filtrowania
            allowed_types = []
            if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
                allowed_types.append('Spotkanie')
            if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
                allowed_types.append('Szkolenie')
            if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
                allowed_types.append('Nadgodziny')

            # Filtruj po typach zdarze
            if allowed_types:
                filtered_data = [e for e in filtered_data if e.get('type') in allowed_types]

            # Filtruj po temacie
            topic_filter = self.topic_filter.text().lower() if hasattr(self, 'topic_filter') else ""
            if topic_filter:
                filtered_data = [e for e in filtered_data if topic_filter in str(e.get('topic', '')).lower()]

            # Filtruj po nazwie
            name_filter = self.name_filter.text().lower() if hasattr(self, 'name_filter') else ""
            if name_filter:
                filtered_data = [e for e in filtered_data if name_filter in str(e.get('name', '')).lower()]

            # Filtruj po datach (tylko jeli nie s ustawione na zakres wybranego miesica)
            date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
            date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

            if date_from_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') >= date_from_str]
            if date_to_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') <= date_to_str]

            # Aktualizuj model po filtrowaniu
            debug_print(f"Filtrowanie lokalne: z {len(base_data)} zdarze po filtrach zostao {len(filtered_data)}")
            self.events_model.filtered_update(filtered_data)

        except Exception as e:
            log_error(f"Bd podczas filtrowania zdarze: {str(e)}")
            import traceback
            traceback.print_exc()

    def diagnose_events_table(self):
        """Metoda diagnostyczna do sprawdzenia stanu tabeli zdarze"""
        debug_print("\n=== DIAGNOSTYKA TABELI ZDARZE ===")

        if not hasattr(self, 'events_table') or not self.events_table:
            log_error("ERROR: Brak obiektu events_table!")
            return

        if not hasattr(self, 'events_model') or not self.events_model:
            log_error("ERROR: Brak obiektu events_model!")
            return

        # Sprawd藕 model
        debug_print(f"events_model ma {self.events_model.rowCount()} wierszy i {self.events_model.columnCount()} kolumn")
        debug_print(f"Dane w events_model: {len(self.events_model._data)} zdarze")
        debug_print(f"Przefiltrowane dane w events_model: {len(self.events_model._filtered_data)} zdarze")

        # Sprawd藕 filtry
        debug_print("\nAktualne filtry:")
        if hasattr(self, 'meetings_checkbox'):
            debug_print(f"Spotkania: {self.meetings_checkbox.isChecked()}")
        if hasattr(self, 'trainings_checkbox'):
            debug_print(f"Szkolenia: {self.trainings_checkbox.isChecked()}")
        if hasattr(self, 'overtime_checkbox'):
            debug_print(f"Nadgodziny: {self.overtime_checkbox.isChecked()}")
        if hasattr(self, 'topic_filter'):
            debug_print(f"Filtr tematu: '{self.topic_filter.text()}'")
        if hasattr(self, 'name_filter'):
            debug_print(f"Filtr nazwy: '{self.name_filter.text()}'")

        # Sprawd藕 przykadowe dane
        if self.events_model._data:
            debug_print("\nPrzykadowe zdarzenie z danych (przed filtrowaniem):")
            debug_print(self.events_model._data[0])

        if self.events_model._filtered_data:
            debug_print("\nPrzykadowe zdarzenie z danych po filtrowaniu:")
            debug_print(self.events_model._filtered_data[0])

        # Sprawd藕 widok
        debug_print(f"\nWidok events_table: {self.events_table.model().rowCount()} wierszy")

        debug_print("=== KONIEC DIAGNOSTYKI TABELI ZDARZE ===\n")

    def standardize_date(self, date_obj):
        """
        Standaryzuje format daty do 'YYYY-MM-DD' dla por贸wna
        """
        if not date_obj:
            return ''

        # Jeli to ju偶 string, wycignij tylko dat
        if isinstance(date_obj, str):
            # Obsuga r贸偶nych format贸w
            if 'T' in date_obj:  # Format ISO 'YYYY-MM-DDThh:mm:ss'
                return date_obj.split('T')[0]
            elif ' ' in date_obj:  # Format 'YYYY-MM-DD hh:mm:ss'
                return date_obj.split(' ')[0]
            elif len(date_obj) == 10 and date_obj.count('-') == 2:  # Format 'YYYY-MM-DD'
                return date_obj
            # Jeli nie dopasowano do 偶adnego formatu, zwr贸 oryginalny string
            return date_obj

        # Jeli to obiekt datetime, skonwertuj na string
        if hasattr(date_obj, 'strftime'):
            return date_obj.strftime('%Y-%m-%d')

        # W przypadku nieznanego typu, zwr贸 pusty string
        return ''

    def diagnose_table_view(self):
        """Metoda diagnostyczna do sprawdzenia stanu SplitTableView"""
        if not hasattr(self, 'table') or not self.table:
            log_error("ERROR: Brak obiektu table!")
            return

        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            log_error("ERROR: Brak obiektu schedule_model!")
            return

        debug_print("\n=== DIAGNOSTYKA TABELI ===")

        # Sprawd藕 model
        debug_print(f"Model ma {self.schedule_model.rowCount()} wierszy i {self.schedule_model.columnCount()} kolumn")
        debug_print(f"Widoczne kolumny: {self.schedule_model.get_visible_columns()}")

        # Sprawd藕 widoki
        debug_print(
            f"Employees view ma {self.table.employees_view.model().rowCount()} wierszy i {self.table.employees_view.model().columnCount()} kolumn")
        debug_print(
            f"Schedule view ma {self.table.schedule_view.model().rowCount()} wierszy i {self.table.schedule_view.model().columnCount()} kolumn")

        # Sprawd藕 kolumny w employees_view
        for col in range(self.table.employees_view.model().columnCount()):
            hidden = self.table.employees_view.isColumnHidden(col)
            width = self.table.employees_view.columnWidth(col)
            debug_print(f"Kolumna {col} w employees_view: ukryta={hidden}, szeroko={width}px")

        # Sprawd藕 przykadowe dane w pierwszym wierszu
        if self.schedule_model.rowCount() > 0:
            debug_print("\nPrzykadowe dane z pierwszego wiersza:")
            for col in range(len(self.schedule_model.get_visible_columns())):
                index = self.schedule_model.index(0, col)
                text = self.schedule_model.data(index, Qt.DisplayRole)
                debug_print(f"Kolumna {col}: '{text}'")

        debug_print("=== KONIEC DIAGNOSTYKI ===\n")

    def diagnose_application_state(self):
        """Wykonuje pen diagnostyk stanu aplikacji i wywietla szczeg贸owe informacje"""
        try:
            debug_print("\n===== DIAGNOSTYKA STANU APLIKACJI =====")

            # 1. Sprawd藕 tabele i dane
            debug_print("\n--- TABELA GRAFIKU ---")
            debug_print(f"Liczba wierszy: {self.table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.table.columnCount()}")

            # Sprawd藕 pierwsze 3 wiersze i kolumny dla przykadu
            debug_print("\nPrzykadowe kom贸rki z tabeli grafiku:")
            for row in range(min(3, self.table.rowCount())):
                for col in range(min(6, self.table.columnCount())):
                    item = self.table.item(row, col)
                    if item:
                        debug_print(f"[{row},{col}] Tekst: {item.text()}")
                        user_role_data = item.data(Qt.UserRole)
                        user_role_2 = item.data(Qt.UserRole + 2)
                        user_role_3 = item.data(Qt.UserRole + 3)
                        debug_print(
                            f"  UserRole: {type(user_role_data)}, UserRole+2: {user_role_2}, UserRole+3: {user_role_3}")
                        if isinstance(user_role_data, dict):
                            debug_print(f"  Zawarto: {user_role_data}")
                    else:
                        debug_print(f"[{row},{col}] Brak elementu")

            debug_print("\n--- TABELA ZDARZE ---")
            debug_print(f"Liczba wierszy: {self.events_table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.events_table.columnCount()}")

            # Sprawd藕 zawarto events_data
            debug_print(
                f"\nLiczba zdarze w events_data: {len(self.events_data) if hasattr(self, 'events_data') else 'Brak'}")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print("Pierwsze zdarzenie:")
                for key, value in self.events_data[0].items():
                    debug_print(f"  {key}: {value}")

            # Sprawd藕 pierwsze 3 wiersze tabeli zdarze
            debug_print("\nPrzykadowe wiersze z tabeli zdarze:")
            for row in range(min(3, self.events_table.rowCount())):
                row_data = []
                for col in range(self.events_table.columnCount() - 1):  # Pomijamy ostatni kolumn z przyciskami
                    item = self.events_table.item(row, col)
                    if item:
                        row_data.append(f"{col}:{item.text()}")
                debug_print(f"Wiersz {row}: {', '.join(row_data)}")

            # 2. Sprawd藕 delegaty i style
            debug_print("\n--- DELEGATY I STYLE ---")
            item_delegate = self.table.itemDelegate()
            debug_print(f"Delegat tabeli grafiku: {item_delegate.__class__.__name__}")
            if isinstance(item_delegate, OvertimeItemDelegate):
                debug_print("  Delegat OvertimeItemDelegate poprawnie przypisany")
            else:
                debug_print("  UWAGA: Delegat OvertimeItemDelegate nie jest przypisany!")

            # 3. Sprawd藕 filtrowanie danych
            debug_print("\n--- FILTROWANIE DANYCH ---")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print(f"Liczba zdarze przed filtrowaniem: {len(self.events_data)}")
                # Sprawd藕, czy metoda filter_events_table jest wywoywana
                debug_print("Spr贸buj wykona filter_events_table:")
                try:
                    self.filter_events_table()
                    debug_print("  Metoda filter_events_table wykonana bez bd贸w")
                except Exception as e:
                    debug_print(f"  BD podczas wykonywania filter_events_table: {e}")

            debug_print("\n===== KONIEC DIAGNOSTYKI =====\n")

        except Exception as e:
            debug_print(f"BD podczas diagnostyki: {e}")
            import traceback
            traceback.print_exc()


    def _get_current_event_filter_params(self):
        """
        Pobiera bie偶ce parametry filtrowania zdarze.

        Returns:
            dict: Parametry filtrowania
        """
        filter_params = {}

        # Dodaj filtr typ贸w zdarze
        allowed_types = []
        if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
            allowed_types.append('Spotkanie')
        if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
            allowed_types.append('Szkolenie')
        if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
            allowed_types.append('Nadgodziny')

        if allowed_types:
            filter_params['allowed_types'] = allowed_types

        # Dodaj filtry tematu i nazwy
        topic_filter = self.topic_filter.text().lower() if hasattr(self,
                                                                   'topic_filter') and self.topic_filter.text() else None
        name_filter = self.name_filter.text().lower() if hasattr(self,
                                                                 'name_filter') and self.name_filter.text() else None

        if topic_filter:
            filter_params['topic'] = topic_filter
        if name_filter:
            filter_params['name'] = name_filter

        # Dodaj filtry zakresu dat
        date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
        date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

        if date_from_str:
            filter_params['date_from'] = date_from_str
        if date_to_str:
            filter_params['date_to'] = date_to_str

        return filter_params

    def find_cell_position(self, user_id, date_str):
        """
        Znajduje pozycj kom贸rki dla podanego u偶ytkownika i daty, korzystajc z modelu.

        Args:
            user_id: ID u偶ytkownika
            date_str: Data w formacie YYYY-MM-DD

        Returns:
            tuple: (wiersz, dzie) lub (-1, -1) jeli nie znaleziono
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return -1, -1

        # Pobierz dzie z daty
        try:
            year, month, day_str = date_str.split('-')
            day = int(day_str)
        except:
            return -1, -1

        # Pobierz liczb wierszy w modelu
        row_count = self.schedule_model.rowCount()

        # Dla ka偶dego wiersza sprawd藕, czy odpowiada szukanemu u偶ytkownikowi
        for row in range(row_count):
            # Pobierz ID u偶ytkownika z pierwszej kolumny
            index = self.schedule_model.index(row, 0)
            user_data = self.schedule_model.data(index, Qt.UserRole)

            if isinstance(user_data, dict) and str(user_data.get('uzytkownik_id', '')) == str(user_id):
                return row, day

        return -1, -1

    def cancel_delegations(self):
        """
        POPRAWIONA WERSJA: Odwouje delegacje z penym odwie偶aniem ikon i tabeli zdarze
        """
        debug_print("\n=== ROZPOCZYNAM OPERACJ ODWOYWANIA DELEGACJI ===")

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Brak danych",
                "Nie wybrano miesica lub brak dostpnych danych do wywietlenia.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone kom贸rki
        selected_cells_data = self.get_selected_cells_data()

        if not selected_cells_data:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono 偶adnych kom贸rek. Zaznacz kom贸rki, dla kt贸rych chcesz odwoa delegacje.",
                QMessageBox.Ok
            )
            return

        # Zbierz pary (user_id, date_str) z zaznaczonych kom贸rek
        user_date_pairs = []
        for cell_data in selected_cells_data:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if user_id and date_str:
                user_date_pairs.append((user_id, date_str))

        if not user_date_pairs:
            QMessageBox.information(
                self,
                "Brak danych",
                "Nie znaleziono danych dla zaznaczonych kom贸rek.",
                QMessageBox.Ok
            )
            return

        debug_print(f"Sprawdzam delegacje dla {len(user_date_pairs)} par (u偶ytkownik, data)")

        # Znajd藕 delegacje do odwoania
        events_to_cancel = []
        grouped_events = {}

        for user_id, date_str in user_date_pairs:
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)
            
            for event in user_events:
                event_type = event.get('type', '')
                event_id = event.get('id')
                event_status = event.get('status')

                if not event_type or event_id is None:
                    continue

                if event_status is not None:
                    event_status = str(event_status)

                if event_type in ['Spotkanie', 'Szkolenie', 'Nadgodziny'] and event_status != '0':
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),
                    })

                    key = (user_id, date_str)
                    if key not in grouped_events:
                        grouped_events[key] = []
                    grouped_events[key].append(event)

        debug_print(f"Znaleziono {len(events_to_cancel)} delegacji do odwoania")

        if not events_to_cancel:
            QMessageBox.information(
                self,
                "Brak delegacji",
                "Nie znaleziono delegacji do odwoania dla zaznaczonych kom贸rek.",
                QMessageBox.Ok
            )
            return

        # Poka偶 potwierdzenie
        delegations_info = self._prepare_delegations_description(grouped_events)
        confirm_message = f"Czy na pewno chcesz odwoa nastpujce delegacje?\n\n{delegations_info}\n"
        confirm_message += f"cznie: {len(events_to_cancel)} delegacji dla {len(user_date_pairs)} kom贸rek"

        reply = QMessageBox.question(
            self,
            "Potwierdzenie odwoania delegacji",
            confirm_message,
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply != QMessageBox.Yes:
            debug_print("=== OPERACJA ANULOWANA PRZEZ U呕YTKOWNIKA ===")
            return

        try:
            # Odwoaj delegacje w bazie danych
            canceled_count = self._cancel_delegations(events_to_cancel)

            if canceled_count > 0:
                # KLUCZOWA ZMIANA 1: Usu zdarzenia z lokalnych danych
                affected_pairs = []
                for event in events_to_cancel:
                    user_id = event.get('user_id')
                    date_str = event.get('date_key', event.get('date'))
                    if user_id and date_str:
                        affected_pairs.append((user_id, date_str))
                        
                    # Usu z events_data (tabela zdarze)
                    if hasattr(self, 'events_data'):
                        self.events_data = [e for e in self.events_data 
                                        if not (e.get('id') == event.get('id') and 
                                                e.get('type') == event.get('type'))]
                    
                    # Usu z all_events_data
                    if hasattr(self, 'all_events_data'):
                        self.all_events_data = [e for e in self.all_events_data 
                                            if not (e.get('id') == event.get('id') and 
                                                    e.get('type') == event.get('type'))]

                # KLUCZOWA ZMIANA 2: Odwie偶 model zdarze
                if hasattr(self, 'events_model') and hasattr(self, 'events_data'):
                    self.events_model.update_data(self.events_data)
                    debug_print(f"Zaktualizowano model zdarze - pozostao {len(self.events_data)} zdarze")

                # KLUCZOWA ZMIANA 3: Wyczy cache i odwie偶 ikony
                affected_pairs = list(set(affected_pairs))  # Usu duplikaty
                
                # Wyczy cache zdarze w DataProvider
                self.data_provider.invalidate_icons_cache(year, month)
                
                # Odwie偶 konkretne ikony
                self.data_provider.invalidate_specific_icons(affected_pairs)
                debug_print(f"Odwie偶ono ikony dla {len(affected_pairs)} zmienionych kom贸rek")

                # KLUCZOWA ZMIANA 4: Odwie偶 model grafiku dla zmienionych kom贸rek
                if hasattr(self, 'schedule_model'):
                    for user_id, date_str in affected_pairs:
                        # Aktualizuj wska藕niki zdarze w modelu
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', False)
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', False)
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', False)

                # KLUCZOWA ZMIANA 5: Wymu odwie偶enie widok贸w
                if hasattr(self, 'table'):
                    if hasattr(self.table, 'schedule_view'):
                        self.table.schedule_view.viewport().update()
                    if hasattr(self.table, 'employees_view'):
                        self.table.employees_view.viewport().update()

                if hasattr(self, 'events_table'):
                    self.events_table.viewport().update()

                # KLUCZOWA ZMIANA 6: Kompleksowe odwie偶enie po odwoaniu delegacji
                # 1. Kompletne czyszczenie cache
                if hasattr(self.data_provider, 'invalidate_complete_cache_for_pairs'):
                    self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)

                # 2. Aktualizuj ikony w modelu grafiku
                if hasattr(self, 'schedule_model'):
                    for user_id, date_str in affected_pairs:
                        # Sprawd藕 pozostae zdarzenia w lokalnych danych
                        remaining_events = [e for e in self.events_data 
                                        if e.get('user_id') == user_id and e.get('date_key') == date_str]
                        
                        # Oblicz ikony na podstawie pozostaych zdarze  
                        has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                        has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                        has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)
                        
                        # Aktualizuj ikony w modelu
                        self.schedule_model.update_cell_icons_directly(
                            user_id, date_str, has_meetings, has_trainings, has_overtime
                        )

                # 3. Odwie偶 tabel zdarze dla zaznaczonych kom贸rek
                selected_cells = self.table.get_data_for_selected_cells()
                if selected_cells:
                    self.on_selection_changed()
                else:
                    self.events_data = []
                    if hasattr(self, 'events_model'):
                        self.events_model.update_data([])

                QMessageBox.information(
                    self,
                    "Sukces",
                    f"Pomylnie odwoano {canceled_count} delegacji z {len(events_to_cancel)} znalezionych.",
                    QMessageBox.Ok
                )

                debug_print(f"=== ZAKOCZONO POMYLNIE - ODWOANO {canceled_count} DELEGACJI ===")
            else:
                QMessageBox.warning(
                    self,
                    "Brak zmian",
                    "Nie udao si odwoa 偶adnej delegacji. Sprawd藕 logi aplikacji.",
                    QMessageBox.Ok
                )

        except Exception as e:
            log_error(f"Bd podczas odwoywania delegacji: {e}")
            QMessageBox.critical(
                self,
                "Bd",
                f"Wystpi bd podczas odwoywania delegacji: {str(e)}",
                QMessageBox.Ok
            )

    def get_data_from_model(self, row, col):
        """
        Pobiera dane z kom贸rki modelu na podstawie wierszy i kolumn.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny

        Returns:
            dict: Dane kom贸rki lub pusty sownik
        """
        if not hasattr(self, 'schedule_model'):
            return {}

        # Pobierz dane z modelu
        index = self.schedule_model.index(row, col)
        cell_data = self.schedule_model.data(index, Qt.UserRole)

        # Upewnij si, 偶e dane s sownikiem
        if not isinstance(cell_data, dict):
            return {}

        return cell_data

    def get_selected_cells_data(self):
        """
        Pobiera dane dla zaznaczonych kom贸rek z modelu.

        Returns:
            list: Lista danych zaznaczonych kom贸rek
        """
        if not hasattr(self, 'table') or not self.table:
            return []

        # Deleguj do metody w SplitTableView, kt贸ra ju偶 obsuguje model
        return self.table.get_data_for_selected_cells()

    def update_model_after_data_change(self, user_id, date_str):
        """
        Aktualizuje dane w modelu po zmianach w bazie danych.

        Args:
            user_id: ID u偶ytkownika
            date_str: Data w formacie YYYY-MM-DD
        """
        if not user_id or not date_str:
            return

        # Pobierz rok i miesic z daty
        if date_str.count('-') != 2:
            return

        year, month, _ = date_str.split('-')
        try:
            year = int(year)
            month = int(month)
        except ValueError:
            return

        # Pobierz aktualne dane z DataProvider - wymu odwie偶enie cache
        self.data_provider.clear_cache()
        schedule_data = self.data_provider.get_schedule_data(year, month, use_cache=False)

        # Aktualizuj model
        if schedule_data and hasattr(self, 'schedule_model'):
            # Aktualizuj model bezporednio
            self.schedule_model.update_data(schedule_data, year, month)

            # Zaktualizuj przefiltrowane dane
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

            # Odwie偶 widok
            if hasattr(self, 'table'):
                self.table.update()

    def setup_model_connections(self):
        """
        czy sygnay modeli z obsug interfejsu u偶ytkownika.
        """
        # Pocz zmiany w modelach z aktualizacj interfejsu
        if hasattr(self, 'schedule_model'):
            self.schedule_model.dataChanged.connect(self.on_schedule_data_changed)

        if hasattr(self, 'events_model'):
            self.events_model.dataChanged.connect(self.on_events_data_changed)

    def on_schedule_data_changed(self, topLeft, bottomRight):
        """
        Obsuguje zmian danych w modelu grafiku.

        Args:
            topLeft: Indeks g贸rnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Odwie偶 widok
        if hasattr(self, 'table'):
            self.table.update()

        # Jeli zmienio si zaznaczenie, zaktualizuj tabel zdarze
        if self.table.selection_changed.receivers() > 0:
            selected_rows = self.table.get_selected_rows()
            if selected_rows:
                self.on_selection_changed()

    def on_events_data_changed(self, topLeft, bottomRight):
        """
        Obsuguje zmian danych w modelu zdarze.

        Args:
            topLeft: Indeks g贸rnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Odwie偶 tabel zdarze
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

  
    def show_insert_change_dialog(self):
        """Pokazuje okno dialogowe do wstawiania zmian w grafiku"""
        # Pobierz aktualn dat z tabeli grafiku
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Bd",
                "Nie wybrano miesica. Nie mo偶na doda zmiany grafiku.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # ZMIANA: U偶yj metody get_data_for_selected_cells z SplitTableView
        selected_cells = self.table.get_data_for_selected_cells()

        if not selected_cells:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono 偶adnych kom贸rek do edycji.",
                QMessageBox.Ok
            )
            return

        # Grupuj kom贸rki wedug u偶ytkownika i dnia dla atwiejszej edycji
        grouped_cells = self.group_cells_by_user_and_day(selected_cells)

        # Utw贸rz dialog
        dialog = ScheduleChangeDialog(self, grouped_cells, year, month)
        dialog.exec()

    def get_selected_schedule_cells(self):
        """Zwraca list zaznaczonych kom贸rek z siatki grafiku"""
        selected_cells = []
        selected_ranges = self.table.selectedRanges()

        for range_item in selected_ranges:
            for row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawd藕 czy to kom贸rka z grafikiem
                    if col >= 3:
                        # Pobierz element tabeli
                        cell_item = self.table.item(row, col)
                        if not cell_item:
                            continue

                        # Pobierz dane z kom贸rki
                        cell_data = self.get_cell_data(cell_item)
                        if not cell_data:
                            continue

                        # Dodaj dane do listy wybranych kom贸rek
                        selected_cells.append(cell_data)

        return selected_cells

    def group_cells_by_user_and_day(self, cells):
        """Grupuje kom贸rki wedug u偶ytkownika i dnia dla atwiejszej edycji"""
        grouped = {}
        for cell in cells:
            # ZMIANA: Dostosuj do nowej struktury danych z modelu
            user_id = cell.get('uzytkownik_id')  # Zmieniono z 'user_id'
            date_str = cell.get('date_str')      # Zmieniono z 'date'

            if not user_id or not date_str:
                continue

            if user_id not in grouped:
                grouped[user_id] = {}

            if date_str not in grouped[user_id]:
                grouped[user_id][date_str] = []

            grouped[user_id][date_str].append(cell)

        return grouped

    def delete_event(self, event_id, event_type):
        """
        POPRAWIONA WERSJA: Usuwa zdarzenie z penym odwie偶aniem ikon
        """
        reply = QMessageBox.question(
            self,
            "Potwierdzenie",
            f"Czy na pewno chcesz usun {event_type.lower()} o ID {event_id}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.Yes
        )

        if reply != QMessageBox.StandardButton.Yes:
            return

        try:
            # KLUCZOWA ZMIANA 1: Znajd藕 zdarzenie w danych PRZED usuniciem z bazy
            affected_pairs = []
            deleted_event = None
            
            for event in self.events_data:
                if event.get('id') == event_id and event.get('type') == event_type:
                    deleted_event = event
                    user_id = event.get('user_id')
                    date_key = event.get('date_key')
                    if user_id and date_key:
                        affected_pairs.append((user_id, date_key))
                    break

            if not deleted_event:
                # Sprawd藕 te偶 w all_events_data jeli nie znaleziono w events_data
                for event in getattr(self, 'all_events_data', []):
                    if event.get('id') == event_id and event.get('type') == event_type:
                        deleted_event = event
                        user_id = event.get('user_id')
                        date_key = event.get('date_key')
                        if user_id and date_key:
                            affected_pairs.append((user_id, date_key))
                        break

            debug_print(f"Usuwanie zdarzenia ID={event_id}, typ={event_type}")
            if affected_pairs:
                debug_print(f"Zdarzenie dotyczy kom贸rek: {affected_pairs}")

            # Pobierz identyfikator u偶ytkownika
            _, user_app_id, _ = get_modifier_id()

            # Usu z bazy danych
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            table_name = ""
            if event_type == "Spotkanie":
                table_name = "p_t_zz_Spotkania"
            elif event_type == "Szkolenie":
                table_name = "p_t_zz_Szkolenia"
            elif event_type == "Nadgodziny":
                table_name = "p_t_zz_Nadgodziny"

            if not table_name:
                QMessageBox.warning(
                    self,
                    "Bd",
                    "Nieprawidowy typ zdarzenia.",
                    QMessageBox.StandardButton.Ok
                )
                return

            if event_type in ["Spotkanie", "Szkolenie"]:
                # Dla spotka i szkole zmieniamy status
                query = f"""UPDATE {table_name} 
                            SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? 
                            WHERE Id = ?"""
                cursor.execute(query, (user_app_id, event_id))
            else:
                # Dla nadgodzin usuwamy rekord
                query = f"DELETE FROM {table_name} WHERE Id = ?"
                cursor.execute(query, (event_id,))

            conn.commit()
            conn.close()

            # KLUCZOWA ZMIANA 2: Usu z lokalnych danych
            # Usu z events_data
            self.events_data = [e for e in self.events_data if
                                not (e.get('id') == event_id and e.get('type') == event_type)]

            # Usu z all_events_data
            if hasattr(self, 'all_events_data'):
                self.all_events_data = [e for e in self.all_events_data if
                                    not (e.get('id') == event_id and e.get('type') == event_type)]

            # KLUCZOWA ZMIANA 3: Aktualizuj model zdarze
            if hasattr(self, 'events_model'):
                self.events_model.update_data(self.events_data)
                debug_print(f"Zaktualizowano model zdarze - pozostao {len(self.events_data)} zdarze")

            # KLUCZOWA ZMIANA 4: Kompleksowe odwie偶enie cache i ikon
            if affected_pairs:
                # 1. Kompletne czyszczenie cache
                if hasattr(self.data_provider, 'invalidate_complete_cache_for_pairs'):
                    self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)
                
                # 2. Aktualizuj ikony w modelu na podstawie aktualnych danych
                if hasattr(self, 'schedule_model'):
                    for user_id, date_str in affected_pairs:
                        # Sprawd藕 pozostae zdarzenia w lokalnych danych
                        remaining_events = [e for e in self.events_data 
                                        if e.get('user_id') == user_id and e.get('date_key') == date_str]
                        
                        # Oblicz ikony na podstawie pozostaych zdarze
                        has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                        has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                        has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)
                        
                        # Aktualizuj bezporednio w modelu
                        self.schedule_model.update_cell_icons_directly(
                            user_id, date_str, has_meetings, has_trainings, has_overtime
                        )
                
                debug_print(f"Kompleksowo odwie偶ono cache i ikony dla {len(affected_pairs)} kom贸rek")

            # KLUCZOWA ZMIANA 5: Wymu odwie偶enie widok贸w
            if hasattr(self, 'table'):
                if hasattr(self.table, 'schedule_view'):
                    self.table.schedule_view.viewport().update()

            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

            # KLUCZOWA ZMIANA 6: Odwie偶 tabel zdarze dla aktualnego zaznaczenia
            # Ale NIE wywouj on_selection_changed() bo to mo偶e przywr贸ci usunite zdarzenie
            # Zamiast tego zastosuj tylko filtry
            self.filter_events_table()

            QMessageBox.information(
                self,
                "Sukces",
                f"{event_type} o ID {event_id} zostao pomylnie usunite.",
                QMessageBox.StandardButton.Ok
            )

            debug_print(f"=== POMYLNIE USUNITO ZDARZENIE ID={event_id} ===")

        except Exception as e:
            log_error(f"Bd podczas usuwania zdarzenia: {e}")
            QMessageBox.critical(
                self,
                "Bd",
                f"Wystpi bd podczas usuwania zdarzenia: {str(e)}",
                QMessageBox.StandardButton.Ok
            )

    def show_add_overtime_dialog(self):
        """
        Pokazuje okno dialogowe do dodawania nadgodzin.
        POPRAWIONA WERSJA - bez duplikacji zdarze i z prawidowym ustawianiem ikon.
        """
        # Pobierz bie偶c dat z tabeli grafiku
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Bd",
                "Nie wybrano miesica. Nie mo偶na doda nadgodzin.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone kom贸rki z modelu
        selected_cells_data = self.table.get_data_for_selected_cells()

        # Sprawd藕 liczb zaznaczonych kom贸rek
        if not selected_cells_data:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono 偶adnej kom贸rki. Zaznacz dokadnie jedn kom贸rk, aby doda nadgodziny.",
                QMessageBox.Ok
            )
            return

        # Jeli zaznaczono wicej ni偶 jedn kom贸rk, wywietl komunikat i zakocz
        if len(selected_cells_data) > 1:
            QMessageBox.warning(
                self,
                "Zbyt wiele zaznaczonych kom贸rek",
                "Zaznaczono zbyt wiele kom贸rek. Zaznacz dokadnie jedn kom贸rk, aby doda nadgodziny.",
                QMessageBox.Ok
            )
            return

        # Pobierz dane pierwszej (i jedynej) zaznaczonej kom贸rki
        cell_data = selected_cells_data[0]

        # Pobierz podstawowe informacje o kom贸rce
        selected_user_id = cell_data.get('uzytkownik_id')
        selected_user_name = cell_data.get('uzytkownik_dane')
        day = cell_data.get('day')
        date_str = cell_data.get('date_str')
        nr_kadrowy = cell_data.get('nr_kadrowy')
        start_hour = cell_data.get('start_hour')
        current_symbol = cell_data.get('symbol', '')
        
        # NOWE: Pobierz lokalizacj domyln z danych u偶ytkownika
        lokalizacja_domyslna = cell_data.get('lokalizacja_domyslna', 'h')

        if not selected_user_id or not day or not date_str:
            QMessageBox.warning(
                self,
                "Bd",
                "Brak wymaganych danych w zaznaczonej kom贸rce.",
                QMessageBox.Ok
            )
            return

        # Utw贸rz dat QDate
        selected_date = QDate.fromString(date_str, "yyyy-MM-dd")

        # Flaga okrelajca, czy to dzie wolny (brak danych lub pusty symbol)
        is_day_off = not current_symbol or current_symbol.strip() == ''

        # Jeli nr_kadrowy jest None, spr贸buj znale藕 go w danych u偶ytkownika
        if nr_kadrowy is None and selected_user_id in self.user_info_map:
            nr_kadrowy = self.user_info_map[selected_user_id].get('nr_kadrowy')

        # Ustaw domyln godzin rozpoczcia
        if start_hour is None:
            start_hour = 9 if is_day_off else 8

        # POPRAWIONE: Pobierz lokalizacj z symbolu lub u偶yj domylnej
        current_location = lokalizacja_domyslna  # Domylna z danych u偶ytkownika
        
        if current_symbol and ';' in current_symbol:
            from symbol_parser import parse_symbol
            parsed_symbol = parse_symbol(current_symbol)
            if parsed_symbol['location']:
                current_location = parsed_symbol['location']

        # Utw贸rz okno dialogowe
        dialog = QDialog(self)

        # Nazwy miesicy po polsku
        polish_months = [
            "stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca",
            "lipca", "sierpnia", "wrzenia", "pa藕dziernika", "listopada", "grudnia"
        ]

        month_name = polish_months[selected_date.month() - 1]
        dialog.setWindowTitle(f"Dodaj nadgodziny w dniu {selected_date.day()} {month_name} {selected_date.year()}")
        dialog.setMinimumWidth(300)

        layout = QVBoxLayout(dialog)

        # Informacja o pracowniku
        user_info_label = QLabel(f"Pracownik: {selected_user_name}")
        user_info_label.setStyleSheet("font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(user_info_label)

        # Informacja o numerze kadrowym
        if nr_kadrowy:
            kadrowy_info_label = QLabel(f"Numer kadrowy: {nr_kadrowy}")
            kadrowy_info_label.setStyleSheet("margin-bottom: 10px;")
            layout.addWidget(kadrowy_info_label)

        # Informacja o miesicu rozliczenia
        settlement_month = month
        settlement_year = year
        settlement_info = QLabel(f"Miesic rozliczenia: {settlement_month:02d}.{settlement_year}")
        settlement_info.setStyleSheet("margin-bottom: 10px;")
        layout.addWidget(settlement_info)

        # Informacja o dniu wolnym (jeli to dzie wolny)
        if is_day_off:
            day_off_info = QLabel("Zaznaczony dzie jest dniem wolnym pracownika.")
            day_off_info.setStyleSheet("color: blue; font-weight: bold; margin-bottom: 10px;")
            layout.addWidget(day_off_info)

        # Formularz wprowadzania
        form_frame = QFrame()
        form_frame.setFrameShape(QFrame.StyledPanel)
        form_frame.setFrameShadow(QFrame.Raised)
        form_layout = QGridLayout(form_frame)

        # Etykiety
        od_label = QLabel("od kiedy")
        ile_label = QLabel("ile godzin")
        typ_label = QLabel("typ")
        ld_label = QLabel("LD")
        zalegle_label = QLabel("czy zalege")

        # Kontrolki wprowadzania
        time_combo = QComboBox()
        time_combo.setMinimumWidth(60)

        # Ustal domylny czas
        if is_day_off:
            default_time = "09:00"  # Dla dnia wolnego
        else:
            # Oblicz koniec zmiany (godzina rozpoczcia + 8 godzin)
            end_hour = (start_hour + 8) % 24
            default_time = f"{end_hour:02d}:00"

        # Dodaj opcje czasu
        for hour in range(0, 24):
            for minute in [0, 30]:
                time_combo.addItem(f"{hour:02d}:{minute:02d}", f"{hour:02d}:{minute:02d}")

        # Ustaw domylny czas
        index = time_combo.findText(default_time)
        if index != -1:
            time_combo.setCurrentIndex(index)
        else:
            time_combo.setCurrentText(default_time)

        # Combo z liczb godzin do 13.0
        hours_combo = QComboBox()
        hours_combo.setMinimumWidth(50)
        for hours in [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5,
                    10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0]:
            hours_combo.addItem(f"{hours:.1f}", hours)
        hours_combo.setCurrentIndex(1)  # Domylnie 1.0

        # Typ: wypata, odbi贸r, odpracowanie
        type_combo = QComboBox()
        type_combo.addItem("wypata", "wypata")
        type_combo.addItem("odbi贸r", "odbi贸r")
        type_combo.addItem("odpracowanie", "odpracowanie")

        # LD (lokalizacja): h, p, s
        ld_combo = QComboBox()
        ld_combo.addItem("h", "h")  # Hybrydowa
        ld_combo.addItem("p", "p")  # Praca zdalna
        ld_combo.addItem("s", "s")  # Stacjonarna

        # POPRAWIONE: Ustaw domyln lokalizacj na podstawie symbolu lub domylnej u偶ytkownika
        if current_location == 'h':
            ld_combo.setCurrentIndex(0)
        elif current_location == 'p':
            ld_combo.setCurrentIndex(1)
        elif current_location == 's':
            ld_combo.setCurrentIndex(2)
        else:
            ld_combo.setCurrentIndex(0)  # Domylnie 'h'

        # Czy zalege
        overdue_combo = QComboBox()
        overdue_combo.addItem("nie", 0)
        overdue_combo.addItem("tak", 1)

        # Przycisk dodawania
        add_button = QPushButton("Dodaj")
        add_button.setStyleSheet("background-color: #333; color: white; font-weight: bold;")

        # Dodaj kontrolki do layoutu
        form_layout.addWidget(od_label, 0, 0)
        form_layout.addWidget(time_combo, 0, 1)
        form_layout.addWidget(ile_label, 0, 2)
        form_layout.addWidget(hours_combo, 0, 3)
        form_layout.addWidget(typ_label, 0, 4)
        form_layout.addWidget(type_combo, 0, 5)
        form_layout.addWidget(ld_label, 0, 6)
        form_layout.addWidget(ld_combo, 0, 7)
        form_layout.addWidget(zalegle_label, 0, 8)
        form_layout.addWidget(overdue_combo, 0, 9)
        form_layout.addWidget(add_button, 0, 10)

        # Dodaj formularz do g贸wnego layoutu
        layout.addWidget(form_frame)

        # POPRAWIONA funkcja dodawania nadgodzin - BEZ _update_after_adding_overtime
        def add_overtime():
            try:
                # Pobierz dane z formularza
                start_time = time_combo.currentText()
                hours = float(hours_combo.currentData())
                overtime_type = type_combo.currentData()
                location = ld_combo.currentData()
                is_overdue = overdue_combo.currentData()

                # Data rozliczenia to pierwszy dzie bie偶cego miesica
                settlement_date_str = f"{settlement_year}-{settlement_month:02d}-01"

                # UPROSZCZONE WYWOANIE - bez user_name
                result = self.call_add_overtime_procedure_fixed(
                    selected_user_id,
                    selected_date.year(),
                    selected_date.month(),
                    selected_date.toString("yyyy-MM-dd"),
                    start_time,
                    hours,
                    settlement_date_str,
                    is_overdue,
                    overtime_type,
                    location,
                    nr_kadrowy
                )

                if result["success"]:
                    QMessageBox.information(dialog, "Sukces", result["message"], QMessageBox.Ok)
                    dialog.accept()
                else:
                    QMessageBox.warning(dialog, "Bd", result["message"], QMessageBox.Ok)

            except Exception as e:
                QMessageBox.critical(dialog, "Bd", f"Wystpi bd: {str(e)}", QMessageBox.Ok)

        # Podcz funkcj do przycisku
        add_button.clicked.connect(add_overtime)

        # Poka偶 dialog
        dialog.exec()

   
        
    def _update_overtime_icon_single(self, user_id, date_str, year, month):
        """
        NOWA METODA: Aktualizuje ikon nadgodzin bez wpywania na cache innych danych.
        """
        try:
            # 1. Aktualizuj bezporednio w modelu grafiku
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikon nadgodzin w modelu dla ({user_id}, {date_str})")

            # 2. Wyczy tylko cache ikon dla tej konkretnej kom贸rki w DataProvider
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla kom贸rki ({user_id}, {date_str})")

            # 3. Odwie偶 widok grafiku
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"Bd podczas aktualizacji ikony nadgodzin: {e}")

    

    def connect_model_signals(self):
        """Podcz sygnay modelu - DODAJ TO DO METODY setup_ui lub __init__"""
        if hasattr(self, 'data_provider'):
            self.data_provider.data_changed.connect(self.on_data_changed)
            
            # NOWE: Podcz sygna odwie偶ania konkretnych ikon
            if hasattr(self.data_provider, 'data_changed'):
                self.data_provider.data_changed.connect(self._handle_specific_icons_refresh)

    def _handle_specific_icons_refresh(self, data_type, year, month):
        """NOWA METODA: Obsuguje sygna odwie偶enia konkretnych ikon"""
        if data_type == "icons" and hasattr(self, 'schedule_model') and self.schedule_model:
            # Model sam odwie偶y ikony przy nastpnym dostpie - nie r贸b nic wicej
            debug_print(f"Otrzymano sygna odwie偶enia ikon dla {year}-{month}")

    def call_add_overtime_procedure_fixed(self, user_id, year, month, date_str, start_time, hours, 
                                settlement_date, is_overdue, overtime_type, location, 
                                nr_kadrowy):
        """
        UPROSZCZONA WERSJA: Dodaje nadgodziny i odwie偶a dane z bazy
        """
        try:
            # Mapowanie lokalizacji na wartoci liczbowe: h - 1, p - 2, s - 3
            location_map = {'h': 1, 'p': 2, 's': 3}
            location_value = location_map.get(location, 1)  # Domylnie 1 (h)

            # Mapowanie typu nadgodzin: wypata i odbi贸r - NULL, odpracowanie - 1
            param_value = None
            if overtime_type == 'odpracowanie':
                param_value = 1

            # Okrelenie wartoci @odebrane: 1 dla typu "odbi贸r", 0 dla pozostaych
            odebrane_value = 1 if overtime_type == 'odbi贸r' else 0

            # Oblicz dat i czas zakoczenia
            from datetime import datetime, timedelta
            start_datetime = datetime.strptime(f"{date_str} {start_time}", "%Y-%m-%d %H:%M")
            end_datetime = start_datetime + timedelta(hours=float(hours))
            end_time = end_datetime.strftime("%H:%M")

            # Wywoaj procedur skadowan
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            params = [
                nr_kadrowy, year, month, date_str, start_time, end_time,
                settlement_date, is_overdue, odebrane_value, location_value,
                param_value
            ]

            placeholders = ", ".join(["?"] * len(params))
            sql = f"{{CALL [dbo].[p_P_ZZ_NadgodzinyWstawienie_v3] ({placeholders})}}"
            cursor.execute(sql, params)

            # Pobierz wyniki procedury
            all_results = []
            while True:
                rows = cursor.fetchall()
                if rows:
                    all_results.append(rows)
                if not cursor.nextset():
                    break

            # Znajd藕 ID nowego zdarzenia
            new_id = None
            success = False
            message = "Wystpi nieznany bd podczas dodawania nadgodzin."

            for result_set in all_results:
                for row in result_set:
                    for value in row:
                        value_str = str(value) if value is not None else ""
                        try:
                            value_int = int(value_str)
                            if value_int >= 100:
                                new_id = value_int
                                success = True
                                message = f"Nadgodziny zostay pomylnie dodane (ID: {new_id})."
                                break
                            elif value_int == 0:
                                success = True
                                message = "Nadgodziny zostay pomylnie dodane."
                        except (ValueError, TypeError):
                            if value_str and "bd" in value_str.lower():
                                success = False
                                message = value_str
                                break
                    if new_id is not None:
                        break
                if new_id is not None:
                    break

            conn.commit()
            conn.close()

            if success and new_id:
                debug_print(f"=== DODANO NADGODZINY ID={new_id}, ODWIE呕AM DANE ===")
                
                # KLUCZOWA ZMIANA: Odwie偶 dane z bazy zamiast sztucznie synchronizowa
                self._refresh_data_after_overtime_addition(new_id, user_id, date_str, year, month)

                return {
                    "success": success,
                    "message": message,
                    "new_id": new_id
                }

            return {
                "success": success,
                "message": message,
                "new_id": new_id
            }

        except Exception as e:
            log_error(f"Bd podczas dodawania nadgodzin: {e}")
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"Wystpi bd: {str(e)}"
            }

    def _refresh_data_after_overtime_addition(self, new_id, user_id, date_str, year, month):
        """
        NOWA METODA: Odwie偶a dane z bazy po dodaniu nadgodzin
        """
        try:
            debug_print(f"Odwie偶am dane po dodaniu nadgodzin ID={new_id}")
            
            # Upewnij si, 偶e column_mapper jest dostpny
            if not hasattr(self, 'column_mapper'):
                from column_mapper import ColumnMapper
                self.column_mapper = ColumnMapper()
            
            # 1. POBIERZ NOWE ZDARZENIE Z BAZY DANYCH
            new_event = self._fetch_specific_event_from_db(year, month, new_id, 'Nadgodziny')
            
            if not new_event:
                log_error(f"Nie znaleziono dodanych nadgodzin o ID {new_id} w bazie danych")
                return
            
            debug_print(f"Pobrano nowe zdarzenie z bazy: {new_event}")
            
            # 2. AKTUALIZUJ CACHE DATAPROVIDER
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]
                
                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data")
                
                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []
                
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache")
                
                # Aktualizuj processed_data - ustaw ikon nadgodzin
                try:
                    day = int(date_str.split('-')[2])
                    for key, user_data in container.processed_data.items():
                        if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikon nadgodzin w processed_data")
                            break
                except Exception as e:
                    log_error(f"Bd aktualizacji processed_data: {e}")
            
            # 3. AKTUALIZUJ LOKALNE DANE
            # Konwertuj na lokalny format
            local_event = self._convert_dp_event_to_local(new_event)
            
            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(local_event)
                    debug_print(f"Dodano nadgodziny do all_events_data")
            
            # 4. AKTUALIZUJ events_data TYLKO JELI KOMRKA JEST ZAZNACZONA
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )
                
                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(local_event)
                        debug_print(f"Dodano nadgodziny do events_data")
                        
                        # Aktualizuj model zdarze
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()
            
            # 5. AKTUALIZUJ MODEL GRAFIKU
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_overtime=True
                )
                debug_print(f"Zaktualizowano ikony w schedule_model")
            
            # 6. WYCZY CACHE IKON
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon")
            
            # 7. ODWIE呕 WIDOKI
            if hasattr(self, 'table'):
                if hasattr(self.table, 'schedule_view'):
                    self.table.schedule_view.viewport().update()
            
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()
            
            debug_print(f"=== ODWIE呕ENIE DANYCH ZAKOCZONE ===")
            
        except Exception as e:
            log_error(f"Bd podczas odwie偶ania danych: {e}")
            import traceback
            traceback.print_exc()

    def _fetch_specific_event_from_db(self, year, month, event_id, event_type):
        """
        NOWA METODA: Pobiera konkretne zdarzenie z bazy danych
        """
        try:
            # Zapytanie do pobrania konkretnego zdarzenia
            query = """
            SELECT * FROM [dbo].[fn_GetEventsData](?, ?) 
            WHERE EventType = ? AND ID = ?
            """
            
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query, (year, month, event_type, event_id))
            result = cursor.fetchone()
            conn.close()
            
            if not result:
                return None
            
            # Konwertuj na format DataProvider u偶ywajc column_mapper
            event_dict = self.column_mapper.map_events_row_to_dict(result)
            
            # Dodaj pola wymagane przez DataProvider
            if 'event_type' in event_dict:
                event_dict['type'] = event_dict['event_type']
            if 'event_id' in event_dict:
                event_dict['id'] = event_dict['event_id']
            
            # Formatuj daty
            raw_date = event_dict.get('date', '')
            if hasattr(raw_date, 'strftime'):
                event_dict['date_display'] = raw_date.strftime('%d.%m.%Y')
                event_dict['date_key'] = raw_date.strftime('%Y-%m-%d')
            elif isinstance(raw_date, str) and raw_date:
                event_dict['date_display'] = self.data_provider._format_date_display(raw_date)
                event_dict['date_key'] = self.data_provider._standardize_date(raw_date)
            
            # Formatuj czasy
            time_from = event_dict.get('time_from')
            time_to = event_dict.get('time_to')
            
            if hasattr(time_from, 'strftime'):
                event_dict['time_from'] = time_from.strftime('%H:%M')
            elif isinstance(time_from, str) and 'T' in time_from:
                event_dict['time_from'] = time_from.split(' ')[1][:5]
            
            if hasattr(time_to, 'strftime'):
                event_dict['time_to'] = time_to.strftime('%H:%M')
            elif isinstance(time_to, str) and 'T' in time_to:
                event_dict['time_to'] = time_to.split(' ')[1][:5]
            
            debug_print(f"Skonwertowano zdarzenie z bazy: {event_dict}")
            return event_dict
            
        except Exception as e:
            log_error(f"Bd podczas pobierania zdarzenia z bazy: {e}")
            return None
        
             
    def _add_event_to_data_provider(self, new_id, user_id, user_name, date_str, start_time, 
                               end_time, overtime_type, is_overdue, year, month):
        """
        NOWA METODA: Dodaje zdarzenie bezporednio do DataProvider i wszystkich cache'y
        """
        try:
            # Utw贸rz obiekt zdarzenia w formacie DataProvider
            display_date = ".".join(reversed(date_str.split("-")))
            
            # Status na podstawie typu i flagi zalegoci
            if overtime_type == 'wypata':
                status = "Wypata - zalege" if is_overdue else "Wypata"
            elif overtime_type == 'odbi贸r':
                status = "Odbi贸r"
            elif overtime_type == 'odpracowanie':
                status = "Odpracowanie"
            else:
                status = "Aktywne"

            # Utw贸rz zdarzenie w formacie zgodnym z DataProvider
            new_event_dp_format = {
                'event_type': 'Nadgodziny',
                'event_id': new_id,
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'date': date_str,  # DataProvider oczekuje YYYY-MM-DD
                'time_from': f"1900-01-01 {start_time}:00",  # Format z bazy
                'time_to': f"1900-01-01 {end_time}:00",
                'status': 'Wstawione',  # Status w formacie bazy
                'type': 'Nadgodziny',
                'id': new_id,
                'date_display': display_date,
                'date_key': date_str
            }

            # Utw贸rz zdarzenie w formacie lokalnym
            new_event_local_format = {
                'type': 'Nadgodziny',
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'user_name': user_name,
                'date': display_date,
                'date_key': date_str,
                'time_from': start_time,
                'time_to': end_time,
                'status': status,
                'id': new_id
            }

            # KLUCZOWA ZMIANA 1: Dodaj do cache DataProvider
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]
                
                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data (ID: {new_id})")
                
                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []
                
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache (ID: {new_id})")
                
                # Aktualizuj processed_data - dodaj ikon nadgodzin
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        try:
                            day = int(date_str.split('-')[2])
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikon nadgodzin w processed_data dla {user_id}, dzie {day}")
                            break
                        except:
                            pass

            # KLUCZOWA ZMIANA 2: Dodaj do lokalnych danych
            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(new_event_local_format)
                    debug_print(f"Dodano nadgodziny do all_events_data (ID: {new_id})")

            # KLUCZOWA ZMIANA 3: Dodaj do events_data tylko jeli kom贸rka jest zaznaczona
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )
                
                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(new_event_local_format)
                        debug_print(f"Dodano nadgodziny do events_data (ID: {new_id})")
                        
                        # Aktualizuj model zdarze
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # KLUCZOWA ZMIANA 4: Aktualizuj ikon w modelu
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikon nadgodzin w modelu dla ({user_id}, {date_str})")

            # KLUCZOWA ZMIANA 5: Wyczy tylko cache ikon dla tej kom贸rki (nie cay cache)
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla kom贸rki ({user_id}, {date_str})")

            # Odwie偶 widok
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"Bd podczas dodawania zdarzenia do DataProvider: {e}")

    def debug_check_event_in_index(self, event_id, event_type='Nadgodziny'):
        """
        Sprawdza, czy zdarzenie o podanym ID istnieje w indeksie zdarze
        i wywietla informacje diagnostyczne.

        Args:
            event_id: ID zdarzenia
            event_type: Typ zdarzenia (domylnie 'Nadgodziny')

        Returns:
            bool: True jeli znaleziono zdarzenie, False w przeciwnym wypadku
        """
        debug_print(f"\n--- DIAGNOSTYKA INDEKSU ZDARZE ---")
        debug_print(f"Szukam zdarzenia o ID {event_id} i typie {event_type}")

        # Sprawd藕 w indeksie zdarze DataProvider
        if hasattr(self.data_provider, 'events_index'):
            # Sprawd藕 bezporednio przez indeks ID
            event = self.data_provider.events_index.get_event_by_id(event_id)
            if event:
                debug_print(f"ZNALEZIONO w indeksie ID: {event}")
                return True

            # Alternatywnie, przeszukaj wszystkie zdarzenia
            found_in_all = False
            for e in self.data_provider.events_index.all_events:
                if e.get('id') == event_id and e.get('type') == event_type:
                    debug_print(f"ZNALEZIONO w all_events: {e}")
                    found_in_all = True

            # Przeszukaj indeks typ贸w
            found_in_type_index = False
            type_events = self.data_provider.events_index.type_index.get(event_type, [])
            for e in type_events:
                if e.get('id') == event_id:
                    debug_print(f"ZNALEZIONO w type_index: {e}")
                    found_in_type_index = True

            if not found_in_all and not found_in_type_index:
                debug_print("NIE ZNALEZIONO w indeksie zdarze")
                return False

            return found_in_all or found_in_type_index
        else:
            debug_print("BRAK indeksu zdarze w data_provider")
            return False

    def show_theme_settings(self):
        """Pokazuje okno dialogowe z ustawieniami motywu"""
        theme = "dark" if self.is_dark_theme else "light"
        dialog = ThemeSettingsDialog(self, theme, self.current_font, self.current_font_size)
        dialog.settings_changed.connect(self.apply_theme_settings)

        # Uruchom dialog
        if dialog.exec() == QDialog.Accepted:
            # Pobierz ustawienia bezporednio z dialogu
            theme = dialog.get_current_theme()
            font = dialog.font_combo.currentFont().family()
            font_size = dialog.font_size_spin.value()

            # Sprawd藕, czy u偶ytkownik chce zapisa ustawienia
            save_settings = dialog.save_settings_checkbox.isChecked()

            # Zapisz ustawienia
            self.save_theme_settings(theme, font, font_size, save_settings)


    def save_theme_settings(self, theme, font_family, font_size, save_to_db):
        """Zapisuje ustawienia motywu trwale"""
        # Zaktualizuj lokalne ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Jeli zaznaczono opcj zapamitania, zapisz w bazie
        if save_to_db:
            try:
                self.settings_db.save_settings(theme, font_family, font_size)
                debug_print(f"Ustawienia zostay zapisane do bazy danych: {theme}, {font_family}, {font_size}")
            except Exception as e:
                debug_print(f"Bd podczas zapisywania ustawie: {e}")

        # Zastosuj ustawienia nawet jeli nie zapisujemy do bazy
        self.apply_theme_settings(theme, font_family, font_size)

    def update_cell_data(self, user_id, date_str, event_type=None, action="update"):
        """
        Aktualizuje dane kom贸rki i ikony po r贸偶nych operacjach.
        Zoptymalizowana wersja wykorzystujca precyzyjne aktualizacje.

        Args:
            user_id: ID u偶ytkownika
            date_str: Data w formacie 'YYYY-MM-DD'
            event_type: Typ zdarzenia (Spotkanie, Szkolenie, Nadgodziny lub None)
            action: Rodzaj operacji - "update", "add", "delete"

        Returns:
            bool: True jeli operacja si powioda, False w przeciwnym wypadku
        """
        if not user_id or not date_str:
            return False

        # Standardyzuj format daty
        date_str = self.data_provider._standardize_date(date_str)

        # Wyczy cache dla miesica tej daty
        if date_str and date_str.count('-') == 2:
            year, month, _ = date_str.split('-')
            self.clear_events_cache(int(year), int(month))

        # Pobierz zdarzenia dla tej pary (u偶ytkownik, data)
        events = self.data_provider.get_events_for_user_date(user_id, date_str)

        # Sprawd藕 typy zdarze
        has_meeting = any(
            e.get('type') == 'Spotkanie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_training = any(
            e.get('type') == 'Szkolenie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_overtime = any(e.get('type') == 'Nadgodziny' for e in events)

        # Aktualizuj wska藕niki w modelu - u偶ywajc zoptymalizowanej metody
        if hasattr(self, 'schedule_model'):
            if event_type == 'Spotkanie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Szkolenie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Nadgodziny':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny',
                                                                  is_active=(action != "delete"))
            else:
                # Aktualizuj wszystkie wska藕niki
                result1 = self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', has_meeting)
                result2 = self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', has_training)
                result3 = self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', has_overtime)
                return result1 or result2 or result3

        return False

    
    def apply_theme_settings(self, theme, font_family, font_size):
        """Stosuje wybrane ustawienia motywu z wykorzystaniem centralnych styl贸w"""
        # Zapamitaj wybrane ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Zastosuj czcionk do caej aplikacji
        font = QFont(font_family, font_size)
        QApplication.setFont(font)

        # Zastosuj g贸wny styl dla caego okna aplikacji
        self.setStyleSheet(AppStyles.get_main_window_style(theme))

        # Bezpieczne ustawianie styl贸w z sprawdzaniem istnienia atrybut贸w

        # Przyciski w g贸rnym pasku
        if hasattr(self, 'theme_button'): self.theme_button.setStyleSheet(AppStyles.get_button_style(theme))
        if hasattr(self, 'refresh_button'): self.refresh_button.setStyleSheet(AppStyles.get_button_style(theme))
        if hasattr(self, 'toggle_menu_button'): self.toggle_menu_button.setStyleSheet(AppStyles.get_button_style(theme))
        if hasattr(self, 'date_combo'): self.date_combo.setStyleSheet(AppStyles.get_combobox_style(theme))

        # Lewy panel i jego elementy
        if hasattr(self, '_left_panel'): self._left_panel.setStyleSheet(AppStyles.get_left_panel_style(theme))
        if hasattr(self, 'wydzial_combo'): self.wydzial_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'dtn_combo'): self.dtn_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'rola_combo'): self.rola_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'jezyk_combo'): self.jezyk_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'etat_combo'): self.etat_combo.setStyleSheet(AppStyles.get_combobox_style(theme))
        if hasattr(self, 'przelozony_filter'): self.przelozony_filter.setStyleSheet(
            AppStyles.get_line_edit_style(theme))
        if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.setStyleSheet(
            AppStyles.get_line_edit_style(theme))
        if hasattr(self, 'przelozony_list'): self.przelozony_list.setStyleSheet(AppStyles.get_list_style(theme))
        if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style(theme))
        if hasattr(self, 'clear_filters_button'): self.clear_filters_button.setStyleSheet(
            AppStyles.get_button_style(theme))

        # Przyciski w dolnym panelu
        if hasattr(self, 'manage_columns_button'): self.manage_columns_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'toggle_events_panel_button'): self.toggle_events_panel_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'insert_change_button'): self.insert_change_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'insert_symbol_button'): self.insert_symbol_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'cancel_delegation_button'): self.cancel_delegation_button.setStyleSheet(
            AppStyles.get_button_style(theme))
        if hasattr(self, 'add_overtime_button'): self.add_overtime_button.setStyleSheet(
            AppStyles.get_button_style(theme))

        # Elementy panelu zdarze
        if hasattr(self, 'date_from'): self.date_from.setStyleSheet(AppStyles.get_date_edit_style(theme))
        if hasattr(self, 'date_to'): self.date_to.setStyleSheet(AppStyles.get_date_edit_style(theme))
        if hasattr(self, 'topic_filter'): self.topic_filter.setStyleSheet(AppStyles.get_line_edit_style(theme))
        if hasattr(self, 'name_filter'): self.name_filter.setStyleSheet(AppStyles.get_line_edit_style(theme))
        if hasattr(self, 'meetings_checkbox'): self.meetings_checkbox.setStyleSheet(AppStyles.get_checkbox_style(theme))
        if hasattr(self, 'trainings_checkbox'): self.trainings_checkbox.setStyleSheet(
            AppStyles.get_checkbox_style(theme))
        if hasattr(self, 'overtime_checkbox'): self.overtime_checkbox.setStyleSheet(AppStyles.get_checkbox_style(theme))

        # Aktualizacja modeli
        if hasattr(self, 'schedule_model'): self.schedule_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'events_model'): self.events_model.set_theme(self.is_dark_theme)

        # Aktualizacja widok贸w tabel
        if hasattr(self, 'table'):
            if hasattr(self.table, 'employees_view'):
                self.table.employees_view.setStyleSheet(AppStyles.get_table_style(theme))
                self.table.employees_view.viewport().update()
            if hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.setStyleSheet(AppStyles.get_table_style(theme))
                self.table.schedule_view.viewport().update()

        if hasattr(self, 'events_table'):
            self.events_table.setStyleSheet(AppStyles.get_table_style(theme))
            self.events_table.viewport().update()

    def closeEvent(self, event):
        """Obsuguje zamknicie aplikacji"""
        try:
            debug_print("=== ZAMYKANIE APLIKACJI TEAMFLOW ===")
            debug_print(f"Sesja trwaa od uruchomienia aplikacji")

            # NOWE: Wyczy filtr klawiatury
            self.cleanup_keyboard_filter()

            close_log_file()
        except:
            pass  # Ignoruj bdy podczas zamykania
        finally:
            event.accept()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = WorkScheduleWindow()
    window.show()
    sys.exit(app.exec())
