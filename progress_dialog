# progress_dialog.py

from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel,
                               QPushButton, QProgressBar, QTextEdit)
from PySide6.QtCore import Qt, Signal, QThread, QTimer, QMutex, QMutexLocker
from PySide6.QtGui import QTextCursor
from debug_utils import debug_print, log_error
import time


class DataLoadingThread(QThread):
    """
    Wątek do asynchronicznego ładowania danych z raportowaniem postępu.
    """
    progress_updated = Signal(int)
    status_updated = Signal(str)
    data_loaded = Signal(object)
    error_occurred = Signal(str)

    def __init__(self, data_provider, year, month, grupa, funkcja, parent=None):
        super().__init__(parent)
        self.data_provider = data_provider
        self.year = year
        self.month = month
        self.grupa = grupa
        self.funkcja = funkcja
        self.cancel_requested = False
        self.mutex = QMutex()

    def run(self):
        """Główna metoda wątku ładującego dane."""
        try:
            debug_print(f"DataLoadingThread: Rozpoczynam async ładowanie danych dla {self.year}-{self.month}")
            self.status_updated.emit("Przygotowywanie do ładowania...")
            self.progress_updated.emit(5)

            if self._check_cancel(): return

            self.status_updated.emit("Pobieranie i podstawowe przetwarzanie danych...")
            self.progress_updated.emit(10)

            container = self.data_provider._get_or_load_monthly_data(
                self.year, self.month, self.grupa, self.funkcja, use_cache=False
            )

            if self._check_cancel(): return
            self.progress_updated.emit(70)

            if not container:
                error_msg = f"Nie udało się załadować kontenera danych dla {self.year}-{self.month}"
                self.error_occurred.emit(error_msg)
                return

            self.status_updated.emit("Przygotowywanie danych do wyświetlenia (ikony)...")
            processed_data_with_icons = self.data_provider.get_processed_data(
                self.year, self.month, self.grupa, self.funkcja
            )

            if self._check_cancel(): return
            self.progress_updated.emit(90)

            result_data = {
                'schedule_data': container.schedule_data,
                'events_data': container.events_data,
                'processed_data': processed_data_with_icons,
                'year': self.year,
                'month': self.month
            }

            self.progress_updated.emit(100)
            self.status_updated.emit("Zakończono!")
            self.msleep(200)

            self.data_loaded.emit(result_data)
            debug_print(f"DataLoadingThread: Async ładowanie zakończone dla {self.year}-{self.month}")

        except Exception as e:
            error_msg = f"DataLoadingThread: Błąd podczas ładowania danych: {str(e)}"
            log_error(error_msg, exception=e)
            self.error_occurred.emit(error_msg)

    def _check_cancel(self):
        """Sprawdza czy użytkownik anulował operację."""
        with QMutexLocker(self.mutex):
            if self.cancel_requested:
                debug_print("DataLoadingThread: Ładowanie danych zostało anulowane")
                self.status_updated.emit("Anulowano ładowanie.")
                return True
        return False

    def cancel_loading(self):
        """Anuluje ładowanie danych."""
        with QMutexLocker(self.mutex):
            self.cancel_requested = True
        debug_print("DataLoadingThread: Zażądano anulowania ładowania danych")


class LoadingProgressDialog(QDialog):
    """Dialog z paskiem postępu dla asynchronicznego ładowania danych."""
    loading_completed = Signal(object)
    loading_cancelled = Signal()
    loading_failed = Signal(str)

    def __init__(self, parent=None, data_provider=None, year=None, month=None, grupa=None, funkcja=None):
        super().__init__(parent)
        self.data_provider = data_provider
        self.year = year
        self.month = month
        self.grupa = grupa
        self.funkcja = funkcja
        self.loading_thread = None
        self.parent_widget = parent

        self.setWindowTitle(f"Ładowanie danych {year}-{month:02d}")
        self.setModal(True)
        self.setFixedSize(400, 150)
        self.setWindowFlags(Qt.Dialog | Qt.CustomizeWindowHint | Qt.WindowTitleHint)

        self.apply_dialog_theme()
        self.setup_ui()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu."""
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            theme = "dark" if self.parent_widget.is_dark_theme else "light"
        else:
            theme = "dark"

        from styles import AppStyles
        self.setStyleSheet(AppStyles.get_dialog_style(theme))

    def setup_ui(self):
        """Inicjalizuje interfejs użytkownika - wersja z paskiem postępu."""
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setAlignment(Qt.AlignCenter)

        # Tytuł okna
        title_label = QLabel(f"Ładowanie danych dla {self.year}-{self.month:02d}")
        title_label.setStyleSheet("font-weight: bold; font-size: 11pt;")
        title_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(title_label)

        # Status tekstowy
        self.status_label = QLabel("Przygotowywanie...")
        self.status_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.status_label)

        # Pasek postępu
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(True)
        self.progress_bar.setStyleSheet("""
            QProgressBar {
                border: 1px solid grey;
                border-radius: 5px;
                padding: 1px;
                text-align: center;
                color: white;
            }
            QProgressBar::chunk {
                background-color: #007bff;
                border-radius: 4px;
            }
        """)
        layout.addWidget(self.progress_bar)

        # Przycisk Anuluj
        buttons_layout = QHBoxLayout()
        self.cancel_button = QPushButton("Anuluj")
        self.cancel_button.clicked.connect(self.cancel_loading)

        theme = "dark"
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            theme = "dark" if self.parent_widget.is_dark_theme else "light"

        from styles import AppStyles
        button_style = AppStyles.get_button_style(theme)
        self.cancel_button.setStyleSheet(button_style)

        buttons_layout.addStretch()
        buttons_layout.addWidget(self.cancel_button)
        buttons_layout.addStretch()
        layout.addLayout(buttons_layout)

    def start_loading(self):
        """Rozpoczyna asynchroniczne ładowanie danych."""
        if not self.data_provider:
            log_error("LoadingProgressDialog: Brak DataProvider do rozpoczęcia ładowania.")
            self.loading_failed.emit("Krytyczny błąd: Brak dostawcy danych.")
            self.reject()
            return

        self.loading_thread = DataLoadingThread(
            self.data_provider, self.year, self.month, self.grupa, self.funkcja, self
        )
        self.loading_thread.progress_updated.connect(self.update_progress)
        self.loading_thread.status_updated.connect(self.update_status)
        self.loading_thread.data_loaded.connect(self.on_data_loaded)
        self.loading_thread.error_occurred.connect(self.on_error_occurred)
        self.loading_thread.finished.connect(self.on_thread_finished)
        self.loading_thread.start()
        debug_print("LoadingProgressDialog: Uruchomiono wątek ładowania danych.")

    def exec(self):
        self.start_loading()
        return super().exec()

    def open(self):
        self.start_loading()
        super().open()

    def update_progress(self, value):
        """Aktualizuje pasek postępu."""
        self.progress_bar.setValue(value)

    def update_status(self, status):
        """Aktualizuje etykietę statusu."""
        self.status_label.setText(status)

    def on_data_loaded(self, data):
        """Obsługuje pomyślne załadowanie danych."""
        debug_print("LoadingProgressDialog: Dane zostały załadowane pomyślnie.")
        self.loading_completed.emit(data)
        QTimer.singleShot(300, self.accept)

    def on_error_occurred(self, error_message):
        """Obsługuje błędy podczas ładowania."""
        log_error(f"LoadingProgressDialog: Wystąpił błąd podczas ładowania - {error_message}")
        self.status_label.setText(f"Błąd: {error_message[:50]}...")
        self.progress_bar.setStyleSheet(
            self.progress_bar.styleSheet().replace("#007bff", "#e74c3c"))
        self.loading_failed.emit(error_message)
        self.cancel_button.setText("Zamknij")
        try:
            self.cancel_button.clicked.disconnect(self.cancel_loading)
        except RuntimeError:
            pass
        self.cancel_button.clicked.connect(self.reject)
        self.cancel_button.setEnabled(True)

    def on_thread_finished(self):
        """Obsługuje zakończenie wątku."""
        debug_print("LoadingProgressDialog: Wątek ładowania zakończył działanie.")
        if self.loading_thread:
            if not self.loading_thread.isRunning():
                self.loading_thread.deleteLater()
                self.loading_thread = None

    def cancel_loading(self):
        """Anuluje ładowanie danych."""
        debug_print("LoadingProgressDialog: Próba anulowania ładowania.")
        if self.loading_thread and self.loading_thread.isRunning():
            self.status_label.setText("Anulowanie...")
            self.cancel_button.setEnabled(False)
            self.loading_thread.cancel_loading()
        else:
            self.loading_cancelled.emit()
            self.reject()

    def closeEvent(self, event):
        """Obsługuje próbę zamknięcia dialogu."""
        if self.loading_thread and self.loading_thread.isRunning():
            event.ignore()
        else:
            if self.loading_thread:
                self.loading_thread.deleteLater()
                self.loading_thread = None
            event.accept()
