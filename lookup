Masz dobrÄ… intuicjÄ™, ale w Å›wiecie Pythona i SQLAlchemy to wÅ‚aÅ›nie None jest tÅ‚umaczony na SQL-owy NULL. JeÅ›li przekaÅ¼esz tekst "NULL", Oracle potraktuje go jako napis i wyrzuci bÅ‚Ä…d, bo nie moÅ¼e wpisaÄ‡ tekstu do kolumny liczbowej.
BÅ‚Ä…d ORA-01722: invalid number oznacza, Å¼e mimo Twoich prÃ³b zamiany, w kolumnie, ktÃ³ra w Oracle jest liczbÄ… (np. TIMEINIVR lub CALLDURATION), nadal znajduje siÄ™ jakiÅ› tekst (np. pusty string '', spacja ' ' albo uparte '<NA>'), ktÃ³rego Oracle nie umie zamieniÄ‡ na liczbÄ™.
Samo .replace({'<NA>': None}) moÅ¼e nie zadziaÅ‚aÄ‡, jeÅ›li <NA> jest czÄ™Å›ciÄ… dÅ‚uÅ¼szego napisu lub jeÅ›li typ kolumny w Pandas to object.
ğŸ› ï¸ RozwiÄ…zanie: "Atomowe" czyszczenie liczb
Musimy zrobiÄ‡ coÅ› bardziej radykalnego: wymusiÄ‡ konwersjÄ™ na liczby. Wszystko, co nie jest liczbÄ… (tekst, Å›mieci, <NA>), zostanie zamienione na NaN, a potem na None.
Wklej ten fragment w metodzie insert_data zamiast poprzedniego bloku czyszczenia (zaraz po astype).
            self.logger.info(f"Wykonanie df_to_load.astype(numpy_dtype_dict)") 
            df_to_load = df_to_load.astype(numpy_dtype_dict) 
            self.logger.info(f"df_to_load.astype(numpy_dtype_dict) - done") 
            
            # ğŸ’¥ğŸ’¥ğŸ’¥ NOWA, SKUTECZNIEJSZA METODA CZYSZCZENIA ğŸ’¥ğŸ’¥ğŸ’¥
            import numpy as np

            # 1. Najpierw ogÃ³lne czyszczenie znanych tekstowych reprezentacji NULLi
            df_to_load = df_to_load.replace({
                '<NA>': np.nan, 'nan': np.nan, 'NaN': np.nan, 'None': np.nan, 'NaT': np.nan,
                '': np.nan,  # Puste stringi teÅ¼ zamieniamy na NaN
                ' ': np.nan  # Spacje teÅ¼
            })

            # 2. BRUTALNE wymuszenie liczb dla kolumn, ktÃ³re majÄ… trafiÄ‡ do Oracle jako liczby
            # Sprawdzamy, ktÃ³re kolumny w mapowaniu (numpy_dtype_dict) sÄ… liczbowe
            for col, dtype in numpy_dtype_dict.items():
                if 'int' in dtype or 'float' in dtype:
                    # errors='coerce' zamieni kaÅ¼de "<NA>", "brak", "bÅ‚Ä…d" na NaN
                    df_to_load[col] = pd.to_numeric(df_to_load[col], errors='coerce')

            # 3. Ostateczna zamiana NaN (float) na None (SQL NULL)
            # where(cond, other) -> tam gdzie cond jest False, wstawia other.
            # Czyli: tam gdzie NIE JEST null, zostaw wartoÅ›Ä‡, w przeciwnym razie wstaw None.
            df_to_load = df_to_load.where(pd.notnull(df_to_load), None)
            
            self.logger.info("Wyczyszczono dane: wymuszono typy liczbowe i zamieniono NaN na None.")
            # ğŸ’¥ğŸ’¥ğŸ’¥ KONIEC POPRAWKI ğŸ’¥ğŸ’¥ğŸ’¥

Dlaczego to zadziaÅ‚a?
 * pd.to_numeric(..., errors='coerce'): To jest klucz. Ta funkcja bierze kolumnÄ™ i prÃ³buje zrobiÄ‡ z niej liczby. JeÅ›li napotka tekst <NA> (lub cokolwiek innego nieliczbowego), nie wyrzuci bÅ‚Ä™du, tylko wstawi tam NaN.
 * df.where(pd.notnull(df), None): To jest najpewniejszy sposÃ³b w Pandasie, Å¼eby zamieniÄ‡ NaN (ktÃ³rego bazy nie lubiÄ…) na pythonowe None (ktÃ³re SQLAlchemy kocha i zamienia na NULL).
Teraz Oracle dostanie albo czystÄ… liczbÄ™, albo czysty NULL. BÅ‚Ä…d ORA-01722 powinien zniknÄ…Ä‡.
