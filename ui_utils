# ui_utils.py
import re
from PySide6.QtCore import Qt
from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel,
                               QPushButton, QTextEdit, QApplication, QStyle,
                               QFrame, QMessageBox)
from PySide6.QtGui import QIcon, QClipboard
from styles import AppStyles
from debug_utils import debug_print


class DetailedMessageDialog(QDialog):
    """
    Zoptymalizowane wizualnie okno błędów.
    """

    def __init__(self, parent, title, message, icon_type="info"):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setMinimumWidth(650)
        self.setMinimumHeight(350)  # Troszkę wyższe

        self.is_dark = True
        if parent:
            if hasattr(parent, 'is_dark_theme'):
                self.is_dark = parent.is_dark_theme
            elif hasattr(parent, 'parent_widget') and hasattr(parent.parent_widget, 'is_dark_theme'):
                self.is_dark = parent.parent_widget.is_dark_theme

        # 1. Czyścimy wiadomość (ALE ZACHOWUJEMY ENTERY!)
        self.clean_message = self._sanitize_sql_error(str(message))

        # 2. Główny Layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(15, 20, 15, 15)
        layout.setSpacing(15)

        # 3. Nagłówek
        header_layout = QHBoxLayout()
        header_layout.setSpacing(15)

        icon_label = QLabel()
        pixmap = self._get_standard_icon(icon_type)
        if pixmap:
            icon_label.setPixmap(pixmap.pixmap(48, 48))

        icon_label.setFixedWidth(50)
        icon_label.setAlignment(Qt.AlignTop | Qt.AlignHCenter)

        title_label = QLabel(title)
        title_color = AppStyles.DARK_TEXT_PRIMARY if self.is_dark else AppStyles.LIGHT_TEXT_PRIMARY
        title_label.setStyleSheet(f"font-size: 13pt; font-weight: bold; border: none; color: {title_color};")
        title_label.setWordWrap(True)
        title_label.setAlignment(Qt.AlignVCenter | Qt.AlignLeft)

        header_layout.addWidget(icon_label)
        header_layout.addWidget(title_label, 1)
        layout.addLayout(header_layout)

        # 4. Treść wiadomości
        self.text_area = QTextEdit()
        self.text_area.setReadOnly(True)
        self.text_area.setPlainText(self.clean_message)
        self.text_area.setFrameShape(QFrame.NoFrame)

        bg_color = "transparent"
        text_color = AppStyles.DARK_TEXT_PRIMARY if self.is_dark else AppStyles.LIGHT_TEXT_PRIMARY

        self.text_area.setStyleSheet(f"""
            QTextEdit {{
                background-color: {bg_color};
                color: {text_color};
                font-size: 10pt; 
                line-height: 1.4;
                border: none;
            }}
        """)

        layout.addWidget(self.text_area)

        # 5. Przyciski
        btn_layout = QHBoxLayout()
        self.copy_btn = QPushButton("Kopiuj treść")
        self.copy_btn.setCursor(Qt.PointingHandCursor)
        self.copy_btn.clicked.connect(self._copy_to_clipboard)

        self.ok_btn = QPushButton("OK")
        self.ok_btn.setCursor(Qt.PointingHandCursor)
        self.ok_btn.clicked.connect(self.accept)
        self.ok_btn.setMinimumWidth(100)
        self.ok_btn.setDefault(True)

        btn_layout.addWidget(self.copy_btn)
        btn_layout.addStretch()
        btn_layout.addWidget(self.ok_btn)
        layout.addLayout(btn_layout)

        self._apply_styles()

    def _get_standard_icon(self, icon_type):
        style = QApplication.style()
        if icon_type == "critical":
            return style.standardIcon(QStyle.SP_MessageBoxCritical)
        elif icon_type == "warning":
            return style.standardIcon(QStyle.SP_MessageBoxWarning)
        elif icon_type == "question":
            return style.standardIcon(QStyle.SP_MessageBoxQuestion)
        return style.standardIcon(QStyle.SP_MessageBoxInformation)

    def _sanitize_sql_error(self, text):
        """
        Agresywne czyszczenie komunikatów z bazy danych.
        ZACHOWUJE NOWE LINIE (\n).
        """
        if not text: return ""

        # --- KROK 0: Ochrona struktury listy ---
        # Jeśli tekst zaczyna się od nagłówka listy błędów, nie psujmy go regexem krotki
        is_list = "Wystąpiły błędy dla" in text

        clean_text = text

        # Krok 1: Dekodowanie krotek Pythona (zrzut str(e) z pyodbc)
        # Szukamy wzorca: ('KOD', 'TRESC')
        # Regex łapie treść między ' a ' która jest drugim elementem krotki
        # Używamy re.sub, aby podmienić w całym tekście (dla każdego wiersza listy osobno)
        if not is_list:
            # Dla pojedynczego błędu - agresywne wyciąganie
            tuple_match = re.search(r"\('\w+',\s*'(.*?)'\)", clean_text, re.DOTALL)
            if tuple_match:
                clean_text = tuple_match.group(1)
        else:
            # Dla listy błędów - czyszczenie wiersz po wierszu
            # Zamienia ('42000', 'TEKST') -> TEKST
            clean_text = re.sub(r"\('\w+',\s*'(.*?)'\)", r"\1", clean_text)

        # Krok 2: Usuwanie prefiksów sterowników [Microsoft][ODBC...][SQL Server]
        clean_text = re.sub(r'(\[[^\]]+\])+', '', clean_text)

        # Krok 3: Usuwanie kodów błędów na końcu np. (50000) (SQLExecDirectW)
        clean_text = re.sub(r'\(\d+\)\s*\(SQLExec\w*\)', '', clean_text)

        # Krok 4: Usuwanie pozostałości
        clean_text = clean_text.replace("Wyjątek SQL:", "").strip()

        # Kosmetyka cudzysłowów, ale zachowując strukturę
        # (Nie robimy global strip, bo usunie wcięcia listy)

        # KROK 5: KRYTYCZNE - NIE USUWAMY ENTERÓW!
        # Poprzednio było tu: clean_text = re.sub(r'\s+', ' ', clean_text) -> TO PSUŁO FORMATOWANIE

        # Jedynie usuwamy podwójne spacje, ale nie entery
        clean_text = re.sub(r'[ \t]+', ' ', clean_text)

        return clean_text

    def _copy_to_clipboard(self):
        clipboard = QApplication.clipboard()
        clipboard.setText(self.clean_message)
        self.copy_btn.setText("Skopiowano!")
        self.copy_btn.setEnabled(False)

    def _apply_styles(self):
        theme = "dark" if self.is_dark else "light"
        dialog_style = AppStyles.get_dialog_style(theme)
        button_style = AppStyles.get_button_style(theme)

        self.setStyleSheet(dialog_style)
        self.copy_btn.setStyleSheet(button_style)
        self.ok_btn.setStyleSheet(button_style)


# --- FUNKCJE PUBLICZNE ---

def show_info_dialog(parent, title: str, message: str):
    dlg = DetailedMessageDialog(parent, title, message, "info")
    dlg.exec()


def show_warning_dialog(parent, title: str, message: str):
    dlg = DetailedMessageDialog(parent, title, message, "warning")
    dlg.exec()


def show_error_dialog(parent, title: str, message: str):
    """Tu trafią błędy SQL - zostaną wyczyszczone i sformatowane."""
    dlg = DetailedMessageDialog(parent, title, message, "critical")
    dlg.exec()


def show_confirmation_dialog(parent, title: str, message: str,
                             default_button=QMessageBox.Yes) -> int:
    """
    Wyświetla stylowane okno potwierdzenia. Zwraca int (kod przycisku).
    """
    msg_box = QMessageBox(parent)
    msg_box.setWindowTitle(title)
    msg_box.setTextFormat(Qt.RichText)
    msg_box.setText(message)
    msg_box.setIcon(QMessageBox.Question)

    yes_button = msg_box.addButton("Tak", QMessageBox.YesRole)
    no_button = msg_box.addButton("Nie", QMessageBox.NoRole)

    is_dark = True
    if parent:
        if hasattr(parent, 'is_dark_theme'):
            is_dark = parent.is_dark_theme
        elif hasattr(parent, 'parent_widget') and hasattr(parent.parent_widget, 'is_dark_theme'):
            is_dark = parent.parent_widget.is_dark_theme

    theme = "dark" if is_dark else "light"
    dialog_style = AppStyles.get_dialog_style(theme)
    msg_box.setStyleSheet(dialog_style.replace("QDialog", "QMessageBox"))

    button_style = AppStyles.get_button_style(theme)
    yes_button.setStyleSheet(button_style)
    no_button.setStyleSheet(button_style)

    if default_button == QMessageBox.Yes:
        msg_box.setDefaultButton(yes_button)
    else:
        msg_box.setDefaultButton(no_button)

    msg_box.exec()

    if msg_box.clickedButton() == yes_button:
        return QMessageBox.Yes
    return QMessageBox.No
