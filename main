# -*- coding: utf-8 -*-
import sys
import time
import getpass
from datetime import datetime, timedelta
from typing import List, Dict
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill
from openpyxl.utils import get_column_letter
import functools
import math
from PySide6.QtWidgets import (QApplication, QMainWindow, QTableView,
                               QVBoxLayout, QHBoxLayout, QWidget, QLabel, QComboBox,
                               QPushButton, QHeaderView, QAbstractItemView, QListWidget,
                               QListWidgetItem, QLineEdit, QDialog, QCheckBox, QFrame, QDateEdit,
                               QMessageBox, QSplitter, QStyledItemDelegate, QFileDialog,
                               QGridLayout, QSizePolicy, QScrollArea, QGroupBox, QStyle, QProgressDialog,
                               QStyleOptionViewItem, QInputDialog)

from PySide6.QtCore import (Qt, Signal, QDate, QTimer, QEvent, QObject,
                            QItemSelection, QItemSelectionModel, QRect, QPoint, QSize, Slot)
from packaging.version import parse as parse_version
from PySide6.QtGui import QShortcut, QKeySequence, QFont, QColor, QStandardItem, QStandardItemModel, QPixmap, QPainter, \
    QPen, QIcon, QBrush, QPolygon, QPainterPath, QValidator

from data_provider import DataProvider
from db_connector import DatabaseConnector, get_modifier_id, load_all_app_settings
from config import APP_VERSION, SQL_OBJECTS, resource_path
from app_settings import app_settings
from settings_db import SettingsDatabase
from styles import AppStyles
from collections import defaultdict
from column_definitions import ColumnDefinitions
from schedule_model import (ScheduleTableModel, ROLE_DATA, ROLE_HAS_MEETING, ROLE_HAS_OVERTIME,
                            ROLE_SPECIAL_SYMBOL, ROLE_LOCATION_SYMBOL, ROLE_IS_SUGGESTED_OFF)  # Dodano importy ról
from events_model import EventsTableModel
from split_table_view import SplitTableView
from schedule_edit_dialogs import ScheduleChangeDialog, ReasonDialog, OvertimeLocationDialog
from debug_utils import debug_print, log_warning, log_error, setup_logging, close_log_file
from symbol_parser import parse_symbol, build_symbol, get_symbol_description
from outlook_connector import create_outlook_email, create_email_from_template
from teams_connector import open_teams_chat
from async_operations import DelegationCanceler, LocationExceptionManager, BackgroundCheckerThread
from ui_utils import show_confirmation_dialog
from overtime_manager import OvertimeManager
from schedule_change_processor import ScheduleChangeProcessor, ChangeType
from preparation_thread import PreparationThread
from loading_indicator import ModernLoadingIndicator
from filter_select_dialog import FilterSelectDialog
from session_manager import SessionManager


class OvertimeItemDelegate(QStyledItemDelegate):
    """Delegat dla komórek tabeli grafiku."""

    def __init__(self, settings=None, parent=None):
        super().__init__(parent)
        self.settings = settings or {}

    def paint(self, painter: QPainter, option: QStyleOptionViewItem, index):
        try:
            painter.save()
            clip_path = QPainterPath()
            clip_path.addRoundedRect(option.rect, 4.0, 4.0)
            painter.setClipPath(clip_path)
            super().paint(painter, option, index)
            painter.restore()

            special_symbol = index.data(ROLE_SPECIAL_SYMBOL)
            location_symbol = index.data(ROLE_LOCATION_SYMBOL)
            has_meeting = index.data(ROLE_HAS_MEETING)
            has_overtime = index.data(ROLE_HAS_OVERTIME)
            is_suggested_off = index.data(ROLE_IS_SUGGESTED_OFF)

            painter.save()
            painter.setRenderHint(QPainter.Antialiasing)

            if has_meeting:
                marker_size = 7
                rect = QRect(option.rect.left() + 2, option.rect.bottom() - marker_size - 1, marker_size, marker_size)
                painter.setBrush(QBrush(QColor(255, 255, 255, 240)))
                painter.setPen(QPen(QColor(0, 0, 0, 220), 1.0))
                painter.drawEllipse(rect)

            if has_overtime:
                marker_size = 7
                x = option.rect.right() - marker_size - 1
                y = option.rect.bottom() - marker_size - 1
                triangle = QPolygon(
                    [QPoint(x, y + marker_size), QPoint(x + marker_size, y + marker_size), QPoint(x + marker_size, y)])
                painter.setBrush(QBrush(QColor(220, 0, 0, 220)))
                painter.setPen(QPen(Qt.black, 1.0))
                painter.drawPolygon(triangle)

            if is_suggested_off:
                # Nakładamy półprzezroczysty zielony kolor na tło
                user_name = index.model().data(index.siblingAtColumn(2), Qt.DisplayRole)
                # debug_print(f"Delegate: Rysuję zielone tło dla {user_name} w kolumnie {index.column()}")
                painter.fillRect(option.rect, QColor(0, 100, 0, 100))

            show_special = self.settings.get('show_special_symbol', True)
            show_location = self.settings.get('show_location_symbol', True)
            special_pos = self.settings.get('special_symbol_position', 'top_left')
            location_pos = self.settings.get('location_symbol_position', 'top_right')

            if special_symbol and show_special:
                self._draw_text_with_background(painter, option, special_symbol, special_pos)
            if location_symbol and show_location:
                self._draw_text_with_background(painter, option, location_symbol, location_pos)

            painter.restore()
        except Exception as e:
            log_error(f"Błąd podczas rysowania delegata: {e}")

    def _draw_text_with_background(self, painter: QPainter, option: QStyleOptionViewItem, text: str, position: str):
        icon_font = QFont(option.font)

        # --- ZMIANA 1: Lepsze skalowanie proporcji ---
        main_size = option.font.pointSize()

        # Zamiast odejmować stałą wartość, używamy mnożnika.
        # Ikona będzie miała ok. 65% wielkości głównego tekstu.
        # Np. Główny 10 -> Ikona 6
        #     Główny 13 -> Ikona 8 (a nie 11 jak wcześniej)
        #     Główny 16 -> Ikona 10
        icon_font_size = max(7, int(main_size * 0.65))

        icon_font.setPointSize(icon_font_size)
        # Ustawiamy pogrubienie dla małych ikon, żeby były czytelne
        # if icon_font_size < 8:
        #     icon_font.setBold(True)

        painter.setFont(icon_font)

        metrics = painter.fontMetrics()

        # --- ZMIANA 2: Ciaśniejszy padding ---
        text_bounds = metrics.boundingRect(text)

        # Zmniejszamy padding, aby ramka nie była "napompowana"
        padding_x = 1  # Minimalny odstęp po bokach
        padding_y = 0  # Brak dodatkowego odstępu w pionie

        # Obliczamy wymiary "na styk"
        total_width = metrics.horizontalAdvance(text) + (2 * padding_x)
        # Dla wysokości bierzemy max z (wysokość znaku, minimalna estetyczna wysokość)
        total_height = max(text_bounds.height() + (2 * padding_y), icon_font_size + 2)

        bg_rect = QRect(0, 0, total_width, total_height)

        # 3. Pozycjonowanie (zerowy margines od krawędzi komórki)
        margin_x = 0
        margin_y = 0

        if position == 'top_left':
            bg_rect.moveTo(option.rect.topLeft() + QPoint(margin_x, margin_y))

        elif position == 'top_right':
            bg_rect.moveTo(option.rect.topRight() + QPoint(-bg_rect.width() - margin_x, margin_y))

        # 4. Rysowanie
        painter.setBrush(QColor(Qt.white))
        painter.setPen(Qt.NoPen)
        painter.drawRoundedRect(bg_rect, 3, 3)

        painter.setPen(QColor(Qt.black))

        # Precyzyjne centrowanie w małej ramce
        painter.drawText(bg_rect, Qt.AlignCenter, text)

    # def _draw_text_with_background(self, painter: QPainter, option: QStyleOptionViewItem, text: str, position: str):
    #     icon_font = QFont(option.font)
    #     font_size_map = {7: 6, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10}
    #     icon_font_size = font_size_map.get(option.font.pointSize(), 7)
    #     icon_font.setPointSize(icon_font_size)
    #     painter.setFont(icon_font)
    #     metrics = painter.fontMetrics()
    #     text_width = metrics.horizontalAdvance(text)
    #     text_height = metrics.ascent() + metrics.descent()
    #
    #     bg_rect = QRect(0, 0, text_width, text_height)
    #     bg_rect.adjust(0, 1, 0, -1)
    #     bg_rect.adjust(-1, 0, 1, 0)
    #
    #     if position == 'top_left':
    #         bg_rect.moveTo(option.rect.topLeft() + QPoint(1, 1))
    #     elif position == 'top_right':
    #         bg_rect.moveTo(option.rect.topRight() - QPoint(bg_rect.width() - 1, -1))
    #
    #     painter.setBrush(QColor(Qt.white))
    #     painter.setPen(Qt.NoPen)
    #     painter.drawRoundedRect(bg_rect, 3, 3)
    #     painter.setPen(QColor(Qt.black))
    #     painter.drawText(bg_rect, Qt.AlignCenter, text)

class ButtonDelegate(QStyledItemDelegate):
    button_clicked = Signal(int)

    def __init__(self, parent=None, button_text="Odwołaj", is_dark_theme=False):
        super().__init__(parent)
        self.button_text = button_text
        self.is_dark_theme = is_dark_theme
        self._pressed_row = -1

    def paint(self, painter, option, index):
        event_data = index.model().data(index, Qt.UserRole)
        status = event_data.get('status', '')
        is_disabled = status in ["Do delegacji", "Usunięty"]
        button_rect = QRect(option.rect).adjusted(4, 4, -4, -4)
        painter.save()
        painter.setRenderHint(QPainter.Antialiasing)
        if is_disabled:
            bg_color = QColor("#5a5a5a") if self.is_dark_theme else QColor("#d3d3d3")
            text_color = QColor("#888888") if self.is_dark_theme else QColor("#a0a0a0")
        elif self._pressed_row == index.row():
            bg_color = QColor("#c0392b")
        else:
            bg_color = QColor("#e74c3c")
        painter.setBrush(bg_color)
        painter.setPen(Qt.NoPen)
        painter.drawRoundedRect(button_rect, 3, 3)
        painter.setPen(text_color if is_disabled else QColor("white"))
        painter.drawText(button_rect, Qt.AlignCenter, self.button_text)
        painter.restore()

    def editorEvent(self, event, model, option, index):
        event_data = index.data(Qt.UserRole)
        status = event_data.get('status', '')
        if status in ["Do delegacji", "Usunięty"]: return False
        if event.type() == QEvent.MouseButtonPress and option.rect.contains(event.position().toPoint()):
            self._pressed_row = index.row()
            return True
        elif event.type() == QEvent.MouseButtonRelease and self._pressed_row == index.row():
            self._pressed_row = -1
            self.button_clicked.emit(index.row())
            return True
        elif event.type() == QEvent.Leave:
            self._pressed_row = -1
        return False


class ScheduleKeyboardFilter(QObject):
    """
    Dedykowany filtr zdarzeń klawiatury dla tabeli grafiku z obsługa:
    - dwucyfrowych godzin i wieloznakowych symboli (z buforowaniem)
    - modyfikacji liczby godzin (+/-/=) z poprawnym odświeżaniem bilansu.
    """

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self._digit_buffer = ""
        self._buffer_timer = QTimer()
        self._buffer_timer.setSingleShot(True)
        self._buffer_timer.timeout.connect(self._process_digit_buffer_on_timeout)
        self._buffer_timeout = 1200
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1200

        # Bufor i timer dla wieloznakowych symboli
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1200

    def eventFilter(self, obj, event):
        """Główna metoda filtrująca zdarzenia klawiatury."""
        if not (hasattr(self.main_window, 'table') and
                hasattr(self.main_window.table, 'schedule_view') and
                obj == self.main_window.table.schedule_view and
                event.type() == QEvent.KeyPress):
            return False

        key = event.key()
        role = self.main_window.current_user_app_role

        if key in (Qt.Key_Plus, Qt.Key_Equal, Qt.Key_Minus):
            self._clear_digit_buffer()
            self._clear_char_buffer()
            # ZMIANA: Odwołanie do app_settings
            if app_settings.has_permission(role, 'schedule_keyboard_edit'):
                self._handle_hour_modification(key)
            return True

        # ZMIANA: Odwołanie do app_settings
        can_edit_hours_symbols = app_settings.has_permission(role, 'schedule_keyboard_edit')

        is_digit_key = (Qt.Key_0 <= key <= Qt.Key_9)
        is_char_key = (Qt.Key_A <= key <= Qt.Key_Z)
        is_delete_key = key in [Qt.Key_Delete, Qt.Key_Backspace]
        is_escape_key = key == Qt.Key_Escape

        if not can_edit_hours_symbols and (is_digit_key or is_char_key or is_delete_key):
            return True

        if is_digit_key or is_char_key or is_delete_key:
            if not self._validate_selected_cells():
                return True

        if is_digit_key:
            self._handle_digit_input(key - Qt.Key_0)
            return True

        if is_char_key:
            self._handle_char_input(event.text())
            return True

        if is_delete_key:
            # ZMIANA: Odwołanie do app_settings
            if app_settings.has_permission(role, 'action_delete_symbol'):
                self.main_window.clear_selected_cells()
            self._clear_digit_buffer()
            self._clear_char_buffer()
            return True

        if is_escape_key:
            self._clear_digit_buffer()
            self._clear_char_buffer()
            self.main_window.table.schedule_view.clearSelection()
            return True

        if key in [Qt.Key_Space, Qt.Key_Enter, Qt.Key_Return, Qt.Key_Tab]:
            return True

        return False

    def _handle_hour_modification(self, key):
        """Obsługuje zwiększanie/zmniejszanie liczby godzin (+/-/=) z uwzględnieniem uprawnień."""
        selected_cells_data = self.main_window.table.get_data_for_selected_cells()
        if not selected_cells_data: return

        updated_info = []
        error_messages = []
        skipped_count = 0
        permission_denied_count = 0
        current_user_role = self.main_window.current_user_app_role  # Pobierz rolę bieżącego użytkownika

        for cell_data in selected_cells_data:
            permissions = self.main_window._get_permission_for_cell(cell_data)
            if not permissions['can_edit_hours']:
                permission_denied_count += 1
                continue

            system_pracy = cell_data.get('system_czasu_pracy', '')

            # --- POCZĄTEK ZMIANY ---
            # Sprawdź system pracy, ale zezwól na edycję dla roli 'Pracownik WPR'
            is_equivalent_system = system_pracy.strip().lower() == 'równoważny'
            if not is_equivalent_system and current_user_role != 'Pracownik WPR':
                skipped_count += 1
                continue
            # --- KONIEC ZMIANY ---

            current_symbol = cell_data.get('symbol', '')
            if not current_symbol: continue

            try:
                parsed = parse_symbol(current_symbol)
                if parsed.get('work_hours') is None: continue

                current_hours = int(parsed['work_hours'])
                new_hours = min(12, current_hours + 1) if key in (Qt.Key_Plus, Qt.Key_Equal) else max(1,
                                                                                                      current_hours - 1)
                if new_hours == current_hours: continue

                new_symbol = build_symbol(
                    location=parsed.get('location'), start_hour=parsed.get('start_hour'),
                    work_hours=new_hours, special_symbol=parsed.get('special_symbol')
                )

                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self.main_window._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )

                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"⑭ {cell_data.get('uzytkownik_dane')}: {result.get('message', 'Błąd zapisu.')}")
            except (ValueError, TypeError) as e:
                log_warning(f"Błąd modyfikacji godzin dla symbolu '{current_symbol}': {e}")
                error_messages.append(f"⑭ {cell_data.get('uzytkownik_dane')}: Błąd aplikacji: {e}")

        if permission_denied_count > 0:
            self.main_window.statusBar().showMessage(
                f"Pominięto {permission_denied_count} komórek z powodu braku uprawnień do zmiany godzin.", 4000)

        if updated_info:
            self.main_window._update_cells_with_new_symbols(updated_info)
            self.main_window.statusBar().showMessage(f"Zmieniono liczbę godzin dla {len(updated_info)} komórek.", 4000)

        if error_messages:
            QMessageBox.warning(self.main_window, "Błędy podczas zapisu",
                                "Wystąpiły następujące błędy:<br><br>" + "<br>".join(error_messages))
        elif not updated_info and skipped_count > 0 and skipped_count == len(selected_cells_data):
            self.main_window.statusBar().showMessage("Operacja dozwolona tylko dla Równoważnego Systemu Czasu Pracy.",
                                                     5000)

    def _handle_char_input(self, char: str):
        self._clear_digit_buffer()
        self._char_buffer += char.upper()
        self.main_window.statusBar().showMessage(f"Wpisywanie symbolu: {self._char_buffer}", self._char_buffer_timeout)
        if len(self._char_buffer) >= 3:
            self._char_buffer_timer.stop()
            self._process_char_buffer()
        else:
            self._char_buffer_timer.start(self._char_buffer_timeout)

    def _process_char_buffer(self):
        symbol = self._char_buffer
        self._clear_char_buffer()
        if not symbol: return

        # Krok 1: Sprawdź, czy symbol jest w ogóle poprawny
        if symbol in self.main_window.get_all_valid_symbols():

            # --- POCZĄTEK POPRAWKI ---
            # Krok 2: Sprawdź, czy bieżąca rola ma uprawnienia do tego symbolu
            current_role = self.main_window.current_user_app_role
            if app_settings.has_symbol_permission(current_role, symbol):
                self.main_window.apply_symbol_from_keyboard(symbol)
            else:
                # Symbol jest poprawny, ale użytkownik nie ma uprawnień
                self.main_window.statusBar().showMessage(
                    f"Brak uprawnień do użycia symbolu '{symbol}' dla Twojej roli.", 4000)
            # --- KONIEC POPRAWKI ---

        else:
            # Symbol jest nieprawidłowy
            self.main_window.statusBar().showMessage(f"Błąd: Symbol '{symbol}' jest nieprawidłowy!", 4000)

    def _handle_digit_input(self, digit: int):
        self._clear_char_buffer()
        self._digit_buffer += str(digit)
        self.main_window.statusBar().showMessage(f"Wpisywanie godziny: {self._digit_buffer}", self._buffer_timeout)

        if len(self._digit_buffer) == 1:
            if int(self._digit_buffer) >= 3:
                self.main_window.quick_edit_selected_cells(int(self._digit_buffer))
                self._clear_digit_buffer()
            else:
                self._buffer_timer.start(self._buffer_timeout)
        elif len(self._digit_buffer) == 2:
            self._buffer_timer.stop()
            potential_hour = int(self._digit_buffer)
            hour = potential_hour if 0 <= potential_hour <= 23 else int(self._digit_buffer[0])
            self.main_window.quick_edit_selected_cells(hour)
            self._clear_digit_buffer()
        else:
            self._buffer_timer.stop()
            self.main_window.quick_edit_selected_cells(digit)
            self._clear_digit_buffer()

    def _process_digit_buffer_on_timeout(self):
        if self._digit_buffer:
            self.main_window.quick_edit_selected_cells(int(self._digit_buffer))
            self._clear_digit_buffer()

    def _clear_digit_buffer(self):
        self._digit_buffer = ""
        if self._buffer_timer.isActive(): self._buffer_timer.stop()
        if self.main_window.statusBar().currentMessage().startswith("Wpisywanie godziny:"):
            self.main_window.statusBar().clearMessage()

    def _clear_char_buffer(self):
        self._char_buffer = ""
        if self._char_buffer_timer.isActive(): self._char_buffer_timer.stop()
        if self.main_window.statusBar().currentMessage().startswith("Wpisywanie symbolu:"):
            self.main_window.statusBar().clearMessage()

    def _validate_selected_cells(self) -> bool:
        selected_cells_data = self.main_window.table.get_data_for_selected_cells()
        if not selected_cells_data: return False
        return self.main_window._can_modify_cells(selected_cells_data)


class CustomMultiComboBox(QComboBox):
    """Niestandardowy ComboBox z obsługa wielokrotnego wyboru (wersja poprawiona)."""
    selection_changed = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)

        self._selected_items = set()
        self._select_all_text = "-Wszystkie-"

        # Konfiguracja modelu
        self.setModel(QStandardItemModel(self))

        # Konfiguracja wyglądu
        self.setEditable(True)
        self.lineEdit().setReadOnly(True)
        self.setEditText("-Wszystkie-")
        self.setSizeAdjustPolicy(QComboBox.AdjustToContents)

        # Używamy filtra zdarzeń do przechwytywania kliknięć, co zapobiega zamykaniu listy
        self.view().viewport().installEventFilter(self)
        self.lineEdit().installEventFilter(self)

        # Delegat jest potrzebny do poprawnego renderowania
        self.setItemDelegate(QStyledItemDelegate(self))

    def eventFilter(self, obj, event):
        # Przechwytujemy kliknięcie myszą w polu tekstowym, aby pokazać listę
        if obj == self.lineEdit() and event.type() == QEvent.MouseButtonPress:
            self.showPopup()
            return True

        # Przechwytujemy zwolnienie przycisku myszy na liście (widoku)
        if obj == self.view().viewport() and event.type() == QEvent.MouseButtonRelease:
            index = self.view().indexAt(event.position().toPoint())  # Użyj .position().toPoint() zamiast .pos()
            if index.isValid():
                self.handle_item_pressed(index)
            return True

        return False

    def handle_item_pressed(self, index):
        """Logika zaznaczania/odznaczania elementu."""
        item = self.model().itemFromIndex(index)
        if not item:
            return

        if item.text() == self._select_all_text:
            # Logika dla przycisku "Zaznacz wszystkie"
            is_checked = (item.checkState() == Qt.Checked)
            new_state = Qt.Unchecked if is_checked else Qt.Checked
            for i in range(1, self.model().rowCount()):
                self.model().item(i).setCheckState(new_state)
        else:
            # Logika dla zwykłego elementu
            current_state = item.checkState()
            item.setCheckState(Qt.Checked if current_state == Qt.Unchecked else Qt.Unchecked)

        self._rebuild_selected_items()
        self.update_display_text()

        self.selection_changed.emit()

    def _rebuild_selected_items(self):
        """Przebudowuje zbiór zaznaczonych elementów na podstawie stanu modelu."""
        self._selected_items.clear()
        all_selected = True
        # Pętla od 1, aby pominąć element "Zaznacz wszystkie"
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.checkState() == Qt.Checked:
                self._selected_items.add(item.text())
            else:
                all_selected = False

        # Aktualizuj stan checkboxa "Zaznacz wszystkie"
        if self.model().rowCount() > 0:
            select_all_item = self.model().item(0)
            select_all_item.setCheckState(Qt.Checked if all_selected else Qt.Unchecked)

    def hidePopup(self):
        """Aktualizuje tekst po zamknięciu listy."""
        self.update_display_text()
        super().hidePopup()

    def add_items(self, items):
        """Dodaje elementy do ComboBoxa."""
        self.clear()

        select_all_item = QStandardItem(self._select_all_text)
        select_all_item.setCheckable(True)
        self.model().appendRow(select_all_item)

        for item_text in sorted(items):
            item = QStandardItem(item_text)
            item.setCheckable(True)
            self.model().appendRow(item)

        self.update_display_text()

    def showPopup(self):
        """Pokaż menu rozwijane z dostosowaną szerokością."""
        super().showPopup()

        width = self.view().sizeHintForColumn(0) + 20
        width = min(width, 450)
        self.view().setMinimumWidth(width)

    def clear(self):
        """Czyści listę elementów."""
        self.model().clear()
        self._selected_items.clear()
        self.setEditText("-Wszystkie-")

    def clear_selection(self):
        """Czyści zaznaczenie wszystkich elementów i emituje sygnał o zmianie TYLKO RAZ."""
        # Blokujemy sygnały modelu, aby nie odświeżać widoku dla każdego elementu
        self.model().blockSignals(True)
        try:
            for i in range(self.model().rowCount()):
                self.model().item(i).setCheckState(Qt.Unchecked)
        finally:
            self.model().blockSignals(False)

        self._rebuild_selected_items()
        self.update_display_text()
        # Emitujemy sygnał zmiany tylko raz na koniec
        self.selection_changed.emit()

    def get_selected_items(self):
        """Zwraca listę zaznaczonych elementów."""
        return list(self._selected_items)

    def select_items(self, items_to_select):
        """Zaznacza programowo określone elementy na liście."""
        lookup = set(items_to_select)
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.text() in lookup:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()

    def update_display_text(self):
        """Aktualizuje tekst wyświetlany w comboboxie."""
        if not self._selected_items or len(self._selected_items) == (self.model().rowCount() - 1):
            self.setEditText("-Wszystkie-")
        else:
            self.setEditText(f"Wybrano {len(self._selected_items)} z {self.model().rowCount() - 1}")


class UpdateRequiredDialog(QDialog):
    """Modalne okno informujące o konieczności aktualizacji i wymuszające zamknięcie."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Wymagana aktualizacja")
        self.setModal(True)
        self.setWindowFlags(Qt.Dialog | Qt.CustomizeWindowHint | Qt.WindowTitleHint)

        self.countdown = 15

        layout = QVBoxLayout(self)
        info_label = QLabel(
            "<b>Dostępna jest nowa wersja aplikacji.</b><br><br>"
            "Aby zapewnić spójność danych i dostęp do nowych funkcji, dalsza praca na tej wersji nie jest możliwa.<br>"

        )
        info_label.setTextFormat(Qt.RichText)
        info_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(info_label)

        self.countdown_label = QLabel(f"Aplikacja zostanie zamknięta za {self.countdown} sekund...")
        self.countdown_label.setAlignment(Qt.AlignCenter)
        self.countdown_label.setStyleSheet("font-weight: bold; color: #e74c3c;")
        layout.addWidget(self.countdown_label)

        self.timer = QTimer(self)
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.update_countdown)
        self.timer.start()

    def update_countdown(self):
        self.countdown -= 1
        self.countdown_label.setText(f"Aplikacja zostanie zamknięta za {self.countdown} sekund...")
        if self.countdown <= 0:
            self.timer.stop()
            self.accept()


class WorkScheduleWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        self._is_updating_layout = False
        self.user_hidden_days = set()
        self.schedule_control_win = None
        self._state_to_restore = None

        self.settings_db = SettingsDatabase()
        try:
            current_windows_user = getpass.getuser().lower()
        except Exception:
            current_windows_user = "unknown_user"

        self.user_app_settings = self.settings_db.load_settings(login_windows=current_windows_user)
        debug_print(f"ZAŁADOWANE USTAWIENIA UŻYTKOWNIKA: {self.user_app_settings}")

        # Wczytaj nowe ustawienie
        self.show_percent_morning_column = self.user_app_settings.get('show_schedule_percent_morning', False)
        self.show_percent_ho_column = self.user_app_settings.get('show_schedule_percent_ho', False)
        self.show_comment_column = self.user_app_settings.get('show_schedule_comment', False)

        # Inicjalizacja Menedżera Sesji
        self.session_manager = SessionManager(current_windows_user)
        self.session_manager.start_session()

        # Timer do Heartbeatu (tylko meldowanie obecności)
        self.heartbeat_timer = QTimer(self)
        self.heartbeat_timer.timeout.connect(self._on_heartbeat_tick)
        # Możesz wydłużyć czas, np. 5 minut (300000 ms), minuta to trochę często jak na sam heartbeat
        self.heartbeat_timer.start(300000)

        self.clear_icon_dark = self._create_clear_icon(QColor("#d0d0d0"))
        self.clear_icon_light = self._create_clear_icon(QColor("#505050"))
        self.is_dark_theme = self.user_app_settings.get('theme') == 'dark'
        self.current_font = self.user_app_settings.get('font_family', 'Segoe UI')
        self.current_font_size = self.user_app_settings.get('font_size', 9)
        self.import_grupa = self.user_app_settings.get('import_grupa', 3)
        self.import_funkcja = self.user_app_settings.get('import_funkcja', 1)
        self.column_definitions = ColumnDefinitions()
        self.default_visible_columns = self.column_definitions.DEFAULT_VISIBLE_COLUMNS
        saved_columns = self.user_app_settings.get('visible_columns')
        self.visible_columns = saved_columns if saved_columns else self.default_visible_columns.copy()
        self.custom_columns = self.user_app_settings.get('custom_columns', {})
        self.user_sort_preferences = self.user_app_settings.get('sort_preferences', [])
        self.show_comment_column = self.user_app_settings.get('show_schedule_comment', False)

        # --- NOWA LOGIKA: Definicja wszystkich filtrów ---
        # (filter_id, display_name, is_locked)
        self.ALL_FILTERS = [
            ('presence', "Obecni w pracy w dniu:", False),
            ('absence', "Nieobecni w pracy w dniu:", False),
            ('separator1', "--------------------", True),  # Separator też jest "filtrem"
            ('grupa', "Grupa:", False),
            ('wydzial', "Wydział:", True),  # ZABLOKOWANY
            ('przelozony', "Przełożony:", True),  # ZABLOKOWANY
            ('uzytkownik', "Użytkownik:", True),  # ZABLOKOWANY
            ('default_location', "LD:", False),
            ('system_czasu_pracy', "System Pracy:", False),
            ('rola', "Rola:", False),
            ('podrola', "PodRola:", False),
            ('jezyk', "Język:", False),
            ('etat', "Etat:", False),
            ('dtn', "DTN:", False),
            ('rka', "Rka:", False),
            ('sched_grafik_za_punkty', "Grafik za pkt:", False),
            ('sched_brak_nocki', "Brak nocki:", False)
        ]

        # Mapa do szybkiego wyszukiwania widgetów po ich ID
        self.filter_widget_map = {}

        # Wczytaj zapisaną kolejność i widoczność
        saved_visible_filters = self.user_app_settings.get('visible_filters')
        if saved_visible_filters is None:
            # Jeśli użytkownik nigdy nie zapisywał, utwórz domyślną listę
            self.visible_filters_list = [f_id for f_id, name, locked in self.ALL_FILTERS]
        else:
            self.visible_filters_list = saved_visible_filters

        # Upewnij się, że zablokowane filtry zawsze są na liście (na wypadek uszkodzonych ustawień)
        for f_id, name, is_locked in self.ALL_FILTERS:
            if is_locked and f_id not in self.visible_filters_list:
                # Dodaj na rozsądnej pozycji (np. po 'grupa')
                try:
                    idx = self.visible_filters_list.index('grupa')
                    self.visible_filters_list.insert(idx + 1, f_id)
                except ValueError:
                    self.visible_filters_list.append(f_id)  # Dodaj na koniec, jeśli nie ma 'grupa'
        # --- KONIEC NOWEJ LOGIKI ---

        self.staffing_details_win = None
        self.current_user_app_role = None
        self.data_provider = DataProvider()
        self.data_provider.data_changed.connect(self._handle_specific_icons_refresh)
        self.employee_columns = self.column_definitions.get_ui_display_columns()

        self.setWindowTitle("TeamFlowApp")

        self._selection_timer = QTimer()
        self._selection_timer.setSingleShot(True)
        self._selection_timer.timeout.connect(self._handle_selection_change)
        self._selection_debounce_delay = 50

        font = QFont(self.current_font, self.current_font_size)
        QApplication.setFont(font)

        self.schedule_change_processor = ScheduleChangeProcessor(self)
        self.delegation_canceler = DelegationCanceler(self)
        self.location_exception_manager = LocationExceptionManager(self)
        self.overtime_manager = OvertimeManager(self)

        # --- POPRAWKA: Przekazanie `column_map` do modelu ---
        self.column_map = {col_id: name for col_id, name, width in self.employee_columns}
        # Ustaw flagi w modelu
        self.schedule_model = ScheduleTableModel(self, column_map=self.column_map)
        self.schedule_model.set_visible_columns(self.visible_columns)
        self.schedule_model.set_show_comment_column(self.show_comment_column)
        self.schedule_model.set_show_percent_morning_column(self.show_percent_morning_column)
        self.schedule_model.set_show_percent_ho_column(self.show_percent_ho_column)
        self.schedule_model.set_custom_columns(self.custom_columns)

        self.refresh_column_configuration()

        self.events_model = EventsTableModel(self)

        self._create_central_widget()

        self._update_saved_filters_combo()
        self._update_delete_button_state()

        self.table.set_model(self.schedule_model)
        self.events_table.setModel(self.events_model)
        self.manage_columns_button.clicked.connect(self.show_column_select_dialog)

        # --- NOWA LOGIKA: Włączenie i podłączenie menu kontekstowego ---
        self.table.employees_view.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.employees_view.customContextMenuRequested.connect(self.show_employee_table_context_menu)
        # --- KONIEC NOWEJ LOGIKI ---

        if self.table.employees_view.selectionModel():
            self.table.employees_view.selectionModel().selectionChanged.connect(self.on_selection_changed)
        if self.table.schedule_view.selectionModel():
            self.table.schedule_view.selectionModel().selectionChanged.connect(self.on_selection_changed)

        self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font, self.current_font_size)

        self.shortcut_f1 = QShortcut(QKeySequence(Qt.Key_F1), self)
        self.shortcut_f1.activated.connect(self.toggle_left_panel)

        self.shortcut_f2 = QShortcut(QKeySequence(Qt.Key_F2), self)
        self.shortcut_f2.activated.connect(self.toggle_events_panel)

        self.shortcut_f3 = QShortcut(QKeySequence(Qt.Key_F3), self)
        self.shortcut_f3.activated.connect(self.show_insert_change_dialog)

        self.shortcut_f4 = QShortcut(QKeySequence(Qt.Key_F4), self)
        self.shortcut_f4.activated.connect(self.show_insert_symbol_dialog)

        self.shortcut_insert = QShortcut(QKeySequence(Qt.Key_Insert), self)
        self.shortcut_insert.activated.connect(self.show_add_overtime_dialog)
        self.shortcut_insert.setEnabled(False)

        self.shortcut_f12 = QShortcut(QKeySequence(Qt.Key_F12), self)
        self.shortcut_f12.activated.connect(self.clear_special_symbol_from_selected_cells)

        self.shortcut_f6 = QShortcut(QKeySequence(Qt.Key_F6), self)
        self.shortcut_f6.setContext(Qt.ShortcutContext.ApplicationShortcut)
        self.shortcut_f6.activated.connect(self.toggle_staffing_window_visibility)

        self.copy_shortcut = QShortcut(QKeySequence.Copy, self)
        self.copy_shortcut.activated.connect(self.copy_selection_to_clipboard)

        # --- NOWA ZMIANA: Skróty klawiszowe dla Teams i Outlook ---
        self.shortcut_teams = QShortcut(QKeySequence("Ctrl+T"), self)
        self.shortcut_teams.activated.connect(self.open_teams_chat_for_selection)
        self.shortcut_teams.setEnabled(False)

        self.shortcut_outlook = QShortcut(QKeySequence("Ctrl+O"), self)
        self.shortcut_outlook.activated.connect(self.send_email_to_selection)
        self.shortcut_outlook.setEnabled(False)
        self.db_listener = None
        self.background_checker = None
        # --- KONIEC ZMIANY ---

        # --- NOWA FLAGA: Zapobieganie rekurencyjnym odświeżeniom ---
        self._is_refreshing_data = False

        self.start_full_initialization()

        # Inicjalizacja Centrum Powiadomień (Warunkowa)
        if app_settings.ENABLE_NOTIFICATION_CENTER:
            from notification_center import NotificationDrawer
            self.notification_drawer = NotificationDrawer(self)
            self.notification_drawer.hide()
        else:
            self.notification_drawer = None

        # PRZENIESIONY BLOK: Ustawienie rozmiaru i pokazanie okna na samym końcu
        if self.user_app_settings.get('is_maximized'):
            self.showMaximized()
        else:
            width, height = self.user_app_settings.get('window_size', (1600, 800))
            self.setGeometry(100, 100, width, height)

        debug_print("=== APLIKACJA URUCHOMIONA W TRYBIE AUTOMATYCZNYM ===")

    def _on_schedule_control_closed(self):
        """Callback wywoływany po zamknięciu okna 'Zarządzaj grafikiem'."""
        debug_print("Okno 'Zarządzaj grafikiem' zostało zamknięte, czyszczę referencję.")
        self.schedule_control_win = None

    def manage_ui_state(self, enabled: bool):
        """Włącza lub wyłącza kluczowe elementy interfejsu użytkownika."""

        self.add_overtime_dialog_instance = None

        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(enabled)

        action_buttons = [
            self.settings_button, self.refresh_button, self.show_audit_button,
            self.staffing_details_button, self.schedule_control_button,
            self.manage_columns_button, self.toggle_events_panel_button,
            self.insert_change_button, self.insert_symbol_button,
            self.cancel_delegation_button, self.add_overtime_button
        ]
        for button in action_buttons:
            if hasattr(self, button.objectName()):
                button.setEnabled(enabled)

        if hasattr(self, 'date_combo'):
            self.date_combo.setEnabled(enabled)

    def start_full_initialization(self):
        """Uruchamia pełną inicjalizację po sprawdzeniu wersji i uprawnień."""
        self.load_data_button.setText("Sprawdzanie uprawnień...")
        self.load_data_button.setEnabled(False)
        QApplication.processEvents()

        # --- NOWA LOGIKA: Wyczyść kolejkę Service Broker przy starcie ---
        self._clear_service_broker_queue()
        # --- KONIEC NOWEJ LOGIKI ---

        if not self.check_user_permissions():
            QTimer.singleShot(10, self.close)
            return

        self.manage_ui_state(enabled=True)
        self.load_data_button.setVisible(False)
        self.refresh_button.setVisible(True)

        self.setup_table_properties()
        self.setup_keyboard_editing()

        self.setup_date_combo()
        self.load_initial_data()

        # self.check_timer = QTimer(self)
        # self.check_timer.timeout.connect(self.check_for_new_data)
        # self.check_timer.start(60000)
        # self.background_checker = None # Referencja do wątku sprawdzającego
        # --- NOWA LOGIKA: Uruchomienie obu mechanizmów sprawdzania ---

        self.start_db_listener()  # Dla zmian danych
        # --- KONIEC NOWEJ LOGIKI ---

    def check_if_update_is_required(self) -> bool:
        """Sprawdza wersję aplikacji na podstawie załadowanych ustawień."""
        # Porównujemy wersje. Funkcja zwraca tylko wynik, nie zamyka już aplikacji.
        return parse_version(APP_VERSION) != parse_version(app_settings.REQUIRED_VERSION)

    def show_staffing_details_window(self):
        """
        Poprawiona wersja: Pokazuje okno 'Obsada'.
        Jeśli okno istnieje, odświeża je, przywraca i aktywuje.
        Jeśli nie istnieje, tworzy je.
        """
        from staffing_details_window import StaffingDetailsWindow  # Leniwy import
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Brak danych", "Proszę wybrać miesiąc, aby wyświetlić szczegóły obsady.",
                                QMessageBox.Ok)
            return
        year, month = current_data

        # --- POCZĄTEK POPRAWKI ---

        # PRZYPADEK 1: Okno nie istnieje (self.staffing_details_win is None)
        if not self.staffing_details_win:
            debug_print("Tworzę nową instancję okna 'Obsada'...")
            self.staffing_details_win = StaffingDetailsWindow(
                self, self.data_provider, year, month, self.import_grupa, self.import_funkcja
            )
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.show()

        # PRZYPADEK 2: Okno istnieje (było już otwarte, może być ukryte, zminimalizowane lub aktywne)
        else:
            debug_print("Aktywuję istniejące okno 'Obsada'...")

            # Najpierw odśwież dane i motyw
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.update_for_new_month_or_filters(year, month)

            # Pokaż je (jeśli było ukryte) i przywróć (jeśli było zminimalizowane)
            self.staffing_details_win.showNormal()
            self.staffing_details_win.activateWindow()
            self.staffing_details_win.raise_()  # Przenieś na wierzch
        # --- KONIEC POPRAWKI ---

    def toggle_staffing_window_visibility(self):
        """
        Przełącza widoczność okna Obsady (F6). Jeżeli jest widoczne, minimalizuje je.
        Jeżeli jest zminimalizowane, przywraca je. Jeżeli jest zamknięte, otwiera je.
        """
        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            # Okno jest widoczne
            if self.staffing_details_win.isMinimized():
                # Jest zminimalizowane, więc je przywracamy
                self.staffing_details_win.showNormal()
                self.staffing_details_win.activateWindow()
            else:
                # Jest normalnie widoczne, więc je minimalizujemy
                self.staffing_details_win.showMinimized()
        else:
            # Okno jest zamknięte lub ukryte, więc je otwieramy
            self.show_staffing_details_window()

    def setup_keyboard_editing(self):
        """Konfiguruje edycję klawiatury dla komórek grafiku"""
        if not app_settings.has_permission(self.current_user_app_role, 'schedule_keyboard_edit'):
            debug_print(f"Edycja klawiatury wyłączona - rola '{self.current_user_app_role}' nie ma uprawnień.")
            return

        self.keyboard_filter = ScheduleKeyboardFilter(self)
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            self.table.schedule_view.installEventFilter(self.keyboard_filter)
            debug_print(f"Włączono edycję klawiatury dla roli: {self.current_user_app_role}")

    def cleanup_keyboard_filter(self):
        """Czyści filtr klawiatury przy zamykaniu aplikacji"""
        if hasattr(self, 'keyboard_filter'):
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.removeEventFilter(self.keyboard_filter)
            del self.keyboard_filter
            debug_print("Wyczyszczono filtr klawiatury")

    def _should_ask_for_confirmation(self) -> bool:
        """
        Sprawdza, czy należy wyświetlić okno dialogowe z prośbą o potwierdzenie.
        Zwraca False, jeśli grafik nie jest opublikowany (praca "na brudno"), True w przeciwnym wypadku.
        """
        current_data = self.date_combo.currentData()
        if not current_data:
            return True  # W razie wątpliwości, dla bezpieczeństwa pytaj

        year, month = current_data
        is_published = self.data_provider.is_schedule_published(year, month)

        # Pytamy o potwierdzenie tylko wtedy, gdy grafik JEST opublikowany.
        return is_published

    def _get_permission_for_cell(self, cell_data: dict) -> dict:
        permissions = {'can_edit_hours': False, 'can_edit_symbol': False, 'can_edit_location': False,
                       'can_delete': False}
        if not cell_data: return permissions

        user_role, user_dept = self.current_user_app_role, self.current_user_app_department
        target_role, target_dept = cell_data.get('rola_nazwa'), cell_data.get('wydzial')

        # Logika dla Administratora i Pracownika WPR (bez zmian - pełny dostęp)
        if user_role in ['Pracownik WPR', 'Administrator']:
            return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}

        # Logika dla Lidera OUT (bez zmian)
        if user_role == 'Lider OUT':
            # Sprawdzenie czy ten sam wydział (lub nadrzędny)
            is_same_dept = user_dept and target_dept and target_dept.strip().lower().startswith(
                user_dept.strip().lower())
            if is_same_dept:
                return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}
            # Specjalny wyjątek dla DTN
            if target_dept and target_dept.strip().lower() == 'dtn':
                return {'can_edit_hours': False, 'can_edit_symbol': True, 'can_edit_location': False,
                        'can_delete': False}
            return permissions

        # --- LOGIKA DLA LIDERA (ZMIENIONA/ZWERYFIKOWANA) ---
        if user_role == 'Lider':
            # Super Lider (bez zmian)
            is_super_lider = self.current_user_app_login_windows.lower() in app_settings.SUPER_LIDER_LOGINS

            # Sprawdzenie wydziału
            is_same_dept = False
            if user_dept and target_dept:
                if target_dept.strip().lower().startswith(user_dept.strip().lower()):
                    is_same_dept = True

            # Wyjątek dla DTN (pozwalamy na edycję symbolu, np. CO)
            if target_dept and target_dept.strip().lower() == 'dtn':
                return {'can_edit_hours': False, 'can_edit_symbol': True, 'can_edit_location': False,
                        'can_delete': False}

            if not is_same_dept:
                return permissions

            # W ramach swojego wydziału:
            if is_super_lider or target_role == 'Lider':
                return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}
            else:
                # Dla zwykłych pracowników Lider nie może edytować godzin, ale może symbole (z wyjątkami obsłużonymi w _apply...)
                return {'can_edit_hours': False, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}

        return permissions

    def quick_edit_selected_cells(self, start_hour):
        """Szybka edycja zaznaczonych komórek z klawiatury"""
        try:
            if not app_settings.has_permission(self.current_user_app_role, 'schedule_keyboard_edit'):
                return

            selected_cells_data = self.table.get_data_for_selected_cells()
            if not self._can_modify_cells(selected_cells_data) or not selected_cells_data:
                return

            schedule_cells = [cell for cell in selected_cells_data if
                              isinstance(cell, dict) and 'date_str' in cell and 'uzytkownik_id' in cell]
            if not schedule_cells:
                return

            grouped_changes = {}
            for cell_data in schedule_cells:
                user_id, user_name, date_str = cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane',
                                                                                             ''), cell_data.get(
                    'date_str')
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str
                user_key = (user_id, user_name)
                if user_key not in grouped_changes:
                    grouped_changes[user_key] = []
                grouped_changes[user_key].append(formatted_date)

            # --- POCZĄTEK POPRAWKI: Ograniczenie długości komunikatu ---
            changes_info = f"Zmiana godziny rozpoczęcia na {start_hour}:00 dla:<br><br>"
            MAX_USERS_TO_SHOW = 15
            user_count = 0
            for (user_id, user_name), dates in grouped_changes.items():
                if user_count >= MAX_USERS_TO_SHOW:
                    break
                changes_info += f"👤 {user_name}: "
                dates_str = ", ".join(sorted(dates))
                changes_info += f"   🗓️ {dates_str}<br><br>"
                user_count += 1

            remaining_users = len(grouped_changes) - user_count
            if remaining_users > 0:
                changes_info += f"... i {remaining_users} więcej pracowników.<br><br>"

            changes_info += f"Łącznie: {len(schedule_cells)} komórek"
            # --- KONIEC POPRAWKI ---

            reply = QMessageBox.Yes
            if self._should_ask_for_confirmation():
                reply = show_confirmation_dialog(self, "Potwierdzenie szybkiej edycji", changes_info)
            if reply == QMessageBox.Yes:
                self._apply_quick_changes(schedule_cells, start_hour)
        except Exception as e:
            log_error(f"Błąd podczas szybkiej edycji: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas edycji: {str(e)}", QMessageBox.Ok)

    def _apply_quick_changes(self, schedule_cells, start_hour):
        """
        Przygotowuje listę zmian dla szybkiej edycji i przekazuje ją do asynchronicznego procesora.
        """
        change_requests = []
        skipped_employees = []

        for cell_data in schedule_cells:
            permissions = self._get_permission_for_cell(cell_data)
            if permissions['can_edit_hours']:
                change_requests.append((ChangeType.QUICK_EDIT_START_HOUR, cell_data, start_hour))
            else:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))

        if skipped_employees:
            QMessageBox.information(self, "Pominięto",
                                    f"Pominięto {len(skipped_employees)} komórek z powodu braku uprawnień dla:<br>"
                                    f"- {', '.join(set(skipped_employees))}")
        if change_requests:
            self.schedule_change_processor.start_changes(change_requests)

    def _prepare_deletion_summary_message(self, schedule_cells: list, contains_vacation_symbol: bool = False) -> str:
        """
        Przygotowuje sformatowaną wiadomość podsumowującą usuwanie symboli,
        z limitem wyświetlanych wierszy.
        """
        if not schedule_cells:
            return "Nie wybrano żadnych komórek z symbolami do usunięcia."

        grouped_deletions = {}
        for cell_data in schedule_cells:
            user_name = cell_data.get('uzytkownik_dane', 'Nieznany Użytkownik')
            date_str = cell_data.get('date_str', 'Nieznana Data')
            symbol = cell_data.get('symbol', '??')
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except ValueError:
                formatted_date = date_str
            if user_name not in grouped_deletions:
                grouped_deletions[user_name] = []
            grouped_deletions[user_name].append(f"{formatted_date} (symbol: {symbol})")

        summary_lines = ["Czy na pewno chcesz usunąć symbole dla następujących pozycji?<br><br>"]
        line_count = 0
        total_cells = len(schedule_cells)
        cells_shown = 0
        MAX_LINES_TO_SHOW = 15

        for user_name, date_symbol_list in grouped_deletions.items():
            if line_count >= MAX_LINES_TO_SHOW:
                break
            summary_lines.append(f"<b>🧑 {user_name}:</b><br>")
            line_count += 1
            for date_with_symbol in sorted(date_symbol_list):
                if line_count >= MAX_LINES_TO_SHOW:
                    break
                summary_lines.append(f"&nbsp;&nbsp;&nbsp;• {date_with_symbol}<br>")
                line_count += 1
                cells_shown += 1
            summary_lines.append("<br>")  # Dodatkowa przerwa między użytkownikami

        remaining_cells = total_cells - cells_shown
        if remaining_cells > 0:
            summary_lines.append(f"<br>... i {remaining_cells} więcej pozycji.")

        summary_lines.append(f"<br>Łącznie zostanie wyczyszczonych: {total_cells} komórek.")

        # --- POCZĄTEK POPRAWKI: PRZYWRÓCENIE OSTRZEŻENIA ---
        # Skoro usuwanie urlopów ma być dozwolone, ostrzeżenie jest jak najbardziej poprawne.
        if contains_vacation_symbol:
            summary_lines.append(
                "<br><br><b><font color='orange'>UWAGA:</font> Ta operacja spowoduje również usunięcie urlopu z planów urlopowych.</b>")
        # --- KONIEC POPRAWKI ---

        return "".join(summary_lines)

    def clear_selected_cells(self):
        """Asynchronicznie czyści zawartość zaznaczonych komórek (klawisz Delete)."""
        if hasattr(self, 'keyboard_filter') and hasattr(self.keyboard_filter, '_buffer_timer'):
            self.keyboard_filter._buffer_timer.stop()
            self.keyboard_filter._digit_buffer = ""

        selected_cells_data = self.table.get_data_for_selected_cells()
        if not selected_cells_data:
            return

        schedule_cells = [cell for cell in selected_cells_data if cell.get('symbol', '').strip()]

        # --- NOWA ZMIANA: Sprawdzenie, czy usuwamy urlop ---
        contains_vacation_symbol = any(
            (parse_symbol(cell.get('symbol', '')).get('special_symbol') or '').upper() in ['U', 'UZ']
            for cell in schedule_cells
        )
        # --- KONIEC ZMIANY ---

        if not schedule_cells:
            QMessageBox.information(self, "Brak symboli do usunięcia", "Zaznaczone komórki są już puste.",
                                    QMessageBox.Ok)
            return

        if not any(self._get_permission_for_cell(c)['can_delete'] for c in schedule_cells):
            QMessageBox.warning(self, "Brak uprawnień",
                                "Nie posiadasz uprawnień do usunięcia symboli dla żadnej z zaznaczonych osób.")
            return

        user_date_pairs = {(cell.get('uzytkownik_id'), cell.get('date_str')) for cell in schedule_cells}
        events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        # --- ZMIANA: Przekazanie flagi o urlopie do funkcji tworzącej komunikat ---
        confirmation_message = self._prepare_deletion_summary_message(
            schedule_cells,
            contains_vacation_symbol=contains_vacation_symbol
        )
        # --- KONIEC ZMIANY ---
        if events_to_cancel:
            grouped_events = self._group_events_by_user_date(events_to_cancel)
            delegations_info = self._prepare_delegations_description(grouped_events)
            confirmation_message += f"<br><br>{delegations_info}"

        reply = show_confirmation_dialog(self, "Potwierdzenie usunięcia", confirmation_message)

        if reply == QMessageBox.Yes:
            if events_to_cancel: self.delegation_canceler.start_cancellation(events_to_cancel)
            self._clear_cells_symbols(schedule_cells)

            # --- NOWA ZMIANA: Wymuś odświeżenie ikon po operacji ---
            # Po usunięciu symbolu i odwołaniu zdarzeń, musimy jawnie
            # poinformować DataProvider, że dane dla tych komórek są nieaktualne,
            # co spowoduje ponowne przeliczenie i usunięcie ikon.
            current_data = self.date_combo.currentData()
            if current_data:
                year, month = current_data
                self.data_provider.invalidate_complete_cache_for_pairs(list(user_date_pairs))

    def _clear_cells_symbols(self, schedule_cells: list):
        """Przygotowuje żądania usunięcia symboli i przekazuje je do ScheduleChangeProcessor."""
        change_requests = []
        skipped_employees = []

        # --- POCZĄTEK POPRAWKI: Usunięto logikę pomijania urlopów ---
        # Usunęliśmy listę skipped_vacation_employees
        # Usunęliśmy blok "if special_symbol in ['U', 'UZ']:"
        # --- KONIEC POPRAWKI ---

        for cell_data in schedule_cells:
            # Sprawdź uprawnienia do usuwania
            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_delete']:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue

            # Dodaj żądanie usunięcia do listy (teraz obejmuje to także 'U' i 'UZ')
            change_requests.append((ChangeType.CLEAR_CELL, cell_data, None))  # None jako wartość dla CLEAR_CELL

        # --- POCZĄTEK POPRAWKI: Usunięto komunikat o pominięciu urlopów ---
        # if skipped_vacation_employees: ... (cały ten blok został usunięty)
        # --- KONIEC POPRAWKI ---

        if skipped_employees:
            QMessageBox.information(self, "Pominięto",
                                    f"Pominięto usuwanie dla następujących osób z powodu braku uprawnień:<br>"
                                    f"- {', '.join(set(skipped_employees))}")

        if change_requests:
            debug_print(f"Przekazuję {len(change_requests)} żądań CLEAR_CELL do ScheduleChangeProcessor.")
            self.schedule_change_processor.start_changes(change_requests)

    def on_data_changed(self, data_type, year, month):
        """Obsługuje powiadomienie o zmianie danych z DataProvider."""
        current_data = self.date_combo.currentData()
        if not (current_data and current_data == (year, month)):
            return

        if data_type == "schedule":
            self.update_table_content()
        elif data_type == "events":
            # Po prostu odświeżamy tabelę zdarzeń, jeśli coś się w nich zmieniło
            self.on_selection_changed()

    def log_time(self, label, start_time):
        """Pomocnicza funkcja do logowania czasu"""
        end_time = time.time()
        elapsed = end_time - start_time
        debug_print(f"[CZAS] {label}: {elapsed:.3f} sekundy")
        return end_time

    def _create_central_widget(self):
        """Tworzy i ustawia główny widget aplikacji."""
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(10, 0, 10, 0)
        main_layout.setSpacing(0)

        top_bar = self.setup_top_bar(main_layout)
        main_layout.addWidget(top_bar)

        middle_splitter = self.setup_middle_section(main_layout)
        main_layout.addWidget(middle_splitter, 1)

        self.setCentralWidget(central_widget)

    def setup_top_bar(self, main_layout):
        top_bar_frame = QFrame()
        top_bar_frame.setFrameShape(QFrame.StyledPanel)
        top_bar_frame.setFrameShadow(QFrame.Raised)
        top_bar_frame.setFixedHeight(50)
        top_bar_layout = QHBoxLayout(top_bar_frame)
        top_bar_layout.setContentsMargins(5, 5, 5, 5)
        top_bar_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        # --- LEWA STRONA PASKA (Menu, Ustawienia, Akcje) ---

        self.toggle_menu_button = QPushButton("☰")  # Używam standardowego znaku menu
        self.toggle_menu_button.setFixedSize(32, 32)
        self.toggle_menu_button.setToolTip("Pokaż/ukryj panel filtrów (F1)")
        self.toggle_menu_button.clicked.connect(self.toggle_left_panel)
        top_bar_layout.addWidget(self.toggle_menu_button)

        self.settings_button = QPushButton("Ustawienia")
        self.settings_button.clicked.connect(self.show_settings_dialog)
        top_bar_layout.addWidget(self.settings_button)

        top_bar_layout.addWidget(self.create_separator())

        top_bar_layout.addWidget(QLabel("Miesiąc:"))
        self.date_combo = QComboBox()
        self.date_combo.setMinimumWidth(120)
        self.date_combo.currentIndexChanged.connect(self.refresh_data)
        top_bar_layout.addWidget(self.date_combo)

        self.load_data_button = QPushButton("🚀 Pobierz Dane")
        self.load_data_button.setToolTip("Kliknij, aby połączyć się z bazą i załadować dane.")
        top_bar_layout.addWidget(self.load_data_button)
        self.load_data_button.setVisible(True)

        self.refresh_button = QPushButton("Odśwież")
        self.refresh_button.setToolTip("Odśwież dane dla bieżących filtrów")
        self.refresh_button.clicked.connect(self.refresh_data)
        top_bar_layout.addWidget(self.refresh_button)
        self.refresh_button.setVisible(False)

        self.show_audit_button = QPushButton("Historia Zmian")
        self.show_audit_button.clicked.connect(self.show_audit_log_window)
        top_bar_layout.addWidget(self.show_audit_button)

        self.staffing_details_button = QPushButton("Obsada")
        self.staffing_details_button.clicked.connect(self.show_staffing_details_window)
        top_bar_layout.addWidget(self.staffing_details_button)

        # Ikony Excel, Teams, Outlook
        self.export_button = QPushButton()
        self.export_button.setIcon(QIcon(resource_path("icons/excel.png")))
        self.export_button.setIconSize(QSize(24, 24))
        self.export_button.setFixedSize(32, 32)
        self.export_button.setToolTip("Eksportuj do Excel (.xlsx)")
        self.export_button.clicked.connect(self.export_schedule_to_excel)
        top_bar_layout.addWidget(self.export_button)

        self.teams_chat_button = QPushButton()
        self.teams_chat_button.setIcon(QIcon(resource_path("icons/teams.png")))
        self.teams_chat_button.setIconSize(QSize(24, 24))
        self.teams_chat_button.setFixedSize(32, 32)
        self.teams_chat_button.setToolTip("Otwórz czat w Teams (Ctrl+T)")
        self.teams_chat_button.clicked.connect(self.open_teams_chat_for_selection)
        self.teams_chat_button.setEnabled(False)
        top_bar_layout.addWidget(self.teams_chat_button)

        self.send_email_button = QPushButton()
        self.send_email_button.setIcon(QIcon(resource_path("icons/outlook.png")))
        self.send_email_button.setIconSize(QSize(24, 24))
        self.send_email_button.setFixedSize(32, 32)
        self.send_email_button.setToolTip("Wyślij e-mail (Ctrl+O)")
        self.send_email_button.clicked.connect(self.send_email_to_selection)
        self.send_email_button.setEnabled(False)
        top_bar_layout.addWidget(self.send_email_button)

        self.schedule_control_button = QPushButton("Zarządzaj Grafikiem")
        self.schedule_control_button.clicked.connect(self.show_schedule_control_dialog)
        top_bar_layout.addWidget(self.schedule_control_button)

        # --- KLUCZOWY ELEMENT: Wypychacz (Spacer) ---
        # To on zajmuje całą wolną przestrzeń między przyciskami po lewej a dzwonkiem po prawej
        top_bar_layout.addStretch()

        # --- PRAWA STRONA PASKA (Tylko Powiadomienia) ---

        self.notification_btn = QPushButton()
        try:
            icon_path = resource_path("icons/notification.png")
            self.notification_btn.setIcon(QIcon(icon_path))
        except Exception as e:
            from debug_utils import log_error
            log_error(f"Nie znaleziono ikony powiadomień: {e}")
            self.notification_btn.setText("🔔")

        self.notification_btn.setIconSize(QSize(24, 24))
        self.notification_btn.setFixedSize(32, 32)
        self.notification_btn.setToolTip("Powiadomienia")

        self.notification_btn.clicked.connect(self.toggle_notifications)
        self.notification_btn.setVisible(app_settings.ENABLE_NOTIFICATION_CENTER)

        top_bar_layout.addWidget(self.notification_btn)

        return top_bar_frame

    def toggle_notifications(self):
        """Przełącza widoczność panelu powiadomień."""
        if hasattr(self, 'notification_drawer'):
            if self.notification_drawer.isHidden():
                self.notification_drawer.show()
            self.notification_drawer.toggle()

    def create_separator(self):
        separator = QFrame()
        separator.setFrameShape(QFrame.VLine)
        separator.setFrameShadow(QFrame.Sunken)
        return separator

    def setup_date_combo(self):
        """Konfiguruje combobox z datami, uwzględniając uprawnienia."""
        self.date_combo.blockSignals(True)
        current_date = datetime.now()
        months_to_show = []
        year, month = current_date.year, current_date.month

        for i in range(3, 0, -1):
            prev_month, prev_year = (month - i, year)
            while prev_month <= 0:
                prev_month += 12
                prev_year -= 1
            months_to_show.append((prev_year, prev_month))

        months_to_show.append((year, month))

        if self.can_see_next_month:
            next_month, next_year = (month + 1, year)
            if next_month > 12:
                next_month = 1
                next_year += 1
            months_to_show.append((next_year, next_month))

        current_index = self.date_combo.currentIndex()
        if current_index == -1:
            current_index = 3

        self.date_combo.clear()
        for y, m in months_to_show:
            self.date_combo.addItem(f"{y}-{m:02d}", (y, m))

        self.date_combo.setCurrentIndex(min(current_index, self.date_combo.count() - 1))
        self.date_combo.blockSignals(False)

    def setup_middle_section(self, main_layout):
        """Tworzy środkową sekcję z filtrem i tabelami"""
        main_splitter = QSplitter(Qt.Horizontal)
        main_splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.setup_left_panel()
        right_panel = self.setup_right_panel()
        main_splitter.addWidget(self._left_panel)
        main_splitter.addWidget(right_panel)

        # Ustawienie rozmiarów początkowych
        main_splitter.setSizes([260, 1200])
        self.main_splitter = main_splitter

        self.main_splitter.setStretchFactor(0, 0)
        self.main_splitter.setStretchFactor(1, 1)

        return main_splitter

    def setup_left_panel(self):
        """Tworzy lewy panel z filtrami w sposób dynamiczny."""
        self._left_panel = QWidget()
        self._left_panel.setMinimumSize(0, 0)
        panel_main_layout = QVBoxLayout(self._left_panel)
        panel_main_layout.setContentsMargins(0, 0, 0, 5)
        panel_main_layout.setSpacing(5)

        # --- 1. SEKCJA GÓRNA: Zapisane Filtry (Statyczna) ---
        saved_filters_group = QGroupBox("Zapisane Filtry")
        saved_filters_layout = QHBoxLayout(saved_filters_group)
        saved_filters_layout.setContentsMargins(5, 10, 5, 5)

        self.saved_filters_combo = QComboBox()
        self.saved_filters_combo.setPlaceholderText("Wybierz/Zastosuj filtr...")
        self.saved_filters_combo.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.saved_filters_combo.activated.connect(self._load_selected_filter_set_from_combo)
        self.saved_filters_combo.currentIndexChanged.connect(self._update_delete_button_state)
        saved_filters_layout.addWidget(self.saved_filters_combo, 1)  # stretch = 1

        icon_buttons_layout = QHBoxLayout()
        icon_buttons_layout.setSpacing(2)
        icon_buttons_layout.setContentsMargins(0, 0, 0, 0)

        self.save_filter_button = QPushButton()
        try:
            icon_path = resource_path("icons/save.png")
            save_icon = QIcon(icon_path)
            if save_icon.isNull(): raise FileNotFoundError(f"Nie znaleziono pliku ikony: {icon_path}")
        except Exception as e:
            log_error(f"Błąd ładowania ikony zapisu: {e}")
            save_icon = self.style().standardIcon(QStyle.StandardPixmap.SP_DialogSaveButton)
        self.save_filter_button.setIcon(save_icon)
        self.save_filter_button.setFixedSize(28, 28)
        self.save_filter_button.setToolTip("Zapisz bieżący zestaw filtrów lub zaktualizuj wybrany...")
        self.save_filter_button.clicked.connect(self._handle_save_button_clicked)
        icon_buttons_layout.addWidget(self.save_filter_button)

        self.delete_filter_button = QPushButton()
        try:
            icon_path = resource_path("icons/delete.png")
            delete_icon = QIcon(icon_path)
            if delete_icon.isNull(): raise FileNotFoundError(f"Nie znaleziono pliku ikony: {icon_path}")
        except Exception as e:
            log_error(f"Błąd ładowania ikony kosza: {e}")
            delete_icon = self.style().standardIcon(QStyle.StandardPixmap.SP_TrashIcon)
        self.delete_filter_button.setIcon(delete_icon)
        self.delete_filter_button.setFixedSize(28, 28)
        self.delete_filter_button.setToolTip("Usuń wybrany zestaw filtrów")
        self.delete_filter_button.clicked.connect(self._delete_selected_filter_set)
        self.delete_filter_button.setEnabled(False)
        icon_buttons_layout.addWidget(self.delete_filter_button)

        self.edit_filter_button = QPushButton()
        try:
            icon_path = resource_path("icons/edit.png")
            edit_icon = QIcon(icon_path)
            if edit_icon.isNull():
                raise FileNotFoundError(f"Nie znaleziono pliku ikony: {icon_path}")
        except Exception as e:
            log_error(f"Błąd ładowania ikony 'edit.png': {e}. Używam ikony domyślnej.")
            edit_icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileDialogContentsView)
        self.edit_filter_button.setIcon(edit_icon)
        self.edit_filter_button.setFixedSize(28, 28)
        self.edit_filter_button.setToolTip("Zmień nazwę wybranego zestawu filtrów")
        self.edit_filter_button.clicked.connect(self._rename_selected_filter_set)
        self.edit_filter_button.setEnabled(False)
        icon_buttons_layout.addWidget(self.edit_filter_button)

        saved_filters_layout.addLayout(icon_buttons_layout, 0)  # stretch = 0

        panel_main_layout.addWidget(saved_filters_group)

        # --- 2. SEKCJA ŚRODKOWA: Dynamiczne filtry (w ScrollArea) ---
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.NoFrame)

        filter_container = QWidget()
        self.filters_layout = QVBoxLayout(filter_container)
        self.filters_layout.setContentsMargins(10, 0, 10, 10)
        self.filters_layout.setSpacing(6)
        filter_container.setMinimumWidth(240)

        # Krok 2a: Stwórz widgety dla filtrów statycznych
        self._create_all_filter_widgets(parent_widget=filter_container)

        # --- KLUCZOWA POPRAWKA ---
        # Krok 2b: Stwórz widgety dla filtrów niestandardowych (które zostały załadowane w __init__)
        # Ta metoda doda je do self.filter_widget_map
        self._synchronize_custom_filter_widgets()
        # --- KONIEC POPRAWKI ---

        # Krok 2c: Teraz pokaż wszystkie widgety (statyczne i niestandardowe), które są na liście widocznych
        self._apply_filter_visibility_and_order()

        scroll_area.setWidget(filter_container)
        panel_main_layout.addWidget(scroll_area)

        # --- 3. SEKCJA DOLNA: Przyciski (Statyczna) ---
        bottom_bar = QFrame()
        bottom_bar.setFrameShape(QFrame.NoFrame)
        bottom_bar.setFixedHeight(40)
        bottom_layout = QHBoxLayout(bottom_bar)
        bottom_layout.setContentsMargins(5, 0, 5, 0)

        self.clear_filters_button = QPushButton("Wyczyść filtry")
        self.clear_filters_button.clicked.connect(self.clear_filters)

        self.filter_settings_button = QPushButton()
        try:
            import os
            icon_path = resource_path("icons/settings.png")
            if not os.path.exists(icon_path):
                raise FileNotFoundError(f"Plik ikony nie istnieje: {icon_path}")

            settings_icon = QIcon(icon_path)
            if settings_icon.isNull():
                raise Exception(f"Nie można załadować pliku ikony (być może uszkodzony): {icon_path}")

        except Exception as e:
            log_error(f"Błąd ładowania ikony 'settings.png': {e}")
            settings_icon = self.style().standardIcon(QStyle.StandardPixmap.SP_FileDialogDetailedView)

        self.filter_settings_button.setIcon(settings_icon)
        self.filter_settings_button.setIconSize(QSize(20, 20))
        self.filter_settings_button.setFixedSize(28, 28)
        self.filter_settings_button.setToolTip("Ustawienia widoczności filtrów")
        self.filter_settings_button.clicked.connect(self.show_filter_select_dialog)

        bottom_layout.addWidget(self.clear_filters_button)
        bottom_layout.addStretch()
        bottom_layout.addWidget(self.filter_settings_button)

        panel_main_layout.addWidget(bottom_bar)

    def _update_saved_filters_combo(self):
        """Aktualizuje listę w QComboBox na podstawie zapisanych filtrów."""
        if not hasattr(self, 'saved_filters_combo'):
            return

        self.saved_filters_combo.blockSignals(True)
        current_text = self.saved_filters_combo.currentText()  # Zapamiętaj, co było wybrane
        self.saved_filters_combo.clear()
        self.saved_filters_combo.addItem("")  # Dodaj pustą opcję na początku
        saved_filters_names = sorted(self.user_app_settings.get('saved_filters', {}).keys())
        self.saved_filters_combo.addItems(saved_filters_names)

        # Spróbuj przywrócić poprzedni wybór
        index = self.saved_filters_combo.findText(current_text)
        if index != -1:
            self.saved_filters_combo.setCurrentIndex(index)
        else:
            self.saved_filters_combo.setCurrentIndex(0)  # Wybierz pustą opcję

        self.saved_filters_combo.blockSignals(False)
        self._update_delete_button_state()

    def _handle_save_button_clicked(self):
        """
        Inteligentnie obsługuje kliknięcie przycisku ZAPISZ.
        - Jeśli wybrano pustą pozycję -> tworzy NOWY filtr.
        - Jeśli wybrano istniejący filtr -> pyta o AKTUALIZACJĘ.
        """
        current_index = self.saved_filters_combo.currentIndex()
        filter_name = self.saved_filters_combo.currentText()
        current_state = self.get_current_filters_state()  # Pobierz aktualne ustawienia filtrów

        if current_index == 0 or not filter_name:
            # PRZYPADEK 1: Tworzenie nowego filtra (bo wybrano pustą pozycję)
            self._create_new_filter_set(current_state)
        else:
            # PRZYPADEK 2: Aktualizacja istniejącego filtra
            reply = QMessageBox.question(self, "Aktualizacja filtru",
                                         f"Czy na pewno chcesz zaktualizować (nadpisać)\nfiltr '{filter_name}' bieżącymi ustawieniami?",
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

            if reply == QMessageBox.Yes:
                self.user_app_settings['saved_filters'][filter_name] = current_state
                self.settings_db.save_settings(self.user_app_settings)  # Zapisz w bazie
                QMessageBox.information(self, "Zaktualizowano",
                                        f"Zestaw filtrów '{filter_name}' został zaktualizowany.")
                # Nie ma potrzeby odświeżać combo, bo nazwy się nie zmieniły

    def _create_new_filter_set(self, current_state: dict):
        """
        Pomocnicza funkcja do tworzenia nowego zestawu filtrów.
        (Wydzielona z logiki `_save_current_filter_set` z poprzedniej odpowiedzi)
        """
        from PySide6.QtWidgets import QInputDialog, QLineEdit

        filter_name, ok = QInputDialog.getText(self, "Zapisz nowy zestaw filtrów",
                                               "Podaj nazwę dla tego zestawu filtrów:",
                                               QLineEdit.Normal, "")
        if ok and filter_name:
            filter_name = filter_name.strip()
            if not filter_name:
                QMessageBox.warning(self, "Błędna nazwa", "Nazwa filtra nie może być pusta.")
                return

            saved_filters = self.user_app_settings.get('saved_filters', {})

            if filter_name in saved_filters:
                QMessageBox.warning(self, "Nazwa istnieje",
                                    f"Filtr o nazwie '{filter_name}' już istnieje.\nJeśli chcesz go zaktualizować, wybierz go z listy i kliknij 'Zapisz'.")
                return

            saved_filters[filter_name] = current_state
            self.user_app_settings['saved_filters'] = saved_filters
            self.settings_db.save_settings(self.user_app_settings)
            self._update_saved_filters_combo()  # Odśwież listę
            self.saved_filters_combo.setCurrentText(filter_name)  # Ustaw nowo zapisaną nazwę
            QMessageBox.information(self, "Zapisano", f"Zestaw filtrów '{filter_name}' został zapisany.")
        elif ok and not filter_name:
            QMessageBox.warning(self, "Błędna nazwa", "Nazwa filtra nie może być pusta.")

    def _delete_selected_filter_set(self):
        """Usuwa aktualnie wybrany zestaw filtrów."""
        filter_name = self.saved_filters_combo.currentText()

        # Przycisk powinien być nieaktywny, ale to dodatkowe zabezpieczenie
        if not filter_name:
            return

        reply = QMessageBox.question(self, "Usuwanie filtra",
                                     f"Czy na pewno chcesz usunąć zapisany filtr:\n'{filter_name}'?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            try:
                del self.user_app_settings['saved_filters'][filter_name]
                self.settings_db.save_settings(self.user_app_settings)  # Zapisz zmiany w bazie
                self._update_saved_filters_combo()  # Odśwież listę w comboboxie
                QMessageBox.information(self, "Usunięto", f"Zestaw filtrów '{filter_name}' został usunięty.")
            except KeyError:
                log_error(f"Próba usunięcia filtra '{filter_name}', który nie istnieje w 'saved_filters'.")
                QMessageBox.warning(self, "Błąd", "Nie można było usunąć wybranego filtra.")
            except Exception as e:
                log_error(f"Błąd podczas usuwania filtra: {e}", exception=e)
                QMessageBox.critical(self, "Błąd", f"Wystąpił nieoczekiwany błąd: {e}")

    def _rename_selected_filter_set(self):
        """
        Otwiera dialog do zmiany nazwy aktualnie wybranego zestawu filtrów.
        """
        current_name = self.saved_filters_combo.currentText()
        current_index = self.saved_filters_combo.currentIndex()

        # Zabezpieczenie, choć przycisk powinien być nieaktywny
        if not current_name or current_index == 0:
            return

        new_name, ok = QInputDialog.getText(self, "Zmień nazwę zestawu filtrów",
                                            "Wprowadź nową nazwę dla filtra:",
                                            QLineEdit.Normal, current_name)

        if not ok or not new_name:
            return  # Użytkownik anulował

        new_name = new_name.strip()

        if not new_name:
            QMessageBox.warning(self, "Błędna nazwa", "Nazwa filtra nie może być pusta.")
            return

        if new_name == current_name:
            return  # Nazwa się nie zmieniła

        saved_filters = self.user_app_settings.get('saved_filters', {})

        if new_name in saved_filters:
            QMessageBox.warning(self, "Nazwa istnieje",
                                f"Filtr o nazwie '{new_name}' już istnieje. Wybierz inną nazwę.")
            return

        try:
            # Zmień nazwę klucza w słowniku
            content = saved_filters.pop(current_name)
            saved_filters[new_name] = content

            self.user_app_settings['saved_filters'] = saved_filters
            self.settings_db.save_settings(self.user_app_settings)  # Zapisz w bazie

            # Odśwież UI
            self._update_saved_filters_combo()
            self.saved_filters_combo.setCurrentText(new_name)  # Ustaw nową nazwę

            QMessageBox.information(self, "Sukces",
                                    f"Nazwa filtra została zmieniona z '{current_name}' na '{new_name}'.")

        except KeyError:
            log_error(f"Próba zmiany nazwy filtra '{current_name}', który nie istnieje w 'saved_filters'.")
            QMessageBox.warning(self, "Błąd", "Nie można było zmienić nazwy. Filtr nie został znaleziony.")
        except Exception as e:
            log_error(f"Błąd podczas zmiany nazwy filtra: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił nieoczekiwany błąd: {e}")

    # --- KONIEC NOWEJ METODY ---

    def _update_delete_button_state(self, index=None):
        """
        Włącza lub wyłącza przyciski 'Usuń' i 'Edytuj' w zależności
        od wyboru w ComboBox.
        """
        # (Domyślny argument 'index' jest potrzebny, gdy metoda jest podłączona do sygnału)
        is_filter_selected = self.saved_filters_combo.currentIndex() > 0

        if hasattr(self, 'delete_filter_button'):
            self.delete_filter_button.setEnabled(is_filter_selected)

        # --- POCZĄTEK POPRAWKI ---
        if hasattr(self, 'edit_filter_button'):
            self.edit_filter_button.setEnabled(is_filter_selected)
        # --- KONIEC POPRAWKI ---

    def _load_selected_filter_set(self):
        """Wczytuje zestaw filtrów wybrany w QComboBox."""
        filter_name = self.saved_filters_combo.currentText()
        if not filter_name:
            QMessageBox.information(self, "Informacja", "Wybierz zapisany zestaw filtrów z listy.")
            return

        saved_filters = self.user_app_settings.get('saved_filters', {})
        filter_state = saved_filters.get(filter_name)

        if filter_state:
            debug_print(f"Wczytywanie zestawu filtrów: '{filter_name}'")
            self.restore_filters_state(filter_state)  # Ta funkcja powinna wywołać filter_data() na końcu
            QMessageBox.information(self, "Wczytano", f"Zastosowano zapisany zestaw filtrów '{filter_name}'.")
        else:
            QMessageBox.warning(self, "Błąd", f"Nie znaleziono zapisanego stanu dla filtra '{filter_name}'.")

    def _load_selected_filter_set_from_combo(self, index):
        """Wczytuje zestaw filtrów po wybraniu go z QComboBox (ignoruje index 0)."""
        if index == 0:  # Ignoruj pustą opcję
            self._update_delete_button_state()
            # Można opcjonalnie wyczyścić filtry po wybraniu pustej opcji:
            # self.clear_filters()
            # self.saved_filters_combo.setCurrentIndex(0) # Upewnij się, że pusta opcja jest wybrana
            return

        filter_name = self.saved_filters_combo.itemText(index)  # Pobierz tekst wybranego elementu

        saved_filters = self.user_app_settings.get('saved_filters', {})
        filter_state = saved_filters.get(filter_name)

        if filter_state:
            debug_print(f"Automatyczne wczytywanie zestawu filtrów: '{filter_name}'")
            self.restore_filters_state(filter_state)  # Ta funkcja powinna wywołać filter_data()
            # Nie pokazujemy QMessageBox, bo akcja jest automatyczna
        else:
            # Ten błąd nie powinien wystąpić, ale zostawiamy jako zabezpieczenie
            log_error(f"Nie znaleziono zapisanego stanu dla filtra '{filter_name}' wybranego z combo.")
            self.saved_filters_combo.setCurrentIndex(0)  # Wróć do pustej opcji w razie błędu

    def _create_clear_icon(self, color: QColor) -> QIcon:
        """Tworzy ikonę 'X' o zadanym kolorze."""
        pixmap = QPixmap(16, 16)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        pen = QPen(color, 2)
        painter.setPen(pen)
        painter.drawLine(4, 4, 12, 12)
        painter.drawLine(4, 12, 12, 4)
        painter.end()
        return QIcon(pixmap)

    # --- NOWA METODA: Tworzenie ikony ustawień ---
    def _create_settings_icon(self, color: QColor) -> QIcon:
        """Tworzy ikonę 'koła zębatego' o zadanym kolorze."""
        pixmap = QPixmap(16, 16)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)

        # Użyjemy prostego symbolu, np. trzech kropek lub gwiazdki
        # Pełne koło zębate jest trudne do narysowania w ten sposób
        # Zróbmy prosty kwadrat z kropką w środku jako "ustawienia"
        pen = QPen(color, 2)
        painter.setPen(pen)
        painter.drawRect(3, 3, 10, 10)  # Ramka
        painter.setBrush(color)
        painter.drawEllipse(6, 6, 4, 4)  # Kropka w środku

        painter.end()
        return QIcon(pixmap)

    # --- MODYFIKACJA: Funkcje pomocnicze zwracają teraz layout ---

    def add_horizontal_filter(self, label_text, combo_name):
        """
        MODYFIKACJA: Tworzy layout filtra, ale go NIE dodaje.
        Zwraca (QHBoxLayout, QComboBox, QPushButton)
        """
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)
        filter_layout.setSpacing(4)

        filter_label = QLabel(label_text)
        filter_label.setFixedWidth(75)
        filter_layout.addWidget(filter_label)

        combo = CustomMultiComboBox()
        combo.setFixedHeight(24)
        combo.view().setMaximumWidth(240)
        combo.selection_changed.connect(self.filter_data)
        setattr(self, combo_name, combo)

        # ZMIANA: Dodajemy kontrolkę z priorytetem rozciągania (stretch=1)
        filter_layout.addWidget(combo, 1)

        clear_button = QPushButton()
        icon = self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light
        clear_button.setIcon(icon)
        clear_button.setObjectName("FilterClearButton")
        clear_button.setFixedSize(22, 22)
        clear_button.setToolTip(f"Wyczyść filtr '{label_text}'")
        clear_button.setFlat(True)
        clear_button.clicked.connect(lambda: combo.clear_selection())

        # ZMIANA: Dodajemy przycisk bez priorytetu rozciągania (stretch=0)
        filter_layout.addWidget(clear_button, 0)

        return (filter_layout, combo, clear_button)

    def add_horizontal_search_filter(self, label_text, filter_name, list_widget_to_clear=None):
        """
        MODYFIKACJA: Tworzy layout filtra, ale go NIE dodaje.
        Zwraca (QHBoxLayout, QLineEdit, QPushButton)
        """
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)
        filter_layout.setSpacing(4)

        filter_label = QLabel(label_text)
        filter_label.setFixedWidth(75)
        filter_layout.addWidget(filter_label)

        text_edit = QLineEdit()
        text_edit.setPlaceholderText(f"Filtruj {label_text.lower()[:-1]}...")
        text_edit.setFixedHeight(24)
        setattr(self, filter_name, text_edit)

        # ZMIANA: Dodajemy kontrolkę z priorytetem rozciągania (stretch=1)
        filter_layout.addWidget(text_edit, 1)

        clear_button = QPushButton()
        icon = self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light
        clear_button.setIcon(icon)
        clear_button.setObjectName("FilterClearButton")
        clear_button.setFixedSize(22, 22)
        clear_button.setToolTip(f"Wyczyść filtr '{label_text}'")
        clear_button.setFlat(True)

        def clear_action():
            text_edit.blockSignals(True)
            if list_widget_to_clear: list_widget_to_clear.blockSignals(True)
            text_edit.clear()
            if list_widget_to_clear: list_widget_to_clear.clearSelection()
            text_edit.blockSignals(False)
            if list_widget_to_clear: list_widget_to_clear.blockSignals(False)
            self.filter_data()

        clear_button.clicked.connect(clear_action)

        # ZMIANA: Dodajemy przycisk bez priorytetu rozciągania (stretch=0)
        filter_layout.addWidget(clear_button, 0)

        return (filter_layout, text_edit, clear_button)

    def _create_all_filter_widgets(self, parent_widget=None):
        """
        Tworzy instancje wszystkich widgetów filtrów i przechowuje je
        w self.filter_widget_map.

        Args:
            parent_widget (QWidget): Widget nadrzędny (filter_container),
                                     który zapobiega "migotaniu" okien.
        """
        self.filter_widget_map = {}

        # --- LOGOWANIE ---
        # debug_print(f"[Filtracja] _create_all_filter_widgets otrzymał rodzica: {parent_widget}")
        # --- KONIEC LOGOWANIA ---

        # --- Filtr Obecności ---
        presence_group = QGroupBox("Obecni w pracy w dniu:", parent=parent_widget)
        presence_group.setCheckable(True)
        presence_group.setChecked(False)
        self.filter_by_presence_check = presence_group
        presence_layout = QGridLayout(presence_group)
        presence_layout.setContentsMargins(5, 10, 5, 5)
        self.presence_date_edit = QDateEdit(QDate.currentDate(), parent=presence_group)  # Ustawiamy rodzica
        self.presence_date_edit.setCalendarPopup(True)
        self.presence_date_edit.setDisplayFormat("dd.MM.yyyy")
        self.presence_location_combo = CustomMultiComboBox(parent=presence_group)  # Ustawiamy rodzica
        self.presence_location_combo.add_items(["Home Office (h)", "SBC (s)", "Przystanek (p)", "Bez lokalizacji"])
        self.presence_hour_combo = CustomMultiComboBox(parent=presence_group)  # Ustawiamy rodzica
        self.presence_hour_combo.add_items([f"{h:02d}:00" for h in range(24)])
        presence_layout.addWidget(QLabel("Data:"), 0, 0)
        presence_layout.addWidget(self.presence_date_edit, 0, 1)
        presence_layout.addWidget(QLabel("Lokalizacja:"), 1, 0)
        presence_layout.addWidget(self.presence_location_combo, 1, 1)
        presence_layout.addWidget(QLabel("Godzina:"), 2, 0)
        presence_layout.addWidget(self.presence_hour_combo, 2, 1)
        self.filter_by_presence_check.toggled.connect(self.filter_data)
        self.filter_by_presence_check.toggled.connect(
            lambda checked: self._handle_exclusive_filters(checked, 'presence'))
        self.presence_date_edit.dateChanged.connect(self.filter_data)
        self.presence_location_combo.selection_changed.connect(self.filter_data)
        self.presence_hour_combo.selection_changed.connect(self.filter_data)

        presence_group.setVisible(False)
        self.filter_widget_map['presence'] = presence_group

        absence_group = QGroupBox("Nieobecni w pracy w dniu:", parent=parent_widget)
        absence_group.setCheckable(True)
        absence_group.setChecked(False)
        self.filter_by_absence_check = absence_group

        absence_layout = QGridLayout(absence_group)
        absence_layout.setContentsMargins(5, 10, 5, 5)

        self.absence_date_edit = QDateEdit(QDate.currentDate(), parent=absence_group)
        self.absence_date_edit.setCalendarPopup(True)
        self.absence_date_edit.setDisplayFormat("dd.MM.yyyy")

        # Combo dla symboli (będzie wypełniane dynamicznie)
        self.absence_symbol_combo = CustomMultiComboBox(parent=absence_group)

        # Combo dla godzin (00-23)
        self.absence_hour_combo = CustomMultiComboBox(parent=absence_group)
        self.absence_hour_combo.add_items([f"{h:02d}:00" for h in range(24)])

        absence_layout.addWidget(QLabel("Data:"), 0, 0)
        absence_layout.addWidget(self.absence_date_edit, 0, 1)
        absence_layout.addWidget(QLabel("Symbol:"), 1, 0)
        absence_layout.addWidget(self.absence_symbol_combo, 1, 1)
        absence_layout.addWidget(QLabel("Godzina rozp.:"), 2, 0)
        absence_layout.addWidget(self.absence_hour_combo, 2, 1)

        # Podłączenie sygnałów
        self.filter_by_absence_check.toggled.connect(self.filter_data)
        self.filter_by_absence_check.toggled.connect(
            lambda checked: self._handle_exclusive_filters(checked, 'absence'))
        self.absence_date_edit.dateChanged.connect(self.filter_data)
        self.absence_symbol_combo.selection_changed.connect(self.filter_data)
        self.absence_hour_combo.selection_changed.connect(self.filter_data)

        absence_group.setVisible(False)
        self.filter_widget_map['absence'] = absence_group

        # --- Separator ---
        separator = QFrame(parent=parent_widget)
        separator.setFrameShape(QFrame.HLine)
        separator.setFrameShadow(QFrame.Sunken)

        separator.setVisible(False)
        self.filter_widget_map['separator1'] = separator
        # debug_print(
        #     f"[Filtracja] Stworzono widget 'separator1'. Rodzic: {separator.parent()}, Widoczny: {separator.isVisible()}")

        # --- Pozostałe filtry ---
        filter_definitions = [
            ("Grupa:", "grupa_main_filter_combo", "grupa"),
            ("Wydział:", "wydzial_combo", "wydzial"),
            ("LD:", "default_location_combo", "default_location"),
            ("System Pracy:", "system_czasu_pracy_combo", "system_czasu_pracy"),
            ("Rola:", "rola_combo", "rola"),
            ("PodRola:", "podrola_combo", "podrola"),
            ("Język:", "jezyk_combo", "jezyk"),
            ("Etat:", "etat_combo", "etat"),
            ("DTN:", "dtn_combo", "dtn"),
            ("Rka:", "rka_combo", "rka"),
            ("Grafik za pkt:", "grafik_za_punkty_combo", "sched_grafik_za_punkty"),
            ("Brak nocki:", "brak_nocki_combo", "sched_brak_nocki")
        ]

        for label, combo_name, f_id in filter_definitions:
            # add_horizontal_filter tworzy layout i widgety.
            # Ważne, żeby te widgety (combo, btn) miały rodzica.
            layout, combo, btn = self.add_horizontal_filter(label, combo_name)

            # Tworzymy widget-kontener z właściwym rodzicem
            container_widget = QWidget(parent=parent_widget)

            # Przypisujemy rodzica (container_widget) do elementów layoutu
            # To jest kluczowe, aby combo i btn nie były osierocone
            combo.setParent(container_widget)
            btn.setParent(container_widget)
            # Label jest już w layout, ale jego rodzicem też staje się container_widget
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if item and item.widget():
                    item.widget().setParent(container_widget)

            container_widget.setLayout(layout)
            container_widget.setVisible(False)
            self.filter_widget_map[f_id] = container_widget
            # debug_print(
            #     f"[Filtracja] Stworzono widget '{f_id}'. Rodzic: {container_widget.parent()}, Widoczny: {container_widget.isVisible()}")

        # --- Filtry złożone (Wyszukiwanie + Lista) ---

        # Przełożony
        przelozony_widget = QWidget(parent=parent_widget)
        przelozony_v_layout = QVBoxLayout(przelozony_widget)
        przelozony_v_layout.setContentsMargins(0, 0, 0, 0)
        przelozony_v_layout.setSpacing(4)

        # Tworzymy listę z właściwym rodzicem
        self.przelozony_list = QListWidget(parent=przelozony_widget)
        self.przelozony_list.setMaximumHeight(150)

        # Tworzymy elementy wyszukiwania
        search_layout, self.przelozony_filter, clear_btn = self.add_horizontal_search_filter("Przełożony:",
                                                                                             "przelozony_filter",
                                                                                             list_widget_to_clear=self.przelozony_list)

        # Ustawiamy rodziców dla elementów z search_layout
        self.przelozony_filter.setParent(przelozony_widget)
        clear_btn.setParent(przelozony_widget)
        for i in range(search_layout.count()):
            item = search_layout.itemAt(i)
            if item and item.widget():
                item.widget().setParent(przelozony_widget)

        przelozony_v_layout.addLayout(search_layout)

        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)
        przelozony_v_layout.addWidget(self.przelozony_list)

        przelozony_widget.setVisible(False)
        self.filter_widget_map['przelozony'] = przelozony_widget
        # debug_print(
        #     f"[Filtracja] Stworzono widget 'przelozony'. Rodzic: {przelozony_widget.parent()}, Widoczny: {przelozony_widget.isVisible()}")

        # Użytkownik
        uzytkownik_widget = QWidget(parent=parent_widget)
        uzytkownik_v_layout = QVBoxLayout(uzytkownik_widget)
        uzytkownik_v_layout.setContentsMargins(0, 0, 0, 0)
        uzytkownik_v_layout.setSpacing(4)

        self.uzytkownik_list = QListWidget(parent=uzytkownik_widget)
        self.uzytkownik_list.setMaximumHeight(150)

        search_layout, self.uzytkownik_filter, clear_btn = self.add_horizontal_search_filter("Użytkownik:",
                                                                                             "uzytkownik_filter",
                                                                                             list_widget_to_clear=self.uzytkownik_list)

        # Ustawiamy rodziców dla elementów z search_layout
        self.uzytkownik_filter.setParent(uzytkownik_widget)
        clear_btn.setParent(uzytkownik_widget)
        for i in range(search_layout.count()):
            item = search_layout.itemAt(i)
            if item and item.widget():
                item.widget().setParent(uzytkownik_widget)

        uzytkownik_v_layout.addLayout(search_layout)

        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)
        uzytkownik_v_layout.addWidget(self.uzytkownik_list)

        uzytkownik_widget.setVisible(False)
        self.filter_widget_map['uzytkownik'] = uzytkownik_widget
        # debug_print(
        #     f"[Filtracja] Stworzono widget 'uzytkownik'. Rodzic: {uzytkownik_widget.parent()}, Widoczny: {uzytkownik_widget.isVisible()}")

    # --- NOWA METODA: Dynamicznie buduje layout filtrów ---
    def _apply_filter_visibility_and_order(self):
        """
        Czyści layout filtrów i buduje go na nowo na podstawie
        self.visible_filters_list, używając widgetów z self.filter_widget_map.
        """
        if not hasattr(self, 'filters_layout') or not hasattr(self, 'filter_widget_map'):
            # debug_print("[Filtracja] Przerwano _apply_filter_visibility_and_order: brak layoutu lub mapy.")
            return

        # --- LOGOWANIE ---
        # debug_print("[Filtracja] Rozpoczynam przebudowę layoutu filtrów...")
        # --- KONIEC LOGOWANIA ---

        # Wyczyść stary layout
        while self.filters_layout.count():
            item = self.filters_layout.takeAt(0)
            widget = item.widget()
            if widget:
                # Ważne: tylko ukrywamy widget, nie usuwamy go!
                widget.setVisible(False)
                # USUWAMY TĘ LINIĘ:
                # widget.setParent(None) # Już nie musimy usuwać rodzica

                # --- LOGOWANIE ---
                # debug_print(
                #     f"[Filtracja] Usuwam z layoutu i ukrywam: {widget.objectName() or widget.__class__.__name__}")
                # --- KONIEC LOGOWANIA ---

        # Dodaj widgety w nowej kolejności
        for filter_id in self.visible_filters_list:
            widget = self.filter_widget_map.get(filter_id)
            if widget:
                # --- LOGOWANIE ---
                # debug_print(f"[Filtracja] Dodaję do layoutu: {filter_id} (Rodzic: {widget.parent()})")
                # --- KONIEC LOGOWANIA ---

                # NAJPIERW dodaj do layoutu
                self.filters_layout.addWidget(widget)
                # DOPIERO TERAZ uczyń widocznym
                widget.setVisible(True)

        self.filters_layout.addStretch()

    def _handle_exclusive_filters(self, checked, filter_type):
        """Zapewnia, że filtry Obecni/Nieobecni nie są włączone jednocześnie."""
        if not checked:
            return

        if filter_type == 'presence':
            if self.filter_by_absence_check.isChecked():
                self.filter_by_absence_check.blockSignals(True)
                self.filter_by_absence_check.setChecked(False)
                self.filter_by_absence_check.blockSignals(False)
        elif filter_type == 'absence':
            if self.filter_by_presence_check.isChecked():
                self.filter_by_presence_check.blockSignals(True)
                self.filter_by_presence_check.setChecked(False)
                self.filter_by_presence_check.blockSignals(False)



    def show_filter_select_dialog(self):
        """Wyświetla dialog do zarządzania widocznością i kolejnością filtrów."""

        # Stwórz listę widocznych ID na podstawie aktualnego stanu
        current_visible_ids = self.visible_filters_list

        # --- NOWY KOD: Budowanie dynamicznej listy dostępnych filtrów ---
        # 1. Zacznij od filtrów statycznych
        available_filters_dynamic = self.ALL_FILTERS.copy()

        # 2. Dodaj filtry dla kolumn niestandardowych
        # Upewnij się, że widgety dla nich istnieją
        self._synchronize_custom_filter_widgets()

        for col_id, data in self.custom_columns.items():
            # (filter_id, display_name, is_locked)
            available_filters_dynamic.append((
                col_id,
                f"{data.get('name', col_id)} (Własna)",  # Użyj nazwy kolumny
                False  # Kolumny niestandardowe nie są blokowane
            ))
        # --- KONIEC NOWEGO KODU ---

        dialog = FilterSelectDialog(
            self,
            available_filters=available_filters_dynamic,  # Użyj listy dynamicznej
            visible_filters=current_visible_ids
        )

        if dialog.exec() == QDialog.Accepted:
            new_visible_list = dialog.get_visible_filters_ordered()

            # Zapisz zmiany
            self.visible_filters_list = new_visible_list
            self.user_app_settings['visible_filters'] = new_visible_list
            self.settings_db.save_settings(self.user_app_settings)

            # Przebuduj layout
            self._apply_filter_visibility_and_order()

    def load_initial_data(self):
        """Uruchamia proces ładowania danych i jednorazowo aplikuje zapisane sortowanie."""
        debug_print("Uruchamianie leniwego ładowania danych początkowych...")
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            # Tworzymy jednorazową funkcję obsługi, aby zastosować sortowanie po załadowaniu danych
            def initial_load_handler(data):
                # Najpierw standardowo zastosuj dane
                self._on_async_data_loaded(data)
                # A następnie, tylko ten jeden raz, zastosuj zapisane sortowanie
                self.apply_custom_sort()
                # Odłącz ten handler, aby nie został ponownie wywołany
                if hasattr(self, 'loading_dialog') and self.loading_dialog:
                    try:
                        self.loading_dialog.loading_completed.disconnect(initial_load_handler)
                    except (TypeError, RuntimeError):
                        pass  # Ignoruj błąd, jeśli sygnał był już odłączony

            # Rozpocznij asynchroniczne ładowanie
            self.update_data(year, month, self.import_grupa, self.import_funkcja, use_async=True)

            # Podłącz nasz jednorazowy handler do sygnału zakończenia ładowania
            if hasattr(self, 'loading_dialog') and self.loading_dialog:
                self.loading_dialog.loading_completed.connect(initial_load_handler)

            self.update_filter_dates()

    def setup_right_panel(self):
        """Tworzy prawy panel z tabelami"""
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)
        right_splitter = QSplitter(Qt.Vertical)
        schedule_frame = self.setup_schedule_section()
        events_frame = self.setup_events_section()
        right_splitter.addWidget(schedule_frame)
        right_splitter.addWidget(events_frame)
        right_splitter.setSizes([650, 350])
        right_layout.addWidget(right_splitter)
        return right_panel

    def setup_schedule_section(self):
        """Tworzy sekcję grafiku (górna część prawego panelu) używając SplitTableView."""
        schedule_frame = QFrame()
        schedule_layout = QVBoxLayout(schedule_frame)
        schedule_layout.setContentsMargins(5, 5, 5, 5)

        self.table = SplitTableView()
        schedule_layout.addWidget(self.table)

        # Tworzymy przycisk i kontener na pozostałe przyciski
        self.manage_columns_button = QPushButton("Dostosuj widok")
        button_frame = self.setup_schedule_buttons()
        button_layout = button_frame.layout()

        # Wstawiamy przycisk zarządzania kolumnami na początek layoutu z przyciskami
        if isinstance(button_layout, QHBoxLayout):
            button_layout.insertWidget(0, self.manage_columns_button)

        # --- POCZĄTEK POPRAWKI ---
        # Dodajemy kontener z WSZYSTKIMI przyciskami do layoutu sekcji grafiku - TYLKO RAZ.
        # Usunięto zduplikowaną linię, która powodowała błąd.
        schedule_layout.addWidget(button_frame)
        # --- KONIEC POPRAWKI ---

        return schedule_frame

    def setup_schedule_buttons(self):
        """Tworzy przyciski akcji dla sekcji grafiku"""
        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setContentsMargins(0, 0, 0, 0)
        button_frame.setFixedHeight(40)
        button_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.toggle_events_panel_button = QPushButton("Ukryj zdarzenia↓")
        self.toggle_events_panel_button.setToolTip("Ukryj panel zdarzeń (dla większego widoku grafiku) (F2)")
        self.toggle_events_panel_button.clicked.connect(self.toggle_events_panel)
        self.location_exception_button = QPushButton("Wyjątki lokalizacyjne")
        self.location_exception_button.setToolTip("Zarządzaj wyjątkami od domyślnej lokalizacji pracy")
        self.location_exception_button.clicked.connect(self.show_location_exception_dialog)
        button_layout.addWidget(self.location_exception_button)
        button_layout.addStretch()
        self.insert_change_button = QPushButton("Wstaw zmianę")
        self.insert_change_button.setToolTip("Wstaw zmianę grafiku (F3)")
        self.insert_change_button.clicked.connect(self.show_insert_change_dialog)
        button_layout.addWidget(self.insert_change_button)
        self.insert_symbol_button = QPushButton("Wstaw nieobecność")
        self.insert_symbol_button.setToolTip("Wstaw nieobecność (F4)")
        self.insert_symbol_button.clicked.connect(self.show_insert_symbol_dialog)
        button_layout.addWidget(self.insert_symbol_button)
        self.cancel_delegation_button = QPushButton("Odwołaj delegacje")
        self.cancel_delegation_button.setToolTip("Odwołaj delegacje dla zaznaczonych komórek (F5)")
        self.cancel_delegation_button.clicked.connect(lambda: self.cancel_delegations())
        button_layout.addWidget(self.cancel_delegation_button)
        self.add_overtime_button = QPushButton("Dodaj nadgodziny")
        # self.add_overtime_button.setShortcut("Insert")
        self.add_overtime_button.setToolTip("Dodaj nadgodziny dla zaznaczonych komórek (Insert)")
        self.add_overtime_button.clicked.connect(self.show_add_overtime_dialog)
        button_layout.addWidget(self.add_overtime_button)
        # Usunięto redundantny warunek, widoczność jest zarządzana przez update_buttons_visibility
        return button_frame

    def setup_events_section(self):
        """Tworzy sekcję zdarzeń używając QTableView i od razu konfiguruje jej kolumny."""
        events_frame = QFrame()
        events_frame.setFrameShape(QFrame.Shape.StyledPanel)
        events_frame.setFrameShadow(QFrame.Shadow.Raised)
        events_layout = QVBoxLayout(events_frame)
        events_layout.setContentsMargins(5, 5, 5, 5)

        filters_frame = self.setup_events_filters()
        events_layout.addWidget(filters_frame)

        self.events_table = QTableView()
        self.events_table.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.events_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.events_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)

        events_layout.addWidget(self.events_table)
        return events_frame

    def setup_events_filters(self):
        """Konfiguruje filtry dla tabeli zdarzeń w jednej linii."""
        events_filter_frame = QFrame()
        # ZMIANA: Powrót do układu poziomego
        events_filter_layout = QHBoxLayout(events_filter_frame)
        events_filter_layout.setContentsMargins(0, 5, 0, 5)

        # Filtry daty od-do z przywróconym kalendarzem
        self.date_from = QDateEdit(QDate.currentDate().addDays(-30))
        self.date_from.setCalendarPopup(True)  # POPRAWKA: Przywrócenie kalendarza
        self.date_to = QDateEdit(QDate.currentDate())
        self.date_to.setCalendarPopup(True)  # POPRAWKA: Przywrócenie kalendarza

        # Filtry tekstowe i statusu
        self.topic_filter = QLineEdit()
        self.topic_filter.setPlaceholderText("Filtruj po temacie...")
        self.name_filter = QLineEdit()
        self.name_filter.setPlaceholderText("Filtruj po nazwie...")
        self.status_filter_combo = CustomMultiComboBox()
        self.status_filter_combo.setMinimumWidth(130)

        # Checkboxy
        self.meetings_checkbox = QCheckBox("Spotkania")
        self.trainings_checkbox = QCheckBox("Szkolenia")
        self.overtime_checkbox = QCheckBox("Nadgodziny")
        self.meetings_checkbox.setChecked(True)
        self.trainings_checkbox.setChecked(True)
        self.overtime_checkbox.setChecked(True)

        # Dodanie wszystkich kontrolek do layoutu w poprawnej kolejności
        events_filter_layout.addWidget(QLabel("Data od:"))
        events_filter_layout.addWidget(self.date_from)
        events_filter_layout.addWidget(QLabel("Data do:"))
        events_filter_layout.addWidget(self.date_to)
        events_filter_layout.addWidget(QLabel("Temat:"))
        events_filter_layout.addWidget(self.topic_filter)
        events_filter_layout.addWidget(QLabel("Nazwa:"))
        events_filter_layout.addWidget(self.name_filter)
        events_filter_layout.addWidget(QLabel("Status:"))
        events_filter_layout.addWidget(self.status_filter_combo)

        events_filter_layout.addStretch()  # Wypełniacz, aby odsunąć checkboxy na prawo

        events_filter_layout.addWidget(self.meetings_checkbox)
        events_filter_layout.addWidget(self.trainings_checkbox)
        events_filter_layout.addWidget(self.overtime_checkbox)

        # Połączenie sygnałów (bez zmian)
        self.date_from.dateChanged.connect(self.filter_events_table)
        self.date_to.dateChanged.connect(self.filter_events_table)
        self.topic_filter.textChanged.connect(self.filter_events_table)
        self.name_filter.textChanged.connect(self.filter_events_table)
        self.meetings_checkbox.stateChanged.connect(self.filter_events_table)
        self.trainings_checkbox.stateChanged.connect(self.filter_events_table)
        self.overtime_checkbox.stateChanged.connect(self.filter_events_table)
        self.status_filter_combo.selection_changed.connect(self.filter_events_table)

        return events_filter_frame

    def setup_events_table_columns(self):
        """
        Konfiguruje kolumny dla tabeli zdarzeń.
        Strategia: Globalne minimum dopasowane do najwęższych kolumn,
        a Temat i Nazwa wypełniają resztę miejsca.
        """
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        header = self.events_table.horizontalHeader()

        # --- WAŻNE: Globalne minimum ---
        # Ustawiamy 35px, żeby kolumny "Id" czy "Akcje" nie były sztucznie szerokie.
        # Kolumny "Stretch" (Temat, Nazwa) i tak będą dążyć do bycia jak największymi.
        header.setMinimumSectionSize(35)

        # Wyłączamy automatyczne rozciąganie ostatniej sekcji, bo sterujemy tym ręcznie
        header.setStretchLastSection(False)

        # 0. Id - Dopasuj do zawartości (jest krótka)
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)

        # 1. Typ - Dopasuj do zawartości (np. "Szkolenie")
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)

        # 2. Temat - ROZCIĄGLIWY (Priorytet 1)
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)

        # 3. Nazwa - ROZCIĄGLIWY (Priorytet 1)
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.Stretch)

        # 4. Użytkownik - Interaktywny (można zmieniać rozmiar)
        header.setSectionResizeMode(4, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(4, 160)

        # 5. Data - Dopasuj do zawartości
        header.setSectionResizeMode(5, QHeaderView.ResizeMode.ResizeToContents)

        # 6. Czas od - Dopasuj do zawartości
        header.setSectionResizeMode(6, QHeaderView.ResizeMode.ResizeToContents)

        # 7. Czas do - Dopasuj do zawartości
        header.setSectionResizeMode(7, QHeaderView.ResizeMode.ResizeToContents)

        # 8. Status - Dopasuj do zawartości
        header.setSectionResizeMode(8, QHeaderView.ResizeMode.ResizeToContents)

        # 9. Data Modyfikacji - Interaktywny
        header.setSectionResizeMode(9, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(9, 110)

        # 10. Akcje - Stała szerokość
        header.setSectionResizeMode(10, QHeaderView.ResizeMode.Fixed)
        self.events_table.setColumnWidth(10, 85)

    def setup_table_properties(self):
        """Konfiguruje właściwości tabel i tworzy delegatów z ustawieniami."""
        self.events_table.setSortingEnabled(True)

        if hasattr(self, 'table') and hasattr(self.table, 'employees_view'):
            self.table.employees_view.setSortingEnabled(True)

            # --- NOWOŚĆ: Podłączenie sygnału zmiany rozmiaru kolumny ---
            # Dzięki temu zapamiętamy szerokość natychmiast po puszczeniu myszki
            self.table.employees_view.horizontalHeader().sectionResized.connect(self._on_column_resized)
            # -----------------------------------------------------------

        if hasattr(self.table, 'employees_view') and hasattr(self.table.employees_view, 'horizontalHeader'):
            self.table.employees_view.horizontalHeader().sortIndicatorChanged.connect(self.on_sort_changed)

        if hasattr(self.events_table, 'horizontalHeader'):
            self.events_table.horizontalHeader().sortIndicatorChanged.connect(self.on_events_sort_changed)
            self.setup_events_table_columns()

        # Konfiguracja menu kontekstowego dla nagłówka dni (Prawy Przycisk Myszy)
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            header = self.table.schedule_view.horizontalHeader()
            header.setContextMenuPolicy(Qt.CustomContextMenu)
            header.customContextMenuRequested.connect(self._on_schedule_header_context_menu)

        overtime_delegate = OvertimeItemDelegate(settings=self.user_app_settings)
        self.table.schedule_view.setItemDelegate(overtime_delegate)

        button_delegate = ButtonDelegate(parent=self, button_text="Odwołaj", is_dark_theme=self.is_dark_theme)
        button_delegate.button_clicked.connect(self.delete_event_from_row)
        self.events_table.setItemDelegateForColumn(10, button_delegate)

        self.table.day_sort_requested.connect(self.apply_day_sort)
        self.table.generic_sort_requested.connect(self.apply_generic_sort)

    def _on_schedule_header_context_menu(self, pos):
        """
        Wyświetla menu kontekstowe na nagłówku dni (ukrywanie/pokazywanie kolumn).
        """
        from PySide6.QtWidgets import QMenu

        header = self.table.schedule_view.horizontalHeader()
        logical_index = header.logicalIndexAt(pos)

        # Oblicz, który to dzień miesiąca
        # logical_index to indeks w modelu (wliczając ukryte kolumny pracownika)
        visible_employee_cols = len(self.schedule_model.get_visible_columns())
        day = logical_index - visible_employee_cols + 1

        # Sprawdź, czy kliknięto w dzień (1-31), a nie w sumy czy komentarz
        if day < 1 or day > 31:
            return

        menu = QMenu(self)

        # Stylizacja menu (opcjonalnie, by pasowało do ciemnego motywu)
        if self.is_dark_theme:
            menu.setStyleSheet(AppStyles.get_dialog_style("dark"))

        # Akcja 1: Ukryj ten dzień
        hide_action = menu.addAction(f"Ukryj dzień {day}")

        # Akcja 2: Ukryj zaznaczone (Excel style)
        # Sprawdzamy, czy jest zaznaczenie kolumn
        selection = self.table.schedule_view.selectionModel()
        selected_cols = []
        if selection.hasSelection():
            # Pobierz unikalne kolumny z zaznaczenia
            indexes = selection.selectedIndexes()
            cols = set(idx.column() for idx in indexes)
            # Filtruj tylko kolumny z dniami
            for col in cols:
                d = col - visible_employee_cols + 1
                if 1 <= d <= 31:
                    selected_cols.append(d)

        if len(selected_cols) > 1:
            hide_selected_action = menu.addAction(f"Ukryj zaznaczone dni ({len(selected_cols)})")
        else:
            hide_selected_action = None

        menu.addSeparator()

        # Akcja 3: Pokaż wszystkie (jeśli coś jest ukryte)
        if self.user_hidden_days:
            unhide_action = menu.addAction(f"Pokaż wszystkie dni (ukryte: {len(self.user_hidden_days)})")
        else:
            unhide_action = None

        # Wyświetl menu i pobierz akcję
        action = menu.exec(header.mapToGlobal(pos))

        if not action:
            return

        # Obsługa akcji
        needs_update = False

        if action == hide_action:
            self.user_hidden_days.add(day)
            needs_update = True

        elif hide_selected_action and action == hide_selected_action:
            self.user_hidden_days.update(selected_cols)
            needs_update = True

        elif unhide_action and action == unhide_action:
            self.user_hidden_days.clear()
            needs_update = True

        # Odśwież widok, jeśli coś zmieniono
        if needs_update:
            self._apply_dynamic_sizes()

    def apply_day_sort(self, day: int, order: Qt.SortOrder):
        """
        Wywołuje sortowanie w modelu danych na podstawie wybranego dnia.
        """
        if hasattr(self, 'schedule_model') and self.schedule_model:
            self.schedule_model.sort_by_day(day, order)

    @Slot(str, Qt.SortOrder)
    def apply_generic_sort(self, col_id: str, order: Qt.SortOrder):
        """
        Wywołuje sortowanie w modelu danych na podstawie ID kolumny (np. 'total_hours').
        """
        if hasattr(self, 'schedule_model') and self.schedule_model:
            debug_print(f"Otrzymano żądanie sortowania generycznego dla: {col_id}")
            self.schedule_model.sort_by_column_id(col_id, order)

    def toggle_left_panel(self):
        """Przełącza widoczność lewego panelu filtrów z zapamiętywaniem rozmiaru."""
        current_sizes = self.main_splitter.sizes()

        # Sprawdź, czy lewy panel jest zwinięty (jego rozmiar jest bliski zeru)
        if current_sizes[0] < 10:
            # Rozwiń panel do ostatniej znanej lub domyślnej szerokości
            right_width = max(0, sum(current_sizes) - self.last_left_panel_width)
            self.main_splitter.setSizes([self.last_left_panel_width, right_width])
        else:
            # Zwiń panel, zapamiętując jego aktualną szerokość
            self.last_left_panel_width = current_sizes[0]
            self.main_splitter.setSizes([0, sum(current_sizes)])

    def toggle_events_panel(self):
        """Przełącza widoczność panelu zdarzeń (dolny panel)"""
        right_splitter = self.centralWidget().findChild(QSplitter, self.main_splitter.objectName()).widget(1).findChild(
            QSplitter)
        if not right_splitter: return

        sizes = right_splitter.sizes()
        if sizes[1] > 0:
            self.events_panel_height = sizes[1]
            right_splitter.setSizes([sum(sizes), 0])
            self.toggle_events_panel_button.setText("Pokaż zdarzenia↑")
        else:
            schedule_height = right_splitter.height() - getattr(self, 'events_panel_height', 300)
            right_splitter.setSizes([schedule_height, getattr(self, 'events_panel_height', 300)])
            self.toggle_events_panel_button.setText("Ukryj zdarzenia↓")

    def export_schedule_to_excel(self):
        """
        Zbiera aktualnie widoczne dane z grafiku i eksportuje je do sformatowanego
        pliku Excel (.xlsx) przy użyciu biblioteki openpyxl.
        """
        if not self.schedule_model or self.schedule_model.rowCount() == 0:
            QMessageBox.warning(self, "Brak danych", "Brak danych do wyeksportowania.")
            return

        default_filename = f"grafik_{self.year}-{self.month:02d}.xlsx"
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Zapisz plik Excel", default_filename, "Pliki Excel (*.xlsx);;Wszystkie pliki (*)"
        )

        if not file_path:
            return

        try:
            # 1. Przygotowanie danych (logika podobna do poprzedniej)
            headers = self.schedule_model._column_headers[:len(self.visible_columns)]
            days_in_month = self.schedule_model._days_in_month
            day_headers = self.schedule_model._column_headers[
                len(self.visible_columns):len(self.visible_columns) + days_in_month]
            # --- ZMIANA: Tworzymy jeden, połączony nagłówek dnia (np. "Pn 1") ---
            day_letters = [h.split('<br>')[1] for h in day_headers]
            day_numbers = [h.split('<br>')[0] for h in day_headers]
            visible_keys = self.schedule_model._keys
            data_rows = []
            for key in visible_keys:
                row_data = self.processed_data.get(key, {})
                row_to_write = []
                for col_id in self.visible_columns:
                    # Mapowanie specjalne dla krotki
                    if col_id == 'sched_wydzial':
                        row_to_write.append(key[0])
                    elif col_id == 'sched_przelozony':
                        row_to_write.append(key[1])
                    elif col_id == 'sched_user_display':
                        row_to_write.append(key[2])
                    else:
                        row_to_write.append(str(row_data.get(col_id, '')))

                # Logika zbierania symboli z grafiku
                days_data = row_data.get('days', {})
                for day in range(1, days_in_month + 1):
                    symbol = days_data.get(day, {}).get('symbol', '')
                    row_to_write.append(symbol)
                data_rows.append(row_to_write)

            # 2. Tworzenie pliku Excel i zapis danych
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = f"Grafik {self.year}-{self.month:02d}"

            # 3. Formatowanie i dodawanie nagłówków
            header_font = Font(bold=True, color="FFFFFF")
            header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
            weekend_fill = PatternFill(start_color="FFF2F2F2", end_color="FFF2F2F2", fill_type="solid")

            # --- ZMIANA: Dodajemy dwa wiersze nagłówków w nowej konfiguracji ---
            ws.append([''] * len(headers) + day_letters)
            ws.append(headers + day_numbers)

            for row in ws.iter_rows(min_row=1, max_row=2, min_col=1, max_col=ws.max_column):
                for cell in row:
                    cell.font = header_font
                    cell.fill = header_fill
                    cell.alignment = Alignment(horizontal='center', vertical='center')

            # 4. Zapis danych
            for row in data_rows:
                ws.append(row)

            # 5. Dodatkowe formatowanie
            employee_cols_count = len(self.visible_columns)

            # Zablokowanie okienek (kolumny pracownicze)
            first_day_column_letter = get_column_letter(employee_cols_count + 1)
            ws.freeze_panes = f"{first_day_column_letter}3"

            # Wyróżnienie weekendów
            weekend_columns = self.schedule_model._weekend_columns
            for weekend_col_idx in weekend_columns:
                col_letter = get_column_letter(employee_cols_count + weekend_col_idx + 1)
                for cell in ws[col_letter]:
                    cell.fill = weekend_fill

            # Automatyczne dopasowanie szerokości kolumn
            for i, column_cells in enumerate(ws.columns):
                # Dla dni grafiku ustawiamy stałą szerokość
                if i >= employee_cols_count:
                    ws.column_dimensions[get_column_letter(i + 1)].width = 5
                else:  # Dla kolumn pracowniczych dopasowujemy do zawartości
                    max_length = 0
                    column = get_column_letter(i + 1)
                    for cell in column_cells:
                        try:
                            if len(str(cell.value)) > max_length:
                                max_length = len(cell.value)
                        except:
                            pass
                    adjusted_width = (max_length + 2)
                    ws.column_dimensions[column].width = adjusted_width

            # 6. Zapis pliku
            wb.save(file_path)

            QMessageBox.information(self, "Eksport zakończony",
                                    f"Dane zostały pomyślnie zapisane w pliku:<br>{file_path}")

        except Exception as e:
            log_error(f"Błąd podczas eksportu do Excel (.xlsx): {e}", exception=e)
            QMessageBox.critical(self, "Błąd eksportu", f"Wystąpił nieoczekiwany błąd:<br>{e}")

    def show_column_select_dialog(self):
        """Wyświetla rozbudowany dialog wyboru kolumn i sortowania."""
        from column_select_dialog import ColumnSelectDialog
        try:
            if not hasattr(self, 'schedule_model'):
                QMessageBox.warning(self, "Błąd", "Model danych nie jest zainicjalizowany.")
                return

            old_visible_set = set(self.visible_columns)
            current_column_widths = self.table.get_column_widths()
            current_splitter_sizes = self.table.splitter.sizes()
            current_left_width = current_splitter_sizes[0]

            self.column_map = {col_id: name for col_id, name, width in self.employee_columns}
            self.column_map.update({col_id: data['name'] for col_id, data in self.custom_columns.items()})
            all_available_columns = list(self.employee_columns) + [(cid, data['name'], 100) for cid, data in
                                                                   self.custom_columns.items()]

            dialog = ColumnSelectDialog(
                parent=self,
                available_columns=all_available_columns,
                visible_columns=self.visible_columns,
                default_columns=self.default_visible_columns,
                user_role=self.current_user_app_role,
                is_comment_column_checked=self.show_comment_column,
                is_percent_morning_checked=self.show_percent_morning_column,
                is_percent_ho_checked=self.show_percent_ho_column,
                sort_preferences=self.user_sort_preferences
            )
            if dialog.exec() == QDialog.Accepted:
                # 1. Najpierw zapisz stan BIEŻĄCY (zanim cokolwiek zmienimy)
                # To gwarantuje, że mamy najnowsze szerokości ustawione ręcznie przez usera
                self.user_app_settings['column_widths'] = self.table.get_column_widths()

                # Pobierz nowy stan z dialogu
                self.visible_columns = dialog.get_selected_columns()
                self.show_comment_column = dialog.get_comment_column_state()
                self.show_percent_morning_column = dialog.get_percent_morning_column_state()
                self.show_percent_ho_column = dialog.get_percent_ho_column_state()

                self.custom_columns = dialog.get_custom_columns()
                new_visible_set = set(self.visible_columns)

                # Zapisz ustawienia
                self.user_app_settings['visible_columns'] = self.visible_columns
                self.user_app_settings['show_schedule_comment'] = self.show_comment_column
                self.user_app_settings['show_schedule_percent_morning'] = self.show_percent_morning_column
                self.user_app_settings['show_schedule_percent_ho'] = self.show_percent_ho_column
                self.user_app_settings['custom_columns'] = self.custom_columns
                self.user_sort_preferences = dialog.get_sort_preferences()
                self.user_app_settings['sort_preferences'] = self.user_sort_preferences
                self.settings_db.save_settings(self.user_app_settings)

                self._synchronize_custom_filter_widgets()
                self.update_filters()

                # Oblicz deltę szerokości dla okna (logika bez zmian)
                delta_width = 0
                hidden_cols = old_visible_set - new_visible_set
                for col_id in hidden_cols:
                    delta_width -= current_column_widths.get(col_id, 100)

                shown_cols = new_visible_set - old_visible_set
                # Pobieramy ZAPISANE szerokości (te z punktu 1)
                saved_widths = self.user_app_settings.get('column_widths', {})

                for col_id in shown_cols:
                    if col_id in saved_widths:
                        width_to_add = saved_widths[col_id]
                    else:
                        default_width = 100
                        for f_id, f_name, f_width in self.employee_columns:
                            if f_id == col_id:
                                default_width = f_width if f_width is not None else 100
                                break
                        width_to_add = default_width
                    delta_width += width_to_add

                # --- SEKCJA KRYTYCZNA: Aplikowanie zmian do widoku ---
                self._is_updating_layout = True  # BLOKUJEMY zapisywanie zmian wywołanych przez kod
                try:
                    debug_print("[DEBUG] Main: Aplikuję zmiany do modelu...")
                    self.schedule_model.set_visible_columns(self.visible_columns)
                    self.schedule_model.set_show_comment_column(self.show_comment_column)
                    self.schedule_model.set_show_percent_morning_column(self.show_percent_morning_column)
                    self.schedule_model.set_show_percent_ho_column(self.show_percent_ho_column)
                    self.schedule_model.set_custom_columns(self.custom_columns)

                    self.refresh_column_configuration()

                    # Tutaj przywracamy szerokości. Ponieważ flaga jest True,
                    # sygnał sectionResized nie nadpisze naszych ustawień domyślnymi wartościami.
                    self.table.apply_column_widths(saved_widths)

                    if hasattr(self, 'table'):
                        new_left_width = max(50, current_left_width + delta_width)
                        total_width = self.table.splitter.width()
                        new_right_width = max(100, total_width - new_left_width - self.table.splitter.handleWidth())
                        self.table.splitter.setSizes([new_left_width, new_right_width])
                        self._apply_dynamic_sizes()  # To też zmienia rozmiary, więc musi być w bloku try

                    self.apply_custom_sort()
                    self._apply_filter_visibility_and_order()

                finally:
                    self._is_updating_layout = False  # ODBLOKOWUJEMY

        except Exception as e:
            log_error(f"Błąd w show_column_select_dialog: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd: {str(e)}")

    def apply_custom_sort(self):
        """
        Sortuje dane w modelu i zabezpiecza widok przed zniszczeniem kolejności.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model._processed_data:
            return

        # --- KROK 1: ZABEZPIECZENIE WIDOKU ---
        # Wyłączamy sortowanie w widoku, żeby Qt nie próbowało przetasować wierszy po swojemu
        emp_view = None
        header = None
        if hasattr(self, 'table') and hasattr(self.table, 'employees_view'):
            emp_view = self.table.employees_view
            header = emp_view.horizontalHeader()
            emp_view.setSortingEnabled(False)  # STOP

        # --- KROK 2: USTALENIE KRYTERIÓW ---
        sort_prefs = self.user_sort_preferences

        # Fallback: Jeśli brak preferencji, użyj domyślnego sortowania biznesowego
        if not sort_prefs:
            sort_prefs = [
                ('sched_dtn', 'asc'),
                ('sched_wydzial', 'asc'),
                ('sched_przelozony_nazwisko', 'asc'),
                ('sched_user_display', 'asc')
            ]
            debug_print("[Sortowanie] Użyto domyślnego schematu sortowania.")
        else:
            debug_print(f"[Sortowanie] Użyto preferencji użytkownika: {sort_prefs}")

        # --- KROK 3: SORTOWANIE DANYCH (PYTHON) ---
        keys_to_sort = self.schedule_model._keys
        self.schedule_model.layoutAboutToBeChanged.emit()

        def compare_rows(key_a, key_b):
            for col_id, direction in sort_prefs:
                val_a = self.schedule_model._get_sort_key(key_a, col_id)
                val_b = self.schedule_model._get_sort_key(key_b, col_id)

                # Bezpieczne porównywanie (liczb i tekstów)
                try:
                    if val_a is None: val_a = ""
                    if val_b is None: val_b = ""

                    if isinstance(val_a, (int, float)) and isinstance(val_b, (int, float)):
                        pass
                    else:
                        val_a, val_b = str(val_a).lower(), str(val_b).lower()
                except Exception:
                    val_a, val_b = str(val_a), str(val_b)

                if val_a < val_b:
                    return -1 if direction == 'asc' else 1
                elif val_a > val_b:
                    return 1 if direction == 'asc' else -1
            return 0

        try:
            keys_to_sort.sort(key=functools.cmp_to_key(compare_rows))
        except Exception as e:
            from debug_utils import log_error
            log_error(f"Błąd sortowania: {e}")

        self.schedule_model.layoutChanged.emit()

        # --- KROK 4: PRZYWRÓCENIE WIDOKU ---
        if emp_view and header:
            # Blokujemy sygnały, żeby setSortIndicator nie wywołał on_sort_changed
            # i nie nadpisał naszych preferencji
            header.blockSignals(True)

            # Resetujemy wskaźnik (brak strzałki)
            header.setSortIndicator(-1, Qt.AscendingOrder)
            if hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.horizontalHeader().setSortIndicator(-1, Qt.AscendingOrder)

            # Jeśli mamy aktywne sortowanie, ustawiamy strzałkę wizualnie
            if sort_prefs:
                col_id, direction = sort_prefs[0]
                order = Qt.DescendingOrder if direction == 'desc' else Qt.AscendingOrder

                # Szukamy indeksu kolumny
                if col_id in self.visible_columns:
                    idx = self.visible_columns.index(col_id)
                    header.setSortIndicator(idx, order)

            # Odblokowujemy i włączamy interakcję
            header.blockSignals(False)
            emp_view.setSortingEnabled(True)  # START (teraz użytkownik może klikać)

    def _apply_dynamic_sizes(self):
        """
        Ustawia dynamiczne rozmiary w oparciu o AKTYWNY PROFIL oraz UKRYTE DNI.
        """
        debug_print("[DEBUG] _apply_dynamic_sizes: START")

        if not hasattr(self, 'table') or not self.table.employees_view.model() or self.schedule_model.rowCount() == 0:
            return

        self._is_updating_layout = True

        try:
            # 1. Pobierz aktywny profil
            profiles = self.user_app_settings.get('layout_profiles', {})
            active_name = self.user_app_settings.get('active_profile', 'Podstawowy')
            # --- DEBUG ---
            debug_print(f"[DEBUG SIZE] Active Profile: {active_name}")
            debug_print(f"[DEBUG SIZE] Available Profiles: {list(profiles.keys())}")
            if active_name in profiles:
                debug_print(f"[DEBUG SIZE] Content: {profiles[active_name]}")
            # -------------
            profile = profiles.get(active_name, {
                'row_height': 25, 'header_height': 36, 'day_col_width': 45, 'font_size': 9
            })

            row_height = int(profile.get('row_height', 25))
            header_height = int(profile.get('header_height', 36))
            day_column_width = int(profile.get('day_col_width', 45))

            self.current_font_size = int(profile.get('font_size', 9))
            self.current_font = profile.get('font_family', 'Segoe UI')

            # 2. Lewa tabela (Pracownicy)
            saved_widths = self.user_app_settings.get('column_widths', {})
            visible_columns = self.schedule_model.get_visible_columns()
            for i, col_id in enumerate(visible_columns):
                if col_id in saved_widths:
                    self.table.employees_view.setColumnWidth(i, saved_widths[col_id])

            # 3. Nagłówek
            self.table.set_header_height(header_height)

            # 4. Prawa tabela (Grafik)
            header = self.table.schedule_view.horizontalHeader()
            model = self.table.employees_view.model()

            # scale_factor = day_column_width / 45.0
            scale_factor = 1.0
            special_widths = {
                "Suma\nRBH": int(40 * scale_factor),
                "Bilans\nRBH": int(40 * scale_factor),
                "Procent\nrano": int(60 * scale_factor),
                "Procent\nHO": int(60 * scale_factor),
                "Komentarz": 300
            }

            for logical_index in range(model.columnCount()):
                header_text = model.headerData(logical_index, Qt.Horizontal, Qt.DisplayRole)
                if header_text:
                    header_text = str(header_text).replace("<br>", "\n")
                width_to_set = special_widths.get(header_text, day_column_width)
                header.resizeSection(logical_index, width_to_set)

            # 5. Ukrywanie dni (spoza miesiąca ORAZ ukrytych ręcznie)
            days_in_month = model._days_in_month
            employee_cols_count = len(model.get_visible_columns())

            for day in range(1, 32):
                logical_index = employee_cols_count + (day - 1)
                if logical_index < model.columnCount():
                    # Dzień jest ukryty jeśli:
                    # A) Jest poza zakresem miesiąca (np. 30 luty)
                    # B) Został dodany do user_hidden_days przez użytkownika
                    should_hide = (day > days_in_month) or (day in self.user_hidden_days)
                    header.setSectionHidden(logical_index, should_hide)

            # 6. Synchronizacja wysokości
            self.table._force_sync_heights(row_height)

        finally:
            self._is_updating_layout = False

        debug_print(f"[DEBUG] _apply_dynamic_sizes: KONIEC. Ukryte dni: {self.user_hidden_days}")

    def showEvent(self, event):
        """Automatycznie wywoływane przez Qt, gdy okno jest pokazywane po raz pierwszy."""
        super().showEvent(event)

        # Sprawdź, czy inicjalizacja UI została już wykonana i czy tabela istnieje
        if not hasattr(self, '_initial_layout_done') and hasattr(self, 'table') and hasattr(self.table, 'splitter'):

            # Pobierz zapisane rozmiary splittera
            saved_sizes = self.user_app_settings.get('schedule_splitter_sizes')

            if saved_sizes and isinstance(saved_sizes, list) and len(saved_sizes) == 2 and sum(saved_sizes) > 100:
                # PRZYPADEK 1: Mamy zapisany i poprawny stan. Przywróć go.
                debug_print(f"Wykryto showEvent - przywracanie szerokości splittera: {saved_sizes}")
                self.table.splitter.setSizes(saved_sizes)
            else:
                # PRZYPADEK 2: Nie ma zapisanego stanu (lub jest niepoprawny). Użyj logiki domyślnej.
                debug_print("Wykryto showEvent - ustawianie domyślnej szerokości splittera.")
                self.table.adjust_employees_table_width()

            self._initial_layout_done = True  # Oznacz jako wykonane

    def delete_event_from_row(self, row):
        """Usuwa zdarzenie na podstawie indeksu wiersza w tabeli zdarzeń."""
        if not hasattr(self, 'events_model') or not self.events_model:
            return
        event = self.events_model.get_event(row)
        if not event:
            return
        event_id = event.get('id')
        event_type = event.get('type')
        if not event_id or not event_type:
            return
        self.delete_event(event_id, event_type)

    def on_sort_changed(self, logical_index, order):
        """
        Obsługuje zmianę sortowania w tabeli grafiku (kliknięcie nagłówka).
        Zapisuje ten wybór jako nową preferencję użytkownika.
        """
        self.last_sort_column = logical_index
        self.last_sort_order = order

        direction = 'desc' if order == Qt.DescendingOrder else 'asc'

        # Znajdź ID kolumny na podstawie indeksu
        if hasattr(self, 'visible_columns') and 0 <= logical_index < len(self.visible_columns):
            col_id = self.visible_columns[logical_index]

            # ZAPAMIĘTAJ WYBÓR: Nadpisujemy preferencje tym jednym, konkretnym sortowaniem
            self.user_sort_preferences = [(col_id, direction)]

            # Aktualizujemy słownik ustawień (żeby przetrwało do zapisu przy wyjściu)
            self.user_app_settings['sort_preferences'] = self.user_sort_preferences

            debug_print(f"Zapisano ręczne sortowanie: {col_id} ({direction})")

    def _on_column_resized(self, logical_index, old_size, new_size):
        """
        Slot wywoływany natychmiast po zmianie rozmiaru kolumny przez użytkownika.
        Aktualizuje ustawienia w pamięci, aby przetrwały odświeżenie danych.
        """
        if self._is_updating_layout:
            return
        # Sprawdź, czy index mieści się w zakresie widocznych kolumn pracownika
        if logical_index < len(self.visible_columns):
            col_id = self.visible_columns[logical_index]

            # Upewnij się, że słownik istnieje
            if 'column_widths' not in self.user_app_settings:
                self.user_app_settings['column_widths'] = {}

            # Zapisz nową szerokość
            self.user_app_settings['column_widths'][col_id] = new_size
            # debug_print(f"Zaktualizowano szerokość kolumny '{col_id}' na {new_size} px")

    def on_events_sort_changed(self, logical_index, order):
        """Obsługuje zmianę sortowania w tabeli zdarzeń"""
        debug_print(
            f"Tabela zdarzeń: Sortowanie po kolumnie {logical_index}, kolejność: {'rosnąco' if order == Qt.AscendingOrder else 'malejąco'}")

    def update_buttons_visibility(self):
        """Aktualizuje widoczność przycisków na podstawie roli użytkownika"""
        is_next_month_selected = False
        current_data = self.date_combo.currentData()
        if current_data:
            selected_year, selected_month = current_data
            today = QDate.currentDate()
            next_month_date = today.addMonths(1)
            if selected_year == next_month_date.year() and selected_month == next_month_date.month():
                is_next_month_selected = True

        # Użycie centralnej funkcji do zarządzania widocznością przycisków
        if hasattr(self, 'add_overtime_button'):
            self.add_overtime_button.setVisible(
                app_settings.has_permission(self.current_user_app_role, 'button_add_overtime'))
        if hasattr(self, 'staffing_details_button'):  #
            self.staffing_details_button.setVisible(
                app_settings.has_permission(self.current_user_app_role, 'button_staffing_details'))
        if hasattr(self, 'show_audit_button'):
            self.show_audit_button.setVisible(
                app_settings.has_permission(self.current_user_app_role, 'button_show_audit'))
        if hasattr(self, 'schedule_control_button'):
            can_see_button = app_settings.has_permission(self.current_user_app_role, 'button_schedule_control')
            self.schedule_control_button.setVisible(can_see_button and is_next_month_selected)
        # Ukryj przycisk wyjątków lokalizacyjnych dla roli Lider OUT
        if hasattr(self, 'location_exception_button'):
            self.location_exception_button.setVisible(self.current_user_app_role != 'Lider OUT')
        if hasattr(self, 'send_email_button'):
            self.send_email_button.setVisible(
                app_settings.has_permission(self.current_user_app_role, 'button_send_email'))
        # Nowy przycisk jest domyślnie widoczny dla wszystkich, którzy mają dostęp do wysyłania e-maili
        if hasattr(self, 'teams_chat_button'):
            self.teams_chat_button.setVisible(
                app_settings.has_permission(self.current_user_app_role, 'button_send_email'))

    def show_audit_log_window(self):
        """Tworzy i pokazuje okno historii zmian."""
        # Leniwe importowanie
        from audit_log_window import AuditLogWindow

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Proszę najpierw wybrać miesiąc.")
            return

        year, month = current_data

        def _get_filtered_audit_data():
            full_data = self.data_provider.get_schedule_audit_data(year, month)
            selected_cells = self.table.get_data_for_selected_cells()
            if selected_cells:
                allowed_users_dates = set()
                for cell in selected_cells:
                    if (user_id := cell.get('uzytkownik_id')) and (date_str := cell.get('date_str')):
                        date_obj = QDate.fromString(date_str, "yyyy-MM-dd").toPython()
                        allowed_users_dates.add((user_id, date_obj))
                return [row for row in full_data if
                        row.get('Data') and (int(row.get('Uzytkownik')), row.get('Data').date()) in allowed_users_dates]
            else:
                visible_user_ids = {key[3] for key in self.schedule_model._keys}
                filtered_by_visibility = [row for row in full_data if row.get('Uzytkownik') is not None and int(
                    row.get('Uzytkownik')) in visible_user_ids]
                sorted_data = sorted(filtered_by_visibility, key=lambda x: x.get('DataModyfikacji'), reverse=True)
                return sorted_data[:50]

        selected_cells = self.table.get_data_for_selected_cells()
        is_limited = not selected_cells
        limit_count = 50
        initial_filtered_data = _get_filtered_audit_data()
        if not initial_filtered_data:
            QMessageBox.information(self, "Informacja", "Brak historii zmian dla wybranych filtrów / zaznaczenia.")
            return

        dialog = AuditLogWindow(initial_filtered_data, self.is_dark_theme, self, is_limited_view=is_limited, year=year,
                                month=month, limit=limit_count)

        def on_refresh_requested():
            self.data_provider.clear_audit_cache(year, month)
            fresh_filtered_data = _get_filtered_audit_data()
            dialog.update_model_data(fresh_filtered_data)
            QMessageBox.information(dialog, "Odświeżono", "Historia zmian została zaktualizowana.")

        dialog.refresh_requested.connect(on_refresh_requested)
        dialog.exec()

    def check_user_permissions(self):
        """Sprawdza uprawnienia użytkownika i zapisuje je w atrybutach klasy."""
        user_app_id, user_app_nr_kadrowy, user_app_role, visible_next_month, user_app_department, user_app_login_windows = get_modifier_id()
        self.current_user_app_id = user_app_id
        self.current_user_app_nr_kadrowy = user_app_nr_kadrowy
        self.current_user_app_login_windows = user_app_login_windows

        # --- POCZĄTEK POPRAWKI: Dynamiczna rekonfiguracja po zmianie roli ---
        # Sprawdź, czy rola się zmieniła od ostatniego sprawdzenia
        if self.current_user_app_role != user_app_role:
            debug_print(f"Wykryto zmianę roli użytkownika z '{self.current_user_app_role}' na '{user_app_role}'.")
            self.current_user_app_role = user_app_role
            # Zrekonfiguruj dostęp do edycji z klawiatury
            self.cleanup_keyboard_filter()
            self.setup_keyboard_editing()
        # --- KONIEC POPRAWKI ---

        self.can_see_next_month = visible_next_month
        self.current_user_app_department = user_app_department

        if not app_settings.has_permission(user_app_role, 'app_access'):
            QMessageBox.critical(self, "Brak uprawnień",
                                 f"Nie masz uprawnień do korzystania z tej aplikacji.<br><br>Twoja rola: {user_app_role}",
                                 QMessageBox.Ok)
            return False

        self.update_buttons_visibility()
        debug_print(
            f"Zalogowano jako: {self.current_user_app_login_windows} (ID: {user_app_login_windows}, Rola: {user_app_role}), Wydział: {self.current_user_app_department}")
        return True

    def _can_modify_cells(self, selected_cells_data: list) -> bool:
        """
        Sprawdza, czy użytkownik ma jakiekolwiek uprawnienia do modyfikacji
        ZAZNACZONYCH komórek. Zwraca True, jeśli choć jedna komórka jest edytowalna.
        """
        if not selected_cells_data:
            return False

        # Sprawdzamy, czy istnieje choć jedna komórka, do której użytkownik ma jakiekolwiek prawo
        can_modify_anything = False
        for cell_data in selected_cells_data:
            permissions = self._get_permission_for_cell(cell_data)
            if any(permissions.values()):
                can_modify_anything = True
                break  # Wystarczy jedna komórka, przerywamy pętlę

        if not can_modify_anything:
            QMessageBox.warning(self, "Brak uprawnień",
                                "Nie posiadasz uprawnień do edycji grafiku dla żadnej z zaznaczonych osób lub komórek.")
            return False

        return True

    def show_insert_symbol_dialog(self):
        """
        Uproszczona metoda: Pokazuje okno dialogowe do wstawiania symbolu,
        a następnie deleguje logikę do scentralizowanej metody.
        """
        if not app_settings.has_permission(self.current_user_app_role, 'schedule_cell_actions'):
            self.statusBar().showMessage("Brak uprawnień do wstawiania symboli.", 3000)
            return

        from schedule_edit_dialogs import InsertSymbolDialog
        selected_cells_data = self.get_selected_cells_data()
        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono żadnych komórek do edycji.", QMessageBox.Ok)
            return

        dialog = InsertSymbolDialog(self, selected_cells_data=selected_cells_data)
        if dialog.exec():
            selected_symbol = dialog.get_selected_symbol()
            if selected_symbol:
                self._apply_special_symbol_to_selection(selected_symbol)

    def _group_cells_for_symbol_changes(self, schedule_cells):
        """Grupuje komórki dla komunikatu potwierdzenia."""
        grouped_changes = {}
        for cell_data in schedule_cells:
            user_id, user_name, date_str, current_symbol = cell_data.get('uzytkownik_id'), cell_data.get(
                'uzytkownik_dane', ''), cell_data.get('date_str'), cell_data.get('symbol', '').strip()
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str
            user_key = (user_id, user_name)
            if user_key not in grouped_changes:
                grouped_changes[user_key] = {}
            if formatted_date not in grouped_changes[user_key]:
                grouped_changes[user_key][formatted_date] = []
            grouped_changes[user_key][formatted_date].append({'current_symbol': current_symbol, 'cell_data': cell_data})
        return grouped_changes

    def _prepare_symbol_changes_description(self, grouped_changes, new_special_symbol):
        """Przygotowuje opis zmian symboli do komunikatu, z limitem wyświetlanych wierszy."""
        changes_info = "<br>"
        line_count = 0
        total_users = len(grouped_changes)
        MAX_LINES_TO_SHOW = 15  # Maksymalna liczba szczegółowych wierszy do pokazania

        for (user_id, user_name), dates in grouped_changes.items():
            if line_count >= MAX_LINES_TO_SHOW:
                remaining_users = total_users - line_count
                if remaining_users > 0:
                    changes_info += f"<br>>... i {remaining_users} więcej użytkowników."
                break

            changes_info += f"<br>👤 {user_name}:<br>"
            line_count += 1

            for date, cells in dates.items():
                if line_count >= MAX_LINES_TO_SHOW:
                    break
                changes_info += f"&nbsp;&nbsp;&nbsp;🗓️ {date}: "
                example_cell = cells[0]['cell_data']
                current_symbol = cells[0]['current_symbol']
                predicted_symbol = self._predict_new_symbol(current_symbol, new_special_symbol, example_cell)
                changes_info += f"{current_symbol or '[puste]'} -> {predicted_symbol}"
                line_count += 1

        return changes_info

    def _predict_new_symbol(self, current_symbol: str, special_symbol: str, cell_data: dict) -> str:
        """
        Przewiduje nowy symbol.
        Dla Lidera OUT w dzień wolny automatycznie ustawia start na 9:00 i godziny z etatu.
        """
        parsed_current = parse_symbol(current_symbol)

        final_start_hour = parsed_current.get('start_hour')
        final_work_hours = parsed_current.get('work_hours')

        # Sprawdź czy to dzień wolny (brak godzin pracy)
        is_day_off = final_work_hours is None

        # --- NOWA LOGIKA DLA LIDERA OUT W DZIEŃ WOLNY ---
        if self.current_user_app_role == 'Lider OUT' and is_day_off:
            # 1. Sztywna godzina rozpoczęcia
            final_start_hour = 9

            # 2. Pobranie godzin z etatu
            try:
                etat_val = float(cell_data.get('etat', 0) or 0)
                # Jeśli etat jest zapisany jako ułamek (np. 1.0, 0.5) -> przelicz na godziny standardowe (x8)
                # Jeśli etat jest zapisany w godzinach (np. 7, 8) -> użyj wprost
                if 0 < etat_val <= 1.0:
                    final_work_hours = int(etat_val * 8)
                elif etat_val > 1.0:
                    final_work_hours = int(etat_val)
                else:
                    final_work_hours = 8  # Fallback
            except (ValueError, TypeError):
                final_work_hours = 8

            # 3. Wstępne ustawienie lokalizacji domyślnej w "sparsowanym" obiekcie,
            # aby logika poniżej mogła z niej skorzystać
            parsed_current['location'] = cell_data.get('lokalizacja_domyslna')
        # ------------------------------------------------

        # Logika dla systemu równoważnego i absencji (zachowana z poprzedniej wersji)
        system_pracy = cell_data.get('system_czasu_pracy', '').strip().lower()
        is_equivalent_system = (system_pracy == 'równoważny')
        is_absence_symbol = special_symbol and special_symbol.upper() in app_settings.get_absence_symbols()

        if is_equivalent_system and is_absence_symbol and final_work_hours is None:
            # Jeśli system równoważny i brak godzin (a nie wpadło w logikę Lider OUT), spróbuj pobrać etat
            try:
                etat_val = float(cell_data.get('etat', 0) or 0)
                final_work_hours = int(etat_val) if etat_val > 1 else 8
            except:
                final_work_hours = 8

        # --- USTALANIE LOKALIZACJI ---
        final_location = None

        # Lokalizację dodajemy TYLKO gdy:
        # 1. Symbol jest "pracujący" (np. HO, DYS, T, PR)
        # 2. LUB brak symbolu specjalnego (zwykła zmiana)
        is_work_like = (special_symbol and special_symbol.upper() in app_settings.WORK_LIKE_SYMBOLS)

        if is_work_like or not special_symbol:
            # Priorytet: 1. Lokalizacja z obecnego symbolu, 2. Domyślna lokalizacja pracownika (lub ta ustawiona dla Lidera OUT wyżej)
            current_loc = parsed_current.get('location')

            # Jeśli Lider OUT wstawia w dzień wolny, parsed_current['location'] został ustawiony w bloku wyżej
            # Jeśli to edycja istniejącego dnia, bierzemy to co było.
            if current_loc:
                final_location = current_loc
            else:
                # Fallback do funkcji SQL (determine_correct_location)
                final_location = self.determine_correct_location(cell_data)

        # Budowanie symbolu
        new_symbol = build_symbol(
            location=final_location,
            start_hour=final_start_hour,
            work_hours=final_work_hours,
            special_symbol=special_symbol
        )

        if not new_symbol.strip() and special_symbol and special_symbol.strip():
            return special_symbol.strip()

        return new_symbol.strip() if new_symbol else ""

    def determine_correct_location(self, cell_data: dict, cursor=None) -> str | None:
        """
        Określa prawidłową lokalizację. Może użyć istniejącego kursora bazy danych
        lub stworzyć własne połączenie.
        """
        local_conn = None
        try:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if not user_id or not date_str:
                return None

            if not cursor:
                local_conn = DatabaseConnector.get_connection()
                cursor = local_conn.cursor()

            sql = f"SELECT FinalLocation FROM {SQL_OBJECTS['fn_getcorrectlocation']}(?, ?)"
            cursor.execute(sql, (user_id, date_str))
            result = cursor.fetchone()

            if result and result[0]:
                return result[0]
            return None

        except Exception as e:
            log_error(f"Błąd w determine_correct_location: {e}", exception=e)
            return None
        finally:
            if local_conn:  # Zamknij połączenie tylko, jeśli zostało stworzone w tej funkcji
                local_conn.close()

    def _find_events_to_cancel(self, user_date_pairs):
        """
        Znajduje zdarzenia do odwołania dla podanych par użytkownik-data.
        WERSJA POPRAWIONA: Używa poprawnej logiki statusów ('Usunięty', 'Do delegacji').
        """
        events_to_cancel = []
        for user_id, date_str in user_date_pairs:
            # Pobieramy wszystkie zdarzenia dla komórki, aby sprawdzić ich dokładny status
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str, active_only=False)

            for event in user_events:
                event_type = event.get('type')
                event_status = event.get('status')
                event_id = event.get('id')

                # Pomiń, jeśli brakuje kluczowych danych
                if not all([event_type, event_id, event_status]):
                    continue

                # --- KLUCZOWA POPRAWKA: Zastosowanie prawidłowej logiki biznesowej ---
                # Aktywne zdarzenie to takie, którego status nie jest ani "Usunięty", ani "Do delegacji".
                is_active = event_status not in ["Usunięty", "Do delegacji"]
                # --- KONIEC POPRAWKI ---

                if is_active and event_type in ['Spotkanie', 'Szkolenie', 'Nadgodziny']:
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),
                    })
        return events_to_cancel

    def _group_events_by_user_date(self, events_to_cancel):
        """Grupuje zdarzenia według użytkownika i daty"""
        grouped_events = {}
        for event in events_to_cancel:
            key = (event['user_id'], event['date'])
            if key not in grouped_events:
                grouped_events[key] = []
            grouped_events[key].append(event)
        return grouped_events

    def clear_special_symbol_from_selected_cells(self):
        """
        Usuwa symbol specjalny (F12).
        Ostrzega o usuwaniu urlopu (U/UZ) dla KAŻDEJ roli.
        """
        if not app_settings.has_permission(self.current_user_app_role, 'action_clear_special_symbol'):
            self.statusBar().showMessage("Brak uprawnień do wykonania tej operacji.", 3000)
            return

        selected_cells_data = self.table.get_data_for_selected_cells()
        if not self._can_modify_cells(selected_cells_data):
            return

        user_role = self.current_user_app_role
        cells_to_modify = []
        skipped_restricted_removal = []

        # Flaga ostrzegawcza
        contains_vacation = False

        for cell in selected_cells_data:
            parsed = parse_symbol(cell.get('symbol', ''))
            current_special = (parsed.get('special_symbol') or '').upper()

            if not current_special:
                continue

            target_role = cell.get('rola_nazwa', '')

            # Logika Lidera (Restrykcje)
            if user_role == 'Lider':
                if current_special in ['U', 'OS']:
                    if target_role != 'Lider':
                        skipped_restricted_removal.append(
                            f"{cell.get('uzytkownik_dane', 'Nieznany')} (Symbol: {current_special})")
                        continue

            # Sprawdzenie czy to urlop (DLA KAŻDEGO)
            if current_special in ['U', 'UZ']:
                contains_vacation = True

            cells_to_modify.append(cell)

        if skipped_restricted_removal:
            QMessageBox.warning(self, "Ograniczenia uprawnień",
                                f"Lider może usunąć symbol 'U' lub 'OS' tylko u innego Lidera.<br>"
                                f"Pominięto usuwanie dla:<br>- {', '.join(set(skipped_restricted_removal))}")

        if not cells_to_modify:
            if not skipped_restricted_removal:
                QMessageBox.information(self, "Brak zmian",
                                        "W zaznaczonych komórkach nie ma symboli możliwych do usunięcia.")
            return

        # --- Budowanie komunikatu potwierdzenia ---
        msg = f"Czy na pewno chcesz usunąć symbole specjalne z {len(cells_to_modify)} komórek?"

        # Dodanie ostrzeżenia dla KAŻDEGO, jeśli wykryto urlop
        if contains_vacation:
            msg += "<br><br><b><font color='orange'>UWAGA:</font> Usuwasz symbol urlopu. Pamiętaj o usunięciu go z planów urlopowych!</b>"

        reply = show_confirmation_dialog(self, "Potwierdzenie operacji", msg)

        if reply != QMessageBox.Yes:
            return

        change_requests = []
        for cell_data in cells_to_modify:
            permissions = self._get_permission_for_cell(cell_data)
            if permissions['can_edit_symbol']:
                change_requests.append((ChangeType.APPLY_SPECIAL_SYMBOL, cell_data, None))

        if change_requests:
            self.schedule_change_processor.start_changes(change_requests)

    def _on_preparation_finished(self, contains_vacation_symbol, change_requests):
        """Slot wywoływany po zakończeniu pracy wątku przygotowawczego."""
        # Ta metoda nie jest już potrzebna, ale zostawiam ją pustą na wypadek,
        # gdyby jakiekolwiek stare połączenia sygnałów wciąż istniały.
        # Docelowo do usunięcia.
        pass

    def _show_f12_vacation_info(self, contains_vacation, successful_updates, failed_updates):
        """Callback do wyświetlania komunikatu po operacji F12."""
        if successful_updates and contains_vacation:
            QMessageBox.information(self, "Informacja o planie urlopowym",
                                    "Usunięcie symbolu urlopu ('U' lub 'UZ') z grafiku nie usuwa go z planu urlopowego.")

    def _show_symbol_change_vacation_info(self, contains_vacation_change, successful_updates, failed_updates):
        """Callback do wyświetlania komunikatu po zmianie symbolu."""
        if successful_updates and contains_vacation_change:
            QMessageBox.information(self, "Informacja o planie urlopowym",
                                    "Zmiana symbolu urlopu ('U' lub 'UZ') na inny nie usuwa go z planu urlopowego.")

    # def _add_location_exception_batch(self, params_list: list):
    #     """Dodaje serię wyjątków w jednej transakcji dla wydajności i bezpieczeństwa."""
    #     errors = []
    #     conn = None
    #     try:
    #         # Krok 1: Otwórz połączenie TYLKO RAZ
    #         conn = DatabaseConnector.get_connection()
    #         cursor = conn.cursor()
    #         query = f"EXEC {SQL_OBJECTS['p_lokalizacjewyjatki']} ?, ?, ?, ?, ?, ?, ?, ?"
    #
    #         # Krok 2: Wykonaj wszystkie operacje w pętli
    #         for params in params_list:
    #             try:
    #                 cursor.execute(query, params)
    #             except Exception as e:
    #                 # Zbierz informacje o błędach, które wystąpiły
    #                 date_str = params[2]  # Data jest na 3. pozycji w krotce
    #                 errors.append(f"Dzień {date_str}: {e}")
    #
    #         # Krok 3: Zatwierdź wszystkie udane operacje JEDNYM poleceniem
    #         conn.commit()
    #
    #         return {"success": not errors, "errors": errors}
    #
    #     except Exception as e:
    #         log_error(f"Błąd krytyczny podczas wsadowego dodawania wyjątków: {e}", exception=e)
    #         return {"success": False, "errors": [str(e)]}
    #     finally:
    #         # Krok 4: Zamknij połączenie na samym końcu
    #         if conn:
    #             conn.close()

    def _check_location_exception(self, user_id, change_date):
        """Sprawdza wyjątek lokalizacyjny dla konkretnego dnia używając nowej funkcji TVF."""
        debug_print(
            f"--- Sprawdzanie wyjątku (TVF) dla Użytkownika ID: {user_id}, Data: {change_date.toString('yyyy-MM-dd')} ---")
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            date_str = change_date.toString("yyyy-MM-dd")

            fn_name = SQL_OBJECTS.get('fn_getlocationexceptions')
            query = f"SELECT * FROM {fn_name}(?, ?, ?)"
            cursor.execute(query, (user_id, date_str, date_str))

            results = [dict(zip([column[0] for column in cursor.description], row)) for row in cursor.fetchall()]
            conn.close()

            debug_print(f"Znaleziono {len(results)} wpisów w bazie danych przez TVF.")

            exact_match = None
            range_match = None
            py_change_date = change_date.toPython()

            for row_dict in results:
                # --- KLUCZOWA POPRAWKA: Sprawdzaj obie możliwe nazwy kolumn ---
                data_od_val = row_dict.get('Dataod', row_dict.get('DataOd'))
                data_do_val = row_dict.get('Datado', row_dict.get('DataDo'))

                if not data_od_val:
                    continue

                data_od = data_od_val.date()
                data_do = data_do_val.date() if data_do_val else None
                # --- KONIEC POPRAWKI ---

                if data_od == py_change_date and data_do and data_do == py_change_date:
                    exact_match = row_dict
                    break
                if data_od <= py_change_date and (not data_do or data_do >= py_change_date):
                    range_match = row_dict

            debug_print(
                f"Zwracam: exact_match={'TAK' if exact_match else 'NIE'}, range_match={'TAK' if range_match else 'NIE'}")
            return exact_match, range_match

        except Exception as e:
            log_error(f"Błąd podczas sprawdzania wyjątków lokalizacyjnych (TVF): {e}", exception=e)
            return None, None

    def _manage_location_exception(self, params):
        """Zarządza dodawaniem, edycją i usuwaniem wyjątków lokalizacyjnych."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            query = f"EXEC {SQL_OBJECTS['p_lokalizacjewyjatki']} ?, ?, ?, ?, ?, ?, ?, ?"
            cursor.execute(query, params)

            # --- POCZĄTEK KLUCZOWEJ POPRAWKI ---
            # Ta pętla zmusza sterownik do poczekania na pełne wykonanie procedury na serwerze,
            # zanim przejdzie do zamknięcia połączenia. Przetwarza wszystkie "ukryte" komunikaty
            # i zestawy wyników, które procedura mogłaby wygenerować.
            while cursor.nextset():
                pass
            # --- KONIEC KLUCZOWEJ POPRAWKI ---

            conn.commit()
            conn.close()
            return {"success": True}
        except Exception as e:
            log_error(f"Błąd podczas zarządzania wyjątkiem lokalizacyjnym: {e}", exception=e)
            return {"success": False, "message": str(e)}

    def _call_import_changes_procedure(self, nr_kadrowy, rok, miesiac, data, symbol):
        """Wywołuje procedurę i bardziej niezawodnie interpretuje jej wyniki."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(
                f"EXEC {SQL_OBJECTS['p_importzmianynaserwer']} @Nr_Kadrowy = ?, @Rok = ?, @Miesiac = ?, @Data = ?, @Symbol = ?, @CzyPobieranieSugestii = ?",
                (nr_kadrowy, rok, miesiac, data, symbol, None))

            all_results = []
            while True:
                try:
                    rows = cursor.fetchall()
                    if rows: all_results.extend(rows)
                    if not cursor.nextset(): break
                except Exception:
                    break
            conn.commit()
            # --- POCZĄTEK KLUCZOWEJ POPRAWKI ---
            # Zatwierdź transakcję, aby trigger i wysłanie wiadomości Service Broker
            # zostały trwale zapisane w bazie danych.
            # --- KONIEC KLUCZOWEJ POPRAWKI ---
            conn.close()

            returned_symbol, success, message = symbol, True, "Operacja zakończona pomyślnie"
            for row in all_results:
                if row and len(row) > 0 and row[0] is not None:
                    raw_value = row[0]
                    if isinstance(raw_value, int) and raw_value == 0: continue
                    value_str = str(raw_value).strip()
                    if not value_str or value_str == "0": continue

                    is_likely_a_symbol = ' ' not in value_str and len(value_str) <= 50
                    if is_likely_a_symbol:
                        returned_symbol = value_str
                    else:
                        success, message = False, value_str
                        break
            if success:
                self._update_modification_date()
            return {"success": success, "message": message, "returned_symbol": returned_symbol}
        except Exception as e:
            log_error(f"Błąd procedury ImportZmianNaSerwer: {e}")
            return {"success": False, "message": f"Błąd bazy danych: {str(e)}", "returned_symbol": symbol}

    def _process_and_apply_changes(self, data_object, dialog_instance=None):
        """
        Uruchamia asynchroniczną aktualizację w tle.

        Args:
            data_object (object): Może to być:
                                1. Krotka (data_dict, global_reason) z okna "Wstaw Zmianę".
                                2. Lista krotek [ (Type, data, value), ... ] ze skrótów klawiaturowych.
            dialog_instance (QDialog, optional): Instancja okna ScheduleChangeDialog.
        """

        is_new_logic = False
        data_to_process = None
        reason_cache = None

        # --- POPRAWIONA LOGIKA: Sprawdzanie typu danych ---
        # Sprawdź, czy to nowa logika
        if isinstance(data_object, tuple) and len(data_object) == 2 and isinstance(data_object[0], dict):
            # Ścieżka 1: Nowa logika z 'Wstaw Zmianę': ({visual_row: row_data}, global_reason)
            data_dict, global_reason = data_object
            data_to_process = data_dict  # To jest SŁOWNIK
            is_new_logic = True

            # Zbuduj "reason_cache" na podstawie globalnego powodu
            reason_cache = {}
            if global_reason is not None:
                user_ids_in_data = {d.get('uzytkownik_id') for d in data_dict.values() if d.get('uzytkownik_id')}
                for user_id in user_ids_in_data:
                    reason_cache[user_id] = global_reason

            debug_print(
                f"[Main] _process_and_apply_changes: Otrzymano {len(data_to_process)} surowych wierszy (Nowa Logika). Powód: {global_reason}")
            if not data_to_process: return

        elif isinstance(data_object, list):
            # Ścieżka 2: Stara logika (np. z klawiatury): [ (ChangeType, cell_data, value), ... ]
            data_to_process = data_object  # To jest LISTA
            is_new_logic = False
            debug_print(f"[Main] _process_and_apply_changes: Otrzymano {len(data_to_process)} żądań (Stara Logika).")
            if not data_to_process: return

        else:
            log_error(f"[Main] Nieprawidłowy format danych w _process_and_apply_changes: {type(data_object)}")
            return

        # --- KONIEC POPRAWIONEJ LOGIKI ---

        # Definicja callbacka do aktualizacji statusów w dialogu
        def process_results_callback(results):
            if not results:
                debug_print("[Main-Callback] Otrzymano pustą listę wyników. Pomijam.")
                return

            if dialog_instance and hasattr(dialog_instance, 'update_status_for_row'):
                debug_print(f"[Main-Callback] Przetwarzanie {len(results)} wyników dla dialogu.")
                for result in results:
                    visual_row = result.get('visual_row', -1)
                    if visual_row != -1:
                        status_override = result.get('status_override')  # np. 'no_change'
                        if status_override:
                            dialog_instance.update_status_for_row(visual_row, status_override, result=result)
                        elif result.get('success'):
                            dialog_instance.update_status_for_row(visual_row, 'success', result=result)
                        else:
                            dialog_instance.update_status_for_row(visual_row, 'failure', result=result)
            else:
                debug_print(
                    "[Main-Callback] Brak instancji dialogu do aktualizacji statusu (normalne dla edycji z klawiatury).")

        # Wywołanie procesora
        self.schedule_change_processor.start_changes(
            data_to_process,  # Przekaż LISTĘ (stara logika) lub SŁOWNIK (nowa logika)
            on_results_processed=process_results_callback,
            reason_cache=reason_cache  # Przekaż cache (nowa logika) lub None (stara logika)
        )

    def _update_cells_with_new_symbols(self, updated_cells_info: list):
        """
        Aktualizuje komórki w modelu na podstawie danych zwróconych przez procedurę.
        Wersja UI: Tekst tylko godziny, Symbole ukryte (dla delegata).
        """
        if not updated_cells_info or not hasattr(self, 'schedule_model'):
            return

        num_changes = len(updated_cells_info)
        self.schedule_model.layoutAboutToBeChanged.emit()

        for user_id, date_str, new_symbol in updated_cells_info:
            if new_symbol is not None:
                try:
                    row_index = -1
                    for idx, key in enumerate(self.schedule_model._keys):
                        if str(key[3]) == str(user_id):
                            row_index = idx
                            break
                    if row_index == -1: continue

                    day = int(date_str.split('-')[2])

                    key = self.schedule_model._keys[row_index]
                    user_data = self.schedule_model._processed_data[key]
                    day_data = user_data.setdefault('days', {}).setdefault(day, {})

                    old_symbol = day_data.get('symbol', '')
                    day_data['symbol'] = str(new_symbol)

                    parsed = parse_symbol(str(new_symbol))
                    old_hours = parse_symbol(old_symbol).get('work_hours', 0) or 0
                    new_hours = parsed.get('work_hours', 0) or 0

                    day_data['hours'] = new_hours
                    day_data['start_hour'] = parsed.get('start_hour')
                    user_data['total_hours'] = (user_data.get('total_hours', 0) or 0) - old_hours + new_hours

                    # --- NOWOŚĆ: Aktualizacja Cache UI ---
                    start_h = parsed.get('start_hour')
                    work_h = parsed.get('work_hours')
                    spec = parsed.get('special_symbol')
                    spec_upper = spec.upper() if spec else ""

                    # A. Aktualizacja _display_value (TYLKO GODZINY)
                    day_data['_display_value'] = ""
                    if start_h is not None:
                        if work_h is not None:
                            val_float = float(work_h)
                            val_str = str(int(val_float)) if val_float.is_integer() else str(val_float)
                            day_data['_display_value'] = f"{start_h};{val_str}"
                        else:
                            day_data['_display_value'] = str(start_h)

                    # B. Aktualizacja _bg_color_hex (Priorytet Absencji)
                    bg_color = None
                    absence_set = app_settings.get_absence_symbols()
                    is_absence = spec_upper in absence_set or spec_upper in ["OS", "U", "UZ"]

                    if is_absence:
                        if spec_upper in ["OS", "U", "UZ"]:
                            bg_color = "#FFFF00"
                        else:
                            bg_color = "#9370DB"
                    elif start_h is not None:
                        try:
                            bg_color = app_settings.SHIFT_COLOR_MAP.get(int(start_h), "#FFFFFF")
                        except (ValueError, TypeError):
                            bg_color = "#FFFFFF"

                    day_data['_bg_color_hex'] = bg_color
                    # Wymuszamy aktualizację cache statystyk w modelu dla tego wiersza
                    if hasattr(self, 'schedule_model'):
                        self.schedule_model.recalculate_row_stats(user_data)
                    # --- KONIEC AKTUALIZACJI CACHE ---

                except (ValueError, IndexError, KeyError):
                    continue

        self.schedule_model.layoutChanged.emit()
        debug_print(f"Zaktualizowano {num_changes} komórek w modelu (z odświeżeniem cache UI).")

    def _update_single_cell_in_model(self, user_id, date_str, new_symbol, year, month):
        """Aktualizuje jedną komórkę w modelu i wymusza jej odświeżenie."""
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model: return False
            row_index = -1
            for idx, key in enumerate(self.schedule_model._keys):
                if str(key[3]) == str(user_id):
                    row_index = idx
                    break
            if row_index == -1: return False

            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)
            if int(year_str) != year or int(month_str) != month: return False

            col_index = len(self.schedule_model.get_visible_columns()) + day - 1
            model_index = self.schedule_model.index(row_index, col_index)
            if model_index.isValid():
                return self.schedule_model.setData(model_index, new_symbol, Qt.EditRole)
            return False
        except Exception as e:
            log_error(f"Błąd aktualizacji komórki {user_id}/{date_str}: {e}")
            return False

    def _get_location_exceptions(self, user_id, start_date, end_date):
        """Pobiera wyjątki lokalizacyjne dla użytkownika w danym zakresie dat używając funkcji TVF."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            fn_name = SQL_OBJECTS.get('fn_getlocationexceptions')
            query = f"SELECT * FROM {fn_name}(?, ?, ?)"
            cursor.execute(query, (user_id, start_date.toString("yyyy-MM-dd"), end_date.toString("yyyy-MM-dd")))
            results = [dict(zip([column[0] for column in cursor.description], row)) for row in cursor.fetchall()]
            conn.close()
            # POPRAWKA: Użycie bezpiecznej metody get() do sortowania, która obsługuje 'DataOd' i 'Dataod'
            return sorted(results, key=lambda x: x.get('DataOd', x.get('Dataod')), reverse=True)
        except Exception as e:
            log_error(f"Błąd podczas pobierania wyjątków (TVF): {e}", exception=e)
            return []

    def show_location_exception_dialog(self):
        """Otwiera okno do zarządzania wyjątkami lokalizacyjnymi."""
        from location_exception_dialog import LocationExceptionDialog

        selected_cells = self.get_selected_cells_data()
        if not selected_cells:
            QMessageBox.warning(self, "Brak zaznaczenia", "Proszę zaznaczyć przynajmniej jedną komórkę pracownika.")
            return

        user_ids = {cell['uzytkownik_id'] for cell in selected_cells}
        if len(user_ids) > 1:
            QMessageBox.warning(self, "Wielu użytkowników", "Proszę zaznaczyć komórki tylko dla jednego pracownika.")
            return

        user_id = user_ids.pop()
        user_name = selected_cells[0]['uzytkownik_dane']

        dates = [QDate.fromString(cell['date_str'], "yyyy-MM-dd") for cell in selected_cells]
        selection_range = {'start': min(dates), 'end': max(dates)}

        dialog = LocationExceptionDialog(self, user_id, user_name, selection_range)
        dialog.data_changed.connect(self.refresh_data)

        # Zapisz stan widoku przed otwarciem dialogu
        self._state_to_restore = self._save_view_state()

        dialog.exec()

    # def check_for_new_data(self):
    #     """Uruchamia wątek sprawdzający aktualizacje w tle."""
    #     if self.background_checker and self.background_checker.isRunning():
    #         debug_print("Sprawdzanie w tle jest już w toku. Pomijam.")
    #         return
    #
    #     current_date_data = self.date_combo.currentData()
    #     if not current_date_data:
    #         return
    #
    #     year, month = current_date_data
    #     last_mod_date = getattr(self, 'last_modification_date', None)
    #
    #     self.background_checker = BackgroundCheckerThread(year, month, last_mod_date)
    #     self.background_checker.update_required.connect(self._handle_update_required)
    #     self.background_checker.new_data_found.connect(self._handle_new_data_found)
    #     self.background_checker.permissions_changed.connect(self.check_user_permissions)
    #     self.background_checker.error_occurred.connect(
    #         lambda msg: log_error(f"Błąd w wątku sprawdzającym: {msg}"))
    #     self.background_checker.finished.connect(self.background_checker.deleteLater)
    #     # --- KLUCZOWA POPRAWKA: Wyczyść referencję po zakończeniu wątku ---
    #     # Zapobiega to błędowi "RuntimeError: Internal C++ object already deleted"
    #     # przy kolejnym wywołaniu, jeśli wątek uległ awarii.
    #     self.background_checker.finished.connect(lambda: setattr(self, 'background_checker', None))
    #     # --- KONIEC POPRAWKI ---
    #     self.background_checker.start()

    def start_db_listener(self):
        """Uruchamia wątek nasłuchujący na powiadomienia z bazy danych (Service Broker)."""
        if self.db_listener and self.db_listener.isRunning():
            debug_print("Listener bazy danych (Service Broker) jest już uruchomiony.")
            return

        # Nazwa kolejki musi być zgodna z tą utworzoną na serwerze SQL
        queue_name = "dbo.KolejkaPowiadomienGrafiku"
        from db_listener import ServiceBrokerListener  # Leniwy import
        self.db_listener = ServiceBrokerListener(queue_name=queue_name, parent=self)
        self.db_listener.notification_received.connect(self.on_db_notification)
        # NOWE: Podłączenie sygnału komend
        self.db_listener.admin_command_received.connect(self.on_admin_command)
        self.db_listener.start()
        debug_print("Service Broker Listener uruchomiony.")

    def on_admin_command(self, cmd_type, target_user, data):
        """
        Obsługuje komendy administracyjne przychodzące z Service Brokera.
        """
        # 1. Normalizacja i porównanie
        my_login = self.current_user_app_login_windows.lower()

        # Jeśli target jest pusty lub 'all', dotyczy wszystkich
        target_normalized = self._normalize_db_login(target_user) if target_user else 'all'

        # Jeśli target to nie 'ALL' i nie mój login -> Ignoruj
        if target_normalized != 'all' and target_normalized != my_login:
            return

        debug_print(f"Wykonywanie komendy administratora: {cmd_type}")

        # 2. Wykonaj akcję
        if cmd_type == 'KILL_SESSION':
            self.session_manager.end_session(exit_type="RemoteKill")
            reason = data if data else "Administrator wymusił zamknięcie."
            QMessageBox.warning(self, "Koniec sesji", f"Sesja została zamknięta zdalnie.\nPowód: {reason}")
            QApplication.quit()

        elif cmd_type == 'REFRESH_PERMISSIONS':
            # Odśwież tylko uprawnienia (np. ktoś dostał awans na Lidera)
            load_all_app_settings()
            self.check_user_permissions()
            self.statusBar().showMessage("Uprawnienia zostały odświeżone zdalnie.", 5000)

        elif cmd_type == 'RELOAD_SETTINGS':
            # --- NOWA OBSŁUGA: Pełne przeładowanie konfiguracji ---
            self._handle_admin_reload_settings()

        elif cmd_type == 'MESSAGE':
            QMessageBox.information(self, "Komunikat od Administratora", data)

    def _handle_admin_reload_settings(self):
        """Przeładowuje ustawienia globalne, style i logikę na żądanie."""
        debug_print("Zdalne żądanie: Pełne przeładowanie ustawień...")

        # --- POPRAWKA: Zapisz bieżący stan widoku (szerokości kolumn) przed resetem ---
        # Dzięki temu, gdy apply_theme_settings -> _apply_dynamic_sizes spróbuje
        # przywrócić widok, użyje tych wartości, zamiast starych z bazy.
        if hasattr(self, 'table'):
             self.user_app_settings['column_widths'] = self.table.get_column_widths()
             # Jeśli masz też splitter, warto go zapisać:
             if hasattr(self.table, 'splitter'):
                 self.user_app_settings['schedule_splitter_sizes'] = self.table.splitter.sizes()
        # ------------------------------------------------------------------------------

        # 1. Pobierz świeże dane
        load_all_app_settings()

        # 2. Odśwież uprawnienia
        self.check_user_permissions()

        # 3. Odśwież wygląd
        # Ta metoda wywoła _apply_dynamic_sizes, która teraz skorzysta z zapisanych wyżej szerokości
        self.apply_theme_settings(
            'dark' if self.is_dark_theme else 'light',
            self.current_font,
            self.current_font_size
        )

        # 4. Obsługa Włączania/Wyłączania Powiadomień w locie
        if app_settings.ENABLE_NOTIFICATION_CENTER:
            if not hasattr(self, 'notification_drawer') or self.notification_drawer is None:
                from notification_center import NotificationDrawer
                self.notification_drawer = NotificationDrawer(self)
                self.notification_drawer.hide()

            if hasattr(self, 'notification_btn'):
                self.notification_btn.setVisible(True)

        else:
            if hasattr(self, 'notification_drawer') and self.notification_drawer:
                self.notification_drawer.deleteLater()
                self.notification_drawer = None

            if hasattr(self, 'notification_btn'):
                self.notification_btn.setVisible(False)

        # Odświeżenie filtrów (np. nowa grupa)
        if hasattr(self, 'update_filters'):
            self.update_filters()

        # 5. Odśwież tabele
        if hasattr(self, 'table'):
            self.table.schedule_view.viewport().update()

        self.statusBar().showMessage("Konfiguracja aplikacji została zaktualizowana.", 5000)

    def _normalize_db_login(self, login_str: str) -> str:
        """
        Usuwa domenę z loginu (np. 'DOMENA\\User' -> 'user').
        Zabezpiecza przed różnicami w formacie między SQL a Pythonem.
        """
        if not login_str:
            return ""

        # Zamień na małe litery
        s = login_str.lower().strip()

        # Jeśli zawiera backslash (DOMENA\User), weź tylko to, co po prawej
        if '\\' in s:
            return s.split('\\')[1]

        return s

    def on_db_notification(self, table_name: str, year: int, month: int, modifier: str):
        """
        Slot wywoływany, gdy nadejdzie powiadomienie z bazy danych.
        Implementuje logikę ignorowania własnych zmian, hybrydowe odświeżanie
        ORAZ obsługę Centrum Powiadomień.
        """
        # 1. Sprawdzenie daty (dla powiadomień specyficznych dla miesiąca - grafik, zdarzenia)
        # Tabela 'appsettings' jest globalna, więc pomijamy dla niej sprawdzanie daty.
        if table_name != 'appsettings':
            current_data = self.date_combo.currentData()
            if not current_data: return
            current_year, current_month = current_data

            # Jeśli powiadomienie dotyczy innego miesiąca niż oglądany -> Ignoruj logikę odświeżania widoku
            # (Ale wciąż można by dodać powiadomienie do Drawera, tu jednak trzymamy się kontekstu widoku)
            if year != current_year or month != current_month:
                return

        # 2. IGNOROWANIE WŁASNYCH ZMIAN
        # Używamy metody pomocniczej do obcięcia domeny (np. 'FIRMA\Jan' -> 'jan')
        db_user_normalized = self._normalize_db_login(modifier)
        app_user_normalized = self.current_user_app_login_windows.lower()

        if db_user_normalized == app_user_normalized:
            debug_print(f"Powiadomienie zignorowane - autorem zmian jest bieżący użytkownik ({modifier}).")
            return

        debug_print(f"Przetwarzanie powiadomienia zewnętrznego: Tabela={table_name}, Kto={modifier}")

        # --- 3. INTEGRACJA Z CENTRUM POWIADOMIEŃ (Poprawiona) ---
        # Sprawdzamy, czy drawer istnieje I nie jest None (kluczowe przy wyłączonej opcji globalnej)
        if hasattr(self, 'notification_drawer') and self.notification_drawer:
            readable_tables = {
                'grafikipracy': 'Grafik',
                'spotkania': 'Spotkanie',
                'szkolenia': 'Szkolenie',
                'nadgodziny': 'Nadgodziny',
                'appsettings': 'Konfiguracja'
            }
            readable_name = readable_tables.get(table_name.lower(), table_name)

            category = "info"
            if table_name == 'grafikipracy':
                category = "schedule"
            elif table_name == 'appsettings':
                category = "warning"
            elif table_name in ['spotkania', 'szkolenia', 'nadgodziny']:
                category = "success"  # lub info

            title = f"Zmiana: {readable_name}"
            message = f"Użytkownik <b>{modifier}</b> wprowadził zmiany dla okresu <b>{month:02}/{year}</b>."

            if table_name == 'nadgodziny':
                message = f"<b>{modifier}</b> zmodyfikował nadgodziny w <b>{month:02}/{year}</b>."

            if table_name == 'appsettings':
                title = "Zmiana globalna"
                message = f"Admin <b>{modifier}</b> zmienił ustawienia aplikacji."

            self.notification_drawer.add_notification(title, message, category)

            # Zmień kolor dzwonka na czerwony, aby zasygnalizować nowe powiadomienie
            if hasattr(self, 'notification_btn') and self.notification_btn:
                self.notification_btn.setStyleSheet("""
                    QPushButton { 
                        color: #e74c3c; 
                        font-weight: bold; 
                        border: none; 
                        background: transparent;
                        font-size: 16px;
                    }
                    QPushButton:hover { background-color: #3a3d42; border-radius: 4px; }
                 """)

        # --- 4. LOGIKA ODŚWIEŻANIA DANYCH (Zależna od tabeli) ---

        # PRZYPADEK A: Zmiana w ustawieniach globalnych (appsettings)
        if table_name == 'appsettings':
            debug_print("Zmiana w AppSettings. Uruchamiam sprawdzanie wersji i uprawnień.")

            # A1. Przeładuj ustawienia w pamięci i odśwież uprawnienia
            load_all_app_settings()
            self.check_user_permissions()

            # A2. Uruchom BackgroundCheckerThread jednorazowo (sprawdzenie wersji)
            from async_operations import BackgroundCheckerThread

            if hasattr(self, 'background_checker') and self.background_checker and self.background_checker.isRunning():
                debug_print("BackgroundCheckerThread już działa. Pomijam.")
                return

            self.background_checker = BackgroundCheckerThread(parent=self)
            self.background_checker.update_required.connect(self._handle_update_required)
            self.background_checker.finished.connect(lambda: setattr(self, 'background_checker', None))
            self.background_checker.start()
            return

        # PRZYPADEK B: Zmiana w zdarzeniach (Spotkania, Szkolenia, Nadgodziny) -> LEKKIE ODŚWIEŻANIE
        if table_name in ['spotkania', 'szkolenia', 'nadgodziny']:
            debug_print("Zmiana w tabelach zdarzeń. Uruchamiam lekkie odświeżanie.")

            # Zapisujemy stan widoku (zaznaczenie, scroll), aby go nie stracić
            view_state = self._save_view_state()

            try:
                # B1. Odśwież tylko cache zdarzeń w DataProvider (pobranie z bazy)
                self.data_provider.refresh_events_data(year, month)

                # B2. Wyczyść cache ikon w DataProvider (wymusi przeliczenie kółek/trójkątów)
                self.data_provider.invalidate_icons_cache(year, month)

                # B3. Odśwież dolną tabelę zdarzeń (jeśli coś jest zaznaczone)
                if view_state and view_state.get('schedule_selection_ids'):
                    self.on_selection_changed()

                # B4. Przerysuj tabelę grafiku (zaciągnie nowe ikony z odświeżonego cache)
                self.table.schedule_view.viewport().update()

            finally:
                # B5. Przywróć zaznaczenie (kluczowe dla komfortu pracy)
                if view_state:
                    self._restore_view_state(view_state)

            self.statusBar().showMessage(f"Zaktualizowano dane zdarzeń (zmiana przez: {modifier})", 5000)
            return

        # PRZYPADEK C: Zmiana w samym grafiku (GrafikiPracy) -> ALERT (CIĘŻKIE ODŚWIEŻANIE)
        if table_name == 'grafikipracy':
            # Zmiany w grafiku (symbole, godziny) są ryzykowne do automatycznego odświeżania
            # podczas edycji. Informujemy użytkownika zmianą koloru przycisku.

            self.refresh_button.setText(f"Nowe dane grafiku!")
            self.refresh_button.setToolTip(
                f"Użytkownik {modifier} wprowadził zmiany w grafiku. Kliknij, aby załadować.")

            # Styl "alarmowy" (pomarańczowy)
            alert_style = AppStyles.get_alert_button_style(
                'dark' if self.is_dark_theme else 'light',
                self.current_font,
                self.current_font_size
            )
            self.refresh_button.setStyleSheet(alert_style)

            # Opcjonalnie: mruganie oknem na pasku zadań
            QApplication.alert(self)

    def _clear_service_broker_queue(self):
        """
        Czyści wszystkie wiadomości z kolejki Service Broker przy starcie aplikacji.
        Najpierw włącza kolejkę, jeśli jest wyłączona.
        """
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            queue_name = SQL_OBJECTS.get('kolejka_powiadomien', 'dbo.KolejkaPowiadomienGrafiku')
            queue_name_only = queue_name.replace('dbo.', '').replace('[', '').replace(']', '')

            debug_print(f"Czyszczenie kolejki Service Broker: {queue_name}")

            # KROK 1: Sprawdź i włącz kolejkę, jeśli jest wyłączona
            try:
                cursor.execute(f"""
                    IF EXISTS (
                        SELECT 1 
                        FROM sys.service_queues 
                        WHERE name = '{queue_name_only}' 
                        AND is_receive_enabled = 0
                    )
                    BEGIN
                        ALTER QUEUE {queue_name} WITH STATUS = ON;
                        SELECT 'ENABLED' as Status;
                    END
                    ELSE
                    BEGIN
                        SELECT 'ALREADY_ON' as Status;
                    END
                """)
                result = cursor.fetchone()
                if result and result[0] == 'ENABLED':
                    debug_print(f"Włączono kolejkę {queue_name}")
                conn.commit()
            except Exception as enable_error:
                log_warning(f"Nie udało się sprawdzić/włączyć kolejki: {enable_error}")

            # KROK 2: Wyczyść kolejkę używając RECEIVE z COMMIT
            debug_print("Czyszczenie wiadomości z kolejki...")
            messages_cleared = 0
            max_iterations = 100
            iteration = 0

            while iteration < max_iterations:
                try:
                    # Odbierz wiadomości w porcjach
                    cursor.execute(f"""
                        BEGIN TRANSACTION;

                        DECLARE @count INT;
                        RECEIVE TOP(1000) * FROM {queue_name};
                        SET @count = @@ROWCOUNT;

                        COMMIT TRANSACTION;

                        SELECT @count;
                    """)

                    result = cursor.fetchone()
                    batch_count = result[0] if result else 0

                    if batch_count == 0:
                        break

                    messages_cleared += batch_count
                    iteration += 1

                except Exception as receive_error:
                    # Jeśli RECEIVE nie działa, spróbuj TRUNCATE
                    try:
                        cursor.execute(f"TRUNCATE TABLE {queue_name}")
                        conn.commit()
                        debug_print(f"Wyczyszczono kolejkę za pomocą TRUNCATE TABLE")
                        return
                    except:
                        pass
                    break

            if messages_cleared > 0:
                debug_print(f"Wyczyszczono {messages_cleared} wiadomości z kolejki")
            else:
                debug_print("Kolejka jest pusta")

        except Exception as e:
            log_error(f"Nie udało się wyczyścić kolejki Service Broker: {e}", exception=e)
        finally:
            if conn:
                try:
                    conn.close()
                except:
                    pass

    # DODATKOWO - metoda do sprawdzenia stanu kolejki (diagnostyka)
    def _check_queue_status(self):
        """Sprawdza i wyświetla status kolejki Service Broker."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            queue_name = SQL_OBJECTS.get('kolejka_powiadomien', 'dbo.KolejkaPowiadomienGrafiku')
            queue_name_only = queue_name.replace('dbo.', '')

            cursor.execute(f"""
                SELECT 
                    name,
                    is_receive_enabled,
                    is_enqueue_enabled,
                    is_activation_enabled,
                    is_poison_message_handling_enabled
                FROM sys.service_queues
                WHERE name = '{queue_name_only}'
            """)

            result = cursor.fetchone()
            if result:
                debug_print(f"Status kolejki {queue_name}:")
                debug_print(f"  - Receive enabled: {result[1]}")
                debug_print(f"  - Enqueue enabled: {result[2]}")
                debug_print(f"  - Activation enabled: {result[3]}")
                debug_print(f"  - Poison handling: {result[4]}")
            else:
                debug_print(f"Kolejka {queue_name} nie istnieje!")

            # Sprawdź liczbę wiadomości
            cursor.execute(f"SELECT COUNT(*) FROM {queue_name} WITH (NOLOCK)")
            count = cursor.fetchone()[0]
            debug_print(f"  - Liczba wiadomości w kolejce: {count}")

        except Exception as e:
            log_error(f"Błąd sprawdzania statusu kolejki: {e}", exception=e)
        finally:
            if conn:
                conn.close()

    def _handle_update_required(self, force_update: bool, version_obsolete: bool):
        """
        Obsługuje sygnał z BackgroundCheckerThread o konieczności aktualizacji aplikacji.
        """
        debug_print(
            f"Otrzymano sygnał o konieczności aktualizacji (force: {force_update}, obsolete: {version_obsolete}).")
        if hasattr(self, 'check_timer'):
            self.check_timer.stop()
        if self.db_listener:
            self.db_listener.cancel()
            self.db_listener.wait(1000)
        dialog = UpdateRequiredDialog(self)
        dialog.exec()
        self.close()

    # def _handle_update_required(self, force_update, version_obsolete):
    #     """Obsługuje sygnał o konieczności aktualizacji."""
    #     debug_print(
    #         f"Otrzymano sygnał o konieczności aktualizacji (force: {force_update}, obsolete: {version_obsolete}).")
    #     self.check_timer.stop()
    #     dialog = UpdateRequiredDialog(self)
    #     dialog.exec()
    #     self.close()

    def _handle_new_data_found(self, data_types, latest_modification):
        """Obsługuje sygnał o znalezieniu nowych danych."""
        is_self_change = False
        if hasattr(self, 'last_self_modification_date') and self.last_self_modification_date:
            if abs(latest_modification - self.last_self_modification_date) < timedelta(seconds=2):
                is_self_change = True

        if not is_self_change:
            change_type_text = " i ".join(data_types)
            self.refresh_button.setText(f"Nowe dane {change_type_text}!")
            self.refresh_button.setToolTip(
                f"Wykryto zmiany w sekcji: {change_type_text}. Kliknij, aby załadować.")

            alert_style = AppStyles.get_alert_button_style(
                'dark' if self.is_dark_theme else 'light',
                self.current_font,
                self.current_font_size
            )
            self.refresh_button.setStyleSheet(alert_style)
            self.check_timer.stop()
        else:
            # To była nasza własna zmiana, więc tylko aktualizujemy datę
            self.last_modification_date = latest_modification

    def _save_current_filter_settings(self):
        """Zapisuje aktualny stan filtrów do słownika ustawień i do bazy danych."""
        if not hasattr(self, 'user_app_settings'):
            return

        # Zaktualizuj słownik o bieżący stan filtrów
        self.user_app_settings['last_filters'] = self.get_current_filters_state()

        # Zapisz cały, zaktualizowany słownik w bazie danych
        self.settings_db.save_settings(self.user_app_settings)
        debug_print("Zapisano bieżący stan filtrów do bazy danych.")

    def refresh_data(self):
        """Wymusza odświeżenie danych z bazy, zachowując stan filtrów i sortowania."""
        # Krok 1: Pobierz bieżący stan filtrów do zmiennej.
        # --- NOWA LOGIKA: Ustaw flagę blokującą ---
        self._is_refreshing_data = True
        debug_print("Ustawiono flagę _is_refreshing_data = True")

        filters_to_preserve = self.get_current_filters_state()

        self.refresh_button.setText("Odśwież")

        # --- KLUCZOWA POPRAWKA ---
        # Przekazujemy aktualne ustawienia czcionki, aby zapewnić spójność wyglądu.
        self.refresh_button.setStyleSheet(AppStyles.get_button_style(
            'dark' if self.is_dark_theme else 'light',
            self.current_font,
            self.current_font_size
        ))
        # --- KONIEC POPRAWKI ---

        self.refresh_button.setToolTip("Odśwież dane")

        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            self.update_buttons_visibility()
            self.data_provider.clear_monthly_cache(year, month)
            # Krok 2: Przekaż stan filtrów do procesu aktualizacji danych.
            self.update_data(year, month, self.import_grupa, self.import_funkcja, use_async=True,
                             filters_to_restore=filters_to_preserve)
            self.update_filter_dates()
            self._update_modification_date()
            if hasattr(self, 'check_timer'):
                self.check_timer.start(60000)

    def _update_modification_date(self):
        """Aktualizuje datę ostatniej modyfikacji po dokonaniu zmian."""
        try:
            current_date_data = self.date_combo.currentData()
            if not current_date_data: return
            year, month = current_date_data
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(
                f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['grafikipracy']} WHERE Rok = ? AND Miesiac = ?",
                (year, month))
            schedule_max_date = cursor.fetchone()[0]
            cursor.execute(f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['fn_geteventsdata']}(?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]
            conn.close()
            all_dates = [d for d in [schedule_max_date, events_max_date] if d is not None]
            if not all_dates: return

            latest_modification = max(all_dates)
            self.last_self_modification_date = latest_modification
            self.last_modification_date = latest_modification

            # --- POCZĄTEK POPRAWKI: Resetowanie timera po własnej zmianie ---
            # Zatrzymaj bieżące odliczanie i uruchom je od nowa.
            if hasattr(self, 'check_timer'):
                self.check_timer.start(60000)
                # --- KONIEC POPRAWKI ---

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji daty modyfikacji: {e}", exception=e)

    def filter_data(self):
        """Filtruje dane grafiku i ZAWSZE stosuje sortowanie z ustawień użytkownika."""
        if not hasattr(self, 'schedule_model') or not self.schedule_model or getattr(self, '_updating_filters', False):
            return
        self._updating_filters = True
        try:
            # Krok 1: Aktualizacja i zastosowanie filtrów
            self.update_cross_filters()
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

            # Krok 2: Zawsze po filtrowaniu, zastosuj zapisane sortowanie
            self.apply_custom_sort()

        finally:
            self._updating_filters = False
            current_data = self.date_combo.currentData()
            if current_data and self.staffing_details_win and not self.staffing_details_win.isHidden():
                year, month = current_data
                self.staffing_details_win.update_for_new_month_or_filters(year, month)

    def filter_events_table(self):
        """Filtruje tabelę zdarzeń, bazując na danych z modelu."""
        try:
            if not hasattr(self, 'events_model') or not self.events_model: return

            # ZMIANA: Zawsze pobieraj dane źródłowe z modelu,
            # które zostały tam wstawione przez `on_selection_changed`.
            source_data = self.events_model.get_all_events()
            if not source_data:
                self.events_model.filtered_update([])
                return

            filtered_data = source_data.copy()

            # Filtr typów
            allowed_types = []
            if self.meetings_checkbox.isChecked(): allowed_types.append('Spotkanie')
            if self.trainings_checkbox.isChecked(): allowed_types.append('Szkolenie')
            if self.overtime_checkbox.isChecked(): allowed_types.append('Nadgodziny')
            if allowed_types:
                filtered_data = [e for e in filtered_data if e.get('type') in allowed_types]

            # Filtr statusu
            selected_statuses = self.status_filter_combo.get_selected_items()
            if selected_statuses:
                filtered_data = [e for e in filtered_data if e.get('status') in selected_statuses]

            # Filtry tekstowe i dat
            topic_filter = self.topic_filter.text().lower()
            if topic_filter:
                filtered_data = [e for e in filtered_data if topic_filter in str(e.get('topic', '')).lower()]

            name_filter = self.name_filter.text().lower()
            if name_filter:
                filtered_data = [e for e in filtered_data if name_filter in str(e.get('name', '')).lower()]

            date_from_str = self.date_from.date().toString('yyyy-MM-dd')
            date_to_str = self.date_to.date().toString('yyyy-MM-dd')
            if date_from_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') >= date_from_str]
            if date_to_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') <= date_to_str]

            self.events_model.filtered_update(filtered_data)
        except Exception as e:
            log_error(f"Błąd podczas filtrowania zdarzeń: {str(e)}")

    def show_schedule_control_dialog(self):
        """
        Pokazuje odpowiednie okno dialogowe w zależności od roli użytkownika.
        WERSJA ZMODYFIKOWANA: Otwiera okno jako nieblokujące i niezależne.
        """
        from schedule_control_dialog import ScheduleControlDialog, SuggestionsOutDialog

        # --- POCZĄTEK NOWEJ LOGIKI ---
        # Krok 1: Sprawdź, czy okno już istnieje i jest widoczne
        if self.schedule_control_win:
            try:
                debug_print("Aktywuję istniejące okno 'Zarządzaj grafikiem'.")
                self.schedule_control_win.activateWindow()  # Przenieś na wierzch
                self.schedule_control_win.raise_()
                return  # Zakończ, nie twórz nowego okna
            except RuntimeError:
                # Błąd: Okno zostało zniszczone (np. przez błąd),
                # ale referencja nie została wyczyszczona. Wyczyść ją teraz.
                self.schedule_control_win = None
        # --- KONIEC NOWEJ LOGIKI ---

        # Główmy przycisk jest już chroniony przez 'button_schedule_control'.
        # Poniższa logika jedynie decyduje, które okno pokazać dla uprawnionego użytkownika.
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Proszę najpierw wybrać miesiąc.")
            return

        year, month = current_data

        dialog = None  # Zmienna tymczasowa

        if self.current_user_app_role == "Pracownik WPR":
            dialog = ScheduleControlDialog(self, year, month)
        elif self.current_user_app_role == "Lider OUT":
            dialog = SuggestionsOutDialog(self, year, month)
        else:
            QMessageBox.information(self, "Brak dostępu", "Twoja rola nie ma dostępu do tej funkcji.")
            return

        # --- ZMIANA: Zapisz referencję i podłącz sygnały ---
        self.schedule_control_win = dialog
        self.schedule_control_win.data_refresh_needed.connect(self.refresh_data)

        # Podłącz sygnał 'finished', który QDialog emituje po zamknięciu (przez OK, Anuluj lub 'X')
        # do naszej funkcji czyszczącej referencję.
        self.schedule_control_win.finished.connect(self._on_schedule_control_closed)

        # Zamiast .exec() (blokujące), użyj .show() (nieblokujące)
        self.schedule_control_win.show()
        # --- KONIEC ZMIANY ---

    def show_insert_change_dialog(self):
        """Pokazuje okno dialogowe do wstawiania zmian w grafiku"""
        if not app_settings.has_permission(self.current_user_app_role, 'schedule_cell_actions'):
            self.statusBar().showMessage("Brak uprawnień do wstawiania zmian.", 3000)
            return

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Nie wybrano miesiąca. Nie można dodać zmiany grafiku.", QMessageBox.Ok)
            return

        year, month = current_data
        selected_cells = self.table.get_data_for_selected_cells()

        if not selected_cells:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono żadnych komórek do edycji.", QMessageBox.Ok)
            return

        grouped_cells = self.group_cells_by_user_and_day(selected_cells)

        dialog = ScheduleChangeDialog(self, grouped_cells=grouped_cells, year=year, month=month, main_window=self)

        # --- ZMODYFIKOWANE POŁĄCZENIE SYGNAŁU ---
        # Oczekujemy teraz obiektu (krotki (all_row_data, global_reason))
        dialog.changes_requested.connect(
            lambda data_tuple: self._process_and_apply_changes(data_tuple, dialog)
        )
        # --- KONIEC ZMIANY ---

        dialog.exec()

    def _handle_location_change_logic(self, cell_data: dict, new_location_code: str, reason: str = None) -> dict:
        """
        Scentralizowana logika do zarządzania wyjątkami lokalizacyjnymi.
        Sprawdza, tworzy, aktualizuje lub usuwa wyjątki.
        """
        try:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            q_date = QDate.fromString(date_str, "yyyy-MM-dd")
            default_location = cell_data.get('lokalizacja_domyslna')
            user_app_id, _, _, _, _, _ = get_modifier_id()
            location_map = {'h': 1, 's': 3, 'p': 2}

            # <<< KRYTYCZNA POPRAWKA: Upewnij się, że new_location_code nie jest puste >>>
            # Jeśli kod lokalizacji jest pusty (None), a nie jest to powrót do domyślnej,
            # oznacza to błąd logiki - ale na potrzeby tej funkcji bezpieczniej jest
            # przyjąć lokalizację domyślną, aby uniknąć NULL.
            if not new_location_code:
                new_location_code = default_location

            new_location_id = location_map.get(new_location_code)
            # --- KONIEC POPRAWKI ---

            exact, in_range = self._check_location_exception(user_id, q_date)

            # Scenariusz 1: Powrót do lokalizacji domyślnej -> usuń wyjątek
            if new_location_code == default_location:
                if exact:
                    params = (None, user_app_id, None, None, None, None, 3, exact['Id'])
                    return self._manage_location_exception(params)
                elif in_range:
                    return {"success": False, "message": "Dzień jest częścią wielodniowego wyjątku. Zmień go ręcznie."}
                else:
                    return {"success": True}  # Nie ma czego usuwać

            # Scenariusz 2: Zmiana na niedomyślną lokalizację
            else:
                if exact:  # Istnieje dokładny wpis na ten dzień
                    if exact.get('Lokalizacja') != new_location_id:
                        params = (user_id, user_app_id, date_str, date_str, new_location_id, reason, 2, exact['Id'])
                        return self._manage_location_exception(params)
                    else:
                        return {"success": True}  # Lokalizacja już się zgadza
                elif in_range:  # Dzień jest częścią wielodniowego wyjątku
                    return {"success": False, "message": "Dzień jest częścią wielodniowego wyjątku. Zmień go ręcznie."}
                else:  # Brak wyjątku, utwórz nowy
                    params = (user_id, user_app_id, date_str, date_str, new_location_id, reason, 1, None)
                    return self._manage_location_exception(params)
        except Exception as e:
            log_error(f"Błąd w _handle_location_change_logic: {e}", exception=e)
            return {"success": False, "message": str(e)}

    def handle_schedule_change_request(self, change_requests: list):
        """
        Przetwarza listę żądań zmian w grafiku, delegując zadanie do nowej
        scentralizowanej metody, która uruchamia BatchUpdater.
        """
        dialog = self.sender()

        # Przekaż żądania i referencję do dialogu do nowej metody
        self._process_and_apply_changes(change_requests, dialog)

    def get_data_from_model_by_id(self, user_id, date_str):
        """
        Wyszukuje i zwraca aktualne dane dla konkretnej komórki (użytkownik/data)
        bezpośrednio z głównego modelu danych.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return None

        try:
            row_index = -1
            for idx, key in enumerate(self.schedule_model._keys):
                if str(key[3]) == str(user_id):
                    row_index = idx
                    break

            if row_index == -1:
                return None

            day = int(date_str.split('-')[2])
            col_index = len(self.schedule_model.get_visible_columns()) + day - 1

            model_index = self.schedule_model.index(row_index, col_index)
            if model_index.isValid():
                return self.schedule_model.data(model_index, ROLE_DATA)

        except (ValueError, IndexError) as e:
            log_error(f"Błąd przy pobieraniu danych z modelu dla {user_id}/{date_str}: {e}")

        return None

    def _save_view_state(self):
        """Zapisuje stabilne identyfikatory zaznaczenia, sortowanie i pozycję przewijania."""
        schedule_selection_ids = []
        if self.table.schedule_view.selectionModel():
            for index in self.table.schedule_view.selectionModel().selectedIndexes():
                data = index.data(ROLE_DATA)
                if isinstance(data, dict) and 'uzytkownik_id' in data and 'date_str' in data:
                    schedule_selection_ids.append((data['uzytkownik_id'], data['date_str']))

        employees_selection_ids = set()
        if self.table.employees_view.selectionModel():
            for index in self.table.employees_view.selectionModel().selectedIndexes():
                data = index.data(ROLE_DATA)
                if isinstance(data, dict) and 'uzytkownik_id' in data:
                    employees_selection_ids.add(data['uzytkownik_id'])

        state = {
            'schedule_selection_ids': schedule_selection_ids,
            'employees_selection_ids': list(employees_selection_ids),
            'emp_sort_col': self.table.employees_view.horizontalHeader().sortIndicatorSection(),
            'emp_sort_order': self.table.employees_view.horizontalHeader().sortIndicatorOrder(),
            'sched_sort_col': self.table.schedule_view.horizontalHeader().sortIndicatorSection(),
            'sched_sort_order': self.table.schedule_view.horizontalHeader().sortIndicatorOrder(),
            'v_scroll_pos': self.table.schedule_view.verticalScrollBar().value(),
            'h_scroll_pos': self.table.schedule_view.horizontalScrollBar().value()
        }
        debug_print(
            f"[DB] ZAPISYWANIE STANU: emp_sort_col={state['emp_sort_col']}, sched_sort_col={state['sched_sort_col']}, selections={len(schedule_selection_ids)}")
        return state

    def _restore_view_state(self, state):
        """Przywraca sortowanie, zaznaczenie i pozycję przewijania po resecie modelu."""
        debug_print(f"[DB] ROZPOCZĘTO PRZYWRACANIE STANU...")
        if not self.schedule_model or self.schedule_model.rowCount() == 0:
            debug_print("[DB] PRZERWANO PRZYWRACANIE: Model jest pusty.")
            return

        schedule_sm = self.table.schedule_view.selectionModel()
        employees_sm = self.table.employees_view.selectionModel()
        if schedule_sm: schedule_sm.blockSignals(True)
        if employees_sm: employees_sm.blockSignals(True)

        try:
            # Krok 1: Zawsze stosuj pełne, wielopoziomowe sortowanie z ustawień użytkownika.
            # To jest jedyne źródło prawdy o pożądanym porządku po resecie danych.
            self.apply_custom_sort()

            # Krok 2: Zbuduj mapę do wyszukania nowych indeksów wierszy po posortowaniu.
            user_id_to_new_row_map = {str(key[3]): i for i, key in enumerate(self.schedule_model._keys)}

            # Krok 3: Odtwórz zaznaczenie na podstawie nowych, prawidłowych indeksów.
            schedule_selection = QItemSelection()
            employee_cols_count = len(self.schedule_model.get_visible_columns())
            for user_id, date_str in state['schedule_selection_ids']:
                new_row = user_id_to_new_row_map.get(str(user_id))
                if new_row is not None:
                    try:
                        day = int(date_str.split('-')[2])
                        new_col = employee_cols_count + day - 1
                        model_index = self.schedule_model.index(new_row, new_col)
                        if model_index.isValid():
                            schedule_selection.select(model_index, model_index)
                    except (ValueError, IndexError):
                        continue

            employees_selection = QItemSelection()
            for user_id in state['employees_selection_ids']:
                new_row = user_id_to_new_row_map.get(str(user_id))
                if new_row is not None:
                    top_left = self.schedule_model.index(new_row, 0)
                    bottom_right = self.schedule_model.index(new_row, employee_cols_count - 1)
                    if top_left.isValid() and bottom_right.isValid():
                        employees_selection.select(top_left, bottom_right)

            debug_print(
                f"[DB] Przywracam zaznaczenie: {len(state['schedule_selection_ids'])} komórek, {len(state['employees_selection_ids'])} wierszy.")
            if schedule_sm: schedule_sm.select(schedule_selection, QItemSelectionModel.ClearAndSelect)
            if employees_sm: employees_sm.select(employees_selection,
                                                 QItemSelectionModel.ClearAndSelect | QItemSelectionModel.Rows)

            # Krok 4: Przywróć pozycję pasków przewijania.
            self.table.schedule_view.verticalScrollBar().setValue(state['v_scroll_pos'])
            self.table.schedule_view.horizontalScrollBar().setValue(state['h_scroll_pos'])
            debug_print(f"[DB] Przywrócono pozycję przewijania: V={state['v_scroll_pos']}, H={state['h_scroll_pos']}")

        finally:
            # Zawsze włączaj sygnały z powrotem.
            if schedule_sm: schedule_sm.blockSignals(False)
            if employees_sm: employees_sm.blockSignals(False)
        debug_print(f"[DB] ZAKOŃCZONO PRZYWRACANIE STANU.")

    def format_date(self, date_str: str) -> str:
        """
        Formatuje datę z formatu 'YYYY-MM-DD' na 'DD.MM.YYYY'.

        Args:
            date_str (str): Data w formacie 'YYYY-MM-DD'.

        Returns:
            str: Sformatowana data lub oryginalny ciąg w razie błędu.
        """
        try:
            year, month, day = date_str.split('-')
            return f"{day}.{month}.{year}"
        except (ValueError, AttributeError):
            return date_str

    def show_add_overtime_dialog(self):
        """Pokazuje okno dialogowe do dodawania nadgodzin."""
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Nie wybrano miesiąca.", QMessageBox.Ok)
            return
        year, month = current_data
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not self._can_modify_cells(selected_cells_data) or not selected_cells_data or len(selected_cells_data) > 1:
            QMessageBox.warning(self, "Błąd zaznaczenia", "Zaznacz dokładnie jedną komórkę, aby dodać nadgodziny.",
                                QMessageBox.Ok)
            return

        cell_data = selected_cells_data[0]
        selected_user_id, selected_user_name, day, date_str, nr_kadrowy, start_hour, current_symbol, lokalizacja_domyslna = (
            cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane'), cell_data.get('day'),
            cell_data.get('date_str'), cell_data.get('nr_kadrowy'), cell_data.get('start_hour'),
            cell_data.get('symbol', ''), cell_data.get('lokalizacja_domyslna')
        )

        if not all([selected_user_id, day, date_str]):
            QMessageBox.warning(self, "Błąd", "Brak wymaganych danych w zaznaczonej komórce.", QMessageBox.Ok)
            return

        selected_date = QDate.fromString(date_str, "yyyy-MM-dd")
        is_day_off = not current_symbol or current_symbol.strip() == ''
        if start_hour is None: start_hour = 9 if is_day_off else 8

        parsed_symbol = parse_symbol(current_symbol)
        current_location = parsed_symbol.get('location') if parsed_symbol and parsed_symbol.get(
            'location') else lokalizacja_domyslna

        dialog = QDialog(self)
        polish_months = ["stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca", "lipca", "sierpnia", "września",
                         "października", "listopada", "grudnia"]
        dialog.setWindowTitle(
            f"Dodaj nadgodziny w dniu {selected_date.day()} {polish_months[selected_date.month() - 1]} {selected_date.year()}")
        dialog.setMinimumWidth(300)
        layout = QVBoxLayout(dialog)
        layout.addWidget(QLabel(f"Pracownik: {selected_user_name}"))
        if nr_kadrowy: layout.addWidget(QLabel(f"Numer kadrowy: {nr_kadrowy}"))
        layout.addWidget(QLabel(f"Miesiąc rozliczenia: {month:02d}.{year}"))
        if is_day_off: layout.addWidget(QLabel("Zaznaczony dzień jest dniem wolnym pracownika."))

        form_frame = QFrame()
        form_layout = QGridLayout(form_frame)
        time_combo = QComboBox()

        # --- POCZĄTEK POPRAWKI ---
        time_combo.setEditable(True)
        time_combo.setFocus()

        # Dodajemy listę zdefiniowanych godzin
        valid_times = [f"{h:02d}:{m:02d}" for h in range(24) for m in [0, 30]]
        time_combo.addItems(valid_times)

        # --- POCZĄTEK POPRAWKI ---
        # Tworzymy dedykowaną klasę walidatora, ponieważ QValidator jest klasą abstrakcyjną.
        class TimeValidator(QValidator):
            def __init__(self, valid_entries, parent=None):
                super().__init__(parent)
                self.valid_entries = set(valid_entries)

            def validate(self, text, pos):
                if text in self.valid_entries:
                    return (QValidator.State.Acceptable, text, pos)
                # Pozwól na wpisywanie, jeśli tekst jest początkiem którejś z poprawnych wartości
                if any(entry.startswith(text) for entry in self.valid_entries):
                    return (QValidator.State.Intermediate, text, pos)
                return (QValidator.State.Invalid, text, pos)

        time_combo.lineEdit().setValidator(TimeValidator(valid_times))

        # --- KONIEC POPRAWKI ---

        def on_text_edited(text):
            """Automatycznie dodaje dwukropek po wpisaniu dwóch cyfr."""
            line_edit = time_combo.lineEdit()
            # Zablokuj sygnały, aby uniknąć rekurencyjnego wywołania
            line_edit.blockSignals(True)
            if len(text) == 2 and text.isdigit():
                line_edit.setText(text + ":")
            # Przywróć sygnały
            line_edit.blockSignals(False)

        time_combo.lineEdit().textEdited.connect(on_text_edited)

        # --- POCZĄTEK NOWEJ LOGIKI ---
        # Domyślna godzina rozpoczęcia nadgodzin to godzina zakończenia zmiany
        work_hours = parsed_symbol.get('work_hours')
        if not is_day_off and start_hour is not None and work_hours is not None:
            end_hour_decimal = start_hour + work_hours
            end_hour_int = int(end_hour_decimal)
            end_minute = int(round((end_hour_decimal - end_hour_int) * 60))
            final_end_hour = end_hour_int % 24
            default_time = f"{final_end_hour:02d}:{end_minute:02d}"
        else:
            # Fallback dla dni wolnych lub braku danych o zmianie
            default_time = "09:00"
        # --- KONIEC NOWEJ LOGIKI ---
        time_combo.setCurrentText(default_time)

        # --- POCZĄTEK POPRAWKI ---
        # Ustawienie wszystkich pól jako edytowalne z autouzupełnianiem
        hours_combo = QComboBox()
        hours_combo.setEditable(True)
        for h in [i * 0.5 for i in range(1, 27)]: hours_combo.addItem(f"{h:.1f}", h)
        hours_combo.setCurrentIndex(1)

        type_combo = QComboBox()
        type_combo.setEditable(True)
        type_combo.addItems(["wypłata", "odbiór", "odpracowanie"])

        ld_combo = QComboBox()
        ld_combo.setEditable(True)
        ld_combo.addItems(["h", "p", "s"])
        ld_combo.setCurrentText(current_location)

        overdue_combo = QComboBox()
        overdue_combo.setEditable(True)
        overdue_combo.addItems(["nie", "tak"])

        # --- POCZĄTEK POPRAWKI ---
        add_button = QPushButton("Dodaj")

        # Ustawienie poprawnej kolejności przechodzenia (TAB)
        QWidget.setTabOrder(time_combo, hours_combo)
        QWidget.setTabOrder(hours_combo, type_combo)
        QWidget.setTabOrder(type_combo, ld_combo)
        QWidget.setTabOrder(ld_combo, overdue_combo)
        QWidget.setTabOrder(overdue_combo, add_button)
        # --- KONIEC POPRAWKI ---
        form_layout.addWidget(QLabel("od kiedy"), 0, 0)
        form_layout.addWidget(time_combo, 0, 1)
        form_layout.addWidget(QLabel("ile godzin"), 0, 2);
        form_layout.addWidget(hours_combo, 0, 3)
        form_layout.addWidget(QLabel("typ"), 0, 4);
        form_layout.addWidget(type_combo, 0, 5)
        form_layout.addWidget(QLabel("LD"), 0, 6);
        form_layout.addWidget(ld_combo, 0, 7)
        form_layout.addWidget(QLabel("czy zaległe"), 0, 8);
        form_layout.addWidget(overdue_combo, 0, 9)
        form_layout.addWidget(add_button, 0, 10)
        layout.addWidget(form_frame)

        # --- POCZĄTEK POPRAWKI ---
        # Zaznacz cały tekst, aby można go było łatwo nadpisać
        time_combo.lineEdit().selectAll()
        # --- KONIEC POPRAWKI ---

        # --- POCZĄTEK POPRAWKI ---
        self.add_overtime_dialog_instance = dialog

        def add_overtime():
            # Krok 1: Zapisz stan widoku (zaznaczenie i przewinięcie)
            view_state = self._save_view_state()

            # --- POCZĄTEK NOWEJ LOGIKI ---
            # Sprawdź, czy zmiana przechodzi przez północ i dostosuj daty
            overtime_start_datetime = datetime.strptime(f"{date_str} {time_combo.currentText()}", "%Y-%m-%d %H:%M")
            shift_work_hours = parsed_symbol.get('work_hours') if not is_day_off else None

            if start_hour is not None and shift_work_hours is not None:
                shift_end_datetime = datetime.strptime(date_str, "%Y-%m-%d") + timedelta(
                    hours=start_hour + shift_work_hours)
                shift_start_datetime = datetime.strptime(f"{date_str} {start_hour:02d}:00", "%Y-%m-%d %H:%M")

                # Warunek: zmiana przechodzi przez północ ORAZ nadgodziny zaczynają się o tej samej godzinie co koniec zmiany
                if shift_end_datetime.date() > shift_start_datetime.date() and \
                        shift_end_datetime.time() == overtime_start_datetime.time():
                    overtime_start_datetime += timedelta(days=1)
            # --- KONIEC NOWEJ LOGIKI ---

            result = self.call_add_overtime_procedure_fixed(
                selected_user_id, selected_date.year(), selected_date.month(),
                overtime_start_datetime, date_str,  # Przekazujemy zmodyfikowaną datę i czas ORAZ oryginalną datę
                float(hours_combo.currentData()), f"{year}-{month:02d}-01",
                overdue_combo.currentIndex(), type_combo.currentText(),
                ld_combo.currentText(), nr_kadrowy
            )
            if result["success"]:
                # --- POCZĄTEK POPRAWKI ---
                # Krok 2: Po sukcesie w bazie, unieważniamy cache dla tej komórki.
                # To zmusi DataProvider do ponownego załadowania danych (w tym zdarzeń) przy następnym zapytaniu.
                self.data_provider.invalidate_complete_cache_for_pairs([(selected_user_id, date_str)])

                # --- POCZĄTEK NOWEJ, ZOPTYMALIZOWANEJ LOGIKI ---
                # Krok 3: Zamiast pobierać wszystkie zdarzenia dla miesiąca, pobieramy je tylko dla zmienionej komórki.
                fresh_events_for_cell = self.data_provider.get_events_for_user_date(selected_user_id, date_str,
                                                                                    active_only=False)

                # Krok 4: Inteligentnie zaktualizuj `self.all_events_data`, aby uniknąć pełnego przeładowania.
                # Usuń stare zdarzenia dla tej komórki i dodaj nowe, świeżo pobrane.
                self.all_events_data = [e for e in self.all_events_data if
                                        not (e.get('user_id') == selected_user_id and e.get('date_key') == date_str)]
                self.all_events_data.extend([self._convert_dp_event_to_local(e) for e in fresh_events_for_cell])
                debug_print(
                    f"Zaktualizowano `self.all_events_data` tylko dla komórki ({selected_user_id}, {date_str}). Nowa liczba zdarzeń: {len(self.all_events_data)}")
                # --- KONIEC NOWEJ, ZOPTYMALIZOWANEJ LOGIKI ---

                # Krok 5: Przywracamy zaznaczenie komórki, które było zapamiętane przed otwarciem okna.
                self._restore_view_state(view_state)

                # Krok 6: Wywołujemy metodę, która jest odpowiedzialna za aktualizację tabeli zdarzeń.
                # Użyje ona świeżych danych z DataProvider (dzięki krokowi 2) i poprawnie wyświetli
                # nowo dodane nadgodziny. To również zaktualizuje `self.all_events_data`.
                self.on_selection_changed()
                # --- KONIEC POPRAWKI ---

                self.statusBar().showMessage("Pomyślnie dodano nadgodziny.", 3000)
                dialog.accept()
            else:
                QMessageBox.warning(dialog, "Błąd", result["message"], QMessageBox.Ok)

        add_button.clicked.connect(add_overtime)

        dialog.exec()

    def show_settings_dialog(self):
        """Pokazuje okno dialogowe ustawień aplikacji."""

        # --- POPRAWKA: Zapisz aktualne szerokości kolumn przed otwarciem okna ---
        # Zapobiega to resetowaniu widoku przy zmianie motywu lub imporcie.
        if hasattr(self, 'table'):
            self.user_app_settings['column_widths'] = self.table.get_column_widths()
        # ------------------------------------------------------------------------

        from settings_dialog import AppSettingsDialog

        # Przekazujemy current_user_app_role
        dialog = AppSettingsDialog(self, settings=self.user_app_settings, user_role=self.current_user_app_role)

        dialog.live_theme_changed.connect(self.apply_theme_settings)
        dialog.import_requested.connect(self.on_import_requested)
        dialog.save_global_settings_requested.connect(self._save_global_app_settings)

        if dialog.exec() == QDialog.Accepted:
            # Ta część wykona się po kliknięciu "OK" lub "Importuj teraz"
            new_settings = dialog.get_current_settings()
            should_save = new_settings.pop('save_to_db', False)

            self.user_app_settings.update(new_settings)

            self.is_dark_theme = self.user_app_settings.get('theme') == 'dark'
            self.current_font = self.user_app_settings.get('font_family')
            self.current_font_size = self.user_app_settings.get('font_size')

            self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font,
                                      self.current_font_size)
            self.setup_table_properties()
            self.table.schedule_view.viewport().update()

            if should_save:
                self.settings_db.save_settings(self.user_app_settings)
                debug_print(f"Zapisano ustawienia z dialogu.")

            # Naprawia kolejność wierszy po tym, jak setup_table_properties ją zresetował
            self.apply_custom_sort()

    def _save_global_app_settings(self, settings_dict):
        """
        Zapisuje ustawienia globalne do tabeli appsettings (SQL)
        ORAZ wysyła komendę RELOAD_SETTINGS do wszystkich klientów.
        Wersja obsługująca zarówno Administratora, jak i Pracownika WPR (dla Grup).
        """
        # --- KROK 1: Walidacja uprawnień ---
        has_admin_access = app_settings.has_permission(self.current_user_app_role, 'manage_app_configuration')
        has_group_access = app_settings.has_permission(self.current_user_app_role, 'manage_group_definitions')

        # Jeśli użytkownik nie ma ŻADNEGO z tych uprawnień, blokujemy.
        if not (has_admin_access or has_group_access):
            from debug_utils import log_warning
            log_warning(f"Próba zapisu ustawień globalnych bez uprawnień przez: {self.current_user_app_role}")
            return

        debug_print(f"Rozpoczynam zapis globalny ustawień SQL. Klucze: {list(settings_dict.keys())}")

        conn = None
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # --- KROK 2: Aktualizacja tabeli appsettings (MERGE) ---
            table_name_settings = SQL_OBJECTS['appsettings']

            for key, value in settings_dict.items():
                # Dodatkowe zabezpieczenie: Jeśli to nie Admin, a próbuje zmienić coś innego niż grupy -> zignoruj/zaloguj
                if not has_admin_access and key != 'GroupMapping':
                    debug_print(f"Pominięto zapis klucza '{key}' - brak uprawnień administratora.")
                    continue

                # Konwersja wartości na string (dla pewności, bo JSON to string)
                val_str = str(value)

                sql_merge = f"""
                    MERGE {table_name_settings} AS target
                    USING (SELECT ? AS SettingKey, ? AS SettingValue) AS source
                    ON (target.SettingKey = source.SettingKey)
                    WHEN MATCHED THEN UPDATE SET target.SettingValue = source.SettingValue
                    WHEN NOT MATCHED THEN INSERT (SettingKey, SettingValue) VALUES (source.SettingKey, source.SettingValue);
                """
                cursor.execute(sql_merge, (key, val_str))

            # --- KROK 3: Wysłanie komendy przeładowania (AppCommands) ---
            if 'appcommands' in SQL_OBJECTS:
                table_name_commands = SQL_OBJECTS['appcommands']

                # Ustalamy treść komunikatu w zależności od tego, co zmieniono
                command_msg = 'Zmiana ustawień globalnych'
                if 'GroupMapping' in settings_dict and len(settings_dict) == 1:
                    command_msg = 'Aktualizacja konfiguracji grup'

                sql_command = f"""
                    INSERT INTO {table_name_commands} 
                    (CommandType, TargetUser, CommandData, CreatedAt, CreatedBy)
                    VALUES (?, ?, ?, GETDATE(), ?)
                """

                cursor.execute(sql_command, (
                    'RELOAD_SETTINGS',
                    'ALL',
                    command_msg,
                    self.current_user_app_login_windows
                ))

            conn.commit()
            debug_print("Zapis do bazy (appsettings + AppCommands) zakończony sukcesem.")

            # Wymuszamy przerysowanie filtrów, aby nowa grupa pojawiła się w ComboBoxie natychmiast
            self.update_filters()

        except Exception as e:
            from debug_utils import log_error
            log_error(f"Błąd zapisu ustawień globalnych: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Nie udało się zapisać ustawień globalnych: {e}")
        finally:
            if conn:
                conn.close()

    def on_import_requested(self, grupa, funkcja):
        """Obsługuje żądanie importu z okna ustawień."""
        debug_print(f"Otrzymano żądanie importu z ustawieniami: Grupa={grupa}, Funkcja={funkcja}")

        # Zaktualizuj atrybuty w głównym oknie
        self.import_grupa = grupa
        self.import_funkcja = funkcja

        # Wywołaj odświeżenie danych
        self.refresh_data()

    def _update_model_with_new_symbols(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje symbole bezpośrednio w modelu
        """
        try:
            if not updated_symbols or not hasattr(self, 'schedule_model'):
                return

            processed_data = self.schedule_model.get_processed_data()
            if not processed_data:
                return

            updated_count = 0
            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Znajdź klucz użytkownika w processed_data
                target_key = None
                for key in processed_data.keys():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        target_key = key
                        break

                if not target_key:
                    debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                    continue

                # Oblicz dzień z daty
                try:
                    year_str, month_str, day_str = date_str.split('-')
                    day = int(day_str)

                    if int(year_str) != year or int(month_str) != month:
                        continue

                except ValueError:
                    continue

                # Aktualizuj symbol w processed_data
                user_data = processed_data[target_key]
                days_data = user_data.setdefault('days', {})
                day_data = days_data.setdefault(day, {})

                old_symbol = day_data.get('symbol', '')
                day_data['symbol'] = new_symbol

                # Przelicz godziny na podstawie nowego symbolu
                from symbol_parser import parse_symbol
                parsed = parse_symbol(new_symbol)
                day_data['hours'] = parsed.get('work_hours', 0) or 0
                day_data['start_hour'] = parsed.get('start_hour')

                # Aktualizuj total_hours użytkownika
                old_hours = 0
                if old_symbol:
                    old_parsed = parse_symbol(old_symbol)
                    old_hours = old_parsed.get('work_hours', 0) or 0

                new_hours = day_data['hours']
                user_data['total_hours'] = (user_data.get('total_hours', 0) or 0) - old_hours + new_hours

                updated_count += 1
                debug_print(
                    f"Model: Zaktualizowano {user_id}/{day}: '{old_symbol}' -> '{new_symbol}' ({old_hours}h -> {new_hours}h)")

            debug_print(f"Zaktualizowano {updated_count} komórek w modelu")

        except Exception as e:
            log_error(f"Błąd aktualizacji modelu: {e}")

    def _update_data_provider_cache(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje cache w DataProvider
        """
        try:
            if not updated_symbols or not hasattr(self.data_provider, 'monthly_cache'):
                return

            month_key = (year, month)
            if month_key not in self.data_provider.monthly_cache:
                return

            container = self.data_provider.monthly_cache[month_key]

            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Aktualizuj processed_data w kontenerze
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):
                        try:
                            year_str, month_str, day_str = date_str.split('-')
                            day = int(day_str)

                            if int(year_str) == year and int(month_str) == month:
                                days_data = user_data.setdefault('days', {})
                                day_data = days_data.setdefault(day, {})
                                day_data['symbol'] = new_symbol

                                # Przelicz godziny
                                from symbol_parser import parse_symbol
                                parsed = parse_symbol(new_symbol)
                                day_data['hours'] = parsed.get('work_hours', 0) or 0
                                day_data['start_hour'] = parsed.get('start_hour')

                                debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")
                                break
                        except:
                            continue

        except Exception as e:
            log_error(f"Błąd aktualizacji DataProvider cache: {e}")

    def _force_full_refresh(self):
        """Fallback - pełne odświeżenie danych"""
        try:
            current_data = self.date_combo.currentData()
            if current_data:
                year, month = current_data
                self.data_provider.refresh_data(year, month)
                self.update_table_content()
        except Exception as e:
            log_error(f"Błąd pełnego odświeżenia: {e}")

    def _force_refresh_specific_cells(self, affected_pairs, year, month):
        """
        POPRAWIONA METODA: Wymusza odświeżenie konkretnych komórek w widoku
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycję komórki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajdź wiersz użytkownika w modelu
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnę dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymusza odświeżenie komórki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej komórki
                        self.schedule_model.dataChanged.emit(model_index, model_index,
                                                             [Qt.DisplayRole, Qt.BackgroundRole])

                        # Metoda 2: Wymuś update widoku dla tej komórki
                        self.table.schedule_view.update(model_index)

                        refreshed_cells += 1
                        debug_print(f"Odświeżono komórkę tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"Błąd odświeżania komórki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymuś całościowy update viewport jeśli zmieniono jakieś komórki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po odświeżeniu {refreshed_cells} komórek")

                # DODATKOWE: Wymuś też odświeżenie tabeli pracowników (dla sum RBH)
                if hasattr(self.table, 'employees_view'):
                    self.table.employees_view.viewport().update()

        except Exception as e:
            log_error(f"Błąd podczas wymuszania odświeżenia komórek tabeli: {e}")

    def _update_model_cells_directly(self, updated_symbols, year, month):
        """
        Aktualizuje symbole bezpośrednio w modelu i DataProvider

        Args:
            updated_symbols (dict): Słownik {(user_id, date_str): symbol}
            year (int): Rok
            month (int): Miesiąc
        """
        try:
            if not updated_symbols:
                return

            updated_count = 0

            # AKTUALIZACJA 1: Schedule Model processed_data
            if hasattr(self, 'schedule_model') and self.schedule_model:
                processed_data = self.schedule_model.get_processed_data()

                if processed_data:
                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        if self._update_single_cell_in_processed_data(processed_data, user_id, date_str, new_symbol,
                                                                      year, month):
                            updated_count += 1

            # AKTUALIZACJA 2: DataProvider cache (jeśli istnieje)
            if hasattr(self.data_provider, 'monthly_cache'):
                month_key = (year, month)
                if month_key in self.data_provider.monthly_cache:
                    container = self.data_provider.monthly_cache[month_key]

                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        self._update_single_cell_in_data_provider(container, user_id, date_str, new_symbol, year, month)

            debug_print(f"Zaktualizowano {updated_count} komórek w modelu")

        except Exception as e:
            log_error(f"Błąd bezpośredniej aktualizacji modelu: {e}")

    def _update_single_cell_in_processed_data(self, processed_data, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczą komórkę w processed_data

        Returns:
            bool: True jeśli zaktualizowano
        """
        try:
            # Znajdź klucz użytkownika
            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if not target_key:
                debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                return False

            # Oblicz dzień
            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)

            if int(year_str) != year or int(month_str) != month:
                return False

            # Aktualizuj symbol
            user_data = processed_data[target_key]
            days_data = user_data.setdefault('days', {})
            day_data = days_data.setdefault(day, {})

            old_symbol = day_data.get('symbol', '')
            day_data['symbol'] = new_symbol

            # Przelicz godziny i inne parametry
            from symbol_parser import parse_symbol
            parsed = parse_symbol(new_symbol)
            day_data['hours'] = parsed.get('work_hours', 0) or 0
            day_data['start_hour'] = parsed.get('start_hour')

            debug_print(f"Model: {user_id}/{day} '{old_symbol}' -> '{new_symbol}'")
            return True

        except Exception as e:
            log_error(f"Błąd aktualizacji komórki processed_data {user_id}/{date_str}: {e}")
            return False

    def _update_single_cell_in_data_provider(self, container, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczą komórkę w DataProvider cache
        """
        try:
            if not hasattr(container, 'processed_data') or not container.processed_data:
                return

            # Podobna logika jak dla processed_data w modelu
            processed_data = container.processed_data

            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if target_key:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)

                if int(year_str) == year and int(month_str) == month:
                    user_data = processed_data[target_key]
                    days_data = user_data.setdefault('days', {})
                    day_data = days_data.setdefault(day, {})
                    day_data['symbol'] = new_symbol

                    # Przelicz godziny
                    from symbol_parser import parse_symbol
                    parsed = parse_symbol(new_symbol)
                    day_data['hours'] = parsed.get('work_hours', 0) or 0
                    day_data['start_hour'] = parsed.get('start_hour')

                    debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")

        except Exception as e:
            log_error(f"Błąd aktualizacji DataProvider cache: {e}")

    def _force_refresh_table_cells(self, affected_pairs, year, month):
        """
        WYMUSZA odświeżenie konkretnych komórek w widoku tabeli

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
            year (int): Rok
            month (int): Miesiąc
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycję komórki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajdź wiersz użytkownika
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnę dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymuś odświeżenie komórki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej komórki
                        self.schedule_model.dataChanged.emit(model_index, model_index, [])

                        # Metoda 2: Wymuś update widoku (backup)
                        self.table.schedule_view.update(model_index)

                        # Metoda 3: Invalidate item (backup)
                        if hasattr(self.table.schedule_view, 'setDirtyRegion'):
                            rect = self.table.schedule_view.visualRect(model_index)
                            if not rect.isEmpty():
                                self.table.schedule_view.viewport().update(rect)

                        refreshed_cells += 1
                        debug_print(f"Odświeżono komórkę tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"Błąd odświeżania komórki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymuś całościowy update viewport jeśli zmieniono jakieś komórki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po odświeżeniu {refreshed_cells} komórek")

        except Exception as e:
            log_error(f"Błąd podczas wymuszania odświeżenia komórek tabeli: {e}")

    def _find_user_row_in_model(self, user_id):
        """
        POPRAWIONA METODA: Znajduje indeks wiersza dla danego użytkownika w modelu
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return -1

            # Pobierz klucze z modelu
            if hasattr(self.schedule_model, '_keys'):
                keys = self.schedule_model._keys
            else:
                return -1

            user_id_str = str(user_id)

            for row_index, key in enumerate(keys):
                if len(key) > 3 and str(key[3]) == user_id_str:
                    return row_index

            return -1

        except Exception as e:
            log_error(f"Błąd podczas szukania wiersza użytkownika {user_id}: {e}")
            return -1

    def _update_local_events_for_cells(self, affected_pairs):
        """
        Aktualizuje lokalny events_data tylko dla zmienionych komórek

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
        """
        try:
            if not hasattr(self, 'events_data'):
                return

            # Sprawdź czy jakieś z zmienionych komórek są obecnie zaznaczone
            if not hasattr(self, 'table'):
                return

            current_selection = self.table.get_data_for_selected_cells()
            selected_pairs = set()

            for cell_data in current_selection:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    selected_pairs.add((user_id, date_str))

            # Sprawdź czy któraś ze zmienionych komórek jest zaznaczona
            intersection = set(affected_pairs) & selected_pairs

            if intersection:
                debug_print(f"Zaktualizowano {len(intersection)} zmienionych komórek w events_data")
                # Jeśli tak, odśwież events_data tylko dla zaznaczonych komórek
                self.on_selection_changed()

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji lokalnych events: {e}")

    def _show_symbol_change_results(self, successful_updates: int, failed_updates: int, error_messages: list,
                                    events_to_cancel: list, skipped_employees: list):
        """
        Wyświetla uzytkownikowi podsumowanie operacji wstawiania symboli,
        uwzględniając komórki pominięte z powodu braku uprawnień.
        """
        title = ""
        full_message = ""

        # Komunikat o sukcesach
        if successful_updates > 0:
            full_message += f"Pomyślnie zaktualizowano {successful_updates} komórek."
            if events_to_cancel:
                full_message += f" i odwołano {len(events_to_cancel)} delegacji."
            full_message += "<br>"

        # Komunikat o pominiętych z powodu braku uprawnień
        if skipped_employees:
            full_message += f"<br>Pominięto {len(skipped_employees)} komórek z powodu braku uprawnień dla:<br>- {', '.join(set(skipped_employees))}<br>"

        # Komunikat o błędach
        if failed_updates > 0:
            title = "Częściowy sukces" if successful_updates > 0 or skipped_employees else "Błąd aktualizacji"
            error_list_str = "<br> - " + "<br> - ".join(error_messages[:10])
            full_message += f"<br>Nie udało się zaktualizować {failed_updates} komórek z powodu błędów:{error_list_str}"
            if len(error_messages) > 10:
                full_message += f"<br>... i {len(error_messages) - 10} więcej błędów."
        elif successful_updates > 0 or skipped_employees:
            title = "Zakończono operację"

        # Wyświetl komunikat tylko jeśli coś się wydarzyło
        if full_message:
            # Jeśli nie było błędów i pominięć, pokaż tylko info na pasku statusu
            if successful_updates > 0 and failed_updates == 0 and not skipped_employees:
                self.statusBar().showMessage(full_message.strip(), 4000)
            else:
                QMessageBox.information(self, title, full_message.strip())

    def _prepare_delegations_description(self, grouped_events, max_groups=10):
        """
        Przygotowuje opis delegacji do odwołania.

        Args:
            grouped_events: Słownik zdarzeń pogrupowanych według użytkownika i daty
            max_groups: Maksymalna liczba grup do wyświetlenia

        Returns:
            str: Opis delegacji do odwołania
        """
        delegations_info = ""

        if not grouped_events:
            return delegations_info

        delegations_info += "<br>Następujące delegacje zostaną automatycznie odwołane:<br><br>"

        # Licznik dla ograniczenia liczby wyświetlanych grup
        group_count = 0

        for (user_id, date_str), events in grouped_events.items():
            # Ograniczenie liczby wyświetlanych grup
            if group_count >= max_groups:
                delegations_info += f"<br>...oraz więcej zdarzeń dla innych użytkowników/dni ({len(grouped_events) - max_groups} więcej grup)...<br>"
                break

            # Pobierz nazwę użytkownika z pierwszego zdarzenia
            user_name = events[0].get('user_name', f"ID: {user_id}")

            # Przygotuj datę w ładniejszym formacie (DD.MM.YYYY)
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            delegations_info += f"&nbsp;&nbsp;&nbsp;👤 {user_name} - 📅 {formatted_date}:<br>"

            # Wyświetl zdarzenia dla tego użytkownika i daty
            for i, event in enumerate(events):
                delegations_info += f"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{i + 1}.  {event['type']}: {event['name']}<br>"

            group_count += 1

        return delegations_info

    def filter_processed_data(self):
        """Filtruje przetworzone dane na podstawie wszystkich filtrów."""
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return {}

        # --- 1. Pobranie stanu kontrolerów UI ---

        # Filtr obecności
        show_only_at_work = self.filter_by_presence_check.isChecked()

        # Filtr nieobecności (NOWOŚĆ)
        show_only_absent = self.filter_by_absence_check.isChecked()

        # Parametry dla filtru nieobecności
        # Pobieramy je zawsze, ale używamy tylko gdy show_only_absent is True
        abs_date = self.absence_date_edit.date()
        abs_day = abs_date.day()
        selected_abs_symbols = set(self.absence_symbol_combo.get_selected_items())
        selected_abs_hours = {int(h.split(':')[0]) for h in self.absence_hour_combo.get_selected_items()}

        # Filtry statyczne (ComboBoxy i Listy)
        selected_wydzialy = set(self.wydzial_combo.get_selected_items())
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
        selected_uzytkownicy_ids = self.get_list_selected_data(self.uzytkownik_list)

        selected_dtn = self.dtn_combo.get_selected_items()
        selected_role = self.rola_combo.get_selected_items()
        selected_podrola = self.podrola_combo.get_selected_items()
        selected_rka = self.rka_combo.get_selected_items()
        selected_grafik_pkt = self.grafik_za_punkty_combo.get_selected_items()
        selected_brak_nocki = self.brak_nocki_combo.get_selected_items()
        selected_jezyki = self.jezyk_combo.get_selected_items()
        selected_etaty = self.etat_combo.get_selected_items()
        selected_scp = self.system_czasu_pracy_combo.get_selected_items()
        selected_grupy = self.grupa_main_filter_combo.get_selected_items()
        selected_locations_default = self.default_location_combo.get_selected_items()

        # --- 2. Przygotowanie filtrów niestandardowych ---

        # Pobierz aktualny kontekst czasowy (rok/miesiąc) potrzebny do zbudowania klucza
        current_data = self.date_combo.currentData()
        current_year, current_month = current_data if current_data else (self.year, self.month)

        active_custom_filters = {}
        for col_id in self.custom_columns.keys():
            container_widget = self.filter_widget_map.get(col_id)
            # Sprawdzamy, czy filtr dla tej kolumny jest włączony/widoczny
            if container_widget and container_widget.isVisible():
                combo = container_widget.findChild(CustomMultiComboBox)
                if combo:
                    selected_values = set(combo.get_selected_items())
                    if selected_values:
                        active_custom_filters[col_id] = selected_values

        # --- 3. Logika dla grup wydziałów ---
        allowed_depts_from_groups = set()
        if selected_grupy:
            group_mapping = app_settings.get_group_mapping()
            for group_name in selected_grupy:
                allowed_depts_from_groups.update(group_mapping.get(group_name, set()))

            # Część wspólna: jeśli wybrano też konkretne wydziały, zawęź wybór
            if selected_wydzialy:
                selected_wydzialy = selected_wydzialy.intersection(allowed_depts_from_groups)
            else:
                selected_wydzialy = allowed_depts_from_groups

        # --- 4. Główna pętla filtrowania ---
        filtered_data = {}

        for key, data in self.processed_data.items():
            # Struktura klucza: (Wydział, Przełożony, UżytkownikDane, UżytkownikID)

            # --- A. Filtry statyczne ---
            if selected_locations_default and data.get('sched_lokalizacja') not in selected_locations_default:
                continue

            if selected_wydzialy and key[0] not in selected_wydzialy:
                continue

            # Przełożony: filtrowanie po tekście (key[1])
            if selected_przelozeni and key[1] not in selected_przelozeni:
                continue

            # Użytkownik: filtrowanie po ID (key[3])
            if selected_uzytkownicy_ids and key[3] not in selected_uzytkownicy_ids:
                continue

            if selected_dtn and str(data.get('sched_dtn', '')) not in selected_dtn:
                continue
            if selected_role and data.get('sched_rola', '') not in selected_role:
                continue
            # Grafik za punkty
            # Pobieramy wartość, zamieniamy None/Pusty na ''
            val_grafik = str(data.get('sched_grafik_za_punkty') or '')
            if not val_grafik.strip(): val_grafik = 'NIE'  # Dodatkowe zabezpieczenie dla pustego stringa

            if selected_grafik_pkt and val_grafik not in selected_grafik_pkt:
                continue

            # Brak nocki
            val_nocki = str(data.get('sched_brak_nocki') or '')
            if not val_nocki.strip(): val_nocki = 'NIE'

            if selected_brak_nocki and val_nocki not in selected_brak_nocki:
                continue
            if selected_jezyki and data.get('sched_jezyk', '') not in selected_jezyki:
                continue
            if selected_etaty and str(data.get('sched_etat', '')) not in selected_etaty:
                continue
            if selected_scp and data.get('sched_system_pracy', '') not in selected_scp:
                continue
            if selected_rka and data.get('sched_rka', '') not in selected_rka:
                continue
            if selected_podrola and data.get('sched_podrola', '') not in selected_podrola:
                continue

            # --- B. Filtry niestandardowe ---
            if active_custom_filters:
                user_id = str(key[3])
                should_skip_user = False

                # Budujemy klucz uwzględniający rok i miesiąc: "ID|ROK|MIESIĄC"
                storage_key = f"{user_id}|{current_year}|{current_month}"

                for col_id, selected_values in active_custom_filters.items():
                    # Pobieramy wartość używając poprawnego klucza czasowego
                    user_value = self.custom_columns[col_id]['values'].get(storage_key)

                    # Jeśli brak wartości lub wartość nie jest na liście wybranych -> pomiń
                    if not user_value or user_value not in selected_values:
                        should_skip_user = True
                        break

                if should_skip_user:
                    continue

            # --- C. Filtr "Obecni w pracy" ---
            if show_only_at_work:
                # Pomijamy osoby z DTN=1 w filtrze obecności (zgodnie z logiką biznesową)
                if data.get('sched_dtn') == 1:
                    continue

                selected_date = self.presence_date_edit.date()

                # --- FIX: Sprawdź czy data pasuje do bieżącego widoku ---
                if selected_date.year() != self.year or selected_date.month() != self.month:
                    continue
                    # ------------------------------------------------------

                day_to_check = selected_date.day()

                # Pobierz kryteria filtra obecności
                selected_hours = {int(h.split(':')[0]) for h in self.presence_hour_combo.get_selected_items()}
                selected_locations_str = self.presence_location_combo.get_selected_items()

                selected_locations = set()
                has_no_location_filter = False
                if selected_locations_str:
                    for loc_str in selected_locations_str:
                        if loc_str == "Bez lokalizacji":
                            has_no_location_filter = True
                        elif "(" in loc_str and loc_str.endswith(")"):
                            code = loc_str.split('(')[-1].replace(')', '').strip()
                            selected_locations.add(code)

                # Sprawdź grafik na ten dzień
                day_data = data.get('days', {}).get(day_to_check, {})
                symbol = day_data.get('symbol', '')
                parsed = parse_symbol(symbol)
                special_symbol = parsed.get('special_symbol')

                is_working_schedule = False
                employee_hours_today = set()
                employee_location_today = None

                # Analiza grafiku (czy pracuje?)
                if symbol and (not special_symbol or special_symbol in app_settings.WORK_LIKE_SYMBOLS):
                    start_hour = parsed.get('start_hour')
                    work_hours = parsed.get('work_hours')
                    if start_hour is not None and work_hours is not None:
                        is_working_schedule = True
                        for h in range(int(work_hours)):
                            employee_hours_today.add((start_hour + h) % 24)
                        employee_location_today = parsed.get('location') or data.get('lokalizacja_domyslna')

                # Analiza nadgodzin (czy ma nadgodziny?)
                user_id = key[3]
                date_str = selected_date.toString("yyyy-MM-dd")
                # Używamy metody z DataProvidera, aby pobrać eventy
                user_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                overtime_events = [e for e in user_events if e.get('type') == 'Nadgodziny']

                if overtime_events:
                    for event in overtime_events:
                        try:
                            t_from = datetime.strptime(event.get('time_from'), '%Y-%m-%d %H:%M')
                            t_to = datetime.strptime(event.get('time_to'), '%Y-%m-%d %H:%M')
                            duration_hours = (t_to - t_from).total_seconds() / 3600.0
                            if duration_hours < 0: duration_hours += 24.0
                            for h in range(int(math.ceil(duration_hours))):
                                employee_hours_today.add((t_from.hour + h) % 24)
                        except (ValueError, TypeError):
                            pass

                # Jeśli nie pracuje i nie ma nadgodzin -> pomiń
                if not is_working_schedule and not overtime_events:
                    continue

                # Sprawdzenie godzin
                if selected_hours:
                    if not employee_hours_today.intersection(selected_hours):
                        continue

                # Sprawdzenie lokalizacji
                if selected_locations or has_no_location_filter:
                    # Lokalizację sprawdzamy tylko dla zmian grafikowych (nadgodziny mają własną logikę, tu uproszczone)
                    if not is_working_schedule:
                        continue

                    is_match = False
                    if employee_location_today in selected_locations:
                        is_match = True
                    if has_no_location_filter and employee_location_today is None:
                        is_match = True

                    if not is_match:
                        continue

            # --- D. NOWOŚĆ: Filtr "Nieobecni w pracy" ---
            if show_only_absent:
                # Pomijamy osoby z DTN=1 (zgodnie z konwencją)
                if data.get('sched_dtn') == 1:
                    continue

                # --- FIX: Sprawdź czy data pasuje do bieżącego widoku ---
                if abs_date.year() != self.year or abs_date.month() != self.month:
                    continue
                # ------------------------------------------------------

                # Pobierz dane dla wybranego dnia
                day_data = data.get('days', {}).get(abs_day, {})
                symbol = day_data.get('symbol', '')
                parsed = parse_symbol(symbol)
                spec_symbol = parsed.get('special_symbol')

                # 1. Sprawdź, czy to w ogóle jest absencja
                if not spec_symbol or spec_symbol.upper() not in app_settings.get_absence_symbols():
                    continue

                # 2. Filtr Symboli (jeśli wybrano konkretne)
                if selected_abs_symbols and spec_symbol.upper() not in selected_abs_symbols:
                    continue

                # 3. Filtr Godziny Rozpoczęcia (jeśli wybrano konkretne)
                # Uwaga: Absencje całodzienne (bez godziny) mają start_hour = None.
                # Jeśli użytkownik wybrał konkretne godziny, a absencja nie ma godziny -> odrzucamy.
                if selected_abs_hours:
                    start_h = parsed.get('start_hour')
                    if start_h is None or start_h not in selected_abs_hours:
                        continue

            # Jeśli pracownik przeszedł wszystkie filtry, dodaj go do wyników
            filtered_data[key] = data

        return filtered_data

    def _cancel_delegations(self, events_to_cancel_input: List[Dict]):
        debug_print(f"Rozpoczynam _cancel_delegations dla {len(events_to_cancel_input)} zdarzeń.")
        if not events_to_cancel_input:
            return 0

        successful_db_updates = 0
        # Lista par (user_id, date_key) dla zdarzeń, które zostały pomyślnie zaktualizowane w DB
        affected_user_date_pairs_for_refresh = set()

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            user_app_id, _, _, _, _, _ = get_modifier_id()

            for event_details in events_to_cancel_input:
                event_id = event_details.get('id')
                event_type = event_details.get('type')
                user_id_for_event = event_details.get('user_id')  # Użyj user_id z event_details
                date_key_for_event = event_details.get('date_key', event_details.get('date'))

                if not event_id or not event_type or not user_id_for_event or not date_key_for_event:
                    log_warning(f"Pominięto zdarzenie z niepełnymi danymi w _cancel_delegations: {event_details}")
                    continue

                table_name = ""
                if event_type == "Spotkanie":
                    table_name = SQL_OBJECTS['spotkania']
                elif event_type == "Szkolenie":
                    table_name = SQL_OBJECTS['szkolenia']
                elif event_type == "Nadgodziny":
                    table_name = SQL_OBJECTS['nadgodziny']

                if not table_name:
                    log_warning(f"Nieznany typ zdarzenia w _cancel_delegations: {event_type}")
                    continue

                try:
                    if event_type in ["Spotkanie", "Szkolenie"]:
                        update_query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                        cursor.execute(update_query, (user_app_id, event_id))
                    else:  # Nadgodziny
                        delete_query = f"DELETE FROM {table_name} WHERE Id = ?"
                        cursor.execute(delete_query, (event_id,))

                    if cursor.rowcount > 0:
                        successful_db_updates += 1
                        affected_user_date_pairs_for_refresh.add((user_id_for_event, date_key_for_event))
                        debug_print(f"DB: Pomyślnie zaktualizowano/usunięto {event_type} ID {event_id}")
                    else:
                        log_warning(f"DB: Nie znaleziono {event_type} ID {event_id} do aktualizacji/usunięcia.")

                except Exception as db_err:
                    log_error(f"Błąd DB podczas odwoływania {event_type} ID {event_id}: {db_err}", exception=db_err)

            if successful_db_updates > 0:
                conn.commit()
                debug_print(f"DB: Zatwierdzono {successful_db_updates} zmian.")
                # Rejestrujemy, że to my dokonaliśmy zmiany w bazie danych
                self._update_modification_date()
            conn.close()

        except Exception as e:
            log_error(f"Generalny błąd w _cancel_delegations podczas operacji DB: {e}", exception=e)
            return 0  # Zwróć 0 jeśli wystąpił błąd przed aktualizacją UI

        # Jeśli były jakiekolwiek udane aktualizacje w DB
        if affected_user_date_pairs_for_refresh:
            debug_print(
                f"_cancel_delegations: Uruchamiam odświeżanie DataProvider dla {len(affected_user_date_pairs_for_refresh)} par.")
            # Krok 1: Unieważnij i odśwież cache DataProvider dla dotkniętych zdarzeń/miesięcy
            self.data_provider.invalidate_complete_cache_for_pairs(list(affected_user_date_pairs_for_refresh))

            # Krok 2: Odśwież tabelę zdarzeń - on_selection_changed użyje świeżych danych z DataProvider
            # Ta metoda zaktualizuje self.events_data i self.events_model
            debug_print(f"_cancel_delegations: Uruchamiam on_selection_changed() w celu odświeżenia tabeli zdarzeń.")
            selected_cells_data = self.table.get_data_for_selected_cells()  # Pobierz aktualnie zaznaczone komórki
            if selected_cells_data:
                self.on_selection_changed()  # To powinno teraz poprawnie wyczyścić zdarzenia
            else:  # Jeśli nic nie jest zaznaczone, wyczyść tabelę zdarzeń ręcznie
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])
                debug_print("_cancel_delegations: Brak zaznaczenia, wyczyszczono tabelę zdarzeń.")

            # Krok 3: Zaktualizuj ikony w tabeli grafiku na podstawie świeżych danych z DataProvider
            if hasattr(self, 'schedule_model'):
                debug_print(
                    f"_cancel_delegations: Uruchamiam aktualizację ikon grafiku dla {len(affected_user_date_pairs_for_refresh)} par.")
                for user_id, date_str in affected_user_date_pairs_for_refresh:
                    # Pobierz aktualne aktywne zdarzenia dla tej komórki z DataProvider
                    # DataProvider powinien teraz mieć świeże dane po invalidate_complete_cache_for_pairs
                    remaining_active_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                    has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_active_events)
                    has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_active_events)
                    has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_active_events)

                    self.schedule_model.update_cell_icons_directly(
                        user_id, date_str, has_meetings, has_trainings, has_overtime
                    )

            # Wymuś odświeżenie widoków tabel, jeśli to konieczne
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        debug_print(f"_cancel_delegations: Zakończono, pomyślnie przetworzono w DB: {successful_db_updates} zdarzeń.")
        return successful_db_updates

    def update_filter_dates(self):
        """Aktualizuje daty filtrowania do pierwszego i ostatniego dnia wybranego miesiąca"""
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # KLUCZOWA POPRAWKA: Blokuj sygnały przed zmianą dat
        self.date_from.blockSignals(True)
        self.date_to.blockSignals(True)

        try:
            # Pierwszy dzień miesiąca
            first_day = QDate(year, month, 1)
            self.date_from.setDate(first_day)

            # Ostatni dzień miesiąca
            if month == 12:
                next_month = QDate(year + 1, 1, 1)
            else:
                next_month = QDate(year, month + 1, 1)

            last_day = next_month.addDays(-1)
            self.date_to.setDate(last_day)

        finally:
            # ZAWSZE odblokuj sygnały
            self.date_from.blockSignals(False)
            self.date_to.blockSignals(False)

        # Wywołaj filtrowanie tylko RAZ po wszystkich zmianach
        self.filter_events_table()

    def update_data(self, year, month, grupa, funkcja, use_async=True, filters_to_restore=None):
        """
        NOWA WERSJA: Ładowanie danych z opcją przekazania stanu filtrów do przywrócenia.
        """
        debug_print(f"Rozpoczynam ładowanie danych dla {year}-{month} (async={use_async})")

        self.year = year
        self.month = month

        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            self.schedule_model = ScheduleTableModel(self)
            self.schedule_model.set_theme(self.is_dark_theme)
            ui_columns = self.column_definitions.get_ui_display_columns()
            visible_cols = self.visible_columns
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

        if not hasattr(self, 'events_model') or not self.events_model:
            self.events_model = EventsTableModel(self)
            self.events_model.set_theme(self.is_dark_theme)

        if use_async:
            self._load_data_async(year, month, filters_to_restore=filters_to_restore)
        else:
            self._load_data_sync(year, month, filters_to_restore=filters_to_restore)

    def _load_data_sync(self, year, month):
        """
        Synchroniczne ładowanie danych (fallback), teraz spójne z logiką asynchroniczną.
        """
        debug_print(f"Ładowanie synchroniczne dla {year}-{month}")

        try:
            if hasattr(self, 'statusBar'):
                self.statusBar().showMessage(f"Ładowanie danych {year}-{month} ...")

            # Krok 1: Pobierz kontener z danymi bazowymi
            container = self.data_provider._get_or_load_monthly_data(
                year, month, self.import_grupa, self.import_funkcja, use_cache=False
            )

            if container:
                # Krok 2: Pobierz przetworzone dane z nałożonymi ikonami
                processed_data_with_icons = self.data_provider.get_processed_data(
                    year, month, self.import_grupa, self.import_funkcja
                )

                # Krok 3: Zastosuj wszystkie dane
                self._apply_loaded_data({
                    'schedule_data': container.schedule_data,
                    'events_data': container.events_data,
                    'processed_data': processed_data_with_icons,  # Używamy danych z ikonami
                    'year': year,
                    'month': month
                })
            else:
                log_error("Nie udało się pobrać danych z DataProvider w trybie synchronicznym.")

        except Exception as e:
            log_error(f"Błąd podczas synchronicznego ładowania: {e}", exception=e)

        finally:
            if hasattr(self, 'statusBar'):
                self.statusBar().clearMessage()

    def _load_data_async(self, year, month, filters_to_restore=None):
        """Asynchroniczne ładowanie danych z progress dialogiem."""
        from functools import partial

        debug_print(f"Uruchamiam async ładowanie dla {year}-{month}")

        # --- NOWA LOGIKA: Użycie nowoczesnego wskaźnika ładowania ---
        self.loading_indicator = ModernLoadingIndicator(self, f"Ładowanie danych dla {year}-{month}...")
        self.loading_indicator.show()

        self.loading_thread = PreparationThread(self.data_provider, year, month, self.import_grupa, self.import_funkcja)
        self.loading_thread.preparation_finished.connect(
            partial(self._on_async_data_loaded, filters_to_restore=filters_to_restore))
        self.loading_thread.error_occurred.connect(self._on_async_loading_failed)
        self.loading_thread.finished.connect(self.loading_indicator.hide)
        self.loading_thread.finished.connect(self.loading_thread.deleteLater)

        self.loading_thread.start()

    def _on_async_data_loaded(self, data, filters_to_restore=None):
        """Obsługuje pomyślne załadowanie danych async."""
        debug_print("Otrzymano dane z async loading")
        try:
            # --- NOWA SEKCJA: Czyszczenie powiadomień po udanym odświeżeniu ---
            if hasattr(self, 'notification_drawer') and self.notification_drawer:
                # 1. Usuń wszystkie kafelki
                self.notification_drawer.clear_notifications()
                debug_print("Wyczyszczono powiadomienia po odświeżeniu danych.")

            if hasattr(self, 'notification_btn'):
                # 2. Przywróć domyślny (szary/przezroczysty) styl dzwonka
                current_theme = 'dark' if self.is_dark_theme else 'light'
                style = AppStyles.get_icon_button_style(current_theme)
                self.notification_btn.setStyleSheet(style)
            # ------------------------------------------------------------------

            is_initial_load = self.schedule_model.rowCount() == 0

            # Zapisz stan widoku (sortowanie i zaznaczenie) przed resetem modelu
            view_state = self._save_view_state()

            self._apply_loaded_data(data, filters_to_restore=filters_to_restore)

            # Zawsze przywracaj stan widoku, chyba że jest to pierwsze ładowanie
            if not is_initial_load:
                debug_print("Przywracanie stanu widoku po załadowaniu asynchronicznym...")
                self._restore_view_state(view_state)

            debug_print("Pomyślnie zastosowano dane z async loading")

        except Exception as e:
            log_error(f"Błąd podczas stosowania załadowanych danych: {e}", exception=e)
        finally:
            self._is_refreshing_data = False
            debug_print("Ustawiono flagę _is_refreshing_data = False (w bloku finally)")

    def _on_async_loading_failed(self, error_message):
        """Obsługuje błędy async loading."""
        debug_print(f"Async loading failed: {error_message}")
        QMessageBox.critical(self, "Błąd ładowania danych",
                             f"Nie udało się załadować danych:<br>{error_message}<br><br>Spróbuj ponownie lub skontaktuj się z administratorem.",
                             QMessageBox.Ok)
        try:
            debug_print("Próbuję fallback do synchronicznego ładowania")
            self._load_data_sync(self.year, self.month)
        except Exception as e:
            log_error(f"Fallback loading też nie powiódł się: {e}")

    def _apply_loaded_data(self, data, filters_to_restore=None):
        """Aplikuje nowo załadowane dane do modeli i UI."""
        if data is None:
            log_error("Błąd: _apply_loaded_data otrzymało puste dane (None).")
            return

        # --- FIX: BLOKADA PRZED RESETEM MODELU ---
        # Ustawiamy flagę na True PRZED jakąkolwiek ingerencją w model.
        # To sprawi, że metoda _on_column_resized zignoruje wszystkie sygnały
        # generowane podczas resetowania i wypełniania tabeli.
        self._is_updating_layout = True
        # -----------------------------------------

        try:
            schedule_data = data.get('schedule_data', [])
            events_data = data.get('events_data', [])
            processed_data = data.get('processed_data', {})
            year = data.get('year')
            month = data.get('month')

            if processed_data is None or year is None or month is None:
                log_error(f"Niekompletne dane przekazane do _apply_loaded_data: rok={year}, miesiac={month}")
                return

            self.raw_data = schedule_data
            self.all_events_data = events_data
            self.processed_data = processed_data

            is_initial_load = self.schedule_model.rowCount() == 0

            # KRYTYCZNY MOMENT: To wywołanie resetuje model.
            # Bez blokady, widok zresetowałby kolumny do domyślnych szerokości,
            # a _on_column_resized nadpisałby ustawienia użytkownika.
            # Dzięki fladze _is_updating_layout=True, ustawienia są bezpieczne.
            self.schedule_model.update_data(self.processed_data, year, month)

            if 'custom_columns' in self.user_app_settings:
                self.schedule_model.set_custom_columns(self.user_app_settings['custom_columns'])

            self.events_data = []
            if 'row_colors' in self.user_app_settings:
                self.schedule_model.set_row_colors(self.user_app_settings['row_colors'])

            if hasattr(self, 'events_model'):
                self.events_model.update_data([])
            self.all_events_data = data.get('events_data', [])

            if hasattr(self, 'status_filter_combo'):
                all_statuses = sorted(list(set(e.get('status', '') for e in self.all_events_data if e.get('status'))))
                self.status_filter_combo.add_items(all_statuses)
                self.status_filter_combo.select_items(all_statuses)

            if filters_to_restore:
                self.restore_filters_state(filters_to_restore)
            else:
                last_filters = self.user_app_settings.get('last_filters')
                if last_filters:
                    self.restore_filters_state(last_filters)
                else:
                    self.update_filters()
                    self.filter_data()

            if is_initial_load:
                self.apply_custom_sort()

            # Na końcu aplikujemy poprawne szerokości z nienaruszonej pamięci ustawień.
            # Metoda _apply_dynamic_sizes zarządza własną blokadą (wewnątrz),
            # ale ponieważ jesteśmy w bloku try...finally, jest to bezpieczne.
            self._apply_dynamic_sizes()
            self.setup_events_table_columns()

        finally:
            # --- ZDEJMOWANIE BLOKADY ---
            # Zawsze zdejmujemy blokadę na końcu, aby przywrócić
            # możliwość ręcznego zmieniania rozmiaru przez użytkownika.
            self._is_updating_layout = False
            # ---------------------------

    def apply_default_sort(self):
        """
        Ręcznie sortuje dane w modelu zgodnie z domyślną, wielopoziomową
        kolejnością i wymusza odświeżenie widoku.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model._processed_data:
            return

        debug_print("Aplikowanie domyślnego, wielopoziomowego sortowania...")

        # Pobieramy klucze i pełne dane do sortowania
        keys_to_sort = self.schedule_model._keys
        processed_data = self.schedule_model._processed_data

        # Sortujemy klucze według docelowej kolejności
        sorted_keys = sorted(keys_to_sort, key=lambda k: (
            processed_data[k].get('dtn', 0),  # 1. Po DTN
            k[0] or '',  # 2. Po Wydziale
            k[1] or '',  # 3. Po Przełożonym
            k[2] or ''  # 4. Po Użytkowniku
        ))

        # Ustawiamy nową, posortowaną listę kluczy w modelu
        self.schedule_model._keys = sorted_keys

        # Informujemy widok, że układ modelu uległ całkowitej zmianie
        self.schedule_model.layoutChanged.emit()
        debug_print("Zakończono domyślne sortowanie. Widok został odświeżony.")

    def clear_events_cache(self, year, month):
        """
        Czyści cache zdarzeń dla danego miesiąca - UPROSZCZONA WERSJA

        Args:
            year: Rok
            month: Miesiąc
        """
        # POPRAWKA: Deleguj TYLKO do DataProvider, bez dodatkowych akcji
        if hasattr(self.data_provider, 'invalidate_icons_cache'):
            self.data_provider.invalidate_icons_cache(year, month)
            debug_print(f"Wyczyszczono cache zdarzeń dla {year}-{month}")
        else:
            debug_print(f"DataProvider nie ma metody invalidate_icons_cache")

    def get_events_for_user_date(self, user_id, date_str):
        """
        UPROSZCZONA METODA: Deleguje do DataProvider
        """
        return self.data_provider.get_events_for_user_date(user_id, date_str)

    def refresh_column_configuration(self):
        """Odświeża konfigurację kolumn w modelu i widoku bez resetowania modelu."""
        ui_columns = self.column_definitions.get_ui_display_columns()
        visible_cols = self.visible_columns

        # Aktualizuj referencje w głównej klasie
        self.employee_columns = ui_columns

        if hasattr(self, 'schedule_model') and self.schedule_model:
            # Poinformuj model o nowej konfiguracji kolumn
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

            # Jeśli tabela już istnieje, poinformuj ją, aby na nowo ustawiła widoczność kolumn
            if hasattr(self, 'table') and self.table:
                self.schedule_model.layoutChanged.emit()  # Sygnał, że struktura się zmieniła
                self.table.setup_columns()  # Wywołanie nowej, dedykowanej metody

    def setup_event_table_columns(self):
        """
        Konfiguruje szerokości kolumn tabeli zdarzeń.
        Wyodrębnione z metody update_data dla lepszej czytelności.
        """
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Użytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

    def show_loading_indicator(self, message="Ładowanie..."):
        """
        Pokazuje wskaźnik ładowania w UI
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().showMessage(message)

        # Wyłącz niektóre kontrolki podczas ładowania
        self.date_combo.setEnabled(False)
        self.refresh_button.setEnabled(False)

        if hasattr(self, 'left_panel_visible') and self.left_panel_visible:
            self._left_panel.setEnabled(False)

    def hide_loading_indicator(self):
        """
        Ukrywa wskaźnik ładowania
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().clearMessage()

        # Włącz z powrotem kontrolki
        self.date_combo.setEnabled(True)
        self.refresh_button.setEnabled(True)

        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(True)

    def get_loading_preferences(self):
        """
        Zwraca preferencje użytkownika dotyczące ładowania
        """
        # Można dodać ustawienia w settings_db dla kontroli async loading
        # Na razie zawsze async dla dużych zbiorów danych
        return {
            'use_async_threshold': 1000,  # Użyj async dla >1000 wierszy
            'show_progress_dialog': True,
            'auto_fallback_to_sync': True
        }

    def update_cross_filters(self):
        """
        Aktualizuje filtry wzajemnie, ale zamiast przebudowywać listy,
        jedynie ukrywa/pokazuje istniejące elementy.
        WERSJA POPRAWIONA: Poprawnie obsługuje ID użytkownika i wyszukiwanie.
        """
        if not getattr(self, '_cross_filtering_enabled', True):
            return

        if not hasattr(self, 'processed_data') or not self.processed_data:
            return

        if getattr(self, '_updating_cross_filters', False):
            return

        self._updating_cross_filters = True
        try:
            # Pobranie aktualnych wyborów
            selected_wydzialy = self.wydzial_combo.get_selected_items()
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
            # Ta metoda (get_list_selected_data) poprawnie zwraca ID (z Qt.UserRole)
            selected_uzytkownik_ids = self.get_list_selected_data(self.uzytkownik_list)

            # Pobranie tekstu z pól wyszukiwania
            przelozony_search_text = self.przelozony_filter.text().lower().strip()
            uzytkownik_search_text = self.uzytkownik_filter.text().lower().strip()

            # === AKTUALIZACJA LISTY PRZEŁOŻONYCH ===
            if hasattr(self, 'przelozony_list'):
                # Oblicz, którzy przełożeni powinni być widoczni (z filtrów nadrzędnych)
                available_przelozeni = set()
                if selected_wydzialy:
                    for key in self.processed_data.keys():
                        if key[0] in selected_wydzialy and key[1]:
                            available_przelozeni.add(key[1])
                else:
                    for key in self.processed_data.keys():
                        if key[1]: available_przelozeni.add(key[1])

                # Pokaż/ukryj elementy
                self.przelozony_list.blockSignals(True)
                for i in range(self.przelozony_list.count()):
                    item = self.przelozony_list.item(i)
                    item_text = item.text()
                    item_text_lower = item_text.lower()

                    # Warunek 1: Czy pasuje do filtrów nadrzędnych?
                    is_in_available = item_text in available_przelozeni
                    # Warunek 2: Czy pasuje do pola wyszukiwania?
                    matches_search = self._matches_supervisor_search(item_text_lower, przelozony_search_text)

                    # Pokaż tylko, jeśli oba warunki są spełnione
                    item.setHidden(not (is_in_available and matches_search))
                self.przelozony_list.blockSignals(False)

            # === AKTUALIZACJA LISTY UŻYTKOWNIKÓW ===
            if hasattr(self, 'uzytkownik_list'):

                # --- POPRAWIONA LOGIKA: Zbieraj ID użytkowników, a nie loginy ---
                available_uzytkownik_ids = set()  # ZMIANA NAZWY
                for key, data in self.processed_data.items():
                    wydzial, przelozony, _, user_id = key  # Pobierz user_id (key[3])

                    if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                            (not selected_przelozeni or przelozony in selected_przelozeni):
                        if user_id:
                            available_uzytkownik_ids.add(user_id)  # Dodaj ID
                # --- KONIEC POPRAWIONEJ LOGIKI ---

                # Pokaż/ukryj elementy
                self.uzytkownik_list.blockSignals(True)
                for i in range(self.uzytkownik_list.count()):
                    item = self.uzytkownik_list.item(i)
                    item_text_lower = item.text().lower()

                    # --- POCZĄTEK POPRAWKI BŁĘDU ---
                    # Poprawnie pobierz wszystkie 3 wartości
                    item_id = item.data(Qt.UserRole)  # Pobierz ID (Qt.UserRole)
                    item_id_str = str(item_id or '').lower()
                    item_login_lower = str(item.data(Qt.UserRole + 1) or '').lower()  # Pobierz Login (Qt.UserRole + 1)

                    # Warunek 1: Czy pasuje do filtrów nadrzędnych? (Porównaj ID)
                    is_in_available = item_id in available_uzytkownik_ids

                    # Warunek 2: Czy pasuje do pola wyszukiwania? (Przekaż wszystkie 4 argumenty)
                    matches_search = self._matches_user_search(
                        item_text_lower,
                        item_id_str,  # Argument 1: item_id
                        item_login_lower,  # Argument 2: item_login
                        uzytkownik_search_text  # Argument 3: search_text
                    )
                    # --- KONIEC POPRAWKI BŁĘDU ---

                    # Pokaż tylko, jeśli oba warunki są spełnione
                    item.setHidden(not (is_in_available and matches_search))
                self.uzytkownik_list.blockSignals(False)

        except Exception as e:
            log_error(f"Błąd podczas cross-filtrowania: {e}", exception=e)
        finally:
            self._updating_cross_filters = False

    def update_list_safely(self, list_widget, items, selected_items):
        """
        Bezpiecznie aktualizuje QListWidget, blokując sygnały na czas modyfikacji.
        """
        if not list_widget:
            return

        list_widget.blockSignals(True)
        try:
            # Zapamiętanie, co jest aktualnie widoczne z pola wyszukiwania
            search_text = ""
            if list_widget is self.przelozony_list:
                search_text = self.przelozony_filter.text().lower()
            elif list_widget is self.uzytkownik_list:
                search_text = self.uzytkownik_filter.text().lower()

            # --- POCZĄTEK NOWEJ LOGIKI: Ukrywanie zamiast czyszczenia ---
            # Zamiast czyścić listę, przejdziemy po istniejących elementach
            # i ukryjemy te, które nie znajdują się w nowym zestawie 'items'.
            # To zachowuje pozycję przewijania i zaznaczenie.

            all_current_items = {list_widget.item(i).text() for i in range(list_widget.count())}
            new_items_set = set(items)

            # Ukryj elementy, których już nie ma
            for i in range(list_widget.count()):
                item = list_widget.item(i)
                if item.text() not in new_items_set:
                    item.setHidden(True)

            # Dodaj nowe elementy, których jeszcze nie ma na liście
            for item_text in new_items_set:
                if item_text not in all_current_items:
                    item = QListWidgetItem(item_text)
                    list_widget.addItem(item)

            # Pokaż elementy, które są w nowym zestawie i mogły być wcześniej ukryte
            for i in range(list_widget.count()):
                item = list_widget.item(i)
                if item.text() in new_items_set:
                    item.setHidden(False)
                    # Przywróć zaznaczenie
                    if item.text() in selected_items:
                        item.setSelected(True)
                    # Przywróć ukrycie na podstawie filtra wyszukiwania
                    if search_text and search_text not in item.text().lower():
                        item.setHidden(True)
            # --- KONIEC NOWEJ LOGIKI ---

            # list_widget.clear()
            # for item_text in sorted(items):
            #     item = QListWidgetItem(item_text)
            #     list_widget.addItem(item)
            #     if item_text in selected_items:
            #         item.setSelected(True)
            #
            #     # Przywrócenie ukrycia na podstawie filtra wyszukiwania
            #     if search_text and search_text not in item_text.lower():
            #         item.setHidden(True)

        finally:
            list_widget.blockSignals(False)

    def get_current_filters_state(self):
        """Zapisuje aktualnie wybrane wartości ze wszystkich ISTNIEJĄCYCH filtrów do słownika."""
        state = {
            'grupa': self.grupa_main_filter_combo.currentText(),
            'wydzial': self.wydzial_combo.get_selected_items(),

            # Przełożony: Zapisuje tekst (stara logika)
            'przelozony': self.get_list_selected_items(self.przelozony_list),

            # Użytkownik: Zapisuje login (nowa logika)
            'uzytkownik': self.get_list_selected_data(self.uzytkownik_list),

            'lokalizacja_domyslna': self.default_location_combo.get_selected_items(),
            'system_czasu_pracy': self.system_czasu_pracy_combo.get_selected_items(),
            'rola': self.rola_combo.get_selected_items(),
            'jezyk': self.jezyk_combo.get_selected_items(),
            'etat': self.etat_combo.get_selected_items(),
            'dtn': self.dtn_combo.get_selected_items(),
            'rka': self.rka_combo.get_selected_items(),
            'podrola': self.podrola_combo.get_selected_items(),
            'grafik_za_punkty': self.grafik_za_punkty_combo.get_selected_items(),
            'brak_nocki': self.brak_nocki_combo.get_selected_items(),
            # --- NOWOŚĆ: Stan filtra nieobecności ---
            'absence_checked': self.filter_by_absence_check.isChecked(),
            'absence_date': self.absence_date_edit.date().toString("yyyy-MM-dd"),
            'absence_symbols': self.absence_symbol_combo.get_selected_items(),
            'absence_hours': self.absence_hour_combo.get_selected_items(),
        }

        # --- NOWA LOGIKA: Zapisywanie filtrów niestandardowych ---
        for col_id in self.custom_columns.keys():
            container_widget = self.filter_widget_map.get(col_id)
            if container_widget:
                combo = container_widget.findChild(CustomMultiComboBox)
                if combo:
                    state[col_id] = combo.get_selected_items()
        # --- KONIEC NOWEJ LOGIKI ---

        debug_print(f"Zapisano stan filtrów: {state}")
        return state

    def restore_filters_state(self, state):
        """
        Przywraca zapisany stan filtrów po załadowaniu nowych danych.
        """
        debug_print("Rozpoczynam przywracanie stanu filtrów...")

        self._cross_filtering_enabled = False

        try:
            # Wypełnij wszystkie ComboBoxy i listy nowymi danymi
            # (Ta metoda musi być wywołana jako pierwsza)
            self.update_filters()

            # --- Przywracanie zaznaczeń ---

            self.grupa_main_filter_combo.blockSignals(True)
            self.grupa_main_filter_combo.setCurrentText(state.get('grupa', '(Wszyscy)'))
            self.grupa_main_filter_combo.blockSignals(False)

            self.wydzial_combo.select_items(state.get('wydzial', []))
            self.default_location_combo.select_items(state.get('lokalizacja_domyslna', []))
            self.system_czasu_pracy_combo.select_items(state.get('system_czasu_pracy', []))
            self.rola_combo.select_items(state.get('rola', []))
            self.jezyk_combo.select_items(state.get('jezyk', []))
            self.etat_combo.select_items(state.get('etat', []))
            self.dtn_combo.select_items(state.get('dtn', []))
            self.rka_combo.select_items(state.get('rka', []))
            self.podrola_combo.select_items(state.get('podrola', []))
            self.grafik_za_punkty_combo.select_items(state.get('grafik_za_punkty', []))
            self.brak_nocki_combo.select_items(state.get('brak_nocki', []))

            # --- NOWOŚĆ: Przywracanie filtra nieobecności ---
            if state.get('absence_checked', False):
                self.filter_by_absence_check.setChecked(True)

            self.absence_symbol_combo.select_items(state.get('absence_symbols', []))
            self.absence_hour_combo.select_items(state.get('absence_hours', []))
            self.presence_date_edit.setDate(QDate.currentDate())

            # Przywróć przełożonego (używa tekstu)
            przelozeni_items_text = state.get('przelozony', [])
            for i in range(self.przelozony_list.count()):
                item = self.przelozony_list.item(i)
                if item.text() in przelozeni_items_text:
                    item.setSelected(True)

            # Przywróć użytkownika (używa loginu z Qt.UserRole)
            uzytkownik_items_logins = state.get('uzytkownik', [])
            for i in range(self.uzytkownik_list.count()):
                item = self.uzytkownik_list.item(i)
                if item.data(Qt.UserRole) in uzytkownik_items_logins:
                    item.setSelected(True)

            # --- NOWA LOGIKA: Przywracanie filtrów niestandardowych ---
            for col_id in self.custom_columns.keys():
                container_widget = self.filter_widget_map.get(col_id)
                if container_widget:
                    combo = container_widget.findChild(CustomMultiComboBox)
                    if combo:
                        combo.select_items(state.get(col_id, []))
            # --- KONIEC NOWEJ LOGIKI ---

        finally:
            self._cross_filtering_enabled = True
            debug_print("Zakończono przywracanie stanu filtrów.")

        debug_print("Uruchamiam filtrowanie po przywróceniu stanu.")
        self.filter_data()

    def _get_unique_values_for_filter(self, filter_key):
        """
        Pobiera unikalne wartości dla danego filtra z aktualnie załadowanych
        danych, uwzględniając nowe nazwy kluczy (sched_...).
        """
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return set()

        unique_values = set()

        # Mapowanie: jeśli pytamy o klucz z krotki głównej, bierzemy go z indeksu
        # Klucze słownika DataProvider: (sched_wydzial, sched_przelozony, sched_user_display, sched_user_id)
        key_map = {
            'sched_wydzial': 0,
            'sched_przelozony': 1,
            'sched_user_display': 2
        }

        if filter_key in key_map:
            key_index = key_map[filter_key]
            for key_tuple in self.processed_data.keys():
                if len(key_tuple) > key_index and key_tuple[key_index]:
                    unique_values.add(str(key_tuple[key_index]))
        else:
            # Pobieranie ze słownika wartości
            for data_dict in self.processed_data.values():
                value = data_dict.get(filter_key)
                if value is not None and value != '':
                    unique_values.add(str(value))

        return unique_values

    def clear_filters(self):
        """Czyści wszystkie filtry i aktualizuje model."""
        debug_print("[Filtracja] Rozpoczynam czyszczenie wszystkich filtrów...")

        # Wyłączamy flagę, aby update_cross_filters nie działało w trakcie
        self._cross_filtering_enabled = False

        # Lista nazw comboboxów do wyczyszczenia
        combo_names_to_clear = [
            'grupa_main_filter_combo', 'wydzial_combo', 'dtn_combo',
            'rola_combo', 'jezyk_combo', 'etat_combo',
            'system_czasu_pracy_combo',
            'default_location_combo', 'rka_combo',
            'grafik_za_punkty_combo', 'brak_nocki_combo',
            'podrola_combo', 'presence_location_combo',
            'presence_hour_combo', 'absence_symbol_combo', 'absence_hour_combo'
        ]

        try:
            # 1. Wyczyść comboboxy (blokując ich sygnały do slotu filter_data)
            for combo_name in combo_names_to_clear:
                if hasattr(self, combo_name):
                    combo = getattr(self, combo_name)
                    # Odłączamy tymczasowo sygnał, aby clear_selection() nie wywołało filter_data()
                    try:
                        combo.selection_changed.disconnect(self.filter_data)
                    except (TypeError, RuntimeError):
                        pass  # Ignoruj, jeśli nie było połączone

                    combo.clear_selection()

                    # Podłączamy z powrotem
                    combo.selection_changed.connect(self.filter_data)

            # 1b. Wyczyść filtry niestandardowe (też blokując sygnały)
            for col_id in self.custom_columns.keys():
                container = self.filter_widget_map.get(col_id)
                if container:
                    combo = container.findChild(CustomMultiComboBox)
                    if combo:
                        try:
                            combo.selection_changed.disconnect(self.filter_data)
                        except:
                            pass
                        combo.clear_selection()
                        combo.selection_changed.connect(self.filter_data)

            # 2. Wyczyść listy (blokując sygnały widgetu)
            if hasattr(self, 'przelozony_list'):
                self.przelozony_list.blockSignals(True)
                self.przelozony_list.clearSelection()
                self.przelozony_list.blockSignals(False)

            if hasattr(self, 'uzytkownik_list'):
                self.uzytkownik_list.blockSignals(True)
                self.uzytkownik_list.clearSelection()
                self.uzytkownik_list.blockSignals(False)

                # 3. Wyczyść pola tekstowe
            if hasattr(self, 'przelozony_filter'):
                self.przelozony_filter.blockSignals(True)
                self.przelozony_filter.clear()
                self.przelozony_filter.blockSignals(False)

            if hasattr(self, 'uzytkownik_filter'):
                self.uzytkownik_filter.blockSignals(True)
                self.uzytkownik_filter.clear()
                self.uzytkownik_filter.blockSignals(False)

                # 4. Inne kontrolki (Checkboxy obecności i nieobecności)
            if hasattr(self, 'filter_by_presence_check'):
                self.filter_by_presence_check.blockSignals(True)
                self.filter_by_presence_check.setChecked(False)
                self.filter_by_presence_check.blockSignals(False)

                # --- NOWOŚĆ: Reset checkboxa nieobecności ---
            if hasattr(self, 'filter_by_absence_check'):
                self.filter_by_absence_check.blockSignals(True)
                self.filter_by_absence_check.setChecked(False)
                self.filter_by_absence_check.blockSignals(False)
                # --------------------------------------------

            if hasattr(self, 'saved_filters_combo'):
                self.saved_filters_combo.blockSignals(True)
                self.saved_filters_combo.setCurrentIndex(0)
                self.saved_filters_combo.blockSignals(False)

        finally:
            self._cross_filtering_enabled = True
            debug_print("[Filtracja] Wywołuję filter_data() po wyczyszczeniu filtrów.")
            self.filter_data()
            self._update_delete_button_state()

    def filter_przelozony_list(self, text):
        """
        Filtruje listę przełożonych na podstawie wpisanego tekstu,
        używając logiki substring lub wyszukiwania po przecinku.
        """
        if not hasattr(self, 'przelozony_list'):
            return

        search_text = text.lower().strip()

        # Zablokuj sygnały na czas filtrowania, aby uniknąć problemów
        self.przelozony_list.blockSignals(True)
        try:
            for i in range(self.przelozony_list.count()):
                item = self.przelozony_list.item(i)
                item_text = item.text().lower()

                # Użyj nowej funkcji pomocniczej do sprawdzenia dopasowania
                matches = self._matches_supervisor_search(item_text, search_text)

                # Ustaw widoczność TYLKO na podstawie wyszukiwania
                # Metoda update_cross_filters() zajmie się filtrami nadrzędnymi
                item.setHidden(not matches)
        finally:
            self.przelozony_list.blockSignals(False)

        # Wywołaj cross-filter, aby dodatkowo przefiltrować listę po zmianie tekstu
        self.update_cross_filters()

    def filter_uzytkownik_list(self, text):
        """
        Filtruje listę użytkowników na podstawie wpisanego tekstu,
        obsługując wyszukiwanie po loginie, nazwie lub liście loginów.
        """
        if not hasattr(self, 'uzytkownik_list'):
            return

        search_text = text.lower().strip()

        self.uzytkownik_list.blockSignals(True)
        try:
            for i in range(self.uzytkownik_list.count()):
                item = self.uzytkownik_list.item(i)
                item_text = item.text().lower()
                # Pobierz ID (Qt.UserRole)
                item_id = str(item.data(Qt.UserRole) or '').lower()
                # Pobierz Login (Qt.UserRole + 1)
                item_login = str(item.data(Qt.UserRole + 1) or '').lower()

                # Użyj nowej funkcji pomocniczej do sprawdzenia dopasowania
                matches = self._matches_user_search(item_text, item_id, item_login, search_text)

                item.setHidden(not matches)
        finally:
            self.uzytkownik_list.blockSignals(False)

        # Wywołaj cross-filter, aby dodatkowo przefiltrować listę po zmianie tekstu
        self.update_cross_filters()

    def update_filtered_table(self):
        """
        Aktualizuje widok tabeli na podstawie zaznaczonych filtrów
        """
        # Bezpośrednio aktualizuj całą tabelę z przefiltrowanymi danymi
        self.update_table_content()

    def get_list_selected_items(self, list_widget):
        """
        Zwraca teksty zaznaczonych elementów z listy.
        POPRAWKA: Zmieniono nazwę metody z get_selected_items na get_list_selected_items,
        aby uniknąć konfliktu z metodą get_selected_items w CustomMultiComboBox.

        Args:
            list_widget: QListWidget do pobrania zaznaczonych elementów

        Returns:
            list: Lista zaznaczonych tekstów
        """
        if not list_widget:
            return []

        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item and item.isSelected():
                selected.append(item.text())
        return selected

    def get_list_selected_data(self, list_widget):
        """
        Zwraca dane (Qt.UserRole) zaznaczonych elementów z listy.
        Używane do pobierania loginów zamiast tekstu.

        Args:
            list_widget: QListWidget do pobrania zaznaczonych danych

        Returns:
            list: Lista zaznaczonych danych (np. loginów)
        """
        if not list_widget:
            return []

        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item and item.isSelected():
                selected.append(item.data(Qt.UserRole))
        return selected

    def update_filters(self):
        """
        Wypełnia wszystkie filtry na podstawie załadowanych danych.
        """
        try:
            if not hasattr(self, 'processed_data') or not self.processed_data:
                debug_print("Brak danych do wypełnienia filtrów, pomijam.")
                return

            debug_print("Rozpoczynam pełną aktualizację filtrów...")

            # --- 1. Pobranie starych zaznaczeń (aby je przywrócić) ---
            selected_grupy = self.grupa_main_filter_combo.get_selected_items()
            selected_wydzialy = self.wydzial_combo.get_selected_items()
            selected_dtn = self.dtn_combo.get_selected_items()
            selected_role = self.rola_combo.get_selected_items()
            selected_jezyki = self.jezyk_combo.get_selected_items()
            selected_etaty = self.etat_combo.get_selected_items()
            selected_scp = self.system_czasu_pracy_combo.get_selected_items()
            selected_locations = self.default_location_combo.get_selected_items()
            selected_rka = self.rka_combo.get_selected_items()
            selected_podrola = self.podrola_combo.get_selected_items()
            selected_grafik_pkt = self.grafik_za_punkty_combo.get_selected_items()
            selected_brak_nocki = self.brak_nocki_combo.get_selected_items()

            # --- NAPRAWA BŁĘDU: Pobieramy to TUTAJ, zanim użyjemy niżej ---
            selected_abs_symbols = self.absence_symbol_combo.get_selected_items()
            # --------------------------------------------------------------

            selected_przelozeni_text = self.get_list_selected_items(self.przelozony_list)
            selected_uzytkownik_ids = self.get_list_selected_data(self.uzytkownik_list)

            # --- 2. Wypełnianie filtrów ComboBox ---

            group_mapping = self.data_provider.get_department_to_group_mapping()
            self.grupa_main_filter_combo.add_items(sorted(group_mapping.keys()))
            self.grupa_main_filter_combo.select_items(selected_grupy)

            # Zbiory na unikalne wartości
            wydzialy = set()
            locations = set()
            scp_values = set()
            role_values = set()
            podrola_values = set()
            jezyki_values = set()
            etaty_values = set()
            dtn_values = set()
            rka_values = set()
            grafik_pkt_values = set()
            brak_nocki_values = set()

            # Dane do list
            przelozeni_set = set()
            user_map = {}  # ID -> (Nazwa, Login)

            # Iteracja po danych raz, żeby zebrać wszystko
            for key, data in self.processed_data.items():
                # key = (Wydzial, Przelozony, UserDisplay, UserID)
                if key[0]: wydzialy.add(key[0])
                if key[1]: przelozeni_set.add(key[1])

                user_id = key[3]
                user_name = key[2]
                login = data.get('sched_login', '')
                if user_id and user_name:
                    user_map[user_id] = (user_name, login)

                if val := data.get('sched_lokalizacja'): locations.add(str(val))
                if val := data.get('sched_system_pracy'): scp_values.add(str(val))
                if val := data.get('sched_rola'): role_values.add(str(val))
                if val := data.get('sched_podrola'): podrola_values.add(str(val))
                if val := data.get('sched_jezyk'): jezyki_values.add(str(val))
                if (val := data.get('sched_etat')) is not None: etaty_values.add(str(val))
                if (val := data.get('sched_dtn')) is not None: dtn_values.add(str(val))
                if val := data.get('sched_rka'): rka_values.add(str(val))

                val_pkt = data.get('sched_grafik_za_punkty')
                grafik_pkt_values.add(str(val_pkt) if val_pkt and str(val_pkt).strip() else 'NIE')

                val_nocki = data.get('sched_brak_nocki')
                brak_nocki_values.add(str(val_nocki) if val_nocki and str(val_nocki).strip() else 'NIE')

            # Aplikowanie wartości do ComboBoxów
            self.wydzial_combo.add_items(sorted(list(wydzialy)))
            self.wydzial_combo.select_items(selected_wydzialy)

            self.default_location_combo.add_items(sorted(list(locations)))
            self.default_location_combo.select_items(selected_locations)

            self.system_czasu_pracy_combo.add_items(sorted(list(scp_values)))
            self.system_czasu_pracy_combo.select_items(selected_scp)

            self.rola_combo.add_items(sorted(list(role_values)))
            self.rola_combo.select_items(selected_role)

            self.podrola_combo.add_items(sorted(list(podrola_values)))
            self.podrola_combo.select_items(selected_podrola)

            self.jezyk_combo.add_items(sorted(list(jezyki_values)))
            self.jezyk_combo.select_items(selected_jezyki)

            self.etat_combo.add_items(
                sorted(list(etaty_values), key=lambda x: float(x) if x.replace('.', '', 1).isdigit() else 0))
            self.etat_combo.select_items(selected_etaty)

            self.dtn_combo.add_items(sorted(list(dtn_values), key=int))
            self.dtn_combo.select_items(selected_dtn)

            self.rka_combo.add_items(sorted(list(rka_values)))
            self.rka_combo.select_items(selected_rka)

            self.grafik_za_punkty_combo.add_items(sorted(list(grafik_pkt_values)))
            self.grafik_za_punkty_combo.select_items(selected_grafik_pkt)

            self.brak_nocki_combo.add_items(sorted(list(brak_nocki_values)))
            self.brak_nocki_combo.select_items(selected_brak_nocki)

            # --- Wypełnianie combo symboli nieobecności ---
            absence_def_set = app_settings.get_absence_symbols()
            current_absence_symbols = set()

            if self.processed_data:
                for data in self.processed_data.values():
                    for day_data in data.get('days', {}).values():
                        sym = day_data.get('symbol', '')
                        if sym:
                            parsed = parse_symbol(sym)
                            spec = parsed.get('special_symbol')
                            if spec and spec.upper() in absence_def_set:
                                current_absence_symbols.add(spec.upper())

            self.absence_symbol_combo.add_items(sorted(list(current_absence_symbols)))
            self.absence_symbol_combo.select_items(selected_abs_symbols)

            # --- 3. Aktualizacja List (Przełożony i Użytkownik) ---

            # Przełożony
            self.update_list_safely(self.przelozony_list, sorted(list(przelozeni_set)), selected_przelozeni_text)

            # Użytkownik - Ręczna aktualizacja
            self.uzytkownik_list.blockSignals(True)
            try:
                search_text = self.uzytkownik_filter.text().lower()
                current_items_map = {}
                for i in range(self.uzytkownik_list.count()):
                    item = self.uzytkownik_list.item(i)
                    current_items_map[item.data(Qt.UserRole)] = item

                new_ids_set = set(user_map.keys())
                current_ids_set = set(current_items_map.keys())

                # Ukryj nieaktualnych
                for user_id in (current_ids_set - new_ids_set):
                    current_items_map[user_id].setHidden(True)

                # Dodaj nowych
                for user_id in (new_ids_set - current_ids_set):
                    display_name, login = user_map[user_id]
                    item = QListWidgetItem(display_name)
                    item.setData(Qt.UserRole, user_id)
                    item.setData(Qt.UserRole + 1, login)
                    self.uzytkownik_list.addItem(item)

                # Odśwież widoczność i zaznaczenie
                for user_id in new_ids_set:
                    item = current_items_map.get(user_id)
                    # Fallback gdyby itemu nie było (teoretycznie niemożliwe po dodaniu wyżej)
                    if not item: continue

                    item.setHidden(False)
                    if user_id in selected_uzytkownik_ids:
                        item.setSelected(True)

                    # Filtr wyszukiwania
                    item_text_lower = item.text().lower()
                    item_id_str = str(user_id)
                    item_login_str = str(item.data(Qt.UserRole + 1) or '').lower()
                    if not self._matches_user_search(item_text_lower, item_id_str, item_login_str, search_text):
                        item.setHidden(True)
            finally:
                self.uzytkownik_list.blockSignals(False)

            # --- 4. Filtry niestandardowe ---
            current_data = self.date_combo.currentData()
            curr_year, curr_month = current_data if current_data else (self.year, self.month)
            suffix = f"|{curr_year}|{curr_month}"

            for col_id, col_data in self.custom_columns.items():
                container_widget = self.filter_widget_map.get(col_id)
                if not container_widget: continue
                combo = container_widget.findChild(CustomMultiComboBox)
                if not combo: continue

                unique_values = set()
                for storage_key, val in col_data.get('values', {}).items():
                    if val and storage_key.endswith(suffix):
                        unique_values.add(val)

                selected_items = combo.get_selected_items()
                combo.add_items(sorted(list(unique_values)))
                combo.select_items(selected_items)

            debug_print("[Filtracja] Zakończono pełną aktualizację wszystkich filtrów.")

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji filtrów: {e}", exception=e)

    def update_przelozony_filter(self, selected_przelozeni=None):
        """
        Aktualizuje listę przełożonych na podstawie wybranych wydziałów.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_przelozeni: Lista zaznaczonych przełożonych (opcjonalnie)
        """
        if not hasattr(self, 'przelozony_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiętaj bieżącą selekcję jeśli nie podano
        if selected_przelozeni is None:
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)

        self.przelozony_list.clear()

        # Pobierz wybrane wydziały
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []

        # Zbiór unikalnych przełożonych
        przelozeni = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, _, _ = key

            # Jeśli nie wybrano wydziałów lub wydział pasuje do filtra
            if not selected_wydzialy or wydzial in selected_wydzialy:
                # Dodaj przełożonego do zbioru (tylko niepuste wartości)
                if przelozony:
                    przelozeni.add(przelozony)

        # Dodaj posortowanych przełożonych do listy
        for przelozony in sorted(przelozeni):
            item = QListWidgetItem(przelozony)
            self.przelozony_list.addItem(item)

            # Przywróć zaznaczenie jeśli było
            if przelozony in selected_przelozeni:
                item.setSelected(True)

    def update_uzytkownik_filter(self, selected_uzytkownicy=None):
        """
        Aktualizuje listę użytkowników na podstawie wybranych wydziałów i przełożonych.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_uzytkownicy: Lista zaznaczonych użytkowników (opcjonalnie)
        """
        if not hasattr(self, 'uzytkownik_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiętaj bieżącą selekcję jeśli nie podano
        if selected_uzytkownicy is None:
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

        self.uzytkownik_list.clear()

        # Pobierz wybrane wydziały i przełożonych
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self,
                                                                                            'przelozony_list') else []

        # Zbiór unikalnych użytkowników (użyj stringa jako tekstowej reprezentacji)
        uzytkownicy = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, uzytkownik_dane, _ = key

            # Sprawdź czy dane pasują do filtrów
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni):
                # Dodaj użytkownika do zbioru (tylko niepuste wartości)
                if uzytkownik_dane:
                    # Konwertuj do stringa dla spójności
                    uzytkownicy.add(str(uzytkownik_dane))

        # Dodaj posortowanych użytkowników do listy
        for uzytkownik in sorted(uzytkownicy):
            item = QListWidgetItem(uzytkownik)
            self.uzytkownik_list.addItem(item)

            # Przywróć zaznaczenie jeśli było
            if uzytkownik in selected_uzytkownicy:
                item.setSelected(True)

    def update_table_content(self):
        """
        Aktualizuje zawartość tabeli grafiku używając modelu danych.
        Zoptymalizowana wersja wykorzystująca precyzyjne aktualizacje.
        """
        # Sprawdź czy modele zostały zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # Ustaw rok i miesiąc w modelu (jeśli jeszcze nie są ustawione)
        if self.schedule_model._year != year or self.schedule_model._month != month:
            # Pobierz dane dla wybranego roku i miesiąca
            schedule_data = self.data_provider.get_schedule_data(year, month, self.import_grupa, self.import_funkcja)

            # Aktualizuj model - to wywoła zoptymalizowaną metodę update_data
            self.schedule_model.update_data(schedule_data, year, month)
            self._apply_dynamic_sizes()
        else:
            # Jeśli rok i miesiąc nie uległy zmianie, tylko zastosuj filtry
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

    def get_cell_color_by_time(self, hour):
        """
        Zwraca kolor tła komórki na podstawie godziny rozpoczęcia.
        Godziny są mapowane na kolory w bardziej czytelnej palecie.

        Args:
            hour (int): Godzina rozpoczęcia zmiany (0-23)

        Returns:
            QColor: Kolor tła komórki
        """
        # Domyślny kolor (przezroczysty) gdy godzina nie jest zdefiniowana
        if hour is None or hour < 0 or hour > 23:
            return QColor(255, 255, 255, 0)  # Przezroczysty

        # Mapowanie godzin na kolory - zharmonizowana paleta
        if hour == 5:
            return QColor(204, 255, 255)  # Jasny błękit (bardzo jasny cyjan)
        elif hour == 6:
            return QColor(204, 255, 255)  # Jasny błękit (bardzo jasny cyjan)
        elif hour == 7:
            return QColor(0, 255, 255)  # Cyjan (akwamaryna)
        elif hour == 8:
            return QColor(0, 204, 255)  # Jasny błękit (niebieskozielony)
        elif hour == 9:
            return QColor(0, 255, 0)  # Limonkowy (czysty zielony)
        elif hour == 10:
            return QColor(153, 204, 0)  # Oliwkowy (żółtozielony)
        elif hour == 11:
            return QColor(204, 255, 204)  # Bardzo jasny zielony (miętowy)
        elif hour == 12:
            return QColor(255, 255, 153)  # Bardzo jasny żółty (kremowy)
        elif hour == 13:
            return QColor(255, 204, 153)  # Jasny łososiowy (brzoskwiniowy)
        elif hour == 14:
            return QColor(255, 153, 0)  # Ciemny pomarańczowy
        elif hour == 15:
            return QColor(255, 0, 255)  # Magenta (fuksja)
        elif hour == 16:
            return QColor(204, 0, 0)  # Ciemnoczerwony
        elif hour == 17:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 18:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 19:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 20:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 21:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 22:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 23:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 0:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour in [1, 2, 3, 4]:
            return QColor(51, 51, 51)  # Ciemny szary

        # Domyślny kolor dla innych wartości
        return QColor(255, 255, 255, 0)  # Przezroczysty

    def _handle_selection_change(self):
        """
        Faktyczna obsługa zmiany zaznaczenia, wywoływana przez timer po upływie opóźnienia.
        """
        debug_print("Zmiana zaznaczenia - aktualizuję tabelę zdarzeń...")
        selected_cells_data = self.table.get_data_for_selected_cells()
        debug_print(f"Zaznaczono {len(selected_cells_data)} komórek")

        is_one_cell_selected = len(selected_cells_data) == 1

        if hasattr(self, 'add_overtime_button'):
            self.add_overtime_button.setEnabled(is_one_cell_selected)
        if hasattr(self, 'shortcut_insert'):
            self.shortcut_insert.setEnabled(is_one_cell_selected)
        if hasattr(self, 'send_email_button'):
            self.send_email_button.setEnabled(bool(selected_cells_data))

        if selected_cells_data:
            events = []
            for cell_data in selected_cells_data:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    user_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                    for event in user_events:
                        local_event = self._convert_dp_event_to_local(event)
                        events.append(local_event)

            debug_print(f"Pobrano {len(events)} aktywnych zdarzeń dla zaznaczonych komórek")
            self.events_data = events
            if hasattr(self, 'events_model'):
                self.events_model.update_data(self.events_data)
                self.filter_events_table()
        else:
            self.events_data = []
            if hasattr(self, 'events_model'):
                self.events_model.update_data([])

    def on_selection_changed(self, selected=None, deselected=None):
        """
        Obsługuje zmianę zaznaczenia z opóźnieniem (debouncing), aby uniknąć
        nadmiernego wywoływania aktualizacji przy zaznaczaniu dużych obszarów.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # Zamiast wykonywać logikę od razu, uruchom lub zresetuj timer.
        # Właściwa obsługa zdarzenia wykona się w funkcji _handle_selection_change.
        if hasattr(self, '_selection_timer'):
            self._selection_timer.stop()
            self._selection_timer.start(self._selection_debounce_delay)

    def _handle_selection_change(self):
        """
        NOWA METODA: Faktyczna obsługa zmiany zaznaczenia (wywoływana po debounce)
        """
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        self._updating_selection = True

        try:
            debug_print("Zmiana zaznaczenia - aktualizuję tabelę zdarzeń...")
            selected_cells_data = self.table.get_data_for_selected_cells()
            debug_print(f"Zaznaczono {len(selected_cells_data)} komórek")

            # Sprawdź, czy zaznaczono dokładnie jedną komórkę
            is_one_cell_selected = len(selected_cells_data) == 1

            # Zaktualizuj stan przycisku ORAZ obiektu skrótu klawiszowego
            if hasattr(self, 'add_overtime_button'):
                self.add_overtime_button.setEnabled(is_one_cell_selected)
            if hasattr(self, 'shortcut_insert'):
                self.shortcut_insert.setEnabled(is_one_cell_selected)

            # Włącz przycisk "Wyślij e-mail", jeśli cokolwiek jest zaznaczone
            if hasattr(self, 'teams_chat_button'):
                is_selection = bool(selected_cells_data)
                self.teams_chat_button.setEnabled(is_selection)
                if hasattr(self, 'shortcut_teams'):
                    self.shortcut_teams.setEnabled(is_selection)

            if hasattr(self, 'send_email_button'):
                is_selection = bool(selected_cells_data)
                self.send_email_button.setEnabled(is_selection)
                if hasattr(self, 'shortcut_outlook'):
                    self.shortcut_outlook.setEnabled(is_selection)

            if selected_cells_data and len(selected_cells_data) > 0:
                # MAMY ZAZNACZONE KOMÓRKI - pokaż zdarzenia
                events = []

                for cell_data in selected_cells_data:
                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')

                    if user_id and date_str:
                        # --- ZMIANA: Usuwamy przekazywanie self.import_grupa i self.import_funkcja ---
                        user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                        for event in user_events:
                            local_event = self._convert_dp_event_to_local(event)
                            events.append(local_event)

                debug_print(f"Pobrano {len(events)} aktywnych zdarzeń dla zaznaczonych komórek")

                # Zaktualizuj events_data
                self.events_data = events

                # Aktualizuj model zdarzeń
                if hasattr(self, 'events_model'):
                    self.events_model.update_data(self.events_data)

                    # WAŻNE: Zastosuj filtry po aktualizacji danych
                    self.filter_events_table()
            else:
                # BRAK ZAZNACZENIA - wyczyść tabelę zdarzeń
                debug_print("Brak zaznaczenia - czyszczę tabelę zdarzeń")
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])

            # DODANE: Wymuś odświeżenie widoku tabeli zdarzeń
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        finally:
            self._updating_selection = False

    def clear_events_on_startup(self):
        """
        NOWA METODA: Czyści tabelę zdarzeń przy starcie aplikacji
        """
        debug_print("Czyszczę tabelę zdarzeń przy starcie aplikacji")

        # Wyczyść dane zdarzeń
        self.events_data = []

        # Wyczyść model zdarzeń jeśli istnieje
        if hasattr(self, 'events_model') and self.events_model:
            self.events_model.update_data([])

        # Odśwież widok tabeli zdarzeń
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

    def _convert_dp_event_to_local(self, dp_event):
        """Konwertuje format zdarzenia z DataProvider na format modelu UI."""
        try:
            # Używamy 'evt_date' (z bazy) lub 'date' (jeśli stare)
            raw_date = dp_event.get('evt_date') or dp_event.get('date')
            date_key = self.data_provider._standardize_date(raw_date)

            display_date = ".".join(reversed(date_key.split("-"))) if date_key and '-' in date_key else date_key

            # --- LOGIKA POBIERANIA NAZWY UŻYTKOWNIKA ---
            # Próbujemy wszystkich możliwych kluczy, pod którymi może kryć się nazwa
            user_display = (
                    dp_event.get('evt_user_display') or
                    dp_event.get('UzytkownikDane') or
                    dp_event.get('user_name') or
                    dp_event.get('evt_user_name') or
                    ""
            )
            # -------------------------------------------

            # Zapewniamy spójność kluczy dla EventsTableModel
            local_event = {
                'evt_type': dp_event.get('evt_type') or dp_event.get('type', ''),
                'evt_id': dp_event.get('evt_id') or dp_event.get('id'),
                'evt_topic': dp_event.get('evt_topic') or dp_event.get('topic', ''),
                'evt_name': dp_event.get('evt_name') or dp_event.get('name', ''),
                'evt_user_id': dp_event.get('evt_user_id') or dp_event.get('user_id'),
                'evt_user_display': user_display,

                'evt_time_from': dp_event.get('evt_time_from') or dp_event.get('time_from', ''),
                'evt_time_to': dp_event.get('evt_time_to') or dp_event.get('time_to', ''),
                'evt_status': dp_event.get('evt_status') or dp_event.get('status', ''),
                'evt_modified_date': dp_event.get('evt_modified_date') or dp_event.get('DataModyfikacji', ''),

                # Klucze pomocnicze (używane w logice main.py, np. delete_event)
                'id': dp_event.get('evt_id') or dp_event.get('id'),
                'user_id': dp_event.get('evt_user_id') or dp_event.get('user_id'),
                'type': dp_event.get('evt_type') or dp_event.get('type'),
                'date_key': date_key,
                'date': display_date,

                # Zachowaj user_name też w starej konwencji dla kompatybilności
                'user_name': user_display
            }
            return local_event
        except Exception as e:
            log_error(f"Błąd konwersji zdarzenia: {e}")
            return dp_event



    def send_email_to_selection(self):
        """Zbiera dane zaznaczonych pracowników i otwiera okno nowej wiadomości w Outlook."""
        if not self.table or not self.table.employees_view.selectionModel():
            return

        selected_rows = self.table.get_selected_rows()
        if not selected_rows:
            QMessageBox.warning(self, "Brak zaznaczenia", "Proszę zaznaczyć przynajmniej jednego pracownika.")
            return

        recipients = []
        missing_email_users = []
        for row_index in selected_rows:
            key = self.schedule_model._keys[row_index]
            full_user_data = self.processed_data.get(key, {})
            email = full_user_data.get('email', '').strip()
            if email:
                recipients.append(email)
            else:
                missing_email_users.append(full_user_data.get('uzytkownik_dane', 'Nieznany'))

        if not recipients:
            QMessageBox.warning(self, "Brak danych",
                                "Żaden z zaznaczonych pracowników nie ma przypisanego adresu e-mail.")
            return

        # Wywołaj funkcję z outlook_connector z pustym tematem i treścią
        success, message = create_outlook_email(recipients=recipients)

        if not success:
            QMessageBox.critical(self, "Błąd Outlook", message)
        elif missing_email_users:
            QMessageBox.information(self, "Informacja",
                                    "Pominięto następujących pracowników z powodu braku adresu e-mail w bazie:<br><br>- " + "<br>- ".join(
                                        missing_email_users))

    def open_teams_chat_for_selection(self):
        """Zbiera dane zaznaczonych pracowników i otwiera czat w Microsoft Teams."""
        if not self.table or not self.table.employees_view.selectionModel():
            return

        selected_rows = self.table.get_selected_rows()
        if not selected_rows:
            QMessageBox.warning(self, "Brak zaznaczenia", "Proszę zaznaczyć przynajmniej jednego pracownika.")
            return

        recipient_emails = []
        missing_email_users = []
        for row_index in selected_rows:
            key = self.schedule_model._keys[row_index]
            full_user_data = self.processed_data.get(key, {})
            email = full_user_data.get('email', '').strip()
            if email:
                recipient_emails.append(email)
            else:
                missing_email_users.append(full_user_data.get('uzytkownik_dane', 'Nieznany'))

        if not recipient_emails:
            QMessageBox.warning(self, "Brak danych",
                                "Żaden z zaznaczonych pracowników nie ma przypisanego adresu e-mail.")
            return

        success, message = open_teams_chat(recipient_emails=recipient_emails)
        if not success:
            QMessageBox.critical(self, "Błąd Microsoft Teams", message)
        elif missing_email_users:
            QMessageBox.information(self, "Informacja",
                                    "Pominięto następujących pracowników z powodu braku adresu e-mail w bazie:<br><br>- " + "<br>- ".join(
                                        missing_email_users))

    # def standardize_date(self, date_obj):
    #     """
    #     Standaryzuje format daty do 'YYYY-MM-DD' dla porównań
    #     """
    #     if not date_obj:
    #         return ''
    #
    #     # Jeśli to już string, wyciągnij tylko datę
    #     if isinstance(date_obj, str):
    #         # Obsługa różnych formatów
    #         if 'T' in date_obj:  # Format ISO 'YYYY-MM-DDThh:mm:ss'
    #             return date_obj.split('T')[0]
    #         elif ' ' in date_obj:  # Format 'YYYY-MM-DD hh:mm:ss'
    #             return date_obj.split(' ')[0]
    #         elif len(date_obj) == 10 and date_obj.count('-') == 2:  # Format 'YYYY-MM-DD'
    #             return date_obj
    #         # Jeśli nie dopasowano do żadnego formatu, zwróć oryginalny string
    #         return date_obj
    #
    #     # Jeśli to obiekt datetime, skonwertuj na string
    #     if hasattr(date_obj, 'strftime'):
    #         return date_obj.strftime('%Y-%m-%d')
    #
    #     # W przypadku nieznanego typu, zwróć pusty string
    #     return ''

    # def diagnose_application_state(self):
    #     """Wykonuje pełną diagnostykę stanu aplikacji i wyświetla szczegółowe informacje"""
    #     try:
    #         debug_print("<br>===== DIAGNOSTYKA STANU APLIKACJI =====")
    #
    #         # 1. Sprawdź tabele i dane
    #         debug_print("<br>--- TABELA GRAFIKU ---")
    #         debug_print(f"Liczba wierszy: {self.table.rowCount()}")
    #         debug_print(f"Liczba kolumn: {self.table.columnCount()}")
    #
    #         # Sprawdź pierwsze 3 wiersze i kolumny dla przykładu
    #         debug_print("<br>Przykładowe komórki z tabeli grafiku:")
    #         for row in range(min(3, self.table.rowCount())):
    #             for col in range(min(6, self.table.columnCount())):
    #                 item = self.table.item(row, col)
    #                 if item:
    #                     debug_print(f"[{row},{col}] Tekst: {item.text()}")
    #                     user_role_data = item.data(Qt.UserRole)
    #                     user_role_2 = item.data(Qt.UserRole + 2)
    #                     user_role_3 = item.data(Qt.UserRole + 3)
    #                     debug_print(
    #                         f"  UserRole: {type(user_role_data)}, UserRole+2: {user_role_2}, UserRole+3: {user_role_3}")
    #                     if isinstance(user_role_data, dict):
    #                         debug_print(f"  Zawartość: {user_role_data}")
    #                 else:
    #                     debug_print(f"[{row},{col}] Brak elementu")
    #
    #         debug_print("<br>--- TABELA ZDARZEŃ ---")
    #         debug_print(f"Liczba wierszy: {self.events_table.rowCount()}")
    #         debug_print(f"Liczba kolumn: {self.events_table.columnCount()}")
    #
    #         # Sprawdź zawartość events_data
    #         debug_print(
    #             f"<br>Liczba zdarzeń w events_data: {len(self.events_data) if hasattr(self, 'events_data') else 'Brak'}")
    #         if hasattr(self, 'events_data') and self.events_data:
    #             debug_print("Pierwsze zdarzenie:")
    #             for key, value in self.events_data[0].items():
    #                 debug_print(f"  {key}: {value}")
    #
    #         # Sprawdź pierwsze 3 wiersze tabeli zdarzeń
    #         debug_print("<br>Przykładowe wiersze z tabeli zdarzeń:")
    #         for row in range(min(3, self.events_table.rowCount())):
    #             row_data = []
    #             for col in range(self.events_table.columnCount() - 1):  # Pomijamy ostatnią kolumnę z przyciskami
    #                 item = self.events_table.item(row, col)
    #                 if item:
    #                     row_data.append(f"{col}:{item.text()}")
    #             debug_print(f"Wiersz {row}: {', '.join(row_data)}")
    #
    #         # 2. Sprawdź delegaty i style
    #         debug_print("<br>--- DELEGATY I STYLE ---")
    #         item_delegate = self.table.itemDelegate()
    #         debug_print(f"Delegat tabeli grafiku: {item_delegate.__class__.__name__}")
    #         if isinstance(item_delegate, OvertimeItemDelegate):
    #             debug_print("  Delegat OvertimeItemDelegate poprawnie przypisany")
    #         else:
    #             debug_print("  UWAGA: Delegat OvertimeItemDelegate nie jest przypisany!")
    #
    #         # 3. Sprawdź filtrowanie danych
    #         debug_print("<br>--- FILTROWANIE DANYCH ---")
    #         if hasattr(self, 'events_data') and self.events_data:
    #             debug_print(f"Liczba zdarzeń przed filtrowaniem: {len(self.events_data)}")
    #             # Sprawdź, czy metoda filter_events_table jest wywoływana
    #             debug_print("Spróbuj wykonać filter_events_table:")
    #             try:
    #                 self.filter_events_table()
    #                 debug_print("  Metoda filter_events_table wykonana bez błędów")
    #             except Exception as e:
    #                 debug_print(f"  BŁĄD podczas wykonywania filter_events_table: {e}")
    #
    #         debug_print("<br>===== KONIEC DIAGNOSTYKI =====<br>")
    #
    #     except Exception as e:
    #         debug_print(f"BŁĄD podczas diagnostyki: {e}")
    #         import traceback
    #         traceback.print_exc()

    # def _get_current_event_filter_params(self):
    #     """
    #     Pobiera bieżące parametry filtrowania zdarzeń.
    #
    #     Returns:
    #         dict: Parametry filtrowania
    #     """
    #     filter_params = {}
    #
    #     # Dodaj filtr typów zdarzeń
    #     allowed_types = []
    #     if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
    #         allowed_types.append('Spotkanie')
    #     if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
    #         allowed_types.append('Szkolenie')
    #     if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
    #         allowed_types.append('Nadgodziny')
    #
    #     if allowed_types:
    #         filter_params['allowed_types'] = allowed_types
    #
    #     # Dodaj filtry tematu i nazwy
    #     topic_filter = self.topic_filter.text().lower() if hasattr(self,
    #                                                                'topic_filter') and self.topic_filter.text() else None
    #     name_filter = self.name_filter.text().lower() if hasattr(self,
    #                                                              'name_filter') and self.name_filter.text() else None
    #
    #     if topic_filter:
    #         filter_params['topic'] = topic_filter
    #     if name_filter:
    #         filter_params['name'] = name_filter
    #
    #     # Dodaj filtry zakresu dat
    #     date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
    #     date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None
    #
    #     if date_from_str:
    #         filter_params['date_from'] = date_from_str
    #     if date_to_str:
    #         filter_params['date_to'] = date_to_str
    #
    #     return filter_params

    def _get_cell_data_for_user_date_pairs(self, user_date_pairs: list) -> list:
        """
        Na podstawie listy par (user_id, date_str) odnajduje i zwraca
        pełne dane komórek z modelu grafiku.
        """
        if not self.schedule_model or not user_date_pairs:
            return []

        cells_data_to_return = []
        user_row_map = {str(key[3]): idx for idx, key in enumerate(self.schedule_model._keys)}

        for user_id, date_str in user_date_pairs:
            row = user_row_map.get(str(user_id))
            if row is not None:
                try:
                    day = int(date_str.split('-')[2])
                    col_offset = len(self.schedule_model.get_visible_columns())
                    col = col_offset + day - 1

                    index = self.schedule_model.index(row, col)

                    # --- ZMIANA: Poprawne odwołanie do ROLE_DATA ---
                    cell_data = self.schedule_model.data(index, ROLE_DATA)

                    if isinstance(cell_data, dict):
                        cells_data_to_return.append(cell_data)
                except (ValueError, IndexError) as e:
                    log_warning(f"Nie udało się znaleźć danych dla komórki ({user_id}, {date_str}): {e}")

        return cells_data_to_return

    def cancel_delegations(self, ask_for_confirmation: bool = True):
        """
        Inicjuje proces odwoływania delegacji. Wyświetla okno potwierdzenia
        tylko wtedy, gdy jest to akcja bezpośrednia (ask_for_confirmation=True).
        """
        debug_print(f"--- cancel_delegations: FUNKCJA WYWOŁANA (ask_for_confirmation={ask_for_confirmation}) ---")

        selected_cells_data = self.get_selected_cells_data()
        if not self._can_modify_cells(selected_cells_data):
            return

        user_date_pairs = list(set((cell.get('uzytkownik_id'), cell.get('date_str')) for cell in selected_cells_data if
                                   cell.get('uzytkownik_id') and cell.get('date_str')))
        if not user_date_pairs:
            if ask_for_confirmation:  # Pokaż błąd tylko, gdy to akcja bezpośrednia
                QMessageBox.warning(self, "Brak zaznaczenia", "Proszę zaznaczyć komórki do analizy.", QMessageBox.Ok)
            return

        events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        if not events_to_cancel:
            if ask_for_confirmation:  # Pokaż informację tylko, gdy to akcja bezpośrednia
                QMessageBox.information(self, "Brak delegacji", "Nie znaleziono aktywnych delegacji do odwołania.",
                                        QMessageBox.Ok)
            return

        # Krok 1: Wyświetlaj dialog tylko, gdy jest to wymagane
        if ask_for_confirmation:
            grouped_events = self._group_events_by_user_date(events_to_cancel)
            delegations_info = self._prepare_delegations_description(grouped_events)
            confirm_message = f"Czy na pewno chcesz odwołać następujące delegacje?<br>{delegations_info}"

            reply = show_confirmation_dialog(self, "Potwierdzenie odwołania delegacji", confirm_message)
            if reply != QMessageBox.Yes:
                return

        # Krok 2: Wykonaj operacje
        try:
            self._state_to_restore = self._save_view_state()

            trainings_to_clear = [evt for evt in events_to_cancel if evt.get('type') == 'Szkolenie']
            if trainings_to_clear:
                pairs_for_trainings = list(
                    set((e.get('user_id'), e.get('date_key', e.get('date'))) for e in trainings_to_clear))
                cells_data = self._get_cell_data_for_user_date_pairs(pairs_for_trainings)
                cells_with_s = [cell for cell in cells_data if
                                (parse_symbol(cell.get('symbol', '')).get('special_symbol') or '').upper() == 'S']
                if cells_with_s:
                    self._remove_s_symbol_directly(cells_with_s)

            self.delegation_canceler.start_cancellation(events_to_cancel)

            # Logika sukcesu/błędu jest teraz wewnątrz DelegationCanceler._on_finished
            if ask_for_confirmation:
                if ask_for_confirmation:  # Pokaż podsumowanie tylko dla akcji bezpośredniej
                    pass  # Wiadomość zostanie pokazana przez DelegationCanceler
            elif ask_for_confirmation:
                QMessageBox.warning(self, "Brak zmian", "Nie udało się odwołać żadnej delegacji.", QMessageBox.Ok)

        except Exception as e:
            log_error(f"Błąd podczas odwoływania delegacji: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił krytyczny błąd: {str(e)}", QMessageBox.Ok)

    def delete_events_for_cells(self, cells_data: list):
        """
        Wyszukuje wszystkie zdarzenia dla podanych komórek, prosi o potwierdzenie
        i odwołuje je. Zwraca True, jeśli użytkownik potwierdził usunięcie.
        """
        if not cells_data:
            return False

        # Zbierz unikalne pary (użytkownik, data) z zaznaczonych komórek
        user_date_pairs = set()
        for cell_data in cells_data:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if user_id and date_str:
                user_date_pairs.add((user_id, date_str))

        # Znajdź wszystkie zdarzenia do odwołania dla tych par
        events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        if not events_to_cancel:
            # Jeśli nie ma zdarzeń do usunięcia, nic więcej nie rób
            return False

        # Przygotuj i pokaż okno dialogowe z potwierdzeniem
        grouped_events = self._group_events_by_user_date(events_to_cancel)
        delegations_info = self._prepare_delegations_description(grouped_events)

        reply = QMessageBox.question(
            self,
            "Potwierdzenie usunięcia zdarzeń",
            f"Wstawienie tego symbolu wymaga odwołania istniejących zdarzeń (spotkań, nadgodzin itp.).<br><br>{delegations_info}<br>Czy chcesz kontynuować?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply == QMessageBox.Yes:
            # Jeśli użytkownik się zgodzi, odwołaj delegacje
            self.delegation_canceler.start_cancellation(events_to_cancel)
            return True
        else:
            # Jeśli użytkownik anuluje, zwróć informację o tym
            self.statusBar().showMessage("Operacja anulowana przez użytkownika.", 3000)
            return False

    def get_data_from_model(self, row, col):
        """
        Pobiera dane z komórki modelu na podstawie wierszy i kolumn.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny

        Returns:
            dict: Dane komórki lub pusty słownik
        """
        if not hasattr(self, 'schedule_model'):
            return {}

        # Pobierz dane z modelu
        index = self.schedule_model.index(row, col)
        cell_data = self.schedule_model.data(index, Qt.UserRole)

        # Upewnij się, że dane są słownikiem
        if not isinstance(cell_data, dict):
            return {}

        return cell_data

    def get_selected_cells_data(self):
        """
        Pobiera dane dla zaznaczonych komórek z modelu.

        Returns:
            list: Lista danych zaznaczonych komórek
        """
        if not hasattr(self, 'table') or not self.table:
            return []

        # Deleguj do metody w SplitTableView, która już obsługuje model
        return self.table.get_data_for_selected_cells()

    def group_cells_by_user_and_day(self, cells):
        """Grupuje komórki według użytkownika i dnia dla łatwiejszej edycji"""
        grouped = {}
        for cell in cells:
            # ZMIANA: Dostosuj do nowej struktury danych z modelu
            user_id = cell.get('uzytkownik_id')  # Zmieniono z 'user_id'
            date_str = cell.get('date_str')  # Zmieniono z 'date'

            if not user_id or not date_str:
                continue

            if user_id not in grouped:
                grouped[user_id] = {}

            if date_str not in grouped[user_id]:
                grouped[user_id][date_str] = []

            grouped[user_id][date_str].append(cell)

        return grouped

    def delete_event(self, event_id, event_type):
        """
        Odwołuje pojedyncze zdarzenie z tabeli zdarzeń. Zawsze prosi o potwierdzenie.
        """
        # --- POCZĄTEK LOGOWANIA DIAGNOSTYCZNEGO ---
        debug_print(
            f"--- delete_event: Próba odwołania zdarzenia ID: {event_id} (typ: {type(event_id)}), Typ: {event_type} ---")
        # --- KONIEC LOGOWANIA DIAGNOSTYCZNEGO ---

        # Krok 1: Zawsze wyświetlaj dialog potwierdzenia.
        reply = show_confirmation_dialog(self, "Potwierdzenie",
                                         f"Czy na pewno chcesz odwołać {event_type.lower()} o ID {event_id}?",
                                         )
        if reply != QMessageBox.Yes:
            return

        # Krok 2: Zbierz dane tylko dla tego jednego zdarzenia.
        event_to_cancel = next(
            (e for e in (self.all_events_data or []) if
             str(e.get('id')) == str(event_id) and e.get('type') == event_type), None)
        if not event_to_cancel:
            # --- POCZĄTEK LOGOWANIA DIAGNOSTYCZNEGO ---
            debug_print(f"BŁĄD: Nie znaleziono zdarzenia ID: {event_id} w self.all_events_data.")
            if hasattr(self, 'all_events_data') and self.all_events_data:
                debug_print("Ostatnie 5 zdarzeń w `all_events_data` do porównania:")
                for event in self.all_events_data[-5:]:
                    debug_print(f"  -> ID: {event.get('id')} (typ: {type(event.get('id'))}), Typ: {event.get('type')}")
            # --- KONIEC LOGOWANIA DIAGNOSTYCZNEGO ---
            QMessageBox.warning(self, "Błąd", "Nie można odnaleźć zdarzenia do odwołania.")
            return

        # Krok 3: Wykonaj operacje.
        try:
            view_state = self._save_view_state()

            user_id = event_to_cancel.get('user_id')
            date_str = event_to_cancel.get('date_key')

            if event_type == 'Szkolenie':
                cell_data = self._get_cell_data_for_user_date_pairs([(user_id, date_str)])
                if cell_data and (
                        parse_symbol(cell_data[0].get('symbol', '')).get('special_symbol') or '').upper() == 'S':
                    self._remove_s_symbol_directly(cell_data)

            self.delegation_canceler.start_cancellation([event_to_cancel])

        except Exception as e:
            log_error(f"Błąd podczas usuwania zdarzenia: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas usuwania zdarzenia: {str(e)}", QMessageBox.Ok)

    def _update_multiple_overtime_locations(self, location_changes):
        """
        Aktualizuje lokalizację dla wielu wpisów nadgodzin, każdy z inną wartością.
        WERSJA POPRAWIONA: Aktualizuje również nazwę zdarzenia w interfejsie.
        """
        if not location_changes:
            return True  # Brak zmian do wykonania to nie błąd

        location_map = {'h': 1, 's': 3, 'p': 2}

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            for event_id, new_location_code in location_changes:
                location_value = location_map.get(new_location_code)
                if location_value is None:
                    log_warning(
                        f"Pominięto aktualizację nadgodzin dla ID {event_id} z powodu nieznanego kodu lokalizacji: {new_location_code}")
                    continue

                query = f"UPDATE {SQL_OBJECTS['nadgodziny']} SET Lokalizacja = ? WHERE Id = ?"
                params = (location_value, event_id)
                debug_print(f"Aktualizuję lokalizację nadgodzin: ID={event_id}, nowa lokalizacja={location_value}")
                cursor.execute(query, params)

            conn.commit()
            conn.close()

            # --- NOWA LOGIKA: Aktualizacja nazwy w modelu danych po pomyślnym zapisie w bazie ---

            # Mapa kodów na pełne nazwy do wyświetlenia
            location_display_map = {'h': 'Home Office', 's': 'SBC', 'p': 'Przystanek'}

            # Stwórz słownik zmian dla szybszego wyszukiwania
            changes_map = dict(location_changes)

            # Zaktualizuj główną listę wszystkich zdarzeń
            for event in self.all_events_data:
                if event.get('id') in changes_map and event.get('type') == 'Nadgodziny':
                    new_loc_code = changes_map[event['id']]
                    new_loc_name = location_display_map.get(new_loc_code, 'N/A')
                    event['name'] = f"Nadgodziny {new_loc_name}"

            # Zaktualizuj listę zdarzeń aktualnie widoczną w tabeli
            for event in self.events_data:
                if event.get('id') in changes_map and event.get('type') == 'Nadgodziny':
                    new_loc_code = changes_map[event['id']]
                    new_loc_name = location_display_map.get(new_loc_code, 'N/A')
                    event['name'] = f"Nadgodziny {new_loc_name}"

            # Odśwież model tabeli zdarzeń, aby UI pokazał zmiany
            if hasattr(self, 'events_model'):
                self.events_model.update_data(self.events_data)

            debug_print(f"Zaktualizowano {len(location_changes)} wpisów nadgodzin w interfejsie.")
            # --- KONIEC NOWEJ LOGIKI ---

            return True

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji wielu lokalizacji nadgodzin: {e}", exception=e)
            QMessageBox.critical(self, "Błąd Bazy Danych", f"Nie udało się zaktualizować lokalizacji nadgodzin:<br>{e}")
            return False

    def _update_overtime_icon_single(self, user_id, date_str, year, month):
        """
        NOWA METODA: Aktualizuje ikonę nadgodzin bez wpływania na cache innych danych.
        """
        try:
            # 1. Aktualizuj bezpośrednio w modelu grafiku
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonę nadgodzin w modelu dla ({user_id}, {date_str})")

            # 2. Wyczyść tylko cache ikon dla tej konkretnej komórki w DataProvider
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla komórki ({user_id}, {date_str})")

            # 3. Odśwież widok grafiku
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji ikony nadgodzin: {e}")

    def _handle_specific_icons_refresh(self, data_type, year, month):
        """Obsługuje sygnał o zmianie danych ikon z DataProvider i odświeża model."""
        if data_type == "icons":
            current_data = self.date_combo.currentData()
            if current_data and current_data == (year, month):
                debug_print(f"[DB] Otrzymano sygnał odświeżenia ikon dla {year}-{month}. Odświeżam model grafiku.")

                fresh_processed_data = self.data_provider.get_processed_data(
                    year, month, self.import_grupa, self.import_funkcja
                )
                self.processed_data = fresh_processed_data

                # Zamiast wywoływać filter_data(), które powoduje problemy,
                # ręcznie przekazujemy przefiltrowane dane do modelu.
                filtered_data = self.filter_processed_data()
                self.schedule_model.update_filtered_data(filtered_data)

                debug_print(
                    f"[DB] W _handle_specific_icons_refresh, sprawdzam flagę self._state_to_restore. Jest ona: {'USTAWIONA' if self._state_to_restore else 'PUSTA (None)'}")
                if self._state_to_restore:
                    # Jeśli istnieje stan do przywrócenia, odtwarzamy go.
                    # Ta funkcja sama zajmie się przywróceniem sortowania i zaznaczenia.
                    self._restore_view_state(self._state_to_restore)
                    self._state_to_restore = None  # Wyczyść flagę po użyciu
                else:
                    # Jeśli nie ma stanu do przywrócenia, stosujemy domyślne sortowanie z ustawień.
                    debug_print("[DB] Brak stanu do przywrócenia, aplikuję sortowanie niestandardowe.")
                    self.apply_custom_sort()

                # Odświeżamy tabelę zdarzeń na samym końcu, gdy zaznaczenie jest już poprawnie przywrócone.
                self.on_selection_changed()

    def call_add_overtime_procedure_fixed(self, user_id, year, month, start_datetime_obj, original_date_str, hours,
                                          settlement_date, is_overdue, overtime_type, location,
                                          nr_kadrowy):
        """
        Dodaje nadgodziny i zapewnia natychmiastową, niezawodną aktualizację
        tabeli zdarzeń oraz ikony w grafiku.
        """
        try:
            # Krok 1: Dodanie rekordu do bazy danych
            location_map = {'h': 1, 'p': 2, 's': 3}
            location_value = location_map.get(location, 1)
            param_value = 1 if overtime_type == 'odpracowanie' else None
            odebrane_value = 1 if overtime_type == 'odbiór' else 0

            end_datetime_obj = start_datetime_obj + timedelta(hours=float(hours))
            date_str_for_db = original_date_str  # Używamy oryginalnej daty z komórki

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            params = [
                nr_kadrowy, year, month, date_str_for_db, start_datetime_obj, end_datetime_obj,
                settlement_date, is_overdue, odebrane_value, location_value,
                param_value
            ]
            sql = f"{{CALL {SQL_OBJECTS['p_nadgodzinywstawienie']} ({', '.join(['?'] * len(params))})}}"
            import pyodbc
            cursor.execute(sql, params)

            # --- NOWA, OSTATECZNA LOGIKA: Niezawodna analiza wyników z procedury ---
            success = True
            message = "Nadgodziny zostały pomyślnie dodane."
            all_results = []

            # Pętla do odczytywania WSZYSTKICH zestawów wyników zwróconych przez procedurę
            while True:
                try:
                    rows = cursor.fetchall()
                    if rows:
                        all_results.extend(rows)
                    if not cursor.nextset():
                        break
                except pyodbc.ProgrammingError:
                    # Koniec zestawów wyników
                    break

            # Przetwarzanie zebranych wyników
            for row in all_results:
                if row and len(row) > 0 and row[0] is not None and row[0] != '0':
                    raw_value = row[0]
                    # Jeśli to tekst, jest to komunikat o błędzie
                    if isinstance(raw_value, str):
                        success = False
                        message = raw_value
                        break  # Przerywamy, bo wystąpił błąd

            conn.commit()
            conn.close()

            if success:
                # Krok 2: Rejestracja własnej zmiany i unieważnienie cache
                self._update_modification_date()

                # --- POCZĄTEK POPRAWKI 2.0 ---
                # Krok 2a: Niezawodne wyodrębnienie ID nowego rekordu i ręczne dodanie go do
                # głównej listy `all_events_data`, aby był od razu dostępny dla operacji "Odwołaj".
                if hasattr(self, 'all_events_data'):
                    try:
                        # Próbujemy wyodrębnić liczbę z komunikatu zwrotnego
                        new_event_id = int(str(message).strip())
                        new_event_data = self._fetch_specific_event_from_db(year, month, new_event_id, 'Nadgodziny')
                        if new_event_data:
                            local_event = self._convert_dp_event_to_local(new_event_data)
                            self.all_events_data.append(local_event)
                            debug_print(f"Ręcznie dodano nowe nadgodziny (ID: {new_event_id}) do self.all_events_data.")
                    except (ValueError, TypeError) as e:
                        log_warning(f"Nie udało się wyodrębnić ID nadgodzin z komunikatu: '{message}'. Błąd: {e}")

                # --- KONIEC POPRAWKI 2.0 ---

                self.data_provider.invalidate_complete_cache_for_pairs([(user_id, original_date_str)])

                # Krok 3: Odświeżenie dolnej tabeli zdarzeń
                self.on_selection_changed()

            return {"success": success, "message": message}

        except Exception as e:
            log_error(f"Błąd podczas dodawania nadgodzin: {e}", exception=e)
            return {
                "success": False,
                "message": f"Wystąpił błąd podczas dodawania nadgodzin: {str(e)}"
            }

    def _refresh_data_after_overtime_addition(self, new_id, user_id, date_str, year, month):
        """
        NOWA METODA: Odświeża dane z bazy po dodaniu nadgodzin
        """
        try:
            debug_print(f"Odświeżam dane po dodaniu nadgodzin ID={new_id}")

            # 1. POBIERZ NOWE ZDARZENIE Z BAZY DANYCH
            new_event = self._fetch_specific_event_from_db(year, month, new_id, 'Nadgodziny')

            if not new_event:
                log_error(f"Nie znaleziono dodanych nadgodzin o ID {new_id} w bazie danych")
                return

            debug_print(f"Pobrano nowe zdarzenie z bazy: {new_event}")

            # 2. AKTUALIZUJ CACHE DATAPROVIDER
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]

                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data")

                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []

                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in
                           container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache")

                # Aktualizuj processed_data - ustaw ikonę nadgodzin
                try:
                    day = int(date_str.split('-')[2])
                    for key, user_data in container.processed_data_base.items():
                        if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonę nadgodzin w processed_data")
                            break
                except Exception as e:
                    log_error(f"Błąd aktualizacji processed_data: {e}")

            # 3. AKTUALIZUJ LOKALNE DANE
            # Konwertuj na lokalny format
            local_event = self._convert_dp_event_to_local(new_event)

            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(local_event)
                    debug_print(f"Dodano nadgodziny do all_events_data")

            # 4. AKTUALIZUJ events_data TYLKO JEŚLI KOMÓRKA JEST ZAZNACZONA
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )

                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(local_event)
                        debug_print(f"Dodano nadgodziny do events_data")

                        # Aktualizuj model zdarzeń
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # 5. AKTUALIZUJ MODEL GRAFIKU
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_overtime=True
                )
                debug_print(f"Zaktualizowano ikony w schedule_model")

            # 6. WYCZYŚĆ CACHE IKON
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon")

            # 7. ODŚWIEŻ WIDOKI
            if hasattr(self, 'table'):
                if hasattr(self.table, 'schedule_view'):
                    self.table.schedule_view.viewport().update()

            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

            debug_print(f"=== ODŚWIEŻENIE DANYCH ZAKOŃCZONE ===")

        except Exception as e:
            log_error(f"Błąd podczas odświeżania danych: {e}")
            import traceback
            traceback.print_exc()

    def _fetch_specific_event_from_db(self, year: int, month: int, event_id: int, event_type: str) -> dict | None:
        """
        Pobiera dane pojedynczego, konkretnego zdarzenia z bazy danych.
        Używane do odświeżenia stanu po dodaniu nowego rekordu.
        """
        conn = None
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # Używamy istniejącej funkcji, ale filtrujemy po ID i typie
            query = f"SELECT * FROM {SQL_OBJECTS['fn_geteventsdata']}(?, ?) WHERE Id = ? AND EventType = ?"
            cursor.execute(query, (year, month, event_id, event_type))

            row = cursor.fetchone()
            if not row:
                return None

            # Mapowanie kolumn (logika skopiowana z DataProvider dla spójności)
            columns = [column[0] for column in cursor.description]
            raw_event = dict(zip(columns, row))

            # Przetwarzanie na format używany w aplikacji
            processed_event = {
                'type': raw_event.get('EventType'),
                'id': raw_event.get('Id'),
                'topic': raw_event.get('Temat'),
                'name': raw_event.get('Nazwa'),
                'user_id': raw_event.get('Uzytkownik'),
                'UzytkownikDane': raw_event.get('UzytkownikDane'),  #
                'date': raw_event.get('Data').strftime('%Y-%m-%d') if hasattr(raw_event.get('Data'),
                                                                              'strftime') else str(
                    raw_event.get('Data')),
                'time_from': raw_event.get('DataOd').strftime('%Y-%m-%d %H:%M') if hasattr(raw_event.get('DataOd'),
                                                                                           'strftime') else str(
                    raw_event.get('DataOd')),
                'time_to': raw_event.get('DataDo').strftime('%Y-%m-%d %H:%M') if hasattr(raw_event.get('DataDo'),
                                                                                         'strftime') else str(
                    raw_event.get('DataDo')),
                'status': raw_event.get('StatusNazwa'),
                'DataModyfikacji': raw_event.get('DataModyfikacji').strftime('%Y-%m-%d %H:%M') if hasattr(
                    raw_event.get('DataModyfikacji'), 'strftime') else str(raw_event.get('DataModyfikacji'))
            }
            return processed_event

        except Exception as e:
            log_error(f"Błąd podczas pobierania konkretnego zdarzenia (ID: {event_id}): {e}", exception=e)
            return None
        finally:
            if conn:
                conn.close()

    def _add_event_to_data_provider(self, new_id, user_id, user_name, date_str, start_time,
                                    end_time, overtime_type, is_overdue, year, month):
        """
        NOWA METODA: Dodaje zdarzenie bezpośrednio do DataProvider i wszystkich cache'y
        """
        try:
            # Utwórz obiekt zdarzenia w formacie DataProvider
            display_date = ".".join(reversed(date_str.split("-")))

            # Status na podstawie typu i flagi zaległości
            if overtime_type == 'wypłata':
                status = "Wypłata - zaległe" if is_overdue else "Wypłata"
            elif overtime_type == 'odbiór':
                status = "Odbiór"
            elif overtime_type == 'odpracowanie':
                status = "Odpracowanie"
            else:
                status = "Aktywne"

            # Utwórz zdarzenie w formacie zgodnym z DataProvider
            new_event_dp_format = {
                'event_type': 'Nadgodziny',
                'event_id': new_id,
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'date': date_str,  # DataProvider oczekuje YYYY-MM-DD
                'time_from': f"{start_time}",  # Format z bazy
                'time_to': f"{end_time}",
                'status': 'Wstawione',  # Status w formacie bazy
                'type': 'Nadgodziny',
                'id': new_id,
                'date_display': display_date,
                'date_key': date_str
            }

            # Utwórz zdarzenie w formacie lokalnym
            new_event_local_format = {
                'type': 'Nadgodziny',
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'user_name': user_name,
                'date': display_date,
                'date_key': date_str,
                'time_from': start_time,
                'time_to': end_time,
                'status': status,
                'id': new_id
            }

            # KLUCZOWA ZMIANA 1: Dodaj do cache DataProvider
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]

                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data (ID: {new_id})")

                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []

                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in
                           container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache (ID: {new_id})")

                # Aktualizuj processed_data - dodaj ikonę nadgodzin
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        try:
                            day = int(date_str.split('-')[2])
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonę nadgodzin w processed_data dla {user_id}, dzień {day}")
                            break
                        except:
                            pass

            # KLUCZOWA ZMIANA 2: Dodaj do lokalnych danych
            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(new_event_local_format)
                    debug_print(f"Dodano nadgodziny do all_events_data (ID: {new_id})")

            # KLUCZOWA ZMIANA 3: Dodaj do events_data tylko jeśli komórka jest zaznaczona
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )

                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(new_event_local_format)
                        debug_print(f"Dodano nadgodziny do events_data (ID: {new_id})")

                        # Aktualizuj model zdarzeń
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # KLUCZOWA ZMIANA 4: Aktualizuj ikonę w modelu
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonę nadgodzin w modelu dla ({user_id}, {date_str})")

            # KLUCZOWA ZMIANA 5: Wyczyść tylko cache ikon dla tej komórki (nie cały cache)
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla komórki ({user_id}, {date_str})")

            # Odśwież widok
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"Błąd podczas dodawania zdarzenia do DataProvider: {e}")

    def debug_check_event_in_index(self, event_id, event_type='Nadgodziny'):
        """
        Sprawdza, czy zdarzenie o podanym ID istnieje w indeksie zdarzeń
        i wyświetla informacje diagnostyczne.

        Args:
            event_id: ID zdarzenia
            event_type: Typ zdarzenia (domyślnie 'Nadgodziny')

        Returns:
            bool: True jeśli znaleziono zdarzenie, False w przeciwnym wypadku
        """
        debug_print(f"<br>--- DIAGNOSTYKA INDEKSU ZDARZEŃ ---")
        debug_print(f"Szukam zdarzenia o ID {event_id} i typie {event_type}")

        # Sprawdź w indeksie zdarzeń DataProvider
        if hasattr(self.data_provider, 'events_index'):
            # Sprawdź bezpośrednio przez indeks ID
            event = self.data_provider.events_index.get_event_by_id(event_id)
            if event:
                debug_print(f"ZNALEZIONO w indeksie ID: {event}")
                return True

            # Alternatywnie, przeszukaj wszystkie zdarzenia
            found_in_all = False
            for e in self.data_provider.events_index.all_events:
                if e.get('id') == event_id and e.get('type') == event_type:
                    debug_print(f"ZNALEZIONO w all_events: {e}")
                    found_in_all = True

            # Przeszukaj indeks typów
            found_in_type_index = False
            type_events = self.data_provider.events_index.type_index.get(event_type, [])
            for e in type_events:
                if e.get('id') == event_id:
                    debug_print(f"ZNALEZIONO w type_index: {e}")
                    found_in_type_index = True

            if not found_in_all and not found_in_type_index:
                debug_print("NIE ZNALEZIONO w indeksie zdarzeń")
                return False

            return found_in_all or found_in_type_index
        else:
            debug_print("BRAK indeksu zdarzeń w data_provider")
            return False

    def update_cell_data(self, user_id, date_str, event_type=None, action="update"):
        """
        Aktualizuje dane komórki i ikony po różnych operacjach.
        Zoptymalizowana wersja wykorzystująca precyzyjne aktualizacje.

        Args:
            user_id: ID użytkownika
            date_str: Data w formacie 'YYYY-MM-DD'
            event_type: Typ zdarzenia (Spotkanie, Szkolenie, Nadgodziny lub None)
            action: Rodzaj operacji - "update", "add", "delete"

        Returns:
            bool: True jeśli operacja się powiodła, False w przeciwnym wypadku
        """
        if not user_id or not date_str:
            return False

        # Standardyzuj format daty
        date_str = self.data_provider._standardize_date(date_str)

        # Wyczyść cache dla miesiąca tej daty
        if date_str and date_str.count('-') == 2:
            year, month, _ = date_str.split('-')
            self.clear_events_cache(int(year), int(month))

        # Pobierz zdarzenia dla tej pary (użytkownik, data)
        events = self.data_provider.get_events_for_user_date(user_id, date_str)

        # Sprawdź typy zdarzeń
        has_meeting = any(
            e.get('type') == 'Spotkanie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_training = any(
            e.get('type') == 'Szkolenie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_overtime = any(e.get('type') == 'Nadgodziny' for e in events)

        # Aktualizuj wskaźniki w modelu - używając zoptymalizowanej metody
        if hasattr(self, 'schedule_model'):
            if event_type == 'Spotkanie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Szkolenie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Nadgodziny':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny',
                                                                  is_active=(action != "delete"))
            else:
                # Aktualizuj wszystkie wskaźniki
                result1 = self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', has_meeting)
                result2 = self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', has_training)
                result3 = self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', has_overtime)
                return result1 or result2 or result3

        return False

    def _remove_s_symbol_directly(self, cells_to_update: list):
        """
        Usuwa symbol 'S' z grafiku przez bezpośredni UPDATE ORAZ aktualizuje
        model danych w aplikacji, aby zmiana była widoczna natychmiast.
        """
        if not cells_to_update:
            return

        updated_cells_info = []
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            table_name = SQL_OBJECTS['grafikipracy']

            for cell_data in cells_to_update:
                current_symbol = cell_data.get('symbol', '')
                if not current_symbol:
                    continue

                parsed = parse_symbol(current_symbol)
                if parsed.get('special_symbol', '').upper() == 'S':
                    new_symbol = build_symbol(
                        location=parsed.get('location'),
                        start_hour=parsed.get('start_hour'),
                        work_hours=parsed.get('work_hours'),
                        special_symbol=None
                    )

                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')

                    if user_id and date_str:
                        # Krok 1: Aktualizacja bazy danych
                        sql = f"UPDATE {table_name} SET Symbol = ? WHERE Uzytkownik = ? AND Data = ?"
                        cursor.execute(sql, (new_symbol, user_id, date_str))

                        # Zbierz dane do aktualizacji UI
                        updated_cells_info.append((user_id, date_str, new_symbol))

            if updated_cells_info:
                conn.commit()
                self.statusBar().showMessage(f"Usunięto symbol 'S' z {len(updated_cells_info)} komórek grafiku.", 3000)

            conn.close()

            # Krok 2: Bezpośrednia aktualizacja modelu danych w aplikacji
            # To zapewni natychmiastowe odświeżenie widoku bez resetowania sortowania.
            if updated_cells_info:
                self._update_cells_with_new_symbols(updated_cells_info)

        except Exception as e:
            log_error(f"Błąd podczas bezpośredniego usuwania symbolu 'S': {e}", exception=e)
            QMessageBox.critical(self, "Błąd Bazy Danych",
                                 f"Nie udało się usunąć symbolu 'S' z grafiku z powodu błędu:<br>{e}")

    def get_all_valid_symbols(self) -> set:
        """Zwraca zbiór wszystkich prawidłowych symboli specjalnych z załadowanej konfiguracji."""
        all_symbols = set()
        for category in app_settings.SYMBOL_CATEGORIES.values():
            all_symbols.update(category.keys())
        return all_symbols

    def apply_symbol_from_keyboard(self, special_symbol: str):
        """
        Uproszczona metoda: Aplikuje symbol z klawiatury, delegując logikę
        do scentralizowanej metody.
        """
        if special_symbol:
            self._apply_special_symbol_to_selection(special_symbol)

    def _apply_special_symbol_to_selection(self, special_symbol: str):
        """
        Aplikuje symbol specjalny do zaznaczonych komórek.
        Ostrzega o zmianie urlopu (U/UZ) dla KAŻDEJ roli.
        """
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not selected_cells_data:
            self.statusBar().showMessage("Nie zaznaczono żadnych komórek do edycji.", 3000)
            return

        if not self._can_modify_cells(selected_cells_data):
            return

        special_symbol_upper = special_symbol.upper()
        user_role = self.current_user_app_role

        # Czy to jest symbol absencji?
        is_absence = special_symbol_upper in app_settings.get_absence_symbols()

        show_vacation_plan_warning = False
        cells_to_process = []

        skipped_restricted_symbol = []
        skipped_day_off = []

        for cell_data in selected_cells_data:
            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_edit_symbol']:
                continue

            target_role = cell_data.get('rola_nazwa', '')
            current_symbol_str = cell_data.get('symbol', '')
            parsed_current = parse_symbol(current_symbol_str)
            current_special = (parsed_current.get('special_symbol') or '').upper()
            is_day_off = parsed_current.get('work_hours') is None

            # --- 1. Logika Lidera (Restrykcje) ---
            if user_role == 'Lider':
                # Blokada absencji w dni wolne
                if is_day_off and is_absence:
                    skipped_day_off.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                    continue
                # Blokada U/OS dla nie-Liderów
                if special_symbol_upper in ['U', 'OS'] and target_role != 'Lider':
                    skipped_restricted_symbol.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                    continue

            # --- 2. Logika Ostrzeżeń (DLA WSZYSTKICH RÓL) ---
            # Jeśli zmieniamy ISTNIEJĄCY urlop (U/UZ) na cokolwiek innego (co nie jest urlopem)
            # To włączamy ostrzeżenie. Niezależnie od tego czy jesteś Adminem czy Liderem.
            if current_special in ['U', 'UZ'] and special_symbol_upper not in ['U', 'UZ']:
                show_vacation_plan_warning = True

            cells_to_process.append(cell_data)

        # --- Obsługa błędów/pominięć ---
        if skipped_restricted_symbol:
            QMessageBox.warning(self, "Ograniczenia uprawnień",
                                f"Symbol '{special_symbol_upper}' może być wstawiony przez Lidera TYLKO innemu Liderowi.<br>"
                                f"Pominięto zmiany dla:<br>- {', '.join(set(skipped_restricted_symbol))}")

        if skipped_day_off:
            msg_users = "<br>- ".join(set(skipped_day_off)) if len(
                skipped_day_off) <= 5 else f"{len(skipped_day_off)} komórek"
            self.statusBar().showMessage(f"Pominięto wstawianie absencji w dni wolne dla: {msg_users}", 5000)

        if not cells_to_process:
            return

        # --- Przygotowanie zmian ---
        events_to_cancel = []
        if is_absence:
            user_date_pairs = {(c.get('uzytkownik_id'), c.get('date_str')) for c in cells_to_process}
            events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        reply = QMessageBox.Yes
        if self._should_ask_for_confirmation():
            grouped_changes = self._group_cells_for_symbol_changes(cells_to_process)
            changes_info = self._prepare_symbol_changes_description(grouped_changes, special_symbol)
            complete_info = f"Czy na pewno chcesz wprowadzić następujące zmiany?{changes_info}"

            # --- DODANIE OSTRZEŻENIA DO DIALOGU ---
            if show_vacation_plan_warning:
                complete_info += "<br><br><b><font color='orange'>UWAGA:</font> Zmieniasz symbol urlopu. Pamiętaj o usunięciu go z planów urlopowych!</b>"

            if events_to_cancel:
                grouped_events = self._group_events_by_user_date(events_to_cancel)
                delegations_info = self._prepare_delegations_description(grouped_events)
                complete_info += f"<br>{delegations_info}"

            reply = show_confirmation_dialog(self, "Potwierdzenie wstawienia symbolu", complete_info)

        if reply != QMessageBox.Yes:
            return

        if events_to_cancel:
            self.cancel_delegations(ask_for_confirmation=False)

        change_requests = []
        for cell_data in cells_to_process:
            # Używamy predykcji z logiką Lidera OUT
            new_symbol = self._predict_new_symbol(cell_data.get('symbol', ''), special_symbol, cell_data)
            change_requests.append((ChangeType.APPLY_BUILT_SYMBOL, cell_data, new_symbol))

        if change_requests:
            self.schedule_change_processor.start_changes(change_requests)
            # Dodatkowe info po operacji, jeśli nie było okna potwierdzenia (np. nieopublikowany grafik)
            if show_vacation_plan_warning and not self._should_ask_for_confirmation():
                QMessageBox.information(self, "Przypomnienie",
                                        "Zmieniono symbol urlopu. Pamiętaj o usunięciu go z planów urlopowych.")


    def _matches_user_search(self, item_text, item_id, item_login, search_text):
        """
        Sprawdza, czy element listy użytkowników pasuje do tekstu wyszukiwania.
        Obsługuje tryb pojedynczego wyszukiwania (substring w nazwie, loginie lub ID)
        oraz tryb wielokrotny po przecinku (dokładne dopasowanie loginów).

        Args:
            item_text (str): Nazwa wyświetlana użytkownika (już małymi literami).
            item_id (str): ID użytkownika (już małymi literami).
            item_login (str): Login użytkownika (już małymi literami).
            search_text (str): Surowy tekst z pola wyszukiwania (już małymi literami).

        Returns:
            bool: True, jeśli pasuje.
        """
        if not search_text:
            return True  # Pusty filtr pasuje do wszystkiego

        # Tryb wyszukiwania wielokrotnego (po przecinku)
        if ',' in search_text:
            logins_to_find = {login.strip() for login in search_text.split(',') if login.strip()}
            if not logins_to_find:
                return True  # Filtr jest pusty (np. same przecinki)

            # Sprawdź dokładne dopasowanie loginu (jeśli login istnieje)
            return item_login and (item_login in logins_to_find)

        # Tryb wyszukiwania pojedynczego (substring)
        # Pasuje do loginu LUB nazwy LUB ID
        return (search_text in item_text) or \
            (item_login and search_text in item_login) or \
            (search_text in item_id)

    def _matches_supervisor_search(self, item_text, search_text):
        """
        Sprawdza, czy element listy przełożonych pasuje do tekstu wyszukiwania.
        Obsługuje tryb pojedynczego wyszukiwania (substring)
        oraz tryb wielokrotny po przecinku (dopasowanie substringów).

        Args:
            item_text (str): Nazwa wyświetlana przełożonego (już małymi literami).
            search_text (str): Surowy tekst z pola wyszukiwania (już małymi literami).

        Returns:
            bool: True, jeśli pasuje.
        """
        if not search_text:
            return True  # Pusty filtr pasuje do wszystkiego

        # Tryb wyszukiwania wielokrotnego (po przecinku)
        if ',' in search_text:
            search_terms = {term.strip() for term in search_text.split(',') if term.strip()}
            if not search_terms:
                return True  # Filtr jest pusty (np. same przecinki)

            # Sprawdź, czy którakolwiek z fraz pasuje (jako substring) do nazwy
            for term in search_terms:
                if term in item_text:
                    return True
            return False

        # Tryb wyszukiwania pojedynczego (substring)
        return search_text in item_text

    def apply_theme_settings(self, theme, font_family, font_size):
        """Stosuje wybrane ustawienia motywu z wykorzystaniem centralnych stylów"""

        # --- NOWOŚĆ: Obsługa profili (jeśli argumenty są puste) ---
        # Zabezpiecza to sytuację startu aplikacji lub przeładowania ustawień
        if not font_family or not font_size:
            profiles = self.user_app_settings.get('layout_profiles', {})
            active = self.user_app_settings.get('active_profile', 'Podstawowy')
            prof = profiles.get(active, {})
            font_family = prof.get('font_family', 'Segoe UI')
            font_size = prof.get('font_size', 9)

        # Zapamiętaj wybrane ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = int(font_size)  # Upewniamy się, że to int

        # Zastosuj czcionkę do całej aplikacji
        font = QFont(font_family, self.current_font_size)
        QApplication.setFont(font)

        # Dodano styl dla QCalendarWidget
        calendar_style = AppStyles.get_calendar_style(theme)
        self.setStyleSheet(AppStyles.get_main_window_style(theme) + calendar_style)

        # Definicje stylów
        button_style = AppStyles.get_button_style(theme, font_family, self.current_font_size)
        combo_style = AppStyles.get_combobox_style(theme)
        line_edit_style = AppStyles.get_line_edit_style(theme)
        list_style = AppStyles.get_list_style(theme)
        date_edit_style = AppStyles.get_date_edit_style(theme)
        checkbox_style = AppStyles.get_checkbox_style(theme)
        table_style = AppStyles.get_table_style(theme)
        left_panel_style = AppStyles.get_left_panel_style(theme)

        # Stosowanie stylów do wszystkich istniejących kontrolek
        all_buttons = self.findChildren(QPushButton)

        icon_button_style = AppStyles.get_icon_button_style(theme)

        icon_buttons = []
        if hasattr(self, 'teams_chat_button'):
            icon_buttons.append(self.teams_chat_button)
        if hasattr(self, 'send_email_button'):
            icon_buttons.append(self.send_email_button)
        if hasattr(self, 'export_button'):
            icon_buttons.append(self.export_button)
        if hasattr(self, 'filter_settings_button'):
            icon_buttons.append(self.filter_settings_button)
        if hasattr(self, 'save_filter_button'):
            icon_buttons.append(self.save_filter_button)
        if hasattr(self, 'delete_filter_button'):
            icon_buttons.append(self.delete_filter_button)
        if hasattr(self, 'edit_filter_button'):
            icon_buttons.append(self.edit_filter_button)

        # --- NOWOŚĆ: Dodanie przycisku powiadomień do stylowania ---
        if hasattr(self, 'notification_btn'):
            icon_buttons.append(self.notification_btn)

        for button in icon_buttons:
            if button:
                button.setStyleSheet(icon_button_style)

        for button in all_buttons:
            if button not in icon_buttons:
                if "FilterClearButton" not in button.objectName():
                    button.setStyleSheet(button_style)

        new_icon = self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light
        for button in self.findChildren(QPushButton, "FilterClearButton"):
            button.setIcon(new_icon)

        # Pola wyboru (ComboBox) - w tym nowe filtry (grafik za pkt, brak nocki)
        combos_to_style = [
            getattr(self, name, None) for name in [
                'date_combo', 'grupa_main_filter_combo', 'wydzial_combo',
                'default_location_combo', 'system_czasu_pracy_combo',
                'rola_combo', 'jezyk_combo', 'etat_combo', 'dtn_combo',
                'rka_combo', 'podrola_combo', 'presence_location_combo',
                'presence_hour_combo', 'absence_symbol_combo', 'absence_hour_combo',
                'status_filter_combo', 'saved_filters_combo',
                'grafik_za_punkty_combo', 'brak_nocki_combo'  # <-- Nowe filtry
            ]
        ]
        for combo in combos_to_style:
            if combo:
                combo.setStyleSheet(combo_style)

        # Inne kontrolki
        if hasattr(self, '_left_panel'): self._left_panel.setStyleSheet(left_panel_style)
        if hasattr(self, 'przelozony_filter'): self.przelozony_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'topic_filter'): self.topic_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'name_filter'): self.name_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'przelozony_list'): self.przelozony_list.setStyleSheet(list_style)
        if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.setStyleSheet(list_style)
        if hasattr(self, 'date_from'): self.date_from.setStyleSheet(date_edit_style)
        if hasattr(self, 'date_to'): self.date_to.setStyleSheet(date_edit_style)
        if hasattr(self, 'presence_date_edit'): self.presence_date_edit.setStyleSheet(date_edit_style)
        if hasattr(self, 'absence_date_edit'): self.absence_date_edit.setStyleSheet(date_edit_style)

        checkboxes_to_style = [
            getattr(self, name, None) for name in [
                'meetings_checkbox', 'trainings_checkbox', 'overtime_checkbox',
                'filter_by_presence_check', 'filter_by_absence_check'
            ]
        ]
        for checkbox in checkboxes_to_style:
            if checkbox:
                checkbox.setStyleSheet(checkbox_style)

        # Aktualizacja modeli i tabel
        if hasattr(self, 'schedule_model'): self.schedule_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'events_model'): self.events_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'table'):
            if hasattr(self.table, 'employees_view'): self.table.employees_view.setStyleSheet(table_style)
            if hasattr(self.table, 'schedule_view'): self.table.schedule_view.setStyleSheet(table_style)
        if hasattr(self, 'events_table'): self.events_table.setStyleSheet(table_style)

        # Aktualizacja otwartych okien pomocniczych
        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            self.staffing_details_win.set_current_theme(self.is_dark_theme)

        if self.schedule_control_win and not self.schedule_control_win.isHidden():
            try:
                self.schedule_control_win.set_current_theme(self.is_dark_theme)
                if hasattr(self.schedule_control_win, 'error_dialog') and self.schedule_control_win.error_dialog:
                    self.schedule_control_win.error_dialog.set_current_theme(self.is_dark_theme)
            except RuntimeError:
                self.schedule_control_win = None

        # --- NOWOŚĆ: Aktualizacja motywu Centrum Powiadomień (jeśli istnieje) ---
        if hasattr(self, 'notification_drawer') and self.notification_drawer:
            self.notification_drawer.set_current_theme(self.is_dark_theme)

        # Na koniec aplikujemy dynamiczne rozmiary (z profilu)
        if hasattr(self, 'table'):
            self._apply_dynamic_sizes()

    def save_user_settings_on_exit(self):
        """Zbiera i zapisuje wszystkie ustawienia użytkownika przy zamykaniu."""
        if not hasattr(self, 'user_app_settings'):
            return

        # Zbierz dynamiczne ustawienia z UI
        ui_settings = {
            'is_maximized': self.isMaximized(),
            'window_size': (self.size().width(), self.size().height()),
            'last_filters': self.get_current_filters_state(),
            'column_widths': self.table.get_column_widths(),
            'visible_columns': self.visible_columns,
            'schedule_splitter_sizes': self.table.splitter.sizes() if hasattr(self, 'table') and hasattr(self.table,
                                                                                                         'splitter') else None,
            'theme': 'dark' if self.is_dark_theme else 'light',
            'font_family': self.current_font,
            'font_size': self.current_font_size
        }

        # Zaktualizuj główny słownik ustawień
        self.user_app_settings.update(ui_settings)

        # --- POPRAWKA: Upewnij się, że `row_colors` istnieje przed zapisem ---
        if 'row_colors' not in self.user_app_settings:
            self.user_app_settings['row_colors'] = {}

        # Zapisz cały słownik do bazy
        self.settings_db.save_settings(self.user_app_settings)
        debug_print("Zapisano ustawienia użytkownika przy zamknięciu.")

    def copy_selection_to_clipboard(self):
        """
        Zbiera dane z zaznaczonych komórek i kopiuje je do schowka
        w formacie TSV, gotowym do wklejenia w Excelu.
        """
        if not hasattr(self, 'table') or not self.schedule_model:
            return

        selection_model_employees = self.table.employees_view.selectionModel()
        selection_model_schedule = self.table.schedule_view.selectionModel()

        # --- NOWA, OSTATECZNA I UPROSZCZONA LOGIKA ---
        # Sprawdzamy, czy zaznaczenie istnieje TYLKO w lewej tabeli (dane pracowników).
        # `selectedIndexes()` dla prawej tabeli będzie puste, jeśli użytkownik nie kliknął w nią bezpośrednio.
        if selection_model_employees.hasSelection() and not selection_model_schedule.selectedIndexes():
            debug_print("Wykryto zaznaczenie tylko w tabeli pracowników. Kopiowanie tylko danych pracowników.")

            selected_indexes = selection_model_employees.selectedIndexes()
            if not selected_indexes:
                return

            # Grupuj indeksy po wierszach
            rows_data = defaultdict(dict)
            for index in selected_indexes:
                rows_data[index.row()][index.column()] = self.schedule_model.data(index, Qt.DisplayRole) or ""

            # Przygotuj nagłówki tylko dla zaznaczonych kolumn
            selected_cols = sorted(rows_data[list(rows_data.keys())[0]].keys())
            headers = [self.schedule_model.headerData(c, Qt.Horizontal) for c in selected_cols]
            clipboard_string = "\t".join(headers) + "\n"

            # Przygotuj dane
            for row_idx in sorted(rows_data.keys()):
                row_values = [rows_data[row_idx].get(col_idx, "") for col_idx in selected_cols]
                clipboard_string += "\t".join(row_values) + "\n"

            QApplication.clipboard().setText(clipboard_string)
            self.statusBar().showMessage(f"Skopiowano {len(rows_data)} wierszy danych pracownika do schowka.", 3000)
            return

        # --- ORYGINALNA LOGIKA DLA KOPIOWANIA GRAFIKU (jeśli zaznaczono coś w prawej tabeli) ---
        debug_print("Wykryto zaznaczenie w tabeli grafiku. Kopiowanie danych grafiku.")
        if not selection_model_employees.hasSelection() or not selection_model_schedule.hasSelection():
            self.statusBar().showMessage("Proszę zaznaczyć komórki do skopiowania.", 3000)
            return

        # Krok 1: Zbierz unikalne, posortowane indeksy wierszy i kolumn
        selected_rows = sorted(list(set(index.row() for index in selection_model_employees.selectedIndexes())))
        selected_schedule_cols = sorted(
            list(set(index.column() for index in selection_model_schedule.selectedIndexes())))

        if not selected_rows or not selected_schedule_cols:
            return

        clipboard_string = ""

        # Przygotuj nagłówki
        employee_headers = []
        visible_employee_cols_ids = self.schedule_model.get_visible_columns()
        for col_id in visible_employee_cols_ids:
            header_name = next((name for id, name, width in self.employee_columns if id == col_id), col_id)
            employee_headers.append(header_name)

        day_letters = []
        day_numbers = []
        for col in selected_schedule_cols:
            header_text = str(self.schedule_model.headerData(col, Qt.Horizontal, self.schedule_model.RawTextRole))
            parts = header_text.split('\n')
            if len(parts) == 2:
                day_numbers.append(parts[0])
                day_letters.append(parts[1])
            else:
                day_numbers.append(header_text)
                day_letters.append('')

        clipboard_string += "\t".join([''] * len(employee_headers) + day_letters) + "\n"
        clipboard_string += "\t".join(employee_headers + day_numbers) + "\n"

        # Przygotuj wiersze z danymi
        for row in selected_rows:
            row_values = []
            # Dane pracowników
            for col_idx in range(len(visible_employee_cols_ids)):
                index = self.schedule_model.index(row, col_idx)
                value = self.schedule_model.data(index, Qt.DisplayRole)
                row_values.append(str(value or ''))

            # Dane z grafiku
            for col in selected_schedule_cols:
                index = self.schedule_model.index(row, col)
                cell_data = self.schedule_model.data(index, ROLE_DATA)
                if isinstance(cell_data, dict):
                    symbol = cell_data.get('symbol', '')
                    row_values.append(symbol)
                else:
                    row_values.append('')

            clipboard_string += "\t".join(row_values) + "\n"

        QApplication.clipboard().setText(clipboard_string)
        self.statusBar().showMessage(f"Skopiowano {len(selected_rows)} wierszy do schowka.", 3000)

    @Slot(QPoint)
    def show_employee_table_context_menu(self, pos: QPoint):
        """Wyświetla menu kontekstowe dla lewej tabeli."""
        from PySide6.QtWidgets import QMenu
        context_menu = QMenu(self)

        # --- Akcja kopiowania ---
        copy_action = context_menu.addAction("Kopiuj zaznaczone komórki")
        copy_action.setEnabled(self.table.employees_view.selectionModel().hasSelection())
        copy_action.triggered.connect(self.copy_employee_cells_to_clipboard)

        context_menu.addSeparator()

        # --- Sekcja kolorowania wierszy ---
        color_menu = context_menu.addMenu("Pokoloruj wiersz")

        # --- NOWA, ROZSZERZONA PALETA KOLORÓW ---
        # Kluczem jest nazwa, wartością jest bazowy kolor HEX. Model sam dobierze
        # odpowiedni odcień dla jasnego i ciemnego motywu.
        colors = {  # Nazwa koloru : bazowy HEX
            "Czerwony": "#e57373",
            "Różowy": "#f06292",
            "Fioletowy": "#ba68c8",
            "Niebieski": "#64b5f6",
            "Cyjan": "#4dd0e1",
            "Zielony": "#81c784",
            "Bursztynowy": "#ffb74d",
            "Pomarańczowy": "#ff8a65",
        }

        import functools
        for name, hex_color in colors.items():
            action = color_menu.addAction(name)
            action.triggered.connect(functools.partial(self.set_row_color, hex_color))

        color_menu.addSeparator()
        clear_color_action = color_menu.addAction("Wyczyść kolor")
        clear_color_action.triggered.connect(functools.partial(self.set_row_color, None))

        # Menu jest aktywne tylko, jeśli coś jest zaznaczone
        color_menu.setEnabled(self.table.employees_view.selectionModel().hasSelection())

        # --- NOWA SEKCJA: Menu dla kolumn niestandardowych ---
        if self.custom_columns:
            context_menu.addSeparator()
            custom_cols_main_menu = context_menu.addMenu("Ustaw wartość kolumny")

            for col_id, col_data in self.custom_columns.items():
                col_menu = custom_cols_main_menu.addMenu(col_data['name'])

                set_value_action = col_menu.addAction("Ustaw wartość...")
                set_value_action.triggered.connect(functools.partial(self.set_custom_column_value, col_id))

                clear_value_action = col_menu.addAction("Wyczyść wartość")
                clear_value_action.triggered.connect(functools.partial(self.set_custom_column_value, col_id, None))

                col_menu.addSeparator()

                # Dodaj szybkie akcje dla najczęstszych wartości
                unique_values = set(col_data['values'].values())
                if unique_values:
                    for value in sorted(list(unique_values))[:5]:  # Pokaż do 5 najczęstszych
                        quick_action = col_menu.addAction(f"Ustaw na: '{value}'")
                        quick_action.triggered.connect(functools.partial(self.set_custom_column_value, col_id, value))

        # Wyświetl menu w miejscu kliknięcia
        context_menu.exec(self.table.employees_view.viewport().mapToGlobal(pos))

    def set_row_color(self, color_hex: str | None):
        """Ustawia kolor tła dla zaznaczonych wierszy."""
        debug_print(f"set_row_color: Wywołano z color_hex={color_hex}")
        selected_rows = self.table.get_selected_rows()
        if not selected_rows:
            return

        if 'row_colors' not in self.user_app_settings:
            self.user_app_settings['row_colors'] = {}

        for row_index in selected_rows:
            key = self.schedule_model._keys[row_index]
            user_id = str(key[3])  # Upewnijmy się, że ID jest stringiem
            debug_print(f"set_row_color: Przetwarzam wiersz {row_index}, user_id={user_id}")

            if color_hex:
                self.user_app_settings['row_colors'][user_id] = color_hex
                debug_print(f"set_row_color: Ustawiam kolor {color_hex} dla user_id={user_id}")
            elif user_id in self.user_app_settings['row_colors']:
                del self.user_app_settings['row_colors'][user_id]
                debug_print(f"set_row_color: Usuwam kolor dla user_id={user_id}")

        # Zapisz ustawienia w tle
        self.settings_db.save_settings(self.user_app_settings)

        # Bezpośrednio poinformuj model o zmianie kolorów
        self.schedule_model.set_row_colors(self.user_app_settings['row_colors'])
        debug_print(
            f"set_row_color: Wywołano schedule_model.set_row_colors z {len(self.user_app_settings['row_colors'])} kolorami.")
        self.table.employees_view.viewport().update()
        self.table.schedule_view.viewport().update()
        debug_print("set_row_color: Wymuszono odświeżenie viewportów tabel.")

    def set_custom_column_value(self, col_id: str, value: str | None = -1):
        """
        Ustawia wartość dla niestandardowej kolumny dla zaznaczonych wierszy.
        WERSJA ZMODYFIKOWANA: Zapisuje wartości w kontekście Roku i Miesiąca.
        """
        selected_rows = self.table.get_selected_rows()
        if not selected_rows:
            return

        # Pobierz aktualny kontekst czasowy z widoku
        current_year = self.year
        current_month = self.month

        # Jeśli value jest -1, to znaczy, że trzeba zapytać użytkownika
        if value == -1:
            # Pobierz ostatnią znaną wartość dla tej komórki (dla bieżącego miesiąca!)
            first_key = self.schedule_model._keys[selected_rows[0]]
            first_user_id = str(first_key[3])

            # Klucz uwzględniający datę
            storage_key = f"{first_user_id}|{current_year}|{current_month}"

            current_value = self.custom_columns[col_id]['values'].get(storage_key, "")

            text, ok = QInputDialog.getText(self, "Ustaw wartość",
                                            f"Wprowadź wartość dla kolumny '{self.custom_columns[col_id]['name']}'\n(dla {current_year}-{current_month:02d}):",
                                            QLineEdit.Normal,
                                            current_value)
            if not ok:
                return
            value = text.strip()

        # Aktualizuj dane
        value_changed = False
        for row_index in selected_rows:
            key = self.schedule_model._keys[row_index]
            user_id = str(key[3])

            # Klucz uwzględniający datę
            storage_key = f"{user_id}|{current_year}|{current_month}"

            old_value = self.custom_columns[col_id]['values'].get(storage_key)

            if value:  # Ustawianie lub zmiana wartości
                if old_value != value:
                    self.custom_columns[col_id]['values'][storage_key] = value
                    value_changed = True
            elif storage_key in self.custom_columns[col_id]['values']:  # Usuwanie wartości
                del self.custom_columns[col_id]['values'][storage_key]
                value_changed = True

        # Zapisz i odśwież tylko wtedy, gdy faktycznie nastąpiła zmiana
        if not value_changed:
            self.statusBar().showMessage("Wartości są już ustawione.", 3000)
            return

        self.user_app_settings['custom_columns'] = self.custom_columns
        self.settings_db.save_settings(self.user_app_settings)

        # Poinformuj model o zmianie
        self.schedule_model.set_custom_columns(self.custom_columns)
        self.update_filters()

        # Wymuś odświeżenie widoku tabeli
        self.table.employees_view.viewport().update()
        self.table.schedule_view.viewport().update()
        self.statusBar().showMessage(f"Zaktualizowano wartości dla kolumny '{self.custom_columns[col_id]['name']}'.",
                                     3000)

    def copy_employee_cells_to_clipboard(self):
        """Kopiuje tylko zaznaczone komórki z lewej tabeli (dane pracowników)."""
        selection_model = self.table.employees_view.selectionModel()
        selected_indexes = selection_model.selectedIndexes()

        if not selected_indexes:
            self.statusBar().showMessage("Brak zaznaczonych komórek do skopiowania.", 3000)
            return

        # Grupuj indeksy po wierszach, aby zachować strukturę tabeli
        rows_data = defaultdict(dict)
        for index in selected_indexes:
            rows_data[index.row()][index.column()] = self.schedule_model.data(index, Qt.DisplayRole) or ""

        # Przygotuj nagłówki tylko dla zaznaczonych kolumn
        # Używamy pierwszego wiersza jako referencji do pobrania indeksów kolumn
        selected_cols = sorted(rows_data[list(rows_data.keys())[0]].keys())
        headers = [self.schedule_model.headerData(c, Qt.Horizontal) for c in selected_cols]
        clipboard_string = "\t".join(headers) + "\n"

        # Przygotuj dane wiersz po wierszu
        for row_idx in sorted(rows_data.keys()):
            row_values = [rows_data[row_idx].get(col_idx, "") for col_idx in selected_cols]
            clipboard_string += "\t".join(row_values) + "\n"

        QApplication.clipboard().setText(clipboard_string)
        self.statusBar().showMessage(f"Skopiowano dane z {len(selected_indexes)} komórek.", 3000)

    def _synchronize_custom_filter_widgets(self):
        """
        Tworzy widgety filtrów dla nowych kolumn niestandardowych i usuwa widgety
        dla kolumn, które zostały usunięte.
        """
        debug_print("[Filtracja] Rozpoczęto synchronizację widgetów filtrów niestandardowych...")

        current_col_ids = set(self.custom_columns.keys())
        current_map_ids = set(k for k in self.filter_widget_map.keys() if k.startswith("custom_"))

        # 1. Usuń widgety dla kolumn, które już nie istnieją
        cols_to_remove = current_map_ids - current_col_ids
        for col_id in cols_to_remove:
            debug_print(f"[Filtracja] Usuwanie widgetu filtra dla: {col_id}")
            widget = self.filter_widget_map.pop(col_id, None)
            if widget:
                widget.setParent(None)
                widget.deleteLater()
            # Usuń też z listy widocznych, jeśli tam jest
            if col_id in self.visible_filters_list:
                self.visible_filters_list.remove(col_id)

        # 2. Dodaj widgety dla nowych kolumn
        cols_to_add = current_col_ids - current_map_ids
        for col_id in cols_to_add:
            col_name = self.custom_columns[col_id].get('name', col_id)
            debug_print(f"[Filtracja] Tworzenie widgetu filtra dla: {col_id} (Nazwa: {col_name})")

            # Pobierz nadrzędny widget (filter_container) z self.filters_layout
            parent_widget = self.filters_layout.parentWidget()
            if not parent_widget:
                log_error("[Filtracja] Nie można znaleźć rodzica dla nowych widgetów filtra!")
                parent_widget = self._left_panel  # Fallback

            # Użyjemy add_horizontal_filter do stworzenia kontrolek
            # Ważne: ta metoda używa self.add_horizontal_filter, która zwraca (layout, combo, btn)
            # Potrzebujemy kontenera dla tego layoutu

            # Tworzymy layout i jego kontrolki
            # Używamy unikalnej nazwy obiektu dla comboboxa
            layout, combo, btn = self.add_horizontal_filter(f"{col_name}:", f"filter_combo_{col_id}")

            # Tworzymy widget-kontener z właściwym rodzicem
            container_widget = QWidget(parent=parent_widget)

            # Ustawiamy rodziców dla elementów layoutu
            combo.setParent(container_widget)
            btn.setParent(container_widget)
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if item and item.widget():
                    item.widget().setParent(container_widget)

            container_widget.setLayout(layout)
            container_widget.setVisible(False)  # Domyślnie ukryty, aż _apply_filter_visibility_and_order go pokaże

            # Zapisujemy kontener w mapie
            self.filter_widget_map[col_id] = container_widget

            # Zastosuj styl
            theme = "dark" if self.is_dark_theme else "light"
            combo.setStyleSheet(AppStyles.get_combobox_style(theme))
            btn.setIcon(self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light)

    def _on_heartbeat_tick(self):
        """
        Cykliczne zadanie: TYLKO wysłanie heartbeatu (aktualizacja czasu w bazie).
        Komendy są teraz obsługiwane przez Service Broker w czasie rzeczywistym.
        """
        if hasattr(self, 'session_manager'):
            # Używamy prostej metody send_heartbeat() z session_manager.py
            # (upewnij się, że w session_manager.py masz tę prostą metodę, którą podałem w kroku 3 poprzedniej odpowiedzi)
            self.session_manager.send_heartbeat()

    # --- Handler dla REFRESH_PERMISSIONS ---
    def _handle_admin_refresh_permissions(self):
        """Odświeża uprawnienia użytkownika na żądanie administratora."""
        debug_print("Wykonywanie zdalnego odświeżania uprawnień...")
        load_all_app_settings()
        self.check_user_permissions()

        # Opcjonalnie: Jeśli rola się zmieniła, odśwież widok
        self.update_buttons_visibility()
        self.statusBar().showMessage("Uprawnienia zostały zaktualizowane zdalnie.", 5000)

    # --- Handler dla KILL_SESSION ---
    def _handle_admin_kill_session(self, reason):
        """Zamyka aplikację na żądanie administratora."""
        reason_text = reason if reason else "Administrator wymusił zamknięcie sesji."
        debug_print(f"Wykonywanie zdalnego zamknięcia sesji. Powód: {reason_text}")

        # Zapisz sesję jako zamkniętą zdalnie
        self.session_manager.end_session(exit_type="RemoteKill")

        # Pokaż komunikat (blokujący, żeby użytkownik przeczytał)
        QMessageBox.warning(self, "Sesja zakończona",
                            f"Twoja sesja została zamknięta przez administratora.\n\nPowód: {reason_text}")

        # Zamknij aplikację
        QApplication.quit()

    # --- Handler dla MESSAGE ---
    def _handle_admin_message(self, message):
        """Wyświetla wiadomość od administratora."""
        if message:
            QMessageBox.information(self, "Wiadomość od Administratora", message)

    def resizeEvent(self, event):
        """Aktualizuje pozycję panelu powiadomień przy zmianie rozmiaru okna."""
        if hasattr(self, 'notification_drawer') and self.notification_drawer:
            self.notification_drawer.update_geometry()
        super().resizeEvent(event)

    def closeEvent(self, event):
        """Obsługuje zamknięcie aplikacji i zapisuje ustawienia."""
        debug_print("=== ZAMYKANIE APLIKACJI TEAMFLOW ===")

        try:
            # KROK 1: Zatrzymaj wątki w tle NAJPIERW (przed zapisem ustawień)
            # Zatrzymaj Service Broker Listener
            if hasattr(self, 'db_listener') and self.db_listener:
                debug_print("Zatrzymywanie Service Broker Listener...")
                self.db_listener.cancel()
                if not self.db_listener.wait(2000):  # Czekaj max 2 sekundy
                    debug_print("Service Broker Listener nie zakończył się w czasie, wymuszam zakończenie")
                    self.db_listener.terminate()
                debug_print("Service Broker Listener zatrzymany")

            # Zatrzymaj BackgroundCheckerThread timer
            if hasattr(self, 'background_checker_timer') and self.background_checker_timer:
                debug_print("Zatrzymywanie BackgroundCheckerThread timer...")
                self.background_checker_timer.stop()
                debug_print("BackgroundCheckerThread timer zatrzymany")

            if hasattr(self, 'heartbeat_timer'):
                self.heartbeat_timer.stop()

                # Zamknij sesję w bazie (jeśli nie była już zamknięta przez KILL_SESSION)
            if hasattr(self, 'session_manager'):
                self.session_manager.end_session(exit_type="UserExit")

            # KROK 2: Zapisz ustawienia użytkownika
            debug_print("Zapisywanie ustawień użytkownika...")
            self.save_user_settings_on_exit()
            debug_print("Zapisano ustawienia użytkownika przy zamknięciu.")

            # KROK 3: Wyczyść filtr klawiatury
            debug_print("Czyszczenie filtra klawiatury...")
            self.cleanup_keyboard_filter()

            # KROK 4: Zamknij plik logów
            debug_print("Zamykanie pliku logów...")
            close_log_file()

        except Exception as e:
            # Zaloguj błąd, ale nie blokuj zamknięcia aplikacji
            try:
                log_error(f"Wystąpił błąd podczas zamykania aplikacji: {e}", exception=e)
            except:
                # Jeśli nawet logowanie się nie udaje, wypisz na stdout
                print(f"KRYTYCZNY BŁĄD podczas zamykania: {e}")
        finally:
            # Zawsze akceptuj zamknięcie, nawet jeśli coś poszło nie tak
            event.accept()


if __name__ == "__main__":
    app = QApplication(sys.argv)

    # Krok 1: Załaduj kluczowe ustawienia PRZED utworzeniem głównego okna
    if not load_all_app_settings():
        QMessageBox.critical(None, "Błąd Krytyczny",
                             "Nie udało się załadować konfiguracji aplikacji z serwera.<br>"
                             "Sprawdź połączenie z bazą danych i plik config.ini.<br><br>"
                             "Aplikacja nie może zostać uruchomiona.")
        sys.exit(1)

    # Krok 2: Sprawdź wersję aplikacji PRZED utworzeniem głównego okna
    if parse_version(APP_VERSION) != parse_version(app_settings.REQUIRED_VERSION):
        dialog = UpdateRequiredDialog()
        dialog.exec()
        sys.exit(0)

    # Krok 3: Zainicjuj logowanie
    try:
        current_windows_user = getpass.getuser().lower()
    except Exception:
        current_windows_user = "unknown_user"
    log_to_file = False
    log_to_console = True
    setup_logging(log_to_file=log_to_file, log_to_console=log_to_console)

    # Krok 4: Utwórz główne okno (wczyta ustawienia użytkownika w __init__)
    window = WorkScheduleWindow()

    # === POCZĄTEK ZMIAN ===
    # Krok 5: Ustaw stan i rozmiar okna PRZED jego pokazaniem
    is_maximized = window.user_app_settings.get('is_maximized', False)  # Pobierz ustawienie

    if is_maximized:
        # Ustaw stan na zmaksymalizowany (ale jeszcze nie pokazuj)
        window.setWindowState(Qt.WindowMaximized)
        debug_print("Ustawiono stan okna na zmaksymalizowany przed pokazaniem.")
    else:
        # Pobierz zapisany rozmiar lub domyślny
        width, height = window.user_app_settings.get('window_size', (1600, 800))
        # Ustaw rozmiar okna (bez ustawiania pozycji)
        window.resize(width, height)
        debug_print(f"Ustawiono rozmiar okna na {width}x{height} przed pokazaniem.")
        # Opcjonalnie: wyśrodkuj okno na ekranie
        try:
            screen_geometry = QApplication.primaryScreen().availableGeometry()
            window.move(int((screen_geometry.width() - width) / 2),
                        int((screen_geometry.height() - height) / 2))
            debug_print("Wyśrodkowano okno.")
        except Exception as e:
            log_error(f"Nie udało się wyśrodkować okna: {e}")

    # Krok 6: Pokaż okno (powinno się pojawić już w docelowym stanie/rozmiarze)
    window.show()
    debug_print("Wywołano window.show().")
    # === KONIEC ZMIAN ===

    sys.exit(app.exec())
