Skoro wracamy do "starej, dobrej metody" (czyli po prostu: wyczyÅ›Ä‡ dane i wstaw), musimy teÅ¼ uproÅ›ciÄ‡ plik importy.py.
Musisz podmieniÄ‡ funkcjÄ™ handle_task w klasie TaskManager.
Co zmieniamy?
 * Usuwamy przekazywanie lookup_keys: Nie bÄ™dziemy juÅ¼ wysyÅ‚aÄ‡ tego parametru do insert_data.
 * Naprawiamy bÅ‚Ä…d "cannot unpack non-iterable bool object": Zamiast zwracaÄ‡ samo True lub False, funkcja bÄ™dzie zwracaÄ‡ krotkÄ™ (True, "Komunikat"). To zabezpieczy CiÄ™ przed bÅ‚Ä™dem, ktÃ³ry widziaÅ‚eÅ› wczeÅ›niej.
Oto peÅ‚ny kod funkcji handle_task. PodmieÅ„ go w pliku importy.py.
    def handle_task(self, task: dict):
        """ObsÅ‚uga pojedynczego zadania (Wersja Stabilna - Standard Insert)"""
        task_name = task.get('name', 'Nieznane zadanie')
        start_time = datetime.now()

        try:
            # Logowanie rozpoczÄ™cia zadania
            self._log_task(task_name, status='Running', start_time=start_time)
            self.logger.info(f"Rozpoczynam zadanie: {task_name}")

            # 1. Czyszczenie tabel tymczasowych (opcjonalne)
            if 'delete_temp' in task:
                self.logger.info(f"WykonujÄ™ czyszczenie tabel tymczasowych")
                # ZakÅ‚adamy, Å¼e ta metoda istnieje w db_manager
                if hasattr(self.db_manager, 'drop_oracle_tables_with_keywords'):
                    self.db_manager.drop_oracle_tables_with_keywords('Oracle', 'TEMP')

            # 2. Delete Query (czyszczenie danych przed wstawieniem)
            if 'delete_query' in task:
                self.logger.info(f"WykonujÄ™ zapytanie usuwajÄ…ce dane")
                self.db_manager.execute_sql(task['destination_db'], task['delete_query'])

            # 3. Fetch & Insert (GÅ‚Ã³wna logika)
            df = None
            if 'fetch_sql' in task:
                self.logger.info(f"Pobieram dane z {task['source_db']}...")
                
                df = self.db_manager.fetch_data(
                    source_db=task['source_db'],
                    sql=task['fetch_sql'], # Upewnij siÄ™, Å¼e nazwa parametru to 'sql' lub 'fetch_sql' zaleÅ¼nie od definicji fetch_data
                    params=task.get('date_param'),
                    split_by_semicolon=True if task.get('split_by_semicolon') is not False else False
                )

                if df is not None and 'destination_db' in task:
                    self.logger.info(f"Wstawiam dane do {task['destination_db']} (tabela {task['sql_table']})...")
                    
                    # ğŸ’¥ STANDARDOWE WSTAWIANIE (BEZ LOOKUP) ğŸ’¥
                    self.db_manager.insert_data(
                        df=df,
                        target_db=task['destination_db'],
                        table_name=task['sql_table'],
                        schema=task['schema'],
                        batch_size=task.get('batch_size', 1000000),
                        if_exists=task.get('if_exists', 'append'),
                        verbose=True
                        # Tu juÅ¼ NIE przekazujemy lookup_keys
                    )

            # 4. Execute Query (dodatkowe SQL po insercie)
            if 'execute_query' in task:
                self.logger.info(f"WykonujÄ™ dodatkowe zapytanie SQL")
                self.db_manager.execute_sql(task['source_db'], task['execute_query'], task.get('date_param'))

            # 5. Procedure (wywoÅ‚anie procedury skÅ‚adowanej)
            if 'procedure' in task:
                self.logger.info(f"WykonujÄ™ procedurÄ™")
                self.db_manager.execute_sql(task['source_db'], task['procedure'])

            # Sukces
            end_time = datetime.now()
            self._log_task(task_name, status='SUCCESS', start_time=start_time, end_time=end_time)
            self.logger.info(f"ZakoÅ„czono zadanie {task_name}. Czas: {end_time - start_time}")
            
            # ğŸ’¥ WAÅ»NE: Zwracamy krotkÄ™ (Status, Komunikat) Å¼eby uniknÄ…Ä‡ bÅ‚Ä™du 'cannot unpack'
            return True, "Success"

        except Exception as e:
            end_time = datetime.now()
            error_msg = f"BÅ‚Ä…d zadania {task_name}: {str(e)}"
            self.logger.error(error_msg)
            self._log_task(task_name, status='ERROR', start_time=start_time, end_time=end_time, message=error_msg)
            
            # Zwracamy FaÅ‚sz w przypadku bÅ‚Ä™du
            return False, str(e)

Czy muszÄ™ zmieniaÄ‡ listÄ™ tasks = [...]?
Nie musisz.
W pliku db_m_windows.py dodaÅ‚em w funkcji insert_data parametr **kwargs.
Oznacza to, Å¼e nawet jeÅ›li w definicji zadania (lista tasks) zostaÅ‚o Ci lookup_keys: [...], a stara funkcja handle_task jakoÅ› by to przekazaÅ‚a, to funkcja insert_data po prostu to zignoruje.
Po wklejeniu powyÅ¼szego handle_task i poprzednich funkcji do db_manager, caÅ‚oÅ›Ä‡ powinna dziaÅ‚aÄ‡ stabilnie jak dawniej, ale z lepszym czyszczeniem danych (brak bÅ‚Ä™dÃ³w ORA-01722).
