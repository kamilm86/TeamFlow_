To Å›wietna wiadomoÅ›Ä‡! PrzeszliÅ›my przez najtrudniejsze bÅ‚Ä™dy zwiÄ…zane z typami danych (ORA-01439 jest teraz poprawnie ignorowany jako WARNING).
Aktualny bÅ‚Ä…d: Not an executable object: 'DROP TABLE ...' oraz Not an executable object: '\n MERGE INTO ...'
ðŸ” Diagnoza
Ten bÅ‚Ä…d wystÄ™puje w nowszych wersjach biblioteki SQLAlchemy (wersja 2.0+).
Biblioteka ta nie pozwala juÅ¼ na przekazywanie "zwykÅ‚ego tekstu" (stringa) bezpoÅ›rednio do funkcji connection.execute(). KaÅ¼de zapytanie SQL napisane jako tekst musi byÄ‡ "opakowane" w funkcjÄ™ text().
ðŸ› ï¸ RozwiÄ…zanie
Musisz poprawiÄ‡ funkcjÄ™ _custom_merge_insert (tÄ™, ktÃ³rÄ… dodaliÅ›my do obsÅ‚ugi lookupu). Trzeba w niej dodaÄ‡ text(...) w dwÃ³ch miejscach: przy wykonywaniu MERGE i przy usuwaniu tabeli tymczasowej.
Oto poprawiony kod. PodmieÅ„ caÅ‚Ä… funkcjÄ™ _custom_merge_insert w swojej klasie DatabaseManager.
    def _custom_merge_insert(self, target_db: str, batch: pd.DataFrame, table: str, schema: str,
                             lookup_keys: List[str], conn) -> None:
        """
        Realizuje wstawienie rekordÃ³w, ktÃ³re nie istniejÄ… (lookup)
        z uÅ¼yciem tabeli tymczasowej i kwerendy MERGE/NOT EXISTS.
        """
        # IMPORT KONIECZNY DO POPRAWKI
        from sqlalchemy import text 

        if not lookup_keys:
            self.logger.info("Brak kluczy lookup. UÅ¼ycie standardowego wstawiania (to_sql).")
            batch.to_sql(table, conn, schema=schema, if_exists='append', index=False)
            return

        # 1. Przygotowanie: Tabela tymczasowa
        import uuid
        temp_table_name = f"TEMP_{uuid.uuid4().hex}"
        
        self.logger.info(f"Tworzenie tymczasowej tabeli {temp_table_name} dla partii ({len(batch)} rekordÃ³w).")
        
        try:
            # Wstawienie danych do tabeli tymczasowej
            batch.to_sql(temp_table_name, conn, schema=schema, if_exists='replace', index=False)
            
            # Przygotowanie kolumn
            all_cols_quoted = [f'"{col}"' for col in batch.columns]
            all_cols_str = ", ".join(all_cols_quoted)
            
            # Warunki zÅ‚Ä…czenia
            join_conditions = " AND ".join([f"T.\"{key}\" = S.\"{key}\"" for key in lookup_keys])
            
            sql_query = ""
            
            if target_db.lower() == 'oracle':
                # --- Oracle: MERGE ---
                values_cols = ', '.join([f"S.{col}" for col in all_cols_quoted])
                
                sql_query = f"""
                MERGE INTO "{schema}"."{table}" T
                USING "{schema}"."{temp_table_name}" S
                ON ({join_conditions})
                WHEN NOT MATCHED THEN
                    INSERT ({all_cols_str})
                    VALUES ({values_cols})
                """
                
            elif target_db in ['SQLServer', 'Impala']:
                # --- SQL Server / Impala: NOT EXISTS ---
                where_not_exists = " AND ".join([f"T.\"{key}\" = S.\"{key}\"" for key in lookup_keys])
                select_cols = ', '.join([f"S.{col}" for col in all_cols_quoted])
                
                sql_query = f"""
                INSERT INTO "{schema}"."{table}" ({all_cols_str})
                SELECT {select_cols}
                FROM "{schema}"."{temp_table_name}" S
                WHERE NOT EXISTS (
                    SELECT 1
                    FROM "{schema}"."{table}" T
                    WHERE {where_not_exists}
                )
                """
            
            self.logger.info("Wykonanie operacji MERGE/NOT EXISTS INSERT.")
            
            # ðŸ’¥ POPRAWKA 1: Opakowanie zapytania w text()
            conn.execute(text(sql_query))
            
        finally:
            # 3. Czyszczenie: UsuniÄ™cie tabeli tymczasowej
            self.logger.info(f"Usuwanie tymczasowej tabeli {temp_table_name}.")
            try:
                # ðŸ’¥ POPRAWKA 2: Opakowanie zapytania DROP w text()
                drop_sql = f'DROP TABLE "{schema}"."{temp_table_name}"'
                conn.execute(text(drop_sql))
            except Exception as e:
                self.logger.error(f"Nie udaÅ‚o siÄ™ usunÄ…Ä‡ tabeli tymczasowej {temp_table_name}: {e}")

Co dokÅ‚adnie siÄ™ zmieniÅ‚o?
 * DodaÅ‚em from sqlalchemy import text na poczÄ…tku funkcji.
 * ZmieniÅ‚em conn.execute(sql_query) na conn.execute(text(sql_query)).
 * ZmieniÅ‚em conn.execute(f'DROP TABLE ...') na conn.execute(text(f'DROP TABLE ...')).
Po tej zmianie operacja MERGE powinna siÄ™ wykonaÄ‡ poprawnie!
