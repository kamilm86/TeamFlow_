Oto poprawiony kod dla funkcji create_table_if_not_exists.
G≈Ç√≥wnym problemem, kt√≥ry powodowa≈Ç b≈ÇƒÖd Cannot interpret 'VARCHAR(length=19)', by≈Ço prawdopodobnie u≈ºycie nieprawid≈Çowych ciƒÖg√≥w znak√≥w (takich jak 'VARCHAR(length)') w definicjach kolumn dla SQLAlchemy/SQL. W przypadku Oracle, czƒôsto u≈ºywa siƒô VARCHAR2 zamiast samego VARCHAR, a d≈Çugo≈õci sƒÖ kluczowe.
Poni≈ºsza wersja koncentruje siƒô na poprawnym formatowaniu ciƒÖgu SQL dla ka≈ºdej bazy danych, biorƒÖc pod uwagƒô standardy, kt√≥re widaƒá w Twoim kodzie.
üõ†Ô∏è Poprawiona funkcja create_table_if_not_exists
Poprawiona funkcja znajduje siƒô w klasie DatabaseManager i skupia siƒô na sekcjach dla Oracle i SQL Server, gdzie najczƒô≈õciej wystƒôpujƒÖ problemy z definicjƒÖ typ√≥w (linia 577 i 605 na Twoim zdjƒôciu).
# --- Fragment klasy DatabaseManager ---

def create_table_if_not_exists(self, engine, df: pd.DataFrame, table_name: str, 
                               schema: str, target_db: str) -> None:
    
    """
    Tworzy tabelƒô docelowƒÖ, je≈õli nie istnieje, u≈ºywajƒÖc dynamicznie
    mapowanych typ√≥w danych dla konkretnej bazy.
    """
    
    # 1. Sprawdzenie, czy tabela ju≈º istnieje (poprzez zapytanie systemowe)
    with engine.connect() as connection:
        if connection.dialect.has_table(connection, table_name, schema=schema):
            self.logger.info(f"Tabela {schema}.{table_name} ju≈º istnieje.")
            return True # Tabela istnieje

    # 2. Mapowanie typ√≥w
    # Zak≈Çadamy, ≈ºe ta metoda zwraca s≈Çownik: {nazwa_kolumny: typ_sqlalchemy lub nazwa_typu_sql}
    column_types = self.map_data_types(df, target_db) 
    columns_def = []

    # 3. Dynamiczne tworzenie definicji kolumn SQL (columns_def)
    
    if target_db.lower() == 'oracle':
        # --- LOGIKA DLA ORACLE ---
        for col_name, col_type in column_types.items():
            col_name_sql = f'"{col_name}"' # Cudzys≈Çowy dla nazwy kolumny w Oracle

            if isinstance(col_type, str):
                # Je≈õli col_type jest ju≈º ciƒÖgiem SQL (np. 'NUMBER(13)'), u≈ºyj go
                columns_def.append(f"{col_name_sql} {col_type}")
            elif hasattr(col_type, 'length'):
                length = getattr(col_type, 'length', 4000)
                if length < 4000:
                    # üí• POPRAWKA: U≈ºycie VARCHAR2 i obs≈Çuga d≈Çugo≈õci
                    columns_def.append(f"{col_name_sql} VARCHAR2({length})")
                else:
                    columns_def.append(f"{col_name_sql} CLOB")
            elif hasattr(col_type, 'precision'):
                 columns_def.append(f'{col_name_sql} NUMBER')
            elif str(col_type) == 'INTEGER':
                columns_def.append(f"{col_name_sql} NUMBER(10)")
            elif str(col_type) == 'FLOAT':
                columns_def.append(f"{col_name_sql} FLOAT")
            elif str(col_type) == 'DATETIME':
                columns_def.append(f"{col_name_sql} TIMESTAMP")
            elif str(col_type) == 'DATE':
                columns_def.append(f"{col_name_sql} DATE")
            else:
                 # W razie wƒÖtpliwo≈õci u≈ºyj og√≥lnego VARCHAR2
                 columns_def.append(f"{col_name_sql} VARCHAR2(100)") 
                 
    elif target_db.lower() == 'impala':
        # --- LOGIKA DLA IMPALA ---
        # Impala jest prosta, u≈ºywamy typ√≥w SQL jako ciƒÖg√≥w
        for col_name, col_type in column_types.items():
            col_name_sql = f"`{col_name}`" # Backticks dla Impali
            
            if hasattr(col_type, 'length'):
                length = getattr(col_type, 'length', 255)
                # U≈ºywamy VARCHAR dla Impali
                columns_def.append(f"{col_name_sql} VARCHAR({length})")
            elif str(col_type) == 'INTEGER':
                columns_def.append(f"{col_name_sql} BIGINT")
            elif str(col_type) == 'FLOAT':
                columns_def.append(f"{col_name_sql} DOUBLE")
            elif str(col_type) == 'DATETIME':
                columns_def.append(f"{col_name_sql} TIMESTAMP")
            elif str(col_type) == 'DATE':
                columns_def.append(f"{col_name_sql} DATE")
            elif str(col_type) == 'BOOLEAN':
                columns_def.append(f"{col_name_sql} BOOLEAN")
            else:
                columns_def.append(f"{col_name_sql} STRING")
                
    elif target_db.lower() == 'sqlserver':
        # --- LOGIKA DLA SQL SERVER ---
        for col_name, col_type in column_types.items():
            col_name_sql = f'[{col_name}]' # Nawiasy kwadratowe dla SQL Server
            
            if hasattr(col_type, 'length'):
                length = getattr(col_type, 'length', 4000)
                if length > 8000:
                    # U≈ºyj NVARCHAR(MAX) lub NVARCHAR(N)
                    columns_def.append(f"{col_name_sql} NVARCHAR(MAX)")
                else:
                    # U≈ºywamy NVARCHAR dla obs≈Çugi unicode
                    columns_def.append(f"{col_name_sql} NVARCHAR({length})")
            elif str(col_type) == 'INTEGER':
                columns_def.append(f"{col_name_sql} BIGINT")
            elif str(col_type) == 'FLOAT':
                columns_def.append(f"{col_name_sql} FLOAT")
            elif str(col_type) == 'DATETIME':
                columns_def.append(f"{col_name_sql} DATETIME2")
            elif str(col_type) == 'DATE':
                columns_def.append(f"{col_name_sql} DATE")
            else:
                columns_def.append(f"{col_name_sql} NVARCHAR(100)")
    
    # 4. Wykonanie zapytania CREATE TABLE
    if not columns_def:
        self.logger.warning(f"Brak definicji kolumn dla tabeli {table_name}. Przerwanie tworzenia.")
        return False

    cols_definition = ',\n'.join(columns_def)
    create_table_sql = f'CREATE TABLE {schema}.{table_name} (\n{cols_definition}\n)'
    
    try:
        connection.execute(create_table_sql)
        self.logger.info(f"Utworzono nowƒÖ tabelƒô {schema}.{table_name} w bazie {target_db}.")
        return True # Tabela zosta≈Ça utworzona
        
    except Exception as e:
        self.logger.error(f"Krytyczny b≈ÇƒÖd podczas tworzenia tabeli {table_name}: {str(e)}")
        # Wypisz zapytanie, kt√≥re spowodowa≈Ço b≈ÇƒÖd, aby u≈Çatwiƒá debugowanie
        self.logger.error(f"Zapytanie SQL, kt√≥re spowodowa≈Ço b≈ÇƒÖd: {create_table_sql}")
        raise # Wznie≈õ wyjƒÖtek, aby zatrzymaƒá zadanie

Najwa≈ºniejsze zmiany i poprawki:
 * Oracle VARCHAR/VARCHAR2: W sekcji Oracle zmieniono podej≈õcie na dynamiczne tworzenie ciƒÖg√≥w SQL, u≈ºywajƒÖc VARCHAR2 dla ciƒÖg√≥w o d≈Çugo≈õci mniejszej ni≈º 4000. Jest to bardziej zgodne ze standardami Oracle i prawdopodobnie naprawi b≈ÇƒÖd mapowania, kt√≥ry pojawi≈Ç siƒô w logu.
 * Obs≈Çuga D≈Çugo≈õci: U≈ºycie getattr(col_type, 'length', X) pozwala na bezpieczne pobranie atrybutu d≈Çugo≈õci z obiektu typu, zapewniajƒÖc jednocze≈õnie warto≈õƒá domy≈õlnƒÖ, je≈õli atrybut nie istnieje.
 * Wypisywanie SQL: Dodano logowanie zapytania CREATE TABLE w bloku except, co jest kluczowe do debugowania b≈Çƒôd√≥w dialektu SQL.
 * Poprawione formatowanie nazw kolumn: U≈ºyto cudzys≈Çow√≥w ("nazwa") dla Oracle, backtick√≥w (`nazwa`) dla Impali oraz nawias√≥w kwadratowych ([nazwa]) dla SQL Server, co zwiƒôksza kompatybilno≈õƒá.
