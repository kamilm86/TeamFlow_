import sys
import time
from datetime import datetime, timedelta, date
from PySide6.QtWidgets import (QApplication, QMainWindow, QTableWidget, QTableWidgetItem,
                              QVBoxLayout, QHBoxLayout, QWidget, QLabel, QComboBox, QCompleter,
                              QPushButton, QHeaderView, QAbstractItemView, QListWidget,
                              QListWidgetItem, QLineEdit, QDialog, QCheckBox, QFrame, QDateEdit,
                              QFormLayout, QDialogButtonBox, QMessageBox, QSplitter, QStyledItemDelegate, QStyle,
                              QGridLayout, QSizePolicy, QTableWidgetSelectionRange)
from PySide6.QtCore import Qt, QThread, Signal, QDate, QTimer, QPoint, QModelIndex, QRect, QEvent
from PySide6.QtGui import QShortcut, QKeySequence, QFont, QColor, QIcon, QPixmap, QPainter, QPolygon, QBrush, QPen, QLinearGradient, QRadialGradient, QStandardItem, QStandardItemModel


from db_connector import DatabaseConnector, get_modifier_id
from theme_dialog import ThemeSettingsDialog, InsertSymbolDialog, ScheduleChangeDialog
from settings_db import SettingsDatabase
from data_provider import DataProvider
from styles import AppStyles

# Globalny przełącznik dla trybu debug
DEBUG_MODE = False

def debug_print(*args, **kwargs):
    """
    Funkcja wyświetlająca komunikaty debugowania tylko gdy DEBUG_MODE=True
    """
    if DEBUG_MODE:
        print(*args, **kwargs)

def debug_combo_event(event_name, details=None):
    """Funkcja do debugowania zdarzeń ComboBoxa"""
    with open('combo_debug.log', 'a') as f:
        timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
        msg = f"{timestamp} - {event_name}"
        if details:
            msg += f": {details}"
        f.write(msg + "\n")
        f.flush()  # Wymuszenie zapisu


class CustomMultiComboBox(QComboBox):
    """Niestandardowy ComboBox z obsługą wielokrotnego wyboru"""

    def __init__(self, parent=None):
        super().__init__(parent)

        # Inicjalizacja wszystkich zmiennych
        self._selected_items = set()
        self._select_all_text = "_*_"
        self._popup_visible = False
        self._block_hide = False

        # Konfiguracja modelu
        self.setModel(QStandardItemModel(self))

        # Konfiguracja wyglądu
        self.setEditable(True)
        self.lineEdit().setReadOnly(True)
        self.setEditText("_*_")  # Początkowy tekst
        self.setStyleSheet("QComboBox::drop-down { border: none; }")
        self.setSizeAdjustPolicy(QComboBox.AdjustToContents)
        self.view().setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.view().setItemDelegate(QStyledItemDelegate())

        # Konfiguracja timera
        self._reopen_timer = QTimer(self)
        self._reopen_timer.setSingleShot(True)
        self._reopen_timer.setInterval(5)  # 5ms wystarczy
        self._reopen_timer.timeout.connect(self._reopen_popup)

        # Zainstaluj filtry zdarzeń i połącz sygnały
        self.lineEdit().installEventFilter(self)
        self.view().pressed.connect(self.handle_item_pressed)
        QApplication.instance().installEventFilter(self)

    def _reopen_popup(self):
        """Ponownie otwiera popup jeśli powinien być otwarty"""
        if self._block_hide:
            self._block_hide = False
            self.showPopup()

    def eventFilter(self, obj, event):
        """
        Obserwuje zdarzenia dla różnych obiektów:
        1. Dla lineEdit przechwytuje kliknięcia myszą
        2. Dla aplikacji wykrywa kliknięcie poza listą
        """
        # Obsługa kliknięć w pole tekstowe (lineEdit)
        if obj == self.lineEdit() and event.type() == QEvent.MouseButtonPress:
            # Przekieruj kliknięcie do głównej kontrolki ComboBox
            self.mousePressEvent(event)
            return True  # Zatrzymaj dalsze przetwarzanie

        # Obsługa kliknięć poza listą (dla całej aplikacji)
        if self._popup_visible and event.type() == QEvent.MouseButtonPress:
            # Używaj globalPosition() zamiast przestarzałego globalPos()
            pos = event.globalPosition().toPoint()

            # Pobierz geometrię listy i comboboxa
            view_rect = QRect(self.view().mapToGlobal(QPoint(0, 0)), self.view().size())
            combo_rect = QRect(self.mapToGlobal(QPoint(0, 0)), self.size())

            # Sprawdź, czy kliknięcie było poza listą i poza samym comboboxem
            if not view_rect.contains(pos) and not combo_rect.contains(pos):
                self._popup_visible = False
                self._block_hide = False  # Pozwól na zamknięcie popupu
                super().hidePopup()
                return True  # Pochłońmy zdarzenie, jeśli faktycznie zamknęliśmy popup

        return False  # Przekaż zdarzenie dalej

    def mousePressEvent(self, event):
        """Obsługa kliknięcia na ComboBox - otwiera lub zamyka listę"""
        if self._popup_visible:
            self._popup_visible = False
            self._block_hide = False  # Pozwól na zamknięcie popupu
            self.hidePopup()
        else:
            self._popup_visible = True
            self.showPopup()

        # Nie przekazuj zdarzenia do QComboBox
        event.accept()

    def handle_item_pressed(self, index):
        """Obsługa naciśnięcia na element listy"""
        item = self.model().itemFromIndex(index)

        if not item:
            return

        # Jeśli to element "Zaznacz wszystkie"
        if item.text() == self._select_all_text:
            all_checked = all(self.model().item(i).checkState() == Qt.Checked
                              for i in range(1, self.model().rowCount()))

            # Przełącz stan - jeśli wszystkie są zaznaczone, odznacz wszystkie
            new_state = Qt.Unchecked if all_checked else Qt.Checked

            # Ustaw stan dla wszystkich elementów (poza "Zaznacz wszystkie")
            for i in range(1, self.model().rowCount()):
                self.model().item(i).setCheckState(new_state)
                text = self.model().item(i).text()
                if new_state == Qt.Checked:
                    self._selected_items.add(text)
                else:
                    self._selected_items.discard(text)
        else:
            # Przełącz stan zaznaczenia dla zwykłego elementu
            if item.checkState() == Qt.Checked:
                item.setCheckState(Qt.Unchecked)
                self._selected_items.discard(item.text())
            else:
                item.setCheckState(Qt.Checked)
                self._selected_items.add(item.text())

            # Aktualizuj stan elementu "Zaznacz wszystkie"
            if self.model().rowCount() > 0:
                all_checked = all(self.model().item(i).checkState() == Qt.Checked
                                  for i in range(1, self.model().rowCount()))
                if self.model().item(0).text() == self._select_all_text:
                    self.model().item(0).setCheckState(Qt.Checked if all_checked else Qt.Unchecked)

        # KLUCZOWA ZMIANA: Przebudowa _selected_items na podstawie aktualnego stanu modelu
        self._rebuild_selected_items()

        # Aktualizuj wyświetlany tekst
        self.update_display_text()

        # Odśwież widok
        self.view().viewport().update()

        # KLUCZOWA CZĘŚĆ: Zablokuj zamykanie popupu i zaplanuj jego przywrócenie
        self._block_hide = True
        self._reopen_timer.start()

        # Zatrzymaj dalsze przetwarzanie
        return True

    def _rebuild_selected_items(self):
        """Przebudowuje zbiór _selected_items na podstawie aktualnego stanu modelu"""
        self._selected_items.clear()
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item and item.checkState() == Qt.Checked:
                self._selected_items.add(item.text())

    def showPopup(self):
        """Pokaż menu rozwijane"""
        # Ustawiamy flagę PRZED pokazaniem popupu
        self._popup_visible = True

        # Ustaw szerokość widoku
        width = self.view().sizeHintForColumn(0) + 20  # Dodaj trochę miejsca na margines
        width = min(width, 250)  # Ogranicz szerokość do maksymalnie 250 pikseli
        self.view().setMinimumWidth(width)

        # Pokazujemy popup
        super().showPopup()

    def hidePopup(self):
        """Ukryj popup z zabezpieczeniem przed automatycznym zamykaniem"""
        # Jeśli ustawiona jest blokada, nie zamykaj popupu
        if self._block_hide:
            # Wykonaj tylko ukrycie, a potem zaplanuj ponowne pokazanie
            super().hidePopup()
            return

        # Normalny przypadek - ukryj popup i ustaw flagę
        self._popup_visible = False
        super().hidePopup()

        # WAŻNE: Aktualizuj tekst po zamknięciu popupu
        self.update_display_text()

    # WAŻNE: Metoda, która powstrzymuje automatyczne zamykanie popupu po kliknięciu
    def setCurrentIndex(self, index):
        """Nadpisana metoda, aby zapobiec zamykaniu popupu"""
        if self._popup_visible:
            # Nie zmieniaj indeksu i nie zamykaj popupu
            pass
        else:
            # Standardowe zachowanie
            super().setCurrentIndex(index)

    def add_items(self, items):
        """Dodaje elementy do ComboBoxa"""
        self.clear()

        # Dodaj element "Zaznacz wszystkie"
        select_all_item = QStandardItem(self._select_all_text)
        select_all_item.setCheckState(Qt.Unchecked)
        select_all_item.setCheckable(True)
        self.model().appendRow(select_all_item)

        # Dodaj pozostałe elementy
        for item_text in items:
            item = QStandardItem(item_text)
            item.setCheckState(Qt.Unchecked)
            item.setCheckable(True)
            self.model().appendRow(item)

        # Ustaw wyświetlany tekst
        self.update_display_text()

    def clear(self):
        """Czyści listę elementów"""
        super().clear()
        self._selected_items.clear()
        self.setEditText("_*_")  # Zmieniony tekst

    def clear_selection(self):
        """Czyści zaznaczenie"""
        self._selected_items.clear()
        for i in range(self.model().rowCount()):
            if i < self.model().rowCount():  # Dodatkowe sprawdzenie
                item = self.model().item(i)
                if item:
                    item.setCheckState(Qt.Unchecked)
        self.update_display_text()

    def get_selected_items(self):
        """Zwraca listę zaznaczonych elementów (poza 'Zaznacz wszystkie')"""
        # WAŻNE: Przebuduj _selected_items dla pewności
        self._rebuild_selected_items()

        # Zwróć listę z elementów zbioru
        return list(self._selected_items)

    def select_items(self, items):
        """Zaznacza określone elementy"""
        self._selected_items = set(items)
        all_selected = True

        for i in range(1, self.model().rowCount()):  # Pomijamy pierwszy element
            if i < self.model().rowCount():  # Dodatkowe sprawdzenie
                item = self.model().item(i)
                if item:
                    if item.text() in items:
                        item.setCheckState(Qt.Checked)
                    else:
                        item.setCheckState(Qt.Unchecked)
                        all_selected = False

        # Ustaw stan dla elementu "Zaznacz wszystkie"
        if self.model().rowCount() > 0:
            item0 = self.model().item(0)
            if item0 and item0.text() == self._select_all_text:
                item0.setCheckState(Qt.Checked if all_selected else Qt.Unchecked)

        self.update_display_text()

    def update_display_text(self):
        """
        Aktualizuje tekst wyświetlany w comboboxie na podstawie zaznaczonych elementów.

        Wyświetla:
        - "--- Wszystkie ---" gdy nie ma zaznaczonych elementów lub gdy są zaznaczone wszystkie
        - "Wybrano {len(selected)} elementów" gdy jest zaznaczona tylko część elementów
        """
        # WAŻNE: Przebuduj _selected_items dla pewności
        self._rebuild_selected_items()

        selected = list(self._selected_items)
        total_items = self.model().rowCount() - 1  # Odejmujemy element "Zaznacz wszystkie"

        # Sprawdź, czy nie ma zaznaczonych elementów lub wszystkie są zaznaczone
        if not selected or len(selected) == total_items:
            self.setEditText("_*_")
        else:
            self.setEditText(f"Wybrano {len(selected)} elementów")


class CheckableItemDelegate(QStyledItemDelegate):
    """Delegat dla elementów zaznaczalnych w comboboxie"""

    def paint(self, painter, option, index):
        # Najpierw ustawiamy poprawny stan zaznaczenia
        check_state = index.data(Qt.CheckStateRole)

        # Niestandardowe rysowanie dla zaznaczonych elementów
        if check_state == Qt.Checked:
            option.font.setBold(True)
            option.backgroundBrush = QBrush(QColor(200, 230, 255))

        # Standardowe rysowanie
        super().paint(painter, option, index)

class DataFetcherThread(QThread):
    data_fetched = Signal(list)  # Sygnał z danymi grafiku i danymi zdarzeń

    def __init__(self, year, month, data_provider):
        super().__init__()
        self.year = year
        self.month = month
        self.data_provider = data_provider  # Dodaj referencję do DataProvider

    def run(self):
        try:
            # Pobierz dane używając DataProvider
            schedule_data = self.data_provider.get_schedule_data(self.year, self.month)
            # Upewnij się, że build_index=True jest przekazane
            events_data = self.data_provider.get_events_data(self.year, self.month, as_dict=False, build_index=True)
            users_data = self.data_provider.get_users_data(self.year, self.month)

            # Wyślij dane
            self.data_fetched.emit([schedule_data, events_data, users_data])

        except Exception as e:
            debug_print(f"Błąd podczas pobierania danych: {e}")
            self.data_fetched.emit([])


class WeekendAwareHeaderView(QHeaderView):
    """Niestandardowy nagłówek tabeli, który koloruje weekendy"""

    def __init__(self, orientation, parent=None):
        super().__init__(orientation, parent)
        self.weekend_columns = set()
        self.dark_theme = False
        self.setSectionsClickable(True)  # Ważne, aby sekcje były klikalne

    def set_weekend_columns(self, weekend_cols, dark_theme=False):
        """Ustawia kolumny, które powinny być oznaczone jako weekendy"""
        self.weekend_columns = set(weekend_cols)
        self.dark_theme = dark_theme
        self.viewport().update()  # Wymusza odświeżenie widoku

    def paintSection(self, painter, rect, logicalIndex):
        """Nadpisuje metodę malowania sekcji nagłówka"""
        # Zapisz aktualny kolor i czcionkę
        old_pen = painter.pen()
        old_brush = painter.brush()
        old_font = painter.font()

        # Sprawdź, czy to weekend
        is_weekend = logicalIndex in self.weekend_columns

        # Najpierw rysujemy tło z odpowiednim kolorem
        if is_weekend:
            # Kolor tła dla weekendów
            if self.dark_theme:
                # Ciemniejszy czerwony dla trybu ciemnego
                painter.fillRect(rect, QColor(120, 40, 40))  # Ciemniejszy odcień czerwonego
            else:
                # Jaśniejszy czerwony dla trybu jasnego
                painter.fillRect(rect, QColor(255, 200, 200))  # Jasny odcień czerwonego
        else:
            # Standardowe tło dla dni powszednich
            if self.dark_theme:
                painter.fillRect(rect, QColor(44, 44, 44))  # Ciemny kolor tła
            else:
                painter.fillRect(rect, QColor(240, 240, 240))  # Jasny kolor tła

        # Ustawienia tekstu dla weekendów
        if is_weekend:
            # Ustawienie koloru tekstu dla weekendów
            if self.dark_theme:
                painter.setPen(QColor(255, 180, 180))  # Jaśniejszy czerwony dla ciemnego motywu
            else:
                painter.setPen(QColor(180, 0, 0))  # Ciemnoczerwony dla jasnego motywu

            # Pogrubiona czcionka dla weekendów
            font = painter.font()
            font.setBold(True)
            painter.setFont(font)
        else:
            # Standardowy kolor tekstu dla dni powszednich
            if self.dark_theme:
                painter.setPen(QColor(255, 255, 255))  # Biały tekst dla ciemnego motywu
            else:
                painter.setPen(QColor(0, 0, 0))  # Czarny tekst dla jasnego motywu

        # Pobierz tekst sekcji nagłówka - WAŻNA ZMIANA: Upewnij się, że text jest stringiem
        text = str(self.model().headerData(logicalIndex, self.orientation(), Qt.DisplayRole))

        # WAŻNA ZMIANA: Poprawnie wywołaj metodę drawText z flagą jako liczbą całkowitą
        # Używamy int(Qt.AlignCenter) aby przekonwertować flagę enumeracyjną na liczbę całkowitą
        painter.drawText(rect.adjusted(5, 5, -5, -5), int(Qt.AlignCenter), text)

        # Przywróć poprzednie ustawienia rysowania
        painter.setPen(old_pen)
        painter.setBrush(old_brush)
        painter.setFont(old_font)


class OvertimeItemDelegate(QStyledItemDelegate):
    """
    Niestandardowy delegat do rysowania komórek tabeli.
    Wyświetla subtelne znaczniki w prawym dolnym rogu:
    - Czerwony trójkąt dla nadgodzin
    - Białe kółko dla spotkań/szkoleń

    Zoptymalizowana wersja, która korzysta z dedykowanych flag zamiast deserializacji JSON.
    """

    def paint(self, painter, option, index):
        # Najpierw narysuj standardowy element
        super().paint(painter, option, index)

        # Pobierz flagi bezpośrednio z dedykowanych ról (bez deserializacji JSON)
        has_overtime = index.data(Qt.UserRole + 4)
        has_meeting_or_training = index.data(Qt.UserRole + 3)

        # Jeśli element ma jakiekolwiek oznaczenia
        if has_overtime or has_meeting_or_training:
            painter.save()
            # Włącz antyaliasing dla gładkich krawędzi
            painter.setRenderHint(QPainter.Antialiasing)

            # Określ szerokość i pozycję znaczników
            marker_width = 8  # Zwiększony rozmiar
            marker_height = 8  # Zwiększony rozmiar

            # Rysuj znacznik spotkań/szkoleń (białe kółko) w górnym prawym rogu
            if has_meeting_or_training:
                # Oblicz pozycję w górnym prawym rogu
                top_right_x = option.rect.right() - marker_width - 2  # -2 to margines
                top_right_y = option.rect.top() + 2  # +2 to margines

                # Rysujemy kółko z białym wypełnieniem i czarną obwódką
                painter.setBrush(QBrush(QColor(255, 255, 255, 240)))  # Białe wypełnienie
                painter.setPen(QPen(QColor(0, 0, 0, 220), 1.0))  # Czarna obwódka
                painter.drawEllipse(
                    top_right_x,
                    top_right_y,
                    marker_width,
                    marker_height
                )

            # Rysuj znacznik nadgodzin (czerwony trójkąt) w dolnym prawym rogu
            if has_overtime:
                # Oblicz pozycję w dolnym prawym rogu
                bottom_right_x = option.rect.right() - marker_width - 2  # -2 to margines
                bottom_right_y = option.rect.bottom() - marker_height - 2  # -2 to margines

                # Czerwony trójkąt z czarną obwódką
                painter.setBrush(QBrush(QColor(220, 0, 0, 220)))  # Czerwone wypełnienie
                painter.setPen(QPen(Qt.black, 1.0))  # Czarna obwódka

                triangle = QPolygon()
                triangle.append(QPoint(bottom_right_x, bottom_right_y + marker_height))
                triangle.append(QPoint(bottom_right_x + marker_width, bottom_right_y + marker_height))
                triangle.append(QPoint(bottom_right_x + marker_width, bottom_right_y))
                painter.drawPolygon(triangle)

            painter.restore()

class WorkScheduleWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # Inicjalizacja bazy danych ustawień
        self.settings_db = SettingsDatabase()

        # Inicjalizacja DataProvider
        self.data_provider = DataProvider()

        # Podłącz sygnał zmiany danych
        self.data_provider.data_changed.connect(self.on_data_changed)

        self.setWindowTitle("TeamFlowApp")
        self.setGeometry(100, 100, 1200, 600)

        # Inicjalizacji zmiennej left_panel_visible
        self.left_panel_visible = True  # Domyślnie panel jest widoczny

        # Zmienna do śledzenia ostatniej modyfikacji dokonanej przez bieżącą sesję
        self.last_self_modification_date = None



        # Inicjalizacja bazy danych ustawień
        self.settings_db = SettingsDatabase()

        # Załaduj ustawienia użytkownika
        user_settings = self.settings_db.load_settings()

        # Zapisz ustawienia motywu z bazy danych
        self.is_dark_theme = user_settings['theme'] == 'dark'
        self.current_font = user_settings['font_family']
        self.current_font_size = user_settings['font_size']

        # Zastosuj czcionkę globalnie dla całej aplikacji
        font = QFont(self.current_font, self.current_font_size)
        QApplication.setFont(font)

        # Zastosuj bazowy styl dla motywu ciemnego/jasnego przed utworzeniem UI
        if self.is_dark_theme:
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #1e1e1e;
                    color: white;
                }
                QPushButton {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QComboBox {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QMessageBox {
                    background-color: #1e1e1e;
                    color: white;
                }
                QMessageBox QPushButton {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        else:
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #f5f5f5;
                    color: black;
                }
                QPushButton {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QComboBox {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QMessageBox {
                    background-color: #f5f5f5;
                    color: black;
                }
                QMessageBox QPushButton {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)

        # Dane
        self.raw_data = []
        self.processed_data = {}
        self.last_modification_date = None
        self.all_events_data = []  # Bufor na wszystkie zdarzenia
        self.user_info_map = {}  # Mapowanie użytkowników na ich dane (wydział, przełożony, nazwa)

        # Utworzenie interfejsu
        self.setup_ui()

        self.setup_shortcuts()  # Dodaj tę linię

        # Zastosuj pełny zestaw stylów dla całej aplikacji
        self.apply_theme_settings(
            'dark' if self.is_dark_theme else 'light',
            self.current_font,
            self.current_font_size
        )

        # Sprawdź uprawnienia użytkownika - jeśli zwróci False, aplikacja się zamknie
        if not self.check_user_permissions():
            return

        # Pobieranie początkowych danych
        self.current_date = QDate.currentDate()
        self.update_data(self.current_date.year(), self.current_date.month())



        # Ustaw daty filtrowania po inicjalizacji danych
        self.update_filter_dates()

    def set_cell_data(self, item, data_dict):
        """
        Zapisuje słownik danych w komórce tabeli używając mechanizmu Qt.UserRole+2.
        Dodatkowo ustawia flagi dla delegata renderującego.

        Args:
            item: QTableWidgetItem do którego zapisujemy dane
            data_dict: Słownik z danymi do zapisania w komórce
        """
        if not item:
            return

        # Serializuj dane do JSON
        import json
        json_data = json.dumps(data_dict)

        # Zapisz dane jako JSON w Qt.UserRole+2
        item.setData(Qt.UserRole + 2, json_data)

        # Dodatkowo ustaw flagi dla OvertimeItemDelegate bezpośrednio
        # (to przyspieszy rendering komórek)
        has_overtime = data_dict.get('has_overtime', False)
        has_meeting = data_dict.get('has_meeting', False)
        has_training = data_dict.get('has_training', False)

        # Ustaw flagi w dedykowanych rolach
        item.setData(Qt.UserRole + 3, has_meeting or has_training)  # Flaga spotkań/szkoleń
        item.setData(Qt.UserRole + 4, has_overtime)  # Flaga nadgodzin

    def get_cell_data(self, item):
        """
        Odczytuje słownik danych z komórki tabeli używając mechanizmu Qt.UserRole+2.

        Args:
            item: QTableWidgetItem z którego odczytujemy dane

        Returns:
            dict: Słownik z danymi lub pusty słownik jeśli brak danych
        """
        if not item:
            return {}

        # Pobierz dane z Qt.UserRole+2
        import json
        json_data = item.data(Qt.UserRole + 2)

        if json_data:
            try:
                return json.loads(json_data)
            except:
                print(f"Błąd podczas parsowania JSON: {json_data}")
                pass

        return {}

    def get_cell_data_by_position(self, row, col):
        """
        Pobiera dane z komórki na podstawie pozycji (wiersz, kolumna).
        Używa standardowej metody get_cell_data wewnętrznie.

        Args:
            row: Fizyczny indeks wiersza
            col: Fizyczny indeks kolumny

        Returns:
            dict: Słownik z danymi lub pusty słownik jeśli komórka nie istnieje
        """
        item = self.table.item(row, col)
        return self.get_cell_data(item)  # To automatycznie obsłuży przypadek gdy item=None

    def on_data_changed(self, data_type, year, month):
        """Obsługuje powiadomienie o zmianie danych"""
        current_data = self.date_combo.currentData()
        if current_data and current_data == (year, month):
            if data_type == "schedule":
                self.update_table_content()
            elif data_type == "events":
                self.filter_events_table()

    def log_time(self, label, start_time):
        """Pomocnicza funkcja do logowania czasu"""
        end_time = time.time()
        elapsed = end_time - start_time
        debug_print(f"[CZAS] {label}: {elapsed:.3f} sekundy")
        return end_time

    def setup_ui(self):
        """Ustawia interfejs użytkownika"""
        # Główny widget i layout
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)

        # WAŻNA ZMIANA: Usunięcie marginesy górnego i dolnego
        main_layout.setContentsMargins(10, 0, 10, 0)  # Lewy, Górny, Prawy, Dolny
        main_layout.setSpacing(0)  # Brak odstępu między elementami

        # Tworzenie poszczególnych części interfejsu
        top_bar = self.setup_top_bar(main_layout)

        # Dodanie górnego paska do głównego layoutu
        main_layout.addWidget(top_bar)

        # Dodanie splittera środkowego
        middle_splitter = self.setup_middle_section(main_layout)
        main_layout.addWidget(middle_splitter, 1)  # Dodaj z rozciąganiem (waga 1)

        # Ustawienie głównego widgetu
        self.setCentralWidget(central_widget)

        # Dodatkowe konfiguracje
        self.setup_table_properties()

    def setup_top_bar(self, main_layout):
        """Tworzy górny pasek z przyciskami i kontrolkami"""
        top_bar_frame = QFrame()
        top_bar_frame.setFrameShape(QFrame.StyledPanel)
        top_bar_frame.setFrameShadow(QFrame.Raised)
        top_bar_frame.setFixedHeight(50)  # Stała wysokość 50px

        # Zastosuj zerowe marginesy w wewnętrznym layoucie
        top_bar_layout = QHBoxLayout(top_bar_frame)
        top_bar_layout.setContentsMargins(5, 5, 5, 5)

        # Ustaw politykę rozmiaru - stała wysokość, rozciąganie szerokości
        top_bar_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        # Przycisk menu (burger)
        self.toggle_menu_button = QPushButton()
        self.toggle_menu_button.setFixedSize(32, 32)
        self.toggle_menu_button.setText("☰")
        self.toggle_menu_button.setToolTip("Pokaż/ukryj panel filtrów")
        self.toggle_menu_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.toggle_menu_button.clicked.connect(self.toggle_left_panel)
        top_bar_layout.addWidget(self.toggle_menu_button)

        # Dodaj skrót klawiszowy Ctrl+D dla diagnostyki zaznaczonej komórki
        debug_shortcut = QShortcut(QKeySequence("Ctrl+G"), self)
        debug_shortcut.activated.connect(self.debug_selected_cell)

        # Przycisk zmiany motywu
        self.theme_button = QPushButton("Zmień motyw")
        self.theme_button.clicked.connect(self.show_theme_settings)
        self.theme_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))

        # Etykieta i combobox na rok-miesiąc
        date_label = QLabel("Miesiąc:")
        self.date_combo = QComboBox()
        self.date_combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))

        # Skonfiguruj zawartość comboboxa dat
        self.setup_date_combo()

        # Podłącz sygnał zmiany comboboxa daty
        self.date_combo.currentIndexChanged.connect(self.on_date_combo_changed)

        # Przycisk odświeżania
        self.refresh_button = QPushButton("Odśwież dane")
        self.refresh_button.clicked.connect(self.refresh_data)
        self.refresh_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))

        # Dodanie widgetów do layoutu górnego paska
        top_bar_layout.addWidget(self.theme_button)
        top_bar_layout.addWidget(date_label)
        top_bar_layout.addWidget(self.date_combo)
        top_bar_layout.addWidget(self.refresh_button)
        top_bar_layout.addStretch()

        # Dodaj górny pasek do głównego layoutu
        main_layout.addWidget(top_bar_frame)

        return top_bar_frame

    def setup_date_combo(self):
        """Konfiguruje combobox z datami"""
        # Dodanie opcji dla 3 miesięcy wstecz i 1 miesiąca do przodu od bieżącego
        current_date = datetime.now()
        months_to_show = []

        # Zacznij od 3 miesięcy wstecz
        year = current_date.year
        month = current_date.month

        # Generowanie 3 miesięcy wstecz
        for i in range(3, 0, -1):
            # Oblicz rok i miesiąc dla i miesięcy wstecz
            prev_month = month - i
            prev_year = year

            # Dostosuj rok, jeśli trzeba
            while prev_month <= 0:
                prev_month += 12
                prev_year -= 1

            months_to_show.append((prev_year, prev_month))

        # Dodaj bieżący miesiąc
        months_to_show.append((year, month))

        # Dodaj 1 miesiąc do przodu
        next_month = month + 1
        next_year = year
        if next_month > 12:
            next_month = 1
            next_year += 1
        months_to_show.append((next_year, next_month))

        # Dodanie miesięcy do comboboxa w formacie YYYY-MM
        self.date_combo.clear()  # Wyczyść poprzednie pozycje
        for year, month in months_to_show:
            self.date_combo.addItem(f"{year}-{month:02d}", (year, month))

        # Ustawienie bieżącego miesiąca (czwarty element, indeks 3)
        self.date_combo.setCurrentIndex(3)

    def setup_middle_section(self, main_layout):
        """Tworzy środkową sekcję z filtrem i tabelami"""
        # Główny kontener na środkową część (filtry po lewej, tabela po prawej)
        main_splitter = QSplitter(Qt.Horizontal)

        # Ustaw politykę rozmiaru - aby element wypełniał dostępną przestrzeń
        main_splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Tworzenie lewego panelu filtrów
        self.setup_left_panel()
        # Zapamiętaj standardową szerokość lewego panelu
        self.left_panel_width = 200  # Domyślna szerokość panelu

        # Tworzenie prawego panelu z tabelami
        right_panel = self.setup_right_panel()

        # Dodaj panele do głównego splittera
        main_splitter.addWidget(self._left_panel)
        main_splitter.addWidget(right_panel)

        # Ustaw początkowe proporcje dla głównego splittera (np. 25% lewy panel, 75% prawy panel)
        main_splitter.setSizes([250, 950])

        # Zapisz referencję do splittera
        self.main_splitter = main_splitter

        # NIE dodawaj main_splitter do main_layout - zwróć go tylko
        return main_splitter

    def setup_left_panel(self):
        """Tworzy lewy panel z filtrami"""
        self._left_panel = QWidget()
        self._left_panel.setStyleSheet(AppStyles.get_left_panel_style("dark" if self.is_dark_theme else "light"))
        self._left_panel.setMinimumWidth(200)  # Zwiększamy minimalną szerokość panelu
        self._left_panel.setMaximumWidth(250)  # Zwiększamy maksymalną szerokość panelu

        filters_layout = QVBoxLayout(self._left_panel)
        filters_layout.setContentsMargins(10, 10, 10, 10)
        filters_layout.setSpacing(6)  # Zmniejsz odstępy między elementami

        # Tytuł filtrów
        filters_title = QLabel("Filtry")
        filters_title.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light", is_title=True))
        filters_layout.addWidget(filters_title)

        # Kolejność zgodnie z oznaczeniami na zdjęciu
        # 1. Wydział
        self.add_horizontal_filter("Wydział:", "wydzial_combo", filters_layout)

        # 2. Przełożony - pole tekstowe i lista w układzie pionowym
        self.add_horizontal_search_filter("Przełożony:", "przelozony_filter", filters_layout)
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)

        # Lista przełożonych
        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_list.setFixedHeight(120)
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.przelozony_list)

        # 3. Użytkownik
        self.add_horizontal_search_filter("Użytkownik:", "uzytkownik_filter", filters_layout)
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)

        # Lista użytkowników
        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_list.setFixedHeight(120)
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.uzytkownik_list)

        # 4. DTN
        self.add_horizontal_filter("DTN:", "dtn_combo", filters_layout)

        # 5. Etat
        self.add_horizontal_filter("Etat:", "etat_combo", filters_layout)

        # 6. Rola
        self.add_horizontal_filter("Rola:", "rola_combo", filters_layout)

        # 7. Język
        self.add_horizontal_filter("Język:", "jezyk_combo", filters_layout)

        # Przycisk wyczyść filtry
        self.clear_filters_button = QPushButton("Wyczyść filtry")
        self.clear_filters_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.clear_filters_button.clicked.connect(self.clear_filters)
        filters_layout.addStretch()
        filters_layout.addWidget(self.clear_filters_button)

    def add_horizontal_filter(self, label_text, combo_name, parent_layout):
        """Dodaje filtr w układzie poziomym (etykieta + kontrolka w jednej linii)"""
        # Układ poziomy dla filtru
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)  # Minimalne marginesy
        filter_layout.setSpacing(4)  # Mniejszy odstęp

        # Etykieta
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        filter_label.setFixedWidth(80)  # Ustaw stałą szerokość etykiet
        filter_layout.addWidget(filter_label)

        # Kontrolka ComboBox
        combo = CustomMultiComboBox()
        combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        combo.setFixedHeight(24)  # Ustaw wysokość podobną do pól tekstowych
        combo.view().setMaximumWidth(250)  # Ograniczenie szerokości rozwijanej listy
        combo.activated.connect(self.filter_data)  # Podłącz sygnał filtrowania

        # Zapisz referencję do kontrolki
        setattr(self, combo_name, combo)

        filter_layout.addWidget(combo, 1)  # Dodaj z rozciąganiem
        parent_layout.addLayout(filter_layout)

    def add_horizontal_search_filter(self, label_text, filter_name, parent_layout):
        """Dodaje filtr wyszukiwania w układzie poziomym (etykieta + pole tekstowe w jednej linii)"""
        # Układ poziomy dla filtru
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)  # Minimalne marginesy
        filter_layout.setSpacing(4)  # Mniejszy odstęp

        # Etykieta
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        filter_label.setFixedWidth(80)  # Ustaw stałą szerokość etykiet
        filter_layout.addWidget(filter_label)

        # Pole tekstowe
        text_edit = QLineEdit()
        text_edit.setPlaceholderText(f"Filtruj {label_text.lower()[:-1]}...")
        text_edit.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        text_edit.setFixedHeight(24)  # Ustaw stałą wysokość

        # Zapisz referencję do kontrolki
        setattr(self, filter_name, text_edit)

        filter_layout.addWidget(text_edit, 1)  # Dodaj z rozciąganiem
        parent_layout.addLayout(filter_layout)

    def setup_filter_combo(self, label_text, combo_name, parent_layout):
        """Konfiguruje filtr jako ComboBox z wielokrotnym wyborem"""
        # Etykieta filtru
        filter_label = QLabel(label_text)
        filter_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(filter_label)

        # ComboBox z wielokrotnym wyborem
        combo = CustomMultiComboBox()
        combo.setStyleSheet(AppStyles.get_combobox_style("dark" if self.is_dark_theme else "light"))
        combo.view().setMinimumWidth(200)  # Ustaw minimalną szerokość listy rozwijanej

        # Dodaj sygnał zmiany stanu ComboBoxa
        combo.view().pressed.connect(self.filter_data)

        # Zapisz referencję do ComboBoxa
        setattr(self, combo_name, combo)

        parent_layout.addWidget(combo)
        parent_layout.addSpacing(10)  # Dodaj odstęp między filtrami

    # Te metody pozostają bez zmian, tylko przenosimy je do oddzielnych funkcji
    def setup_filter_przelozony(self, parent_layout):
        """Konfiguruje filtr przełożonego"""
        # Filtr przełożonego
        przelozony_label = QLabel("Przełożony:")
        przelozony_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(przelozony_label)

        # Lista przełożonych
        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_list.setFixedHeight(120)

        # Dodaj pole wyszukiwania dla przełożonych
        self.przelozony_filter = QLineEdit()
        self.przelozony_filter.setPlaceholderText("Filtruj przełożonych...")
        self.przelozony_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)

        parent_layout.addWidget(self.przelozony_filter)
        parent_layout.addWidget(self.przelozony_list)

        # Podłącz sygnał zmiany filtru
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)

    def setup_filter_uzytkownik(self, parent_layout):
        """Konfiguruje filtr użytkownika"""
        # Filtr użytkownika
        uzytkownik_label = QLabel("Użytkownik:")
        uzytkownik_label.setStyleSheet(AppStyles.get_label_style("dark" if self.is_dark_theme else "light"))
        parent_layout.addWidget(uzytkownik_label)

        # Lista użytkowników
        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_list.setFixedHeight(120)

        # Dodaj pole wyszukiwania dla użytkowników
        self.uzytkownik_filter = QLineEdit()
        self.uzytkownik_filter.setPlaceholderText("Filtruj użytkowników...")
        self.uzytkownik_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)

        parent_layout.addWidget(self.uzytkownik_filter)
        parent_layout.addWidget(self.uzytkownik_list)

        # Podłącz sygnał zmiany filtru
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)

    def setup_right_panel(self):
        """Tworzy prawy panel z tabelami"""
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)

        # Splitter pionowy dla prawego panelu (grafik | zdarzenia)
        right_splitter = QSplitter(Qt.Vertical)

        # Dodaj sekcje
        schedule_frame = self.setup_schedule_section()
        events_frame = self.setup_events_section()

        # Dodaj panele do pionowego splittera
        right_splitter.addWidget(schedule_frame)
        right_splitter.addWidget(events_frame)

        # Ustaw początkowe proporcje dla pionowego splittera (np. 60% grafik, 40% zdarzenia)
        right_splitter.setSizes([600, 400])

        # Dodaj pionowy splitter do layoutu prawego panelu
        right_layout.addWidget(right_splitter)

        return right_panel

    def setup_schedule_section(self):
        """Tworzy sekcję grafiku (górna część prawego panelu)"""
        schedule_frame = QFrame()
        schedule_frame.setFrameShape(QFrame.StyledPanel)
        schedule_frame.setFrameShadow(QFrame.Raised)
        schedule_layout = QVBoxLayout(schedule_frame)
        schedule_layout.setContentsMargins(5, 5, 5, 5)

        # Tabela z grafikiem
        self.table = QTableWidget()
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.table.setSelectionBehavior(QAbstractItemView.SelectItems)
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.itemSelectionChanged.connect(self.on_selection_changed)
        self.table.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))

        # DODAJ TE LINIE: Ustaw politykę rozciągania dla tabeli
        self.table.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

        # Zastąp standardowy nagłówek poziomy niestandardowym
        self.table.setHorizontalHeader(WeekendAwareHeaderView(Qt.Horizontal, self.table))

        # Dodaj tabelę do layoutu
        schedule_layout.addWidget(self.table)

        # Ustaw domyślną wysokość wierszy
        self.table.verticalHeader().setDefaultSectionSize(15)

        # Wyłącz automatyczne dostosowywanie wysokości wierszy
        self.table.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)

        # Dodaj przyciski akcji
        button_frame = self.setup_schedule_buttons()
        schedule_layout.addWidget(button_frame)

        return schedule_frame

    def setup_schedule_buttons(self):
        """Tworzy przyciski akcji dla sekcji grafiku"""
        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setContentsMargins(0, 0, 0, 0)

        # NOWOŚĆ: Dodajemy przycisk do ukrywania/pokazywania panelu zdarzeń (po lewej stronie)
        self.toggle_events_panel_button = QPushButton("Ukryj zdarzenia↓")
        self.toggle_events_panel_button.setToolTip("Ukryj panel zdarzeń (dla większego widoku grafiku)")
        self.toggle_events_panel_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.toggle_events_panel_button.clicked.connect(self.toggle_events_panel)

        # Dodaj przycisk po lewej stronie
        button_layout.addWidget(self.toggle_events_panel_button)

        # Dodaj elastyczny odstęp, aby rozdzielić przyciski
        button_layout.addStretch()

        # Przycisk "Wstaw zmianę"
        self.insert_change_button = QPushButton("Wstaw zmianę")
        self.insert_change_button.setShortcut("Ctrl+Z")  # Skrót klawiszowy
        self.insert_change_button.setToolTip("Wstaw zmianę grafiku (Ctrl+Z)")
        self.insert_change_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.insert_change_button.clicked.connect(self.show_insert_change_dialog)
        button_layout.addWidget(self.insert_change_button)

        # Przycisk "Wstaw nieobecność"
        self.insert_symbol_button = QPushButton("Wstaw nieobecność")
        self.insert_symbol_button.setShortcut("Ctrl+I")  # Skrót klawiszowy Ctrl+I
        self.insert_symbol_button.setToolTip("Wstaw nieobecność (Ctrl+I)")  # Podpowiedź z informacją o skrócie
        self.insert_symbol_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.insert_symbol_button.clicked.connect(self.show_insert_symbol_dialog)
        button_layout.addWidget(self.insert_symbol_button)

        # Przycisk "Odwołaj delegacje"
        self.cancel_delegation_button = QPushButton("Odwołaj delegacje")
        self.cancel_delegation_button.setShortcut("Ctrl+D")  # Skrót klawiszowy Ctrl+D
        self.cancel_delegation_button.setToolTip("Odwołaj delegacje dla zaznaczonych komórek (Ctrl+D)")
        self.cancel_delegation_button.setStyleSheet(
            AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.cancel_delegation_button.clicked.connect(self.cancel_delegations)
        button_layout.addWidget(self.cancel_delegation_button)

        # Przycisk "Dodaj nadgodziny"
        self.add_overtime_button = QPushButton("Dodaj nadgodziny")
        self.add_overtime_button.setShortcut("Ctrl+N")  # Skrót klawiszowy Ctrl+N
        self.add_overtime_button.setToolTip("Dodaj nadgodziny dla zaznaczonych komórek (Ctrl+N)")
        self.add_overtime_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.add_overtime_button.clicked.connect(self.show_add_overtime_dialog)

        # ZMODYFIKOWANA LINIA: Zawsze dodawaj przycisk do layoutu
        button_layout.addWidget(self.add_overtime_button)

        # Ewentualnie ustaw widoczność przycisku na podstawie roli
        # Można to zrobić po inicjalizacji wszystkich komponentów
        if hasattr(self, 'current_user_role'):
            self.add_overtime_button.setVisible(self.current_user_role == "Pracownik WPR")
        else:
            # Domyślnie widoczny, możemy to zmienić później
            self.add_overtime_button.setVisible(True)

        return button_frame

    def setup_events_section(self):
        """Tworzy sekcję zdarzeń (dolna część prawego panelu)"""
        events_frame = QFrame()
        events_frame.setFrameShape(QFrame.StyledPanel)
        events_frame.setFrameShadow(QFrame.Raised)
        events_layout = QVBoxLayout(events_frame)
        events_layout.setContentsMargins(5, 5, 5, 5)

        # Dodaj kontrolki filtrów
        filters_frame = self.setup_events_filters()
        events_layout.addWidget(filters_frame)

        # Tworzenie tabeli zdarzeń
        self.events_table = QTableWidget()
        self.events_table.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.events_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.events_table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.events_table.setStyleSheet(AppStyles.get_table_style("dark" if self.is_dark_theme else "light"))

        # Ustawienie kolumn dla tabeli zdarzeń
        self.setup_events_table_columns()

        # Dodaj tabelę zdarzeń do panelu zdarzeń
        events_layout.addWidget(self.events_table)

        return events_frame

    def setup_events_filters(self):
        """Konfiguruje filtry dla tabeli zdarzeń"""
        events_filter_frame = QFrame()
        events_filter_layout = QHBoxLayout(events_filter_frame)
        events_filter_layout.setContentsMargins(0, 0, 0, 0)

        # Filtry daty od-do
        date_from_label = QLabel("Data od:")
        self.date_from = QDateEdit()
        self.date_from.setDisplayFormat("dd.MM.yyyy")
        self.date_from.setDate(QDate.currentDate().addDays(-30))
        self.date_from.setCalendarPopup(True)
        self.date_from.setStyleSheet(AppStyles.get_date_edit_style("dark" if self.is_dark_theme else "light"))

        date_to_label = QLabel("Data do:")
        self.date_to = QDateEdit()
        self.date_to.setDisplayFormat("dd.MM.yyyy")
        self.date_to.setDate(QDate.currentDate())
        self.date_to.setCalendarPopup(True)
        self.date_to.setStyleSheet(AppStyles.get_date_edit_style("dark" if self.is_dark_theme else "light"))

        # Filtr tematu
        topic_label = QLabel("Temat:")
        self.topic_filter = QLineEdit()
        self.topic_filter.setPlaceholderText("Filtruj po temacie...")
        self.topic_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))

        # Filtr nazwy
        name_label = QLabel("Nazwa:")
        self.name_filter = QLineEdit()
        self.name_filter.setPlaceholderText("Filtruj po nazwie...")
        self.name_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))

        # Checkboxy do filtrowania typów zdarzeń
        self.meetings_checkbox = QCheckBox("Spotkania")
        self.meetings_checkbox.setChecked(True)
        self.meetings_checkbox.stateChanged.connect(self.filter_events_table)

        self.trainings_checkbox = QCheckBox("Szkolenia")
        self.trainings_checkbox.setChecked(True)
        self.trainings_checkbox.stateChanged.connect(self.filter_events_table)

        self.overtime_checkbox = QCheckBox("Nadgodziny")
        self.overtime_checkbox.setChecked(True)
        self.overtime_checkbox.stateChanged.connect(self.filter_events_table)

        # Podłącz sygnały zmiany daty bezpośrednio do filtrowania
        self.date_from.dateChanged.connect(self.filter_events_table)
        self.date_to.dateChanged.connect(self.filter_events_table)
        self.topic_filter.textChanged.connect(self.filter_events_table)
        self.name_filter.textChanged.connect(self.filter_events_table)

        # Dodaj kontrolki do layoutu filtrów zdarzeń
        events_filter_layout.addWidget(date_from_label)
        events_filter_layout.addWidget(self.date_from)
        events_filter_layout.addWidget(date_to_label)
        events_filter_layout.addWidget(self.date_to)
        events_filter_layout.addWidget(topic_label)
        events_filter_layout.addWidget(self.topic_filter)
        events_filter_layout.addWidget(name_label)
        events_filter_layout.addWidget(self.name_filter)
        events_filter_layout.addWidget(self.meetings_checkbox)
        events_filter_layout.addWidget(self.trainings_checkbox)
        events_filter_layout.addWidget(self.overtime_checkbox)
        events_filter_layout.addStretch()

        return events_filter_frame

    def setup_events_table_columns(self):
        """Konfiguruje kolumny dla tabeli zdarzeń"""
        self.events_table.setColumnCount(10)
        self.events_table.setHorizontalHeaderLabels([
            "Id", "Typ", "Temat", "Nazwa", "Użytkownik", "Data", "Od", "Do", "Status", "Akcje"
        ])

        # Ustaw szerokość kolumn
        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Użytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

    def setup_table_properties(self):
        """Konfiguruje właściwości tabel"""
        # Sortowanie
        self.table.setSortingEnabled(True)
        self.events_table.setSortingEnabled(True)

        # Domyślnie sortuj po pierwszej kolumnie (Wydział)
        self.table.sortByColumn(0, Qt.AscendingOrder)
        self.events_table.sortByColumn(0, Qt.AscendingOrder)

        # Możemy także zachować informację o ostatnim sortowaniu
        self.last_sort_column = 0
        self.last_sort_order = Qt.AscendingOrder

        # Podłącz sygnały sortowania
        self.table.horizontalHeader().sortIndicatorChanged.connect(self.on_sort_changed)
        self.events_table.horizontalHeader().sortIndicatorChanged.connect(self.on_events_sort_changed)

        # Dodaj delegata do tabeli aby obsługiwał niestandardowe rysowanie
        self.table.setItemDelegate(OvertimeItemDelegate())

    def toggle_left_panel(self):
        """Przełącza widoczność lewego panelu filtrów"""
        if self.left_panel_visible:
            # Ukryj panel
            self.left_panel_width = self._left_panel.width()  # Zapamiętaj bieżącą szerokość
            self._left_panel.setFixedWidth(0)
            self.left_panel_visible = False
            self.toggle_menu_button.setText("☲")  # Zmień ikonę na "pokaż menu"
            self.toggle_menu_button.setToolTip("Pokaż panel filtrów")
        else:
            # Pokaż panel
            self._left_panel.setMinimumWidth(200)
            self._left_panel.setMaximumWidth(250)

            # Sprawdź czy mamy zapamiętaną szerokość
            if hasattr(self, 'left_panel_width'):
                self._left_panel.setFixedWidth(self.left_panel_width)
            else:
                self._left_panel.setFixedWidth(200)  # Domyślna szerokość

            self.left_panel_visible = True
            self.toggle_menu_button.setText("☰")  # Przywróć ikonę "burger menu"
            self.toggle_menu_button.setToolTip("Ukryj panel filtrów")

        # Dostosuj widoczność głównego splittera
        self.main_splitter.update()

    def toggle_events_panel(self):
        """Przełącza widoczność panelu zdarzeń (dolny panel)"""
        # Znajdź splitter, który organizuje układ prawy (grafik | zdarzenia)
        right_splitter = None

        # Szukamy w rodzicu prawego panelu, który zawiera splitter
        for widget in self.findChildren(QSplitter):
            # Sprawdź, czy to pionowy splitter zawierający panel zdarzeń
            if widget.orientation() == Qt.Vertical and widget.count() > 1:
                right_splitter = widget
                break

        if right_splitter:
            # Pobierz rozmiary paneli
            sizes = right_splitter.sizes()

            # Jeśli panel zdarzeń jest widoczny, ukryj go
            if sizes[1] > 0:
                # Zapisz obecny rozmiar panelu zdarzeń przed ukryciem
                self.events_panel_size = sizes[1]

                # Ustaw nowe rozmiary - cała przestrzeń dla grafiku, 0 dla zdarzeń
                right_splitter.setSizes([sizes[0] + sizes[1], 0])

                # Zmień tekst przycisku
                self.toggle_events_panel_button.setText("Pokaż zdarzenia↑")
                self.toggle_events_panel_button.setToolTip("Pokaż panel zdarzeń↑")
            else:
                # Jeśli panel zdarzeń jest ukryty, pokaż go
                # Użyj zapisanego wcześniej rozmiaru lub domyślnego (300)
                events_size = getattr(self, 'events_panel_size', 300)

                # Oblicz nowy rozmiar dla panelu grafiku
                schedule_size = sizes[0] - events_size
                if schedule_size < 200:  # Minimalny rozmiar dla grafiku
                    schedule_size = 200
                    events_size = sizes[0] - schedule_size

                # Ustaw nowe rozmiary
                right_splitter.setSizes([schedule_size, events_size])

                # Zmień tekst przycisku
                self.toggle_events_panel_button.setText("Ukryj zdarzenia↓")
                self.toggle_events_panel_button.setToolTip("Ukryj panel zdarzeń (dla większego widoku grafiku)")


    def on_sort_changed(self, logical_index, order):
        """Obsługuje zmianę sortowania w tabeli grafiku"""
        self.last_sort_column = logical_index
        self.last_sort_order = order
        debug_print(
            f"Tabela grafiku: Sortowanie po kolumnie {logical_index}, kolejność: {'rosnąco' if order == Qt.AscendingOrder else 'malejąco'}")

    def on_events_sort_changed(self, logical_index, order):
        """Obsługuje zmianę sortowania w tabeli zdarzeń"""
        debug_print(f"Tabela zdarzeń: Sortowanie po kolumnie {logical_index}, kolejność: {'rosnąco' if order == Qt.AscendingOrder else 'malejąco'}")

    def update_buttons_visibility(self):
        """Aktualizuje widoczność przycisków na podstawie roli użytkownika"""
        if hasattr(self, 'add_overtime_button') and hasattr(self, 'current_user_role'):
            self.add_overtime_button.setVisible(self.current_user_role == "Pracownik WPR")

    def check_user_permissions(self):
        """Sprawdza, czy użytkownik ma odpowiednie uprawnienia do korzystania z aplikacji"""
        # Pobierz dane użytkownika
        user_id, user_app_id, user_app_role = get_modifier_id()

        # Zapisz ID użytkownika do wykorzystania w zapytaniach SQL
        self.current_user_id = user_id
        self.current_user_app_id = user_app_id
        self.current_user_role = user_app_role

        # Aktualizuj widoczność przycisków na podstawie roli
        self.update_buttons_visibility()

        # Lista dozwolonych ról
        allowed_roles = ["Pracownik WPR", "Lider", "Menadżer"]

        # Sprawdź, czy rola użytkownika jest na liście dozwolonych
        if user_app_role not in allowed_roles:
            # Pokaż komunikat o braku uprawnień
            QMessageBox.critical(
                self,
                "Brak uprawnień",
                f"Nie masz uprawnień do korzystania z tej aplikacji.\n\n"
                f"Wymagana rola: Pracownik WPR, Lider lub Menadżer\n"
                f"Twoja rola: {user_app_role}",
                QMessageBox.Ok
            )
            # Zamknij aplikację
            self.close()
            return False

        print(f"Zalogowano jako: {user_app_id} ({user_app_role})")
        return True

    def debug_icons_in_cell(self, row, col):
        """Wyświetla stan ikon w komórce (czy są ustawione flagi dla ikon)"""
        cell_item = self.table.item(row, col)
        if not cell_item:
            debug_print(f"Brak elementu w komórce [{row}, {col}]")
            return

        # Pobierz dane z UserRole
        user_role_data = cell_item.data(Qt.UserRole)
        user_role_overtime = cell_item.data(Qt.UserRole + 2)
        user_role_meetings = cell_item.data(Qt.UserRole + 3)

        debug_print(f"Stan ikon w komórce [{row}, {col}]:")
        debug_print(f"  Tekst: {cell_item.text()}")
        debug_print(f"  Flaga nadgodzin (UserRole+2): {user_role_overtime}")
        debug_print(f"  Flaga spotkań/szkoleń (UserRole+3): {user_role_meetings}")

        if isinstance(user_role_data, dict):
            debug_print("  Z danych słownika:")
            debug_print(f"    has_overtime: {user_role_data.get('has_overtime')}")
            debug_print(f"    has_meeting: {user_role_data.get('has_meeting')}")
            debug_print(f"    has_training: {user_role_data.get('has_training')}")

    def show_insert_symbol_dialog(self):
        """
        Pokazuje okno dialogowe do wstawiania symbolu.
        Zoptymalizowana wersja, która automatycznie odwołuje delegacje i prezentuje grupowanie po użytkownikach.
        """
        dialog = InsertSymbolDialog(self)
        if dialog.exec():
            symbol = dialog.get_selected_symbol()

            # Pobierz zaznaczone komórki
            selected_ranges = self.table.selectedRanges()
            current_data = self.date_combo.currentData()

            if not current_data:
                QMessageBox.warning(
                    self,
                    "Brak danych",
                    "Nie wybrano miesiąca lub brak dostępnych danych do wyświetlenia.",
                    QMessageBox.Ok
                )
                return

            if not selected_ranges:
                QMessageBox.warning(
                    self,
                    "Brak zaznaczenia",
                    "Nie zaznaczono żadnych komórek do aktualizacji.",
                    QMessageBox.Ok
                )
                return

            # Zapamietaj bieżące zaznaczenie, aby później je przywrócić
            saved_selections = []
            for range_item in selected_ranges:
                saved_selections.append((
                    range_item.topRow(),
                    range_item.leftColumn(),
                    range_item.bottomRow(),
                    range_item.rightColumn()
                ))

            # Zbierz informacje o zaznaczonych komórkach
            selected_cells = []
            user_date_pairs = set()  # Dla odwoływania delegacji

            for range_item in selected_ranges:
                for row in range(range_item.topRow(), range_item.bottomRow() + 1):
                    for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                        # Sprawdź czy to komórka z dniem miesiąca
                        if col < 3:
                            continue

                        # Pobierz element tabeli
                        cell_item = self.table.item(row, col)
                        if not cell_item:
                            continue

                        # Pobierz dane z komórki
                        cell_data = self.get_cell_data(cell_item)
                        if not cell_data:
                            continue

                        # Dodaj dane do listy wybranych komórek
                        selected_cells.append(cell_data)

                        # Dodaj parę (użytkownik, data) do odwołania delegacji
                        user_id = cell_data.get('uzytkownik_id')
                        date_str = cell_data.get('date_str')
                        if user_id and date_str:
                            user_date_pairs.add((user_id, date_str))

            if not selected_cells:
                QMessageBox.information(
                    self,
                    "Brak danych",
                    "Nie znaleziono danych dla zaznaczonych komórek.",
                    QMessageBox.Ok
                )
                return

            # Znajdź delegacje, które kolidują z nieobecnością
            events_to_cancel = []

            # Słownik do grupowania zdarzeń według użytkownika i dnia
            grouped_events = {}

            # Użyj indeksu zdarzeń do szybkiego znalezienia delegacji
            for user_id, date_str in user_date_pairs:
                # Pobierz zdarzenia dla tej pary użytkownik-data z indeksu
                user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                # Filtruj tylko aktywne spotkania i szkolenia
                for event in user_events:
                    event_type = event.get('type', '')
                    event_id = event.get('id')
                    event_status = event.get('status')

                    # Konwersja statusu do str dla jednolitości porównania
                    if event_status is not None:
                        event_status = str(event_status)

                    if event_type in ['Spotkanie', 'Szkolenie'] and event_id and event_status != '0':
                        # Dodaj do listy ogólnej
                        events_to_cancel.append({
                            'id': event_id,
                            'type': event_type,
                            'user_id': user_id,
                            'date': date_str,
                            'date_key': event.get('date_key', date_str),
                            'name': event.get('name', ''),
                            'user_name': event.get('user_name', ''),  # Nazwa użytkownika
                        })

                        # Dodaj do słownika grupującego
                        key = (user_id, date_str)
                        if key not in grouped_events:
                            grouped_events[key] = []
                        grouped_events[key].append(event)

            # Grupowanie zmian według użytkowników i dat
            grouped_changes = {}
            for cell in selected_cells:
                user_id = cell.get('uzytkownik_id')
                user_name = cell.get('uzytkownik_dane', '')
                date_str = cell.get('date_str')

                # Przetwórz datę na czytelniejszy format (DD.MM.YYYY)
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str

                # Utwórz klucz (użytkownik_id, user_name)
                user_key = (user_id, user_name)

                # Dodaj do słownika grupującego
                if user_key not in grouped_changes:
                    grouped_changes[user_key] = {}

                if formatted_date not in grouped_changes[user_key]:
                    grouped_changes[user_key][formatted_date] = []

                grouped_changes[user_key][formatted_date].append(cell)

            # Przygotuj szczegółowy opis zmian
            changes_info = ""

            # Przejdź przez pogrupowane zmiany
            for (user_id, user_name), dates in grouped_changes.items():
                changes_info += f"\n👤 {user_name}:\n"

                for date, cells in dates.items():
                    changes_info += f"   📅 {date}: "

                    # Lista symboli do zmiany
                    symbols = [cell.get('symbol', 'brak') for cell in cells]
                    unique_symbols = set(symbols)

                    if len(unique_symbols) == 1:
                        # Jeśli wszystkie symbole są takie same
                        current_symbol = next(iter(unique_symbols))
                        changes_info += f"{current_symbol} -> {symbol}\n"
                    else:
                        # Jeśli są różne symbole
                        symbols_str = ", ".join([f"{s}" for s in unique_symbols])
                        changes_info += f"[{symbols_str}] -> {symbol}\n"

            # Przygotuj szczegółowy opis zdarzeń do odwołania
            delegations_info = ""

            # Licznik dla ograniczenia liczby wyświetlanych grup
            group_count = 0
            max_groups_to_show = 10

            # Przetwarzaj zgrupowane zdarzenia
            if grouped_events:
                delegations_info += "\nNastępujące delegacje zostaną automatycznie odwołane:\n"

                for (user_id, date_str), events in grouped_events.items():
                    # Ograniczenie liczby wyświetlanych grup
                    if group_count >= max_groups_to_show:
                        delegations_info += f"\n...oraz więcej zdarzeń dla innych użytkowników/dni ({len(grouped_events) - max_groups_to_show} więcej grup)...\n"
                        break

                    # Pobierz nazwę użytkownika z pierwszego zdarzenia
                    user_name = events[0].get('user_name', f"ID: {user_id}")

                    # Przygotuj datę w ładniejszym formacie (DD.MM.YYYY)
                    try:
                        year, month, day = date_str.split('-')
                        formatted_date = f"{day}.{month}.{year}"
                    except:
                        formatted_date = date_str

                    delegations_info += f"   👤 {user_name} - 📅 {formatted_date}:\n"

                    # Wyświetl zdarzenia dla tego użytkownika i daty
                    for i, event in enumerate(events):
                        delegations_info += f"      {i + 1}. {event['type']}: {event['name']}\n"

                    group_count += 1

            # Pokaż komunikat potwierdzenia z pogrupowanymi zmianami
            complete_info = f"Czy na pewno chcesz wprowadzić następujące zmiany?\n\n{changes_info}"

            if delegations_info:
                complete_info += f"\n{delegations_info}"

            complete_info += f"\nŁącznie: {len(selected_cells)} komórek zmieni symbol"

            if events_to_cancel:
                complete_info += f", {len(events_to_cancel)} delegacji zostanie odwołanych"

            reply = QMessageBox.question(
                self,
                "Potwierdzenie zmiany symbolu",
                complete_info,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )

            if reply == QMessageBox.Yes:
                try:
                    # Najpierw odwołaj delegacje, jeśli są
                    if events_to_cancel:
                        # Pobierz identyfikator użytkownika
                        _, user_app_id, _ = get_modifier_id()

                        # Przygotuj zbiór do śledzenia par użytkownik-data do aktualizacji
                        affected_users_dates = set()

                        conn = DatabaseConnector.get_connection()
                        cursor = conn.cursor()
                        canceled_count = 0

                        # Dla każdego zdarzenia do odwołania
                        for event in events_to_cancel:
                            event_id = event['id']
                            event_type = event['type']
                            user_id = event['user_id']
                            date_key = event.get('date_key')

                            # Określ odpowiednią tabelę
                            table_name = "p_t_zz_Spotkania" if event_type == "Spotkanie" else "p_t_zz_Szkolenia"

                            # Aktualizuj status zdarzenia
                            update_query = f"""
                            UPDATE {table_name} 
                            SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? 
                            WHERE Id = ?
                            """
                            cursor.execute(update_query, (user_app_id, event_id))
                            canceled_count += 1

                            affected_users_dates.add((user_id, date_key))

                            # Usuń zdarzenie z indeksu zdarzeń
                            self.data_provider.delete_event_from_index(event_id, event_type)

                            # ULEPSZENIE 1: Wyczyść cache dla tej pary (użytkownik, data)
                            pair_cache_key = f"user_{user_id}_date_{date_key}"
                            if hasattr(self.data_provider, 'cache') and pair_cache_key in self.data_provider.cache:
                                del self.data_provider.cache[pair_cache_key]

                            # ULEPSZENIE 2: Usuń z list danych zdarzeń - używaj list comprehension dla wydajności
                            if hasattr(self, 'events_data'):
                                self.events_data = [e for e in self.events_data if
                                                    not (e.get('id') == event_id and e.get('type') == event_type)]

                            # ULEPSZENIE 3: Usuń z all_events_data
                            if hasattr(self, 'all_events_data'):
                                self.all_events_data = [e for e in self.all_events_data if
                                                        not (e.get('id') == event_id and e.get('type') == event_type)]

                        conn.commit()

                        # ULEPSZENIE 4: Wyczyść cache dla wszystkich zmienionych miesięcy
                        year_month_cache = {}
                        for user_id, date_str in affected_users_dates:
                            if date_str and date_str.count('-') == 2:
                                year, month, _ = date_str.split('-')
                                year_month_cache[(int(year), int(month))] = True

                        for year, month in year_month_cache.keys():
                            self.clear_events_cache(year, month)

                        # Informacja o zakończeniu odwoływania delegacji
                        print(f"Automatycznie odwołano {canceled_count} delegacji")

                    # Teraz wprowadź zmiany symbolu
                    conn = DatabaseConnector.get_connection()
                    cursor = conn.cursor()

                    # Pobierz identyfikator użytkownika modyfikującego rekord
                    _, user_app_id, _ = get_modifier_id()

                    successful_updates = 0

                    for cell in selected_cells:
                        user_id = cell.get('uzytkownik_id')
                        day = cell.get('day')
                        year, month, _ = cell.get('date_str', '').split('-')
                        date = QDate(int(year), int(month), day).toString('yyyy-MM-dd')

                        # Sprawdź, czy rekord już istnieje
                        existing_id = cell.get('id')
                        if existing_id:
                            # Zmodyfikowane zapytanie do aktualizacji symbolu
                            query = f'''
                            DECLARE @NewSymbol VARCHAR(3) = '{symbol}';
                            DECLARE @Modyfikujacy VARCHAR(50) = '{user_app_id}';
                            UPDATE p_T_ZZ_GrafikiPracy
                            SET Symbol = 
                                CASE 
                                -- Obsługa usuwania lokalizacji (h;, s;, p;)
                                WHEN Symbol LIKE 'h;%' OR Symbol LIKE 's;%' OR Symbol LIKE 'p;%' THEN
                                    CASE
                                        -- Jeśli po lokalizacji jest jeszcze jakiś średnik, zachowaj do ostatniego średnika i dodaj nowy symbol
                                        WHEN 
                                            (SUBSTRING(Symbol, 3, LEN(Symbol)) LIKE '%' + ';') THEN 
                                            SUBSTRING(Symbol, 3, LEN(Symbol) - 2) + @NewSymbol
                                        -- Jeśli po lokalizacji są jakieś średniki w środku
                                        WHEN 
                                            (SUBSTRING(Symbol, 3, LEN(Symbol)) LIKE '%' + ';' + '%') THEN
                                            SUBSTRING(Symbol, 3, LEN(SUBSTRING(Symbol, 3, LEN(Symbol))) - CHARINDEX(';', REVERSE(SUBSTRING(Symbol, 3, LEN(Symbol))))) + ';' + @NewSymbol
                                        -- Jeśli po lokalizacji nie ma już średników
                                        ELSE
                                            SUBSTRING(Symbol, 3, LEN(Symbol)) + ';' + @NewSymbol
                                    END

                                -- Dla zwykłych przypadków bez lokalizacji
                                WHEN Symbol LIKE '%' + ';' THEN Symbol + @NewSymbol
                                WHEN Symbol LIKE '%' + ';' + '%' THEN
                                    SUBSTRING(Symbol, 1, LEN(Symbol) - CHARINDEX(';', REVERSE(Symbol))) + ';' + @NewSymbol
                                ELSE Symbol + ';' + @NewSymbol
                            END,
                                DataModyfikacji = GETDATE(),
                                Modyfikujacy = @Modyfikujacy
                            WHERE Id = {existing_id} ;
                            '''
                            cursor.execute(query)
                            successful_updates += 1

                    conn.commit()
                    conn.close()

                    # Po pomyślnej aktualizacji danych w bazie danych:
                    try:
                        # Pobierz najnowszą datę modyfikacji po wykonaniu zmian
                        query = """
                                SELECT MAX(DataModyfikacji) as DataModyfikacji FROM p_v_zz_GrafikiPracy
                            """
                        conn = DatabaseConnector.get_connection()
                        cursor = conn.cursor()
                        cursor.execute(query)
                        result = cursor.fetchone()
                        conn.close()

                        if result and result[0]:
                            # Zapisz tę datę jako własną modyfikację
                            self.last_self_modification_date = result[0]
                            self.last_modification_date = result[0]  # Aktualizuj również ostatnią znaną modyfikację
                            print(f"Zarejestrowano własną modyfikację z datą: {self.last_self_modification_date}")
                    except Exception as e:
                        print(f"Błąd podczas rejestrowania własnej modyfikacji: {e}")

                    # Teraz aktualizuj tabele i ikony

                    # 1. Aktualizuj komórki bezpośrednio w tabeli
                    for cell in selected_cells:
                        user_id = cell.get('uzytkownik_id')
                        day = cell.get('day')
                        date_str = cell.get('date_str')

                        # Przeszukaj tabelę, aby znaleźć odpowiednią komórkę
                        for row in range(self.table.rowCount()):
                            for day_col in range(3, self.table.columnCount() - 1):
                                # Sprawdź czy to odpowiednia kolumna dla dnia
                                if day_col != day + 2:
                                    continue

                                # Pobierz element tabeli
                                day_item = self.table.item(row, day_col)
                                if not day_item:
                                    continue

                                # Pobierz dane z komórki
                                day_data = self.get_cell_data(day_item)
                                if not day_data:
                                    continue

                                # Sprawdź czy to ta sama komórka
                                if day_data.get('uzytkownik_id') == user_id and day_data.get('day') == day:
                                    # Znaleźliśmy właściwą komórkę, aktualizuj symbol
                                    current_text = day_item.text()
                                    new_text = ""

                                    # 1. Usuwanie prefiksów (h;, s;, p;) na początku
                                    prefixes = ['h;', 's;', 'p;']
                                    for prefix in prefixes:
                                        if current_text.startswith(prefix):
                                            current_text = current_text[len(prefix):]
                                            break

                                    # 2. Usuwanie części przed ostatnim średnikiem (jeśli istnieje)
                                    if ';' in current_text:
                                        parts = current_text.split(';')
                                        # Zachowaj tylko ostatnią część po średniku, jeśli taka istnieje
                                        if len(parts) == 3:  # Jeśli jest już symbol
                                            prefix = ';'.join(parts[:-1]) + ';'
                                            new_text = prefix + symbol
                                        elif len(parts) == 2:  # Jeśli brak symbolu
                                            prefix = ';'.join(parts) + ';'
                                            new_text = prefix + symbol
                                    print(f"Oryginalny symbol: {day_item.text()}, Po przetworzeniu: {new_text}")

                                    # Zaktualizuj tekst komórki
                                    day_item.setText(new_text)

                                    # Aktualizuj dane w komórce - ustawiamy wszystkie flagi na false
                                    # ponieważ odwołaliśmy wszystkie delegacje
                                    day_data['symbol'] = symbol
                                    day_data['has_meeting'] = False
                                    day_data['has_training'] = False

                                    # Zapisz zaktualizowane dane
                                    self.set_cell_data(day_item, day_data)

                                    # Ustaw kolor tła jeśli to dzień urlopowy
                                    if symbol and ("OS" in symbol or "U" in symbol):
                                        day_item.setBackground(QColor(255, 180, 0))  # Pomarańczowy dla OS/U
                                        day_item.setForeground(QColor(0, 0, 0))  # Czarny tekst

                                    break  # Znaleźliśmy i zaktualizowaliśmy komórkę, przerwij pętlę

                    # 2. Odśwież tabele
                    self.filter_events_table()  # Odśwież tabelę zdarzeń
                    self.table.viewport().update()  # Odśwież tabelę grafiku

                    # 3. Przywróć zaznaczenie
                    for top_row, left_col, bottom_row, right_col in saved_selections:
                        selection_range = QTableWidgetSelectionRange(
                            top_row, left_col, bottom_row, right_col
                        )
                        self.table.setRangeSelected(selection_range, True)

                    # Poinformuj o zakończeniu
                    QMessageBox.information(
                        self,
                        "Sukces",
                        f"Operacja zakończona pomyślnie. Wprowadzono {successful_updates} zmian w grafiku"
                        + (f", odwołano {canceled_count} delegacji" if events_to_cancel else ""),
                        QMessageBox.Ok
                    )

                except Exception as e:
                    QMessageBox.critical(
                        self,
                        "Błąd",
                        f"Wystąpił błąd podczas aktualizacji grafiku: {str(e)}",
                        QMessageBox.Ok
                    )
                    import traceback
                    traceback.print_exc()
                    return

    def update_filter_dates(self):
        """Aktualizuje daty filtrowania do pierwszego i ostatniego dnia wybranego miesiąca"""
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # Pierwszy dzień miesiąca
        first_day = QDate(year, month, 1)
        self.date_from.setDate(first_day)

        # Ostatni dzień miesiąca (przejdź do następnego miesiąca i cofnij o 1 dzień)
        if month == 12:
            next_month = QDate(year + 1, 1, 1)
        else:
            next_month = QDate(year, month + 1, 1)

        last_day = next_month.addDays(-1)
        self.date_to.setDate(last_day)

        # DODANE: Odśwież filtry po aktualizacji dat
        self.filter_events_table()

    # Aktualizacja metody on_date_combo_changed aby odświeżać indeks zdarzeń przy zmianie miesiąca
    def on_date_combo_changed(self):
        """Obsługuje zmianę wybranego miesiąca"""
        # Pobierz rok i miesiąc
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data
            # Aktualizuj dane
            self.update_data(year, month)
            # Aktualizuj daty filtrowania
            self.update_filter_dates()

    def get_selected_schedule_cells(self):
        """Zwraca listę zaznaczonych komórek z siatki grafiku"""
        selected_cells = []
        selected_ranges = self.table.selectedRanges()

        for range_item in selected_ranges:
            for row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawdź czy to komórka z grafikiem
                    if col >= 3:
                        # Pobierz element tabeli
                        cell_item = self.table.item(row, col)
                        if not cell_item:
                            continue

                        # Pobierz dane z komórki
                        cell_data = self.get_cell_data(cell_item)
                        if not cell_data:
                            continue

                        # Dodaj dane do listy wybranych komórek
                        selected_cells.append(cell_data)

        return selected_cells



    # Metoda do aktualizacji danych
    def update_data(self, year, month):
        """Aktualizuje dane dla wybranego roku i miesiąca"""
        self.year = year
        self.month = month

        debug_print(f"Pobieranie danych dla {year}-{month}")

        # Wyczyść istniejące dane
        self.raw_data = []
        self.processed_data = {}
        self.all_events_data = []
        self.user_info_map = {}

        # Pokaż informację o ładowaniu
        self.table.clear()
        self.table.setRowCount(1)
        self.table.setColumnCount(1)

        loading_item = QTableWidgetItem("Ładowanie danych...")
        loading_item.setTextAlignment(Qt.AlignCenter)
        loading_font = QFont()
        loading_font.setBold(True)
        loading_font.setPointSize(10)
        loading_item.setFont(loading_font)

        self.table.setItem(0, 0, loading_item)
        self.table.horizontalHeader().setVisible(True)
        self.table.verticalHeader().setVisible(True)

        # Wyczyść tabelę zdarzeń
        self.events_table.setRowCount(0)

        # Użyj wątku do pobrania danych bez blokowania interfejsu
        self.data_thread = DataFetcherThread(year, month, self.data_provider)  # Przekaż data_provider
        self.data_thread.data_fetched.connect(self.on_data_fetched)
        self.data_thread.start()

        # Rozpocznij sprawdzanie nowych danych co 1 minutę
        self.setup_check_timer()

    def setup_check_timer(self):
        """Konfiguruje timer do sprawdzania nowych danych"""
        # Zatrzymaj istniejący timer jeśli działa
        if hasattr(self, 'check_timer') and self.check_timer.isActive():
            self.check_timer.stop()

        # Utwórz nowy timer
        self.check_timer = QTimer()
        self.check_timer.timeout.connect(self.check_for_new_data)
        self.check_timer.start(60000)  # 60 sekund = 1 minuta

    def refresh_data(self):
        """Odświeża dane i resetuje stan przycisku odświeżania"""
        # Resetuj stan przycisku
        self.refresh_button.setText("Odśwież dane")

        # Przywróć domyślny styl przycisku
        button_style = """
            background-color: #2c2c2c;
            color: white;
            border: 1px solid #3a3a3a;
            padding: 5px;
            border-radius: 3px;
        """ if self.is_dark_theme else """
            background-color: #e0e0e0;
            color: black;
            border: 1px solid #cccccc;
            padding: 5px;
            border-radius: 3px;
        """
        self.refresh_button.setStyleSheet(button_style)

        # Pobierz rok i miesiąc
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            debug_print(f"Odświeżam dane dla {year}-{month}")

            # Odśwież dane w DataProvider
            self.data_provider.refresh_data(year, month)

            # Pobierz dane na nowo
            self.update_data(year, month)

    def check_for_new_data(self):
        """Sprawdza czy są nowe dane w bazie danych, ignorując własne modyfikacje"""
        try:
            # Pobierz najnowszą datę modyfikacji z bazy danych
            query = """
                SELECT MAX(DataModyfikacji) as DataModyfikacji FROM p_v_zz_GrafikiPracy
            """
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query)
            result = cursor.fetchone()
            conn.close()

            if result and result[0]:
                latest_modification = result[0]
                debug_print(f"Ostatnia modyfikacja w bazie: {latest_modification}")

                # Jeśli to pierwszy raz, zapamiętaj datę i wyjdź
                if not hasattr(self, 'last_modification_date') or not self.last_modification_date:
                    self.last_modification_date = latest_modification
                    debug_print("Zapamiętano początkową datę modyfikacji")
                    return False

                # Sprawdź czy najnowsza modyfikacja jest własną modyfikacją
                if hasattr(self, 'last_self_modification_date') and self.last_self_modification_date:
                    # Porównaj daty jako string dla pewności
                    latest_str = str(latest_modification)
                    self_mod_str = str(self.last_self_modification_date)

                    # Jeśli najnowsza modyfikacja to nasza własna, ignoruj ją
                    if latest_str == self_mod_str:
                        debug_print(f"Ignoruję własną modyfikację z datą: {latest_str}")
                        return False

                # Sprawdź czy są nowsze dane niż ostatnio zapamiętane (które nie są naszymi własnymi)
                latest_str = str(latest_modification)
                last_str = str(self.last_modification_date)

                # Jeśli znajdziesz nowe dane, odśwież cache w DataProvider
                if latest_str > last_str:
                    # Aktualizuj ostatnią datę modyfikacji
                    self.last_modification_date = latest_modification

                    # Oznacz przycisk odświeżania
                    self.refresh_button.setText("Nowe dane!")

                    # Wyraźny styl przycisku z nowymi danymi
                    new_data_style = """
                        background-color: #f39c12; 
                        color: white;
                        font-weight: bold;
                        border: 2px solid #e67e22;
                        padding: 5px;
                        border-radius: 3px;
                    """
                    self.refresh_button.setStyleSheet(new_data_style)

                    # Zatrzymaj timer - nie musimy już sprawdzać, czekamy na akcję użytkownika
                    self.check_timer.stop()

                    return True
                else:
                    debug_print("Brak nowych danych")

            return False

        except Exception as e:
            debug_print(f"Błąd podczas sprawdzania nowych danych: {e}")
            return False

    def filter_data(self):
        """
        Filtruje dane i aktualizuje tabelę
        """
        start_time = time.time()

        # Bezpośrednio aktualizuj tabelę - filtrowanie będzie wykonane wewnątrz update_table_content()
        self.update_filtered_table()

        # Wyczyść tabelę zdarzeń, gdy zmieniają się filtry
        self.events_data = []
        self.events_table.setRowCount(0)

        self.log_time("Filtrowanie danych", start_time)

    def clear_filters(self):
        """Czyści wszystkie filtry"""
        # Wyczyść filtry ComboBox z wielokrotnym wyborem
        for combo_name in ['wydzial_combo', 'dtn_combo', 'rola_combo', 'jezyk_combo', 'etat_combo']:
            if hasattr(self, combo_name):
                combo = getattr(self, combo_name)
                combo.clear_selection()

        # Wyczyść filtry list
        self.przelozony_list.clearSelection()
        self.uzytkownik_list.clearSelection()

        # Wyczyść pola filtrowania
        self.przelozony_filter.clear()
        self.uzytkownik_filter.clear()

        # Pokaż wszystkie elementy list
        for i in range(self.przelozony_list.count()):
            self.przelozony_list.item(i).setHidden(False)

        for i in range(self.uzytkownik_list.count()):
            self.uzytkownik_list.item(i).setHidden(False)

        # Odśwież dane
        self.update_filtered_table()

    def filter_przelozony_list(self, text):
        """Filtruje listę przełożonych na podstawie wpisanego tekstu"""
        text = text.lower()
        for i in range(self.przelozony_list.count()):
            item = self.przelozony_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_uzytkownik_list(self, text):
        """Filtruje listę użytkowników na podstawie wpisanego tekstu"""
        text = text.lower()
        for i in range(self.uzytkownik_list.count()):
            item = self.uzytkownik_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def update_filtered_table(self):
        """
        Aktualizuje widok tabeli na podstawie zaznaczonych filtrów
        """
        # Bezpośrednio aktualizuj całą tabelę z przefiltrowanymi danymi
        self.update_table_content()

    # Metoda do obsługi danych zwróconych przez wątek
    def on_data_fetched(self, data):
        try:
            if not data or len(data) < 3:
                QMessageBox.critical(
                    self,
                    "Błąd",
                    "Nie udało się pobrać danych. Proszę spróbować ponownie.",
                    QMessageBox.StandardButton.Ok
                )
                return

            schedule_data, events_data, users_data = data

            # Przywróć tylko nagłówek poziomy
            self.table.horizontalHeader().setVisible(True)

            # Ukryj nagłówek pionowy (numery wierszy)
            self.table.verticalHeader().setVisible(True)

            # Przetwarzanie danych grafiku
            process_start = time.time()
            try:
                self.raw_data = schedule_data
                self.process_data(schedule_data)
                process_end = self.log_time("Przetwarzanie grafiku", process_start)
            except Exception as e:
                debug_print(f"Błąd podczas przetwarzania grafiku: {str(e)}")
                process_end = time.time()
                # Kontynuuj mimo błędu

            # Przetwarzanie danych użytkowników
            users_start = time.time()
            try:
                self.user_info_map = {}
                for user_data in users_data:
                    if len(user_data) >= 4:  # Sprawdź czy dane są kompletne
                        user_id, wydzial, przelozony, uzytkownik_dane = user_data
                        self.user_info_map[user_id] = {
                            'wydzial': wydzial or 'Nieznany',
                            'przelozony': przelozony or 'Nieznany',
                            'uzytkownik_dane': uzytkownik_dane or f"{user_id}"
                        }
                users_end = self.log_time("Przetwarzanie użytkowników", users_start)
            except Exception as e:
                debug_print(f"Błąd podczas przetwarzania użytkowników: {str(e)}")
                users_end = time.time()
                # Kontynuuj mimo błędu

            # Przetwarzanie zdarzeń - ta część może powodować problemy
            events_start = time.time()
            try:
                self.all_events_data = []
                if events_data:
                    for event_data in events_data:
                        try:
                            if len(event_data) >= 9:  # Sprawdź czy dane są kompletne
                                event_type, topic, name, event_user_id, event_date, time_from, time_to, status, event_id = event_data

                                # Pobierz dane użytkownika - bezpiecznie
                                user_info = self.user_info_map.get(event_user_id, {
                                    'wydzial': 'Nieznany',
                                    'przelozony': 'Nieznany',
                                    'uzytkownik_dane': f"{event_user_id}"
                                })
                                user_name = user_info.get('uzytkownik_dane', f"{event_user_id}")

                                # Bezpieczne formatowanie dat
                                date_obj = "01.01.2025"  # Wartość domyślna
                                date_key = event_date  # Zachowaj oryginalną datę

                                if event_date:
                                    try:
                                        if isinstance(event_date, str):
                                            date_parts = event_date.split(' ')[0].split('-')
                                            if len(date_parts) >= 3:
                                                date_obj = f"{date_parts[2]}.{date_parts[1]}.{date_parts[0]}"
                                        else:
                                            date_obj = event_date.strftime('%d.%m.%Y')
                                    except:
                                        # W przypadku problemu z formatowaniem daty
                                        pass

                                # Bezpieczne formatowanie czasu
                                time_from_obj = "00:00"
                                time_to_obj = "00:00"

                                try:
                                    if time_from:
                                        time_from_obj = time_from.strftime('%H:%M')
                                except:
                                    pass

                                try:
                                    if time_to:
                                        time_to_obj = time_to.strftime('%H:%M')
                                except:
                                    pass

                                self.all_events_data.append({
                                    'type': event_type or 'Nieznany',
                                    'topic': topic or '',
                                    'name': name or '',
                                    'user_id': event_user_id,
                                    'user_name': user_name,
                                    'date': date_obj,
                                    'date_key': date_key,
                                    'time_from': time_from_obj,
                                    'time_to': time_to_obj,
                                    'status': status or 'Nieznany',
                                    'id': event_id
                                })
                        except Exception as event_error:
                            debug_print(f"Błąd podczas przetwarzania zdarzenia: {str(event_error)}")
                            continue  # Przejdź do następnego zdarzenia



                events_end = self.log_time(f"Przetwarzanie {len(self.all_events_data)} zdarzeń", events_start)
            except Exception as e:
                debug_print(f"Błąd podczas przetwarzania zdarzeń: {str(e)}")
                events_end = time.time()
                # Kontynuuj mimo błędu - już mamy grafik

            # Aktualizacja interfejsu - każda operacja zabezpieczona oddzielnie
            ui_start = time.time()

            # Aktualizacja filtrów
            filters_start = time.time()
            try:
                self.update_filters()
                # Dodaj debugowanie dla kluczy processed_data
                debug_print("Klucze processed_data:")
                key_count = 0
                for key in self.processed_data.keys():
                    if key_count < 5:  # Pokaż tylko pierwsze 5 kluczy
                        debug_print(f"  {key}")
                    key_count += 1
                debug_print(f"  ...i {key_count - 5} więcej kluczy") if key_count > 5 else None

                # Sprawdź, czy dane mają pola dla filtrów
                debug_print("Wartości pól dla filtrów:")
                wydzialy = set()
                dtns = set()
                role = set()
                jezyki = set()
                etaty = set()

                for key, data in self.processed_data.items():
                    wydzialy.add(key[0]) if key[0] else None
                    dtns.add(str(data.get('dtn', ''))) if data.get('dtn') else None
                    role.add(data.get('rola_nazwa', '')) if data.get('rola_nazwa') else None
                    jezyki.add(data.get('jezyk', '')) if data.get('jezyk') else None
                    etat_val = data.get('etat')
                    if etat_val is not None:
                        etaty.add(str(etat_val))

                debug_print(f"  Wydziały: {len(wydzialy)} unikalne wartości")
                debug_print(f"  DTN: {len(dtns)} unikalne wartości")
                debug_print(f"  Role: {len(role)} unikalne wartości")
                debug_print(f"  Języki: {len(jezyki)} unikalne wartości")
                debug_print(f"  Etaty: {len(etaty)} unikalne wartości")
                filters_end = self.log_time("Aktualizacja filtrów", filters_start)
            except Exception as e:
                debug_print(f"Błąd podczas aktualizacji filtrów: {str(e)}")
                filters_end = time.time()

            # Aktualizacja tabeli
            table_start = time.time()
            try:
                self.update_filtered_table()
                table_end = self.log_time("Aktualizacja tabeli grafiku", table_start)
            except Exception as e:
                debug_print(f"Błąd podczas aktualizacji tabeli: {str(e)}")
                table_end = time.time()

            # Aktualizacja dat
            dates_start = time.time()
            try:
                self.update_filter_dates()
                dates_end = self.log_time("Aktualizacja dat", dates_start)
            except Exception as e:
                debug_print(f"Błąd podczas aktualizacji dat: {str(e)}")
                dates_end = time.time()

            # Aktualizacja zdarzeń
            selection_start = time.time()
            try:
                # To może być problematyczne - obsługujemy tylko jeśli zainicjalizowano zdarzenia
                if hasattr(self, 'all_events_data') and self.all_events_data:
                    self.on_selection_changed()
                selection_end = self.log_time("Aktualizacja zdarzeń", selection_start)
            except Exception as e:
                debug_print(f"Błąd podczas aktualizacji zaznaczenia: {str(e)}")
                selection_end = time.time()

            self.log_time("Całkowity czas aktualizacji UI", ui_start)

            # Na końcu metody również upewnij się, że nagłówek pionowy jest ukryty
            self.table.verticalHeader().setVisible(True)

        except Exception as e:

            debug_print(f"Błąd podczas przetwarzania danych: {str(e)}")

            QMessageBox.critical(

                self,

                "Błąd",

                f"Wystąpił błąd podczas przetwarzania danych: {str(e)}",

                QMessageBox.StandardButton.Ok

            )


    def get_selected_items(self, list_widget):
        """Zwraca teksty zaznaczonych elementów z listy"""
        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item.isSelected():
                selected.append(item.text())
        return selected

    def update_filters(self):
        """Aktualizacja filtrów na podstawie pobranych danych"""
        try:
            # Zapamiętaj bieżące zaznaczenia (jeśli kontrolki istnieją)
            if not hasattr(self, 'wydzial_combo'):
                print("UWAGA: Brak kontrolki wydzial_combo - inicjalizacja może być niepoprawna!")
                return

            selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
            selected_dtn = self.dtn_combo.get_selected_items() if hasattr(self, 'dtn_combo') else []
            selected_role = self.rola_combo.get_selected_items() if hasattr(self, 'rola_combo') else []
            selected_jezyki = self.jezyk_combo.get_selected_items() if hasattr(self, 'jezyk_combo') else []
            selected_etaty = self.etat_combo.get_selected_items() if hasattr(self, 'etat_combo') else []

            # Sprawdzenie, czy wszystkie wymagane kontrolki istnieją
            required_combos = ['wydzial_combo', 'dtn_combo', 'rola_combo', 'jezyk_combo', 'etat_combo']
            for combo in required_combos:
                if not hasattr(self, combo):
                    print(f"UWAGA: Brak kontrolki {combo}")

            # Zapamiętaj bieżące zaznaczenia dla niezmienionych kontrolek
            selected_przelozeni = self.get_selected_items(self.przelozony_list)
            selected_uzytkownicy = self.get_selected_items(self.uzytkownik_list)

            # Bezpośrednie pobieranie danych - najprostsze rozwiązanie
            if hasattr(self, 'wydzial_combo'):
                wydzialy = set()
                for key in self.processed_data.keys():
                    wydzial = key[0]
                    if wydzial:  # Pomiń puste wartości
                        wydzialy.add(wydzial)
                self.wydzial_combo.add_items(sorted(wydzialy))
                self.wydzial_combo.select_items(selected_wydzialy)
                print(f"Dodano {len(wydzialy)} wydziałów")

            if hasattr(self, 'dtn_combo'):
                dtn_values = set()
                for _, data in self.processed_data.items():
                    dtn = str(data.get('dtn', ''))
                    if dtn:  # Pomiń puste wartości
                        dtn_values.add(dtn)
                self.dtn_combo.add_items(sorted(dtn_values))
                self.dtn_combo.select_items(selected_dtn)
                print(f"Dodano {len(dtn_values)} wartości DTN")

            if hasattr(self, 'rola_combo'):
                role = set()
                for _, data in self.processed_data.items():
                    rola = data.get('rola_nazwa', '')
                    if rola:  # Pomiń puste wartości
                        role.add(rola)
                self.rola_combo.add_items(sorted(role))
                self.rola_combo.select_items(selected_role)
                print(f"Dodano {len(role)} ról")

            if hasattr(self, 'jezyk_combo'):
                jezyki = set()
                for _, data in self.processed_data.items():
                    jezyk = data.get('jezyk', '')
                    if jezyk:  # Pomiń puste wartości
                        jezyki.add(jezyk)
                self.jezyk_combo.add_items(sorted(jezyki))
                self.jezyk_combo.select_items(selected_jezyki)
                print(f"Dodano {len(jezyki)} języków")

            if hasattr(self, 'etat_combo'):
                etaty = set()
                for _, data in self.processed_data.items():
                    etat = str(data.get('etat', '')) if data.get('etat') is not None else ''
                    if etat:  # Pomiń puste wartości
                        etaty.add(etat)
                sorted_etaty = sorted(etaty, key=lambda x: float(x) if x.replace('.', '', 1).isdigit() else 0)
                self.etat_combo.add_items(sorted_etaty)
                self.etat_combo.select_items(selected_etaty)
                print(f"Dodano {len(etaty)} etatów")

            # Aktualizacja przełożonych i użytkowników
            self.update_przelozony_filter(selected_przelozeni)
            self.update_uzytkownik_filter(selected_uzytkownicy)

        except Exception as e:
            import traceback
            print(f"Błąd podczas aktualizacji filtrów: {e}")
            traceback.print_exc()

    def update_combo_data(self, combo_name, value_getter, selected_items, sort_key=None):
        """
        Aktualizuje dane w ComboBox.

        Args:
            combo_name: Nazwa atrybutu ComboBoxa
            value_getter: Funkcja pobierająca wartość z key/data (key, data) -> wartość
            selected_items: Lista zaznaczonych elementów do przywrócenia
            sort_key: Opcjonalna funkcja do sortowania wartości
        """
        if hasattr(self, combo_name):
            combo = getattr(self, combo_name)
            values = set()

            # Zbierz wartości z processed_data
            for key, data in self.processed_data.items():
                value = value_getter(key, data)
                if value:  # Pomiń puste wartości
                    values.add(value)

            # Sortuj wartości
            if sort_key:
                sorted_values = sorted(values, key=sort_key)
            else:
                sorted_values = sorted(values)

            # Zaktualizuj ComboBox
            combo.add_items(sorted_values)
            combo.select_items(selected_items)

    def update_combo_filter(self, combo_name, data_field, selected_items, sort_key=None):
        """Aktualizuje filtr ComboBox na podstawie danych"""
        if hasattr(self, combo_name):
            combo = getattr(self, combo_name)
            combo.clear()
            values = set()

            # Zbierz unikalne wartości z danych
            for _, data in self.processed_data.items():
                value = data.get(data_field, '')
                if data_field == 'etat' and value is not None:
                    value = str(value)
                if value:
                    values.add(value)

            # Sortuj wartości
            if sort_key:
                sorted_values = sorted(values, key=sort_key)
            else:
                sorted_values = sorted(values)

            # Dodaj do combo-boxa
            combo.add_items(sorted_values)
            combo.select_items(selected_items)

    def update_rola_filter(self, selected_role=None):
        """Aktualizuje listę ról na podstawie danych"""
        if selected_role is None:
            selected_role = []

        if hasattr(self, 'rola_list'):
            self.rola_list.clear()
            role = set()

            # Zbierz wszystkie unikalne role
            for key, data in self.processed_data.items():
                rola = data.get('rola_nazwa')
                if rola:
                    role.add(rola)

            # Dodaj do listy
            for rola in sorted(role):
                item = QListWidgetItem(rola)
                self.rola_list.addItem(item)
                if rola in selected_role:
                    item.setSelected(True)

    def update_etat_filter(self, selected_etaty=None):
        """Aktualizuje listę etatów na podstawie danych"""
        if selected_etaty is None:
            selected_etaty = []

        if hasattr(self, 'etat_list'):
            self.etat_list.clear()
            etaty = set()

            # Zbierz wszystkie unikalne etaty
            for key, data in self.processed_data.items():
                etat = data.get('etat')
                if etat is not None:
                    etaty.add(str(etat))

            # Dodaj do listy
            for etat in sorted(etaty, key=lambda x: float(x) if x.replace('.', '', 1).isdigit() else 0):
                item = QListWidgetItem(etat)
                self.etat_list.addItem(item)
                if etat in selected_etaty:
                    item.setSelected(True)

    def update_przelozony_filter(self, selected_przelozeni=None):
        # Aktualizacja listy przełożonych na podstawie wybranych wydziałów
        if selected_przelozeni is None:
            selected_przelozeni = []

        self.przelozony_list.clear()

        # Pobierz wybrane wydziały z comboboxa zamiast starej listy
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []

        przelozeni = set()
        for key in self.processed_data.keys():
            wydzial, przelozony, _, _ = key
            if not selected_wydzialy or wydzial in selected_wydzialy:
                przelozeni.add(przelozony)

        for przelozony in sorted(przelozeni):
            item = QListWidgetItem(przelozony)
            self.przelozony_list.addItem(item)
            # Przywróć zaznaczenie jeśli było
            if przelozony in selected_przelozeni:
                item.setSelected(True)

    def update_uzytkownik_filter(self, selected_uzytkownicy=None):
        # Aktualizacja listy użytkowników na podstawie wybranych wydziałów i przełożonych
        if selected_uzytkownicy is None:
            selected_uzytkownicy = []

        self.uzytkownik_list.clear()

        # Pobierz wybrane wydziały z comboboxa zamiast starej listy
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_selected_items(self.przelozony_list)

        uzytkownicy_data = []
        for key in self.processed_data.keys():
            wydzial, przelozony, uzytkownik_dane, uzytkownik = key
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni):
                uzytkownicy_data.append(uzytkownik_dane)

        for uzytkownik in sorted(uzytkownicy_data):
            item = QListWidgetItem(str(uzytkownik))
            self.uzytkownik_list.addItem(item)
            # Przywróć zaznaczenie jeśli było
            if str(uzytkownik) in selected_uzytkownicy:
                item.setSelected(True)

    def process_data(self, data):
        # Przetwarzamy dane do struktury:
        self.processed_data = {}

        for row in data:
            try:
                # Obsługa pełnego zestawu kolumn z funkcji tabelarycznej
                wydzial, przelozony, uzytkownik_dane, uzytkownik, data_str, symbol, godziny_pracy, id_wpisu, \
                    spotkania, szkolenia, nadgodziny, start_hour, nr_kadrowy, rola_nazwa, pod_rola_nazwa, \
                    etat, jezyk, korekta, przelozony_imie_nazwisko, dtn = row

                # Klucz dla grupy (wydział, przełożony, użytkownik)
                key = (wydzial, przelozony, uzytkownik_dane, uzytkownik)

                # Jeśli nie ma jeszcze wpisu dla tego klucza, utwórz go
                if key not in self.processed_data:
                    self.processed_data[key] = {
                        'days': {},
                        'total_hours': 0,
                        'rola_nazwa': rola_nazwa,
                        'pod_rola_nazwa': pod_rola_nazwa,
                        'etat': etat,
                        'jezyk': jezyk,
                        'dtn': dtn
                    }

                # Jeśli data_str nie jest None, dodaj symbol i godziny dla odpowiedniego dnia
                if data_str:
                    day = int(data_str.split('-')[2])  # Pobierz dzień z daty w formacie 'YYYY-MM-DD'
                    self.processed_data[key]['days'][day] = {
                        'symbol': symbol,
                        'hours': godziny_pracy if godziny_pracy is not None else 0,
                        'id': id_wpisu,
                        'spotkania': spotkania if spotkania is not None else 0,
                        'szkolenia': szkolenia if szkolenia is not None else 0,
                        'nadgodziny': nadgodziny if nadgodziny is not None else 0,
                        'start_hour': start_hour,  # Dodaj godzinę rozpoczęcia
                        'nr_kadrowy': nr_kadrowy  # Dodaj numer kadrowy
                    }

                    # Sumuj godziny pracy
                    if godziny_pracy is not None:
                        self.processed_data[key]['total_hours'] += godziny_pracy
            except Exception as e:
                debug_print(f"Błąd podczas przetwarzania wiersza danych: {e}, liczba kolumn: {len(row)}")
                debug_print(f"Dane wiersza: {row}")
                continue  # Kontynuuj z następnym wierszem w przypadku błędu

    def update_table_content(self):
        """
        Aktualizuje zawartość tabeli na podstawie przetworzonych danych.
        Zoptymalizowana wersja wykorzystująca ujednolicony system przechowywania danych.
        """
        start_time = time.time()

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month_idx = current_data

        # Określ liczbę dni w miesiącu
        if month_idx in [4, 6, 9, 11]:
            days_in_month = 30
        elif month_idx == 2:  # Luty
            if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):  # Rok przestępny
                days_in_month = 29
            else:
                days_in_month = 28
        else:
            days_in_month = 31

        # Konfiguracja tabeli
        self.table.clear()

        # Ustawienie liczby kolumn (Wydział, Przełożony, Pracownik, dni miesiąca, Suma RBH)
        self.table.setColumnCount(3 + days_in_month + 1)

        # Ustawienie nagłówków kolumn
        headers = ["Wydział", "Przełożony", "Pracownik"]
        for day in range(1, days_in_month + 1):
            # Ustal dzień tygodnia
            date = QDate(year, month_idx, day)
            day_of_week = date.dayOfWeek()  # 1=Pon, 2=Wt, ..., 7=Nie

            # Ustal etykietę dnia tygodnia
            day_labels = ["Pon", "Wt", "Śr", "Czw", "Pt", "Sob", "Nie"]
            day_label = day_labels[day_of_week - 1]

            headers.append(f"{day}\n{day_label}")

        # Dodaj nagłówek suma RBH
        headers.append("Suma RBH")

        self.table.setHorizontalHeaderLabels(headers)

        # Znajdź kolumny z weekendami i ustaw je w niestandardowym nagłówku
        weekend_columns = []
        for col in range(3, 3 + days_in_month):
            day = col - 2
            date = QDate(year, month_idx, day)
            day_of_week = date.dayOfWeek()

            # Jeśli to weekend (sobota=6, niedziela=7)
            if day_of_week >= 6:
                weekend_columns.append(col)

        # Ustaw kolumny weekendowe w niestandardowym nagłówku
        header = self.table.horizontalHeader()
        if isinstance(header, WeekendAwareHeaderView):
            header.set_weekend_columns(weekend_columns, self.is_dark_theme)
            # Ważne - wymuś odświeżenie nagłówka
            header.viewport().update()

        # Ustaw szerokość kolumn
        self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Wydział
        self.table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Przełożony
        self.table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)  # Pracownik

        # Dla dni miesiąca - stała szerokość
        for i in range(3, 3 + days_in_month):
            self.table.horizontalHeader().setSectionResizeMode(i, QHeaderView.Interactive)
            self.table.setColumnWidth(i, 70)  # Szerokość kolumn z dniami

        # Kolumna z sumą RBH
        suma_rbh_col = 3 + days_in_month
        self.table.horizontalHeader().setSectionResizeMode(suma_rbh_col, QHeaderView.ResizeToContents)

        # Aplikuj filtry do danych przed wypełnieniem tabeli
        filtered_data = self.filter_processed_data()

        # ZOPTYMALIZOWANE WYPEŁNIANIE TABELI
        self.table.setRowCount(len(filtered_data))

        # Blokuj sygnały podczas wypełniania tabeli
        self.table.blockSignals(True)
        self.table.setUpdatesEnabled(False)

        # Dodaj delegata do tabeli aby obsługiwał niestandardowe rysowanie
        self.table.setItemDelegate(OvertimeItemDelegate())

        for row_idx, (key, data) in enumerate(filtered_data.items()):
            wydzial, przelozony, uzytkownik_dane, uzytkownik = key
            day_data = data['days']
            total_hours = data['total_hours']

            # Podstawowe informacje
            wydzial_item = QTableWidgetItem(wydzial)
            przelozony_item = QTableWidgetItem(przelozony)
            uzytkownik_item = QTableWidgetItem(uzytkownik_dane)

            # Zapisz dane klucza w komórkach
            key_data = {
                'wydzial': wydzial,
                'przelozony': przelozony,
                'uzytkownik_dane': uzytkownik_dane,
                'uzytkownik_id': uzytkownik
            }
            self.set_cell_data(wydzial_item, key_data)
            self.set_cell_data(przelozony_item, key_data)
            self.set_cell_data(uzytkownik_item, key_data)

            self.table.setItem(row_idx, 0, wydzial_item)
            self.table.setItem(row_idx, 1, przelozony_item)
            self.table.setItem(row_idx, 2, uzytkownik_item)

            # Symbole grafiku dla poszczególnych dni
            for day in range(1, days_in_month + 1):
                if day in day_data:
                    # Komórka z danymi grafiku
                    try:
                        symbol = day_data[day]['symbol']
                        start_hour = day_data[day].get('start_hour')  # Pobierz godzinę rozpoczęcia

                        # Sprawdź różne typy zdarzeń
                        has_meeting = day_data[day].get('spotkania', 0)
                        has_training = day_data[day].get('szkolenia', 0)
                        has_overtime = day_data[day].get('nadgodziny', 0)

                        # Utwórz nowy element tabeli
                        item = QTableWidgetItem(symbol)

                        # Ustaw kolor tła na podstawie godziny rozpoczęcia
                        if start_hour is not None:
                            background_color = self.get_cell_color_by_time(start_hour)
                            item.setBackground(background_color)

                            # Określ jasność tła i dostosuj kolor tekstu
                            brightness = (
                                                     background_color.red() * 299 + background_color.green() * 587 + background_color.blue() * 114) / 1000
                            if brightness > 128:
                                item.setForeground(QColor(0, 0, 0))  # Czarny tekst dla jasnego tła
                            else:
                                item.setForeground(QColor(255, 255, 255))  # Biały tekst dla ciemnego tła

                        # Kolorowanie specjalnych symboli
                        if symbol and "OS" in symbol:
                            item.setBackground(QColor(255, 180, 0))  # Pomarańczowy dla OS
                            item.setForeground(QColor(0, 0, 0))  # Czarny tekst dla jasnego tła
                        elif symbol and "U" in symbol:
                            item.setBackground(QColor(255, 180, 0))  # Pomarańczowy dla U
                            item.setForeground(QColor(0, 0, 0))  # Czarny tekst dla jasnego tła

                        # Zapisz wszystkie dane komórki - zoptymalizowana wersja
                        cell_data = {
                            'wydzial': wydzial,
                            'przelozony': przelozony,
                            'uzytkownik_dane': uzytkownik_dane,
                            'uzytkownik_id': uzytkownik,
                            'day': day,
                            'date_str': f"{year}-{month_idx:02d}-{day:02d}",
                            'symbol': symbol,
                            'hours': day_data[day].get('hours'),
                            'id': day_data[day].get('id'),
                            'nr_kadrowy': day_data[day].get('nr_kadrowy'),
                            'start_hour': start_hour,
                            # Dodaj flagi dla ikon
                            'has_meeting': bool(has_meeting),
                            'has_training': bool(has_training),
                            'has_overtime': bool(has_overtime)
                        }

                        # Użyj ujednoliconej metody set_cell_data
                        self.set_cell_data(item, cell_data)

                    except Exception as e:
                        print(f"Błąd podczas tworzenia komórki: {e}")
                        # W przypadku błędu, użyj standardowej komórki
                        item = QTableWidgetItem(day_data[day].get('symbol', ''))

                        # Dodaj minimalne dane do komórki
                        basic_data = {
                            'uzytkownik_id': uzytkownik,
                            'day': day,
                            'date_str': f"{year}-{month_idx:02d}-{day:02d}"
                        }
                        self.set_cell_data(item, basic_data)

                    # Dodaj element do tabeli
                    self.table.setItem(row_idx, 2 + day, item)
                else:
                    # Pusta komórka bez danych w grafiku
                    item = QTableWidgetItem("")

                    # Dodaj podstawowe dane do pustej komórki (użytkownik, dzień, data)
                    basic_data = {
                        'wydzial': wydzial,
                        'przelozony': przelozony,
                        'uzytkownik_dane': uzytkownik_dane,
                        'uzytkownik_id': uzytkownik,
                        'day': day,
                        'date_str': f"{year}-{month_idx:02d}-{day:02d}",
                        'has_meeting': False,
                        'has_training': False,
                        'has_overtime': False
                    }
                    self.set_cell_data(item, basic_data)

                    # Sprawdzamy czy mamy zbuforowane dane o zdarzeniach
                    if hasattr(self, 'events_index'):
                        try:
                            # Tworzymy nową datę dla tego dnia w formacie string
                            date_str = f"{year}-{month_idx:02d}-{day:02d}"  # Format YYYY-MM-DD

                            # Przygotuj identyfikator użytkownika jako string dla porównania
                            user_id_str = str(uzytkownik)

                            # Użyj indeksu zdarzeń do sprawdzenia, czy istnieją zdarzenia dla tej pary (użytkownik, data)
                            events_for_cell = self.data_provider.get_events_for_user_date(user_id_str, date_str)

                            # Flagi na zdarzenia
                            has_meeting = False
                            has_training = False
                            has_overtime = False

                            # Sprawdź typy zdarzeń
                            for event in events_for_cell:
                                event_type = event.get('type', '')
                                if event_type == 'Spotkanie':
                                    has_meeting = True
                                elif event_type == 'Szkolenie':
                                    has_training = True
                                elif event_type == 'Nadgodziny':
                                    has_overtime = True

                                # Optymalizacja - jeśli mamy już wszystkie typy zdarzeń, przerywamy pętlę
                                if has_meeting and has_training and has_overtime:
                                    break

                            # Zaktualizuj dane komórki
                            cell_data = self.get_cell_data(item)
                            cell_data.update({
                                'has_meeting': has_meeting,
                                'has_training': has_training,
                                'has_overtime': has_overtime
                            })
                            self.set_cell_data(item, cell_data)

                        except Exception as e:
                            print(
                                f"Błąd podczas sprawdzania zdarzeń dla pustej komórki ({day}.{month_idx}.{year}, {uzytkownik}): {e}")

                    # Dodaj pustą komórkę do tabeli
                    self.table.setItem(row_idx, 2 + day, item)

            # Suma RBH
            rbh_item = QTableWidgetItem(str(total_hours))

            # Zapisz dane klucza także w komórce sumy RBH
            key_data = {
                'wydzial': wydzial,
                'przelozony': przelozony,
                'uzytkownik_dane': uzytkownik_dane,
                'uzytkownik_id': uzytkownik
            }
            self.set_cell_data(rbh_item, key_data)

            self.table.setItem(row_idx, suma_rbh_col, rbh_item)

        # Przywróć sygnały i aktualizacje UI
        self.table.setUpdatesEnabled(True)
        self.table.blockSignals(False)

        # Dopasuj wysokość wierszy
        self.table.resizeRowsToContents()

        self.log_time("Aktualizacja zawartości tabeli grafiku", start_time)

        # Numer wiersza
        self.table.verticalHeader().setVisible(True)

    def filter_processed_data(self):
        """
        Filtruje dane z self.processed_data na podstawie zaznaczonych filtrów
        i zwraca nowy słownik z przefiltrowanymi danymi.
        """
        # Pobierz zaznaczone filtry z różnych kontrolek
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_selected_items(self.uzytkownik_list)
        selected_dtn = self.dtn_combo.get_selected_items() if hasattr(self, 'dtn_combo') else []
        selected_role = self.rola_combo.get_selected_items() if hasattr(self, 'rola_combo') else []
        selected_jezyki = self.jezyk_combo.get_selected_items() if hasattr(self, 'jezyk_combo') else []
        selected_etaty = self.etat_combo.get_selected_items() if hasattr(self, 'etat_combo') else []

        # Jeśli nie ma filtrów, zwróć wszystkie dane
        if not (selected_wydzialy or selected_przelozeni or selected_uzytkownicy or
                selected_dtn or selected_role or selected_jezyki or selected_etaty):
            return self.processed_data

        # Przygotuj przefiltrowane dane
        filtered_data = {}

        # Przeiteruj przez wszystkie klucze i dane
        for key, data in self.processed_data.items():
            wydzial, przelozony, uzytkownik_dane, uzytkownik = key

            # Pobierz dane dla nowych filtrów
            dtn = str(data.get('dtn', ''))
            rola_nazwa = data.get('rola_nazwa', '')
            jezyk = data.get('jezyk', '')
            etat = str(data.get('etat', '')) if data.get('etat') is not None else ''

            # Sprawdź czy dane pasują do filtrów
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni) and \
                    (not selected_uzytkownicy or str(uzytkownik_dane) in selected_uzytkownicy) and \
                    (not selected_dtn or dtn in selected_dtn) and \
                    (not selected_role or rola_nazwa in selected_role) and \
                    (not selected_jezyki or jezyk in selected_jezyki) and \
                    (not selected_etaty or etat in selected_etaty):
                filtered_data[key] = data

        return filtered_data

    def debug_selected_cell(self):
        """Wyświetla szczegółowe informacje o aktualnie zaznaczonej komórce"""
        selected_items = self.table.selectedItems()

        if not selected_items:
            debug_print("Brak zaznaczonych komórek")
            return

        for item in selected_items:
            row = item.row()
            col = item.column()

            debug_print(f"\n=== DIAGNOSTYKA KOMÓRKI [{row}, {col}] ===")
            debug_print(f"Tekst: {item.text()}")

            # Pobierz dane z UserRole
            cell_data = item.data(Qt.UserRole)
            if cell_data:
                if isinstance(cell_data, dict):
                    debug_print("Dane komórki (słownik):")
                    for key, value in cell_data.items():
                        debug_print(f"  {key}: {value}")

                    # Ważna zmiana: pobierz user_id i date_str bezpośrednio z danych komórki
                    user_id = cell_data.get('user_id')
                    date_str = cell_data.get('date_str')
                else:
                    debug_print(f"Dane UserRole: {cell_data}")
                    user_id = None
                    date_str = None
            else:
                user_id = None
                date_str = None

            # Pobierz dane flagi dla spotkań/szkoleń
            has_meetings = item.data(Qt.UserRole + 1)
            debug_print(f"Flaga spotkań/szkoleń (UserRole+1): {has_meetings}")

            # Sprawdź, czy komórka ma ikony
            flags = item.flags()
            debug_print(f"Flagi komórki: {flags}")

            # Pobierz kolor tła
            bg_color = item.background().color()
            debug_print(f"Kolor tła: R={bg_color.red()}, G={bg_color.green()}, B={bg_color.blue()}")

            # Jeśli to komórka z dniem (kolumny od 3)
            if col >= 3:
                # Spróbuj pobrać informacje o użytkowniku z tego wiersza
                user_item = self.table.item(row, 2)  # Kolumna "Pracownik"
                if user_item:
                    debug_print(f"Użytkownik: {user_item.text()}")

                # Pobierz aktualny rok i miesiąc
                current_data = self.date_combo.currentData()
                if current_data and not date_str:
                    year, month = current_data
                    day = col - 2
                    date_str = f"{year}-{month:02d}-{day:02d}"

                if date_str:
                    debug_print(f"Data: {date_str}")

                # Jeśli mamy ID użytkownika i datę, pobierz zdarzenia
                if user_id and date_str:
                    debug_print(f"ID użytkownika: {user_id}")

                    # Pobierz zdarzenia dla użytkownika i daty
                    events = self.data_provider.get_events_for_user_date(user_id, date_str)
                    if events:
                        debug_print(f"Znaleziono {len(events)} zdarzeń:")
                        for i, event in enumerate(events):
                            debug_print(f"  Zdarzenie {i + 1}:")
                            debug_print(f"    ID: {event.get('id')}")
                            debug_print(f"    Typ: {event.get('type')}")
                            debug_print(f"    Temat: {event.get('topic')}")
                            debug_print(f"    Czas: {event.get('time_from')} - {event.get('time_to')}")
                    else:
                        debug_print("Brak zdarzeń dla tej komórki")

            debug_print("=== KONIEC DIAGNOSTYKI ===\n")

    def get_cell_color_by_time(self, hour):
        """
        Zwraca kolor tła komórki na podstawie godziny rozpoczęcia.
        Godziny są mapowane na kolory w bardziej czytelnej palecie.

        Args:
            hour (int): Godzina rozpoczęcia zmiany (0-23)

        Returns:
            QColor: Kolor tła komórki
        """
        # Domyślny kolor (przezroczysty) gdy godzina nie jest zdefiniowana
        if hour is None or hour < 0 or hour > 23:
            return QColor(255, 255, 255, 0)  # Przezroczysty

        # Mapowanie godzin na kolory - zharmonizowana paleta
        if hour == 5:
            return QColor(204, 255, 255)  # Jasny błękit (bardzo jasny cyjan)
        elif hour == 6:
            return QColor(204, 255, 255)  # Jasny błękit (bardzo jasny cyjan)
        elif hour == 7:
            return QColor(0, 255, 255)  # Cyjan (akwamaryna)
        elif hour == 8:
            return QColor(0, 204, 255)  # Jasny błękit (niebieskozielony)
        elif hour == 9:
            return QColor(0, 255, 0)  # Limonkowy (czysty zielony)
        elif hour == 10:
            return QColor(153, 204, 0)  # Oliwkowy (żółtozielony)
        elif hour == 11:
            return QColor(204, 255, 204)  # Bardzo jasny zielony (miętowy)
        elif hour == 12:
            return QColor(255, 255, 153)  # Bardzo jasny żółty (kremowy)
        elif hour == 13:
            return QColor(255, 204, 153)  # Jasny łososiowy (brzoskwiniowy)
        elif hour == 14:
            return QColor(255, 153, 0)  # Ciemny pomarańczowy
        elif hour == 15:
            return QColor(255, 0, 255)  # Magenta (fuksja)
        elif hour == 16:
            return QColor(204, 0, 0)  # Ciemnoczerwony
        elif hour == 17:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 18:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 19:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 20:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 21:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 22:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 23:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 0:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour in [1, 2, 3, 4]:
            return QColor(51, 51, 51)  # Ciemny szary

        # Domyślny kolor dla innych wartości
        return QColor(255, 255, 255, 0)  # Przezroczysty



    def update_cell_icons(self, user_id, date_str, event_type=None, action="update"):
        """
        Uniwersalna metoda do aktualizacji ikon w komórkach.

        Args:
            user_id: ID użytkownika
            date_str: Data w formacie 'YYYY-MM-DD'
            event_type: Typ zdarzenia (opcjonalnie)
            action: Akcja do wykonania ('update', 'add', 'delete')
        """
        try:
            # Pobierz rok, miesiąc i dzień z date_str
            if not date_str or date_str.count('-') != 2:
                print(f"Nieprawidłowy format daty: {date_str}")
                return

            year, month, day = date_str.split('-')
            day = int(day)
            col = day + 2  # Kolumna odpowiadająca dniowi

            # Pobierz wszystkie zdarzenia dla tej pary (użytkownik, data)
            events = self.data_provider.get_events_for_user_date(user_id, date_str)

            # Sprawdź typy zdarzeń
            has_meeting = any(
                e.get('type') == 'Spotkanie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
            has_training = any(
                e.get('type') == 'Szkolenie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
            has_overtime = any(e.get('type') == 'Nadgodziny' for e in events)

            # Szukaj odpowiedniej komórki w tabeli
            found = False

            for row in range(self.table.rowCount()):
                # Pobierz dane komórki
                cell_data = self.get_cell_data(row, col)

                # Sprawdź, czy komórka odpowiada szukanemu użytkownikowi
                if cell_data and str(cell_data.get('user_id')) == str(user_id):
                    # Znaleziono właściwą komórkę
                    item = self.table.item(row, col)
                    if item:
                        # Aktualizuj dane komórki
                        new_data = cell_data.copy()
                        new_data.update({
                            'has_meeting': has_meeting,
                            'has_training': has_training,
                            'has_overtime': has_overtime
                        })

                        # Zapisz zaktualizowane dane
                        item.setData(Qt.UserRole, new_data)

                        # Aktualizuj flagi ikon
                        item.setData(Qt.UserRole + 2, has_overtime)
                        item.setData(Qt.UserRole + 3, has_meeting or has_training)

                        # Wymuś odświeżenie komórki
                        self.table.update(self.table.model().index(row, col))
                        found = True
                        break

            if not found:
                print(f"Nie znaleziono komórki dla użytkownika {user_id} i dnia {day}")

            # Wymuś odświeżenie tabeli
            self.table.viewport().update()

        except Exception as e:
            print(f"Błąd podczas aktualizacji ikon: {e}")
            import traceback
            traceback.print_exc()

    def clear_events_table(self):
        """
        Czyści tabelę zdarzeń w bezpieczny sposób.
        """
        # Zabezpiecz przed sygnałami podczas czyszczenia
        self.events_table.blockSignals(True)
        self.events_table.setUpdatesEnabled(False)

        # Usuń wszystkie wiersze
        self.events_table.setRowCount(0)

        # Wyczyść dane zdarzeń
        self.events_data = []

        # Przywróć sygnały
        self.events_table.setUpdatesEnabled(True)
        self.events_table.blockSignals(False)

        # Wymuś odświeżenie
        self.events_table.update()

    def on_selection_changed(self):
        """
        Obsługuje zmianę zaznaczenia w tabeli grafiku.
        Zoptymalizowana wersja bez automatycznego ładowania wszystkich zdarzeń.
        """
        start_time = time.time()
        selected_ranges = self.table.selectedRanges()

        # Jeśli nie ma zaznaczenia, wyczyść tabelę zdarzeń
        if not selected_ranges:
            print("Brak zaznaczenia - czyszczę tabelę zdarzeń")
            self.events_data = []
            self.events_table.setRowCount(0)
            return

        # Przygotujemy zbiór unikalnych par (użytkownik, data) aby uniknąć duplikatów
        user_date_pairs = set()

        for range_item in selected_ranges:
            for row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawdź czy to kolumna z dniem miesiąca
                    if col < 3:
                        continue

                    # Pobierz element tabeli
                    cell_item = self.table.item(row, col)
                    if not cell_item:
                        continue

                    # Pobierz dane z komórki używając naszej standardowej metody
                    cell_data = self.get_cell_data(cell_item)
                    if not cell_data:
                        continue

                    # Dodaj parę (użytkownik, data) do zbioru - eliminuje duplikaty
                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')
                    if user_id and date_str:
                        user_date_pairs.add((user_id, date_str))

        # Szybkie sprawdzenie czy jest co ładować
        if not user_date_pairs:
            print("Brak danych do załadowania - czyszczę tabelę zdarzeń")
            self.events_data = []
            self.events_table.setRowCount(0)
            return

        # Czyść poprzednie dane i pokaż komunikat "Ładowanie..."
        self.events_data = []
        self.events_table.setRowCount(1)
        loading_item = QTableWidgetItem("Ładowanie zdarzeń dla zaznaczonych komórek...")
        loading_item.setTextAlignment(Qt.AlignCenter)
        # Ustawienie tekstu we wszystkich kolumnach (w PySide6 nie ma setColumnSpan)
        for col in range(self.events_table.columnCount()):
            self.events_table.setItem(0, col, QTableWidgetItem(""))
        self.events_table.setItem(0, 0, loading_item)
        QApplication.processEvents()  # Pozwól UI się odświeżyć

        # Pobierz zdarzenia dla wszystkich par (użytkownik, data) jednocześnie
        all_events = self.data_provider.get_events_for_user_date_pairs(
            list(user_date_pairs),
            allowed_types=None,  # Wszystkie typy, filtrowanie będzie wykonane później
            as_dict=True  # Pobierz dane jako słowniki
        )

        # Aktualizuj dane zdarzeń - filtruj tylko aktywne zdarzenia
        self.events_data = [event for event in all_events if str(event.get('status', '0')) != '0']

        print(f"Łącznie znaleziono {len(self.events_data)} aktywnych zdarzeń dla {len(user_date_pairs)} komórek")

        # Aktualizuj tabelę zdarzeń
        self.filter_events_table()

        self.log_time(f"Ładowanie zdarzeń dla {len(user_date_pairs)} komórek", start_time)

    def load_all_events_for_month(self, year, month):
        """Ładuje wszystkie zdarzenia dla wybranego miesiąca w zoptymalizowany sposób"""
        start_time = time.time()

        # Pobierz wybrane filtry
        selected_wydzialy = self.get_selected_items(self.wydzial_list)
        selected_przelozeni = self.get_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_selected_items(self.uzytkownik_list)

        debug_print(
            f"Ładowanie wszystkich zdarzeń dla {month}/{year} z filtrami: Wydziały({len(selected_wydzialy)}), Przełożeni({len(selected_przelozeni)}), Użytkownicy({len(selected_uzytkownicy)})")

        # Zablokuj sygnały tabeli podczas ładowania
        self.events_table.blockSignals(True)
        self.events_table.setUpdatesEnabled(False)

        try:
            # Użyj DataProvider aby pobrać zdarzenia w sposób zoptymalizowany
            events = self.data_provider.get_events_data(year, month, as_dict=True)

            # Zastosuj filtry wydziałów, przełożonych, użytkowników
            if selected_wydzialy or selected_przelozeni or selected_uzytkownicy:
                filtered_events = []
                for event in events:
                    event_user_id = event.get('user_id')
                    user_info = self.user_info_map.get(event_user_id, {})

                    # Sprawdź filtry
                    if selected_wydzialy and user_info.get('wydzial') not in selected_wydzialy:
                        continue
                    if selected_przelozeni and user_info.get('przelozony') not in selected_przelozeni:
                        continue
                    if selected_uzytkownicy and str(user_info.get('uzytkownik_dane')) not in selected_uzytkownicy:
                        continue

                    # Upewnij się, że event zawiera dane użytkownika
                    if not event.get('user_name'):
                        event['user_name'] = user_info.get('uzytkownik_dane', str(event_user_id))

                    filtered_events.append(event)

                events = filtered_events

            # Aktualizuj dane zdarzeń
            self.events_data = events

            debug_print(f"Znaleziono {len(self.events_data)} zdarzeń dla miesiąca {month}/{year} z zastosowaniem filtrów")

            # Aktualizuj tabelę zdarzeń używając zoptymalizowanej metody
            self.filter_events_table()

        except Exception as e:
            debug_print(f"Błąd podczas ładowania wszystkich zdarzeń: {e}")
            import traceback
            traceback.print_exc()

            # Wyczyść tabelę w przypadku błędu
            self.events_data = []
            self.events_table.setRowCount(0)

        finally:
            # Przywróć normalne działanie tabeli
            self.events_table.setUpdatesEnabled(True)
            self.events_table.blockSignals(False)

        self.log_time(f"Ładowanie wszystkich zdarzeń dla miesiąca {month}/{year}", start_time)

    def load_events_for_selection(self, selected_cells):
        """Ładuje zdarzenia dla wybranych komórek w grafiku"""
        start_time = time.time()

        # Jeśli nie ma zaznaczonych komórek, wyczyść tabelę zdarzeń
        if not selected_cells:
            print("Brak zaznaczonych komórek - czyszczę tabelę zdarzeń")
            self.events_data = []
            self.events_table.setRowCount(0)
            return

        # Czyść poprzednie dane
        self.events_data = []

        # Przygotuj zbiór unikalnych par (użytkownik, data)
        user_date_pairs = set()
        for cell in selected_cells:
            user_id = cell.get('uzytkownik_id')
            date_str = cell.get('date_str')
            if user_id and date_str:
                user_date_pairs.add((user_id, date_str))

        print(f"Szukam zdarzeń dla {len(user_date_pairs)} par (użytkownik, data)")

        # Pobierz zdarzenia dla wszystkich par jednocześnie
        all_events = self.data_provider.get_events_for_user_date_pairs(
            list(user_date_pairs),
            allowed_types=None,  # Wszystkie typy, filtrowanie będzie wykonane później
            as_dict=True  # Pobierz dane jako słowniki
        )

        # Aktualizuj dane zdarzeń
        self.events_data = all_events

        print(f"Łącznie znaleziono {len(self.events_data)} zdarzeń dla {len(user_date_pairs)} par")

        # Aktualizuj tabelę zdarzeń
        self.filter_events_table()

        self.log_time(f"Ładowanie zdarzeń dla {len(selected_cells)} komórek", start_time)

    def filter_events_table(self):
        """
        Filtruje tabelę zdarzeń na podstawie zaznaczonych filtrów i zakresów dat.
        Zoptymalizowana wersja korzystająca z list comprehension dla wydajności.
        """
        try:
            start_time = time.time()

            # Wyświetl informacje o aktualnych danych zdarzeń
            debug_print(
                f"filter_events_table: liczba wszystkich zdarzeń: {len(self.events_data) if hasattr(self, 'events_data') and isinstance(self.events_data, list) else 'brak'}")

            # Szybkie sprawdzenie czy jest co filtrować
            if not hasattr(self, 'events_data') or not isinstance(self.events_data, list) or not self.events_data:
                debug_print("Brak danych zdarzeń do filtrowania")
                self.events_table.setRowCount(0)  # Wyczyść tabelę
                return

            # Pobierz zaznaczone typy zdarzeń
            allowed_types = []
            if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
                allowed_types.append('Spotkanie')
            if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
                allowed_types.append('Szkolenie')
            if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
                allowed_types.append('Nadgodziny')

            debug_print(f"Dozwolone typy zdarzeń: {allowed_types}")

            # Pobierz daty z kontrolek i przekształć na format YYYY-MM-DD
            date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
            date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

            # Przygotuj parametry filtrowania
            filter_params = {}

            # Dodaj filtr typów zdarzeń
            if allowed_types:
                filter_params['allowed_types'] = allowed_types

            # Dodaj filtry tematu i nazwy
            topic_filter = self.topic_filter.text().lower() if hasattr(self,
                                                                       'topic_filter') and self.topic_filter.text() else None
            name_filter = self.name_filter.text().lower() if hasattr(self,
                                                                     'name_filter') and self.name_filter.text() else None

            if topic_filter:
                filter_params['topic'] = topic_filter
            if name_filter:
                filter_params['name'] = name_filter

            # Dodaj filtry zakresu dat
            if date_from_str:
                filter_params['date_from'] = date_from_str
            if date_to_str:
                filter_params['date_to'] = date_to_str

            debug_print(f"Parametry filtrowania: {filter_params}")

            # Kopia wydarzeń do filtrowania, aby nie modyfikować oryginału
            events_to_filter = self.events_data.copy()

            # OPTYMALIZACJA: Użyj list comprehension dla wszystkich filtrów w jednym przebiegu
            filtered_data = events_to_filter

            # Filtrowanie tylko wtedy, gdy są parametry
            if filter_params:
                # Filtrowanie w jednym kroku przy użyciu oddzielnych warunków
                filtered_data = [
                    event for event in events_to_filter
                    if (
                        # Filtr typu wydarzenia
                            ('allowed_types' not in filter_params or event.get('type', '') in filter_params[
                                'allowed_types']) and

                            # Filtr tematu
                            ('topic' not in filter_params or filter_params['topic'] in str(
                                event.get('topic', '')).lower()) and

                            # Filtr nazwy
                            ('name' not in filter_params or filter_params['name'] in str(
                                event.get('name', '')).lower()) and

                            # Filtr daty od
                            ('date_from' not in filter_params or self.standardize_date(event.get('date_key', '')) >=
                             filter_params['date_from']) and

                            # Filtr daty do
                            ('date_to' not in filter_params or self.standardize_date(event.get('date_key', '')) <=
                             filter_params['date_to'])
                    )
                ]

            debug_print(f"Po filtrowaniu pozostało {len(filtered_data)} zdarzeń")
            filtering_time = self.log_time("Filtrowanie zdarzeń", start_time)

            # Zaktualizuj tabelę zdarzeń z przefiltrowanymi danymi
            self.update_events_table(filtered_data)

        except Exception as e:
            debug_print(f"Błąd podczas filtrowania zdarzeń: {str(e)}")
            import traceback
            traceback.print_exc()
            # Wyczyść tabelę w przypadku błędu
            self.events_table.setRowCount(0)

    def standardize_date(self, date_obj):
        """
        Standaryzuje format daty do 'YYYY-MM-DD' dla porównań
        """
        if not date_obj:
            return ''

        # Jeśli to już string, wyciągnij tylko datę
        if isinstance(date_obj, str):
            # Obsługa różnych formatów
            if 'T' in date_obj:  # Format ISO 'YYYY-MM-DDThh:mm:ss'
                return date_obj.split('T')[0]
            elif ' ' in date_obj:  # Format 'YYYY-MM-DD hh:mm:ss'
                return date_obj.split(' ')[0]
            elif len(date_obj) == 10 and date_obj.count('-') == 2:  # Format 'YYYY-MM-DD'
                return date_obj
            # Jeśli nie dopasowano do żadnego formatu, zwróć oryginalny string
            return date_obj

        # Jeśli to obiekt datetime, skonwertuj na string
        if hasattr(date_obj, 'strftime'):
            return date_obj.strftime('%Y-%m-%d')

        # W przypadku nieznanego typu, zwróć pusty string
        return ''


    def diagnose_application_state(self):
        """Wykonuje pełną diagnostykę stanu aplikacji i wyświetla szczegółowe informacje"""
        try:
            debug_print("\n===== DIAGNOSTYKA STANU APLIKACJI =====")

            # 1. Sprawdź tabele i dane
            debug_print("\n--- TABELA GRAFIKU ---")
            debug_print(f"Liczba wierszy: {self.table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.table.columnCount()}")

            # Sprawdź pierwsze 3 wiersze i kolumny dla przykładu
            debug_print("\nPrzykładowe komórki z tabeli grafiku:")
            for row in range(min(3, self.table.rowCount())):
                for col in range(min(6, self.table.columnCount())):
                    item = self.table.item(row, col)
                    if item:
                        debug_print(f"[{row},{col}] Tekst: {item.text()}")
                        user_role_data = item.data(Qt.UserRole)
                        user_role_2 = item.data(Qt.UserRole + 2)
                        user_role_3 = item.data(Qt.UserRole + 3)
                        debug_print(
                            f"  UserRole: {type(user_role_data)}, UserRole+2: {user_role_2}, UserRole+3: {user_role_3}")
                        if isinstance(user_role_data, dict):
                            debug_print(f"  Zawartość: {user_role_data}")
                    else:
                        debug_print(f"[{row},{col}] Brak elementu")

            debug_print("\n--- TABELA ZDARZEŃ ---")
            debug_print(f"Liczba wierszy: {self.events_table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.events_table.columnCount()}")

            # Sprawdź zawartość events_data
            debug_print(
                f"\nLiczba zdarzeń w events_data: {len(self.events_data) if hasattr(self, 'events_data') else 'Brak'}")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print("Pierwsze zdarzenie:")
                for key, value in self.events_data[0].items():
                    debug_print(f"  {key}: {value}")

            # Sprawdź pierwsze 3 wiersze tabeli zdarzeń
            debug_print("\nPrzykładowe wiersze z tabeli zdarzeń:")
            for row in range(min(3, self.events_table.rowCount())):
                row_data = []
                for col in range(self.events_table.columnCount() - 1):  # Pomijamy ostatnią kolumnę z przyciskami
                    item = self.events_table.item(row, col)
                    if item:
                        row_data.append(f"{col}:{item.text()}")
                debug_print(f"Wiersz {row}: {', '.join(row_data)}")

            # 2. Sprawdź delegaty i style
            debug_print("\n--- DELEGATY I STYLE ---")
            item_delegate = self.table.itemDelegate()
            debug_print(f"Delegat tabeli grafiku: {item_delegate.__class__.__name__}")
            if isinstance(item_delegate, OvertimeItemDelegate):
                debug_print("  Delegat OvertimeItemDelegate poprawnie przypisany")
            else:
                debug_print("  UWAGA: Delegat OvertimeItemDelegate nie jest przypisany!")

            # 3. Sprawdź filtrowanie danych
            debug_print("\n--- FILTROWANIE DANYCH ---")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print(f"Liczba zdarzeń przed filtrowaniem: {len(self.events_data)}")
                # Sprawdź, czy metoda filter_events_table jest wywoływana
                debug_print("Spróbuj wykonać filter_events_table:")
                try:
                    self.filter_events_table()
                    debug_print("  Metoda filter_events_table wykonana bez błędów")
                except Exception as e:
                    debug_print(f"  BŁĄD podczas wykonywania filter_events_table: {e}")

            debug_print("\n===== KONIEC DIAGNOSTYKI =====\n")

        except Exception as e:
            debug_print(f"BŁĄD podczas diagnostyki: {e}")
            import traceback
            traceback.print_exc()

    def update_events_table(self, filtered_data):
        """
        Aktualizuje tabelę zdarzeń na podstawie przefiltrowanych danych.
        Zoptymalizowana wersja z ograniczoną serializacją i jednorazowym aktualizowaniem tabeli.
        """
        start_time = time.time()

        # Logowanie początkowe
        debug_print(f"update_events_table: Rozpoczynam aktualizację z {len(filtered_data)} zdarzeniami")

        # Blokujemy sygnały tabeli podczas aktualizacji
        self.events_table.blockSignals(True)
        self.events_table.setUpdatesEnabled(False)
        self.events_table.setSortingEnabled(False)

        # Ustawienie rozmiaru tabeli - tylko raz!
        self.events_table.setRowCount(len(filtered_data))

        # Listy do przechowywania obiektów do umieszczenia w tabeli
        table_items = []
        delete_buttons = []

        # Przygotuj wszystkie elementy tabeli w pamięci
        for row, event in enumerate(filtered_data):
            # Sprawdź kompletność danych i dodaj domyślne wartości jeśli potrzeba
            for field in ['type', 'id', 'topic', 'name', 'user_id', 'date', 'time_from', 'time_to', 'status']:
                if field not in event or event.get(field) is None:
                    event[field] = f"Brak {field}"

            # Obsługa brakującej nazwy użytkownika
            if 'user_name' not in event or not event.get('user_name'):
                user_id = event.get('user_id', '')
                user_info = self.user_info_map.get(user_id, {})
                event['user_name'] = user_info.get('uzytkownik_dane', str(user_id))

            # Id zdarzenia - zapisujemy bezpośrednio w Qt.UserRole jako int
            event_id = event.get('id', '')
            id_item = QTableWidgetItem(str(event_id))
            id_item.setData(Qt.UserRole, event_id)  # Bez serializacji
            table_items.append((row, 0, id_item))

            # Typ zdarzenia - też używamy Qt.UserRole dla ID
            event_type = event.get('type', '')
            type_item = QTableWidgetItem(event_type)
            type_item.setData(Qt.UserRole, event_id)  # Zapisz ID zdarzenia

            # Koloruj na podstawie typu
            if event_type == 'Spotkanie':
                type_item.setBackground(QColor(100, 149, 237))  # Cornflower Blue
            elif event_type == 'Szkolenie':
                type_item.setBackground(QColor(144, 238, 144))  # Light Green
            elif event_type == 'Nadgodziny':
                type_item.setBackground(QColor(255, 165, 0))  # Orange

            table_items.append((row, 1, type_item))

            # Pozostałe kolumny - tekstowe, wszystkie z zapisanym ID zdarzenia
            topic_item = QTableWidgetItem(str(event.get('topic', '')))
            topic_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 2, topic_item))

            name_item = QTableWidgetItem(str(event.get('name', '')))
            name_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 3, name_item))

            user_name = event.get('user_name', '')
            user_item = QTableWidgetItem(str(user_name))
            user_item.setData(Qt.UserRole, event_id)
            user_item.setData(Qt.UserRole + 1, event.get('user_id', ''))  # ID użytkownika w dodatkowym polu
            table_items.append((row, 4, user_item))

            date_item = QTableWidgetItem(str(event.get('date', '')))
            date_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 5, date_item))

            time_from_item = QTableWidgetItem(str(event.get('time_from', '')))
            time_from_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 6, time_from_item))

            time_to_item = QTableWidgetItem(str(event.get('time_to', '')))
            time_to_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 7, time_to_item))

            status_item = QTableWidgetItem(str(event.get('status', '')))
            status_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 8, status_item))

            # Zapisz informacje o przycisku usuwania do późniejszego dodania
            delete_buttons.append((row, 9, event_id, event_type))

        # JEDNORAZOWO umieść wszystkie przygotowane elementy w tabeli
        for row, col, item in table_items:
            self.events_table.setItem(row, col, item)

        # TERAZ dodaj przyciski usuwania
        for row, col, event_id, event_type in delete_buttons:
            # Utwórz przycisk usuwania
            delete_button = QPushButton("Usuń")
            delete_button.setStyleSheet("""
                background-color: #e74c3c;
                color: white;
                border-radius: 3px;
                padding: 3px;
                font-weight: bold;
            """)

            # Funkcja closures - utworzona specjalnie dla każdego przycisku
            def create_click_handler(eid, etype):
                def handler():
                    self.delete_event(eid, etype)

                return handler

            # Podłącz handler do przycisku
            handler = create_click_handler(event_id, event_type)
            delete_button.clicked.connect(handler)

            # Dodaj przycisk do tabeli
            self.events_table.setCellWidget(row, col, delete_button)

        # Przywróć normalne działanie tabeli
        self.events_table.setSortingEnabled(True)
        self.events_table.setUpdatesEnabled(True)
        self.events_table.blockSignals(False)

        # Dopasuj wysokość wierszy
        self.events_table.resizeRowsToContents()

        # Logowanie zakończenia
        debug_print(f"Aktualizacja tabeli zdarzeń zakończona, czas: {time.time() - start_time:.3f} sekund")

    def setup_shortcuts(self):
        """Ustawia skróty klawiszowe dla diagnostyki"""
        # Skrót dla pełnej diagnostyki
        diag_shortcut = QShortcut(QKeySequence("Ctrl+Shift+D"), self)
        diag_shortcut.activated.connect(self.diagnose_application_state)

        # Skrót dla debugowania zaznaczonej komórki
        cell_debug_shortcut = QShortcut(QKeySequence("Ctrl+Shift+C"), self)
        cell_debug_shortcut.activated.connect(self.debug_selected_cell)

    # Nowa metoda do obsługi usuwania zdarzenia z przycisku
    def delete_event_from_button(self, button):
        """Usuwa zdarzenie na podstawie danych przypisanych do przycisku"""
        # Pobierz dane zdarzenia z przycisku
        event_data = button.property("event_data")
        if not event_data:
            QMessageBox.warning(self, "Błąd", "Nie znaleziono danych zdarzenia.", QMessageBox.Ok)
            return

        # Pobierz ID i typ zdarzenia
        event_id = event_data.get('id')
        event_type = event_data.get('type')

        # Wywołaj istniejącą metodę usuwania
        self.delete_event(event_id, event_type)

    def cancel_delegations(self):
        """
        Odwołuje delegacje (spotkania i szkolenia) dla zaznaczonych komórek w grafiku.
        Zoptymalizowana i ulepszona wersja bazująca na metodzie delete_event.
        """
        # Pobierz zaznaczone komórki
        selected_ranges = self.table.selectedRanges()
        current_data = self.date_combo.currentData()

        if not current_data:
            QMessageBox.warning(
                self,
                "Brak danych",
                "Nie wybrano miesiąca lub brak dostępnych danych do wyświetlenia.",
                QMessageBox.Ok
            )
            return

        if not selected_ranges:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono żadnych komórek do odwołania delegacji.",
                QMessageBox.Ok
            )
            return

        # Zapamietaj bieżące zaznaczenie, aby później je przywrócić
        saved_selections = []
        for range_item in selected_ranges:
            saved_selections.append((
                range_item.topRow(),
                range_item.leftColumn(),
                range_item.bottomRow(),
                range_item.rightColumn()
            ))

        # Zbierz informacje o zaznaczonych komórkach
        user_date_pairs = set()

        for range_item in selected_ranges:
            for row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawdź czy to kolumna z dniem miesiąca
                    if col < 3:
                        continue

                    # Pobierz element tabeli
                    cell_item = self.table.item(row, col)
                    if not cell_item:
                        continue

                    # Pobierz dane z komórki
                    cell_data = self.get_cell_data(cell_item)
                    if not cell_data:
                        continue

                    # Dodaj parę (użytkownik, data) do zbioru
                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')
                    if user_id and date_str:
                        user_date_pairs.add((user_id, date_str))

        # Jeśli nie znaleziono par użytkownik-data, pokaż komunikat
        if not user_date_pairs:
            QMessageBox.information(
                self,
                "Brak danych",
                "Nie znaleziono danych dla zaznaczonych komórek.",
                QMessageBox.Ok
            )
            return

        # Przygotuj listę zdarzeń do odwołania
        events_to_cancel = []

        # Słownik do grupowania zdarzeń według użytkownika i dnia
        grouped_events = {}

        # ULEPSZENIE 1: Przygotuj słownik miesiąców do czyszczenia cache
        year_month_cache = {}

        # Użyj indeksu zdarzeń do szybkiego znalezienia delegacji
        for user_id, date_str in user_date_pairs:
            # Dodaj rok i miesiąc do słownika czyszczenia cache
            if date_str and date_str.count('-') == 2:
                year, month, _ = date_str.split('-')
                year_month_cache[(int(year), int(month))] = True

            # Pobierz zdarzenia dla tej pary użytkownik-data z indeksu
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

            # Filtruj tylko aktywne spotkania i szkolenia
            for event in user_events:
                event_type = event.get('type', '')
                event_id = event.get('id')
                event_status = event.get('status')

                # Konwersja statusu do str dla jednolitości porównania
                if event_status is not None:
                    event_status = str(event_status)

                # Tylko aktywne zdarzenia (status różny od '0')
                if event_type in ['Spotkanie', 'Szkolenie'] and event_id and event_status != '0':
                    # Dodaj do listy ogólnej
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),  # Nazwa użytkownika
                    })

                    # Dodaj do słownika grupującego
                    key = (user_id, date_str)
                    if key not in grouped_events:
                        grouped_events[key] = []
                    grouped_events[key].append(event)

        # Jeśli nie znaleziono delegacji do odwołania, pokaż komunikat
        if not events_to_cancel:
            QMessageBox.information(
                self,
                "Brak delegacji",
                "Nie znaleziono delegacji do odwołania dla zaznaczonych komórek.",
                QMessageBox.Ok
            )
            return

        # Przygotuj szczegółowy opis zdarzeń pogrupowany według użytkownika i dnia
        detailed_info = ""

        # Licznik dla ograniczenia liczby wyświetlanych grup
        group_count = 0
        max_groups_to_show = 10

        # Przetwarzaj zgrupowane zdarzenia
        for (user_id, date_str), events in grouped_events.items():
            # Ograniczenie liczby wyświetlanych grup
            if group_count >= max_groups_to_show:
                detailed_info += f"\n...oraz więcej zdarzeń dla innych użytkowników/dni ({len(grouped_events) - max_groups_to_show} więcej grup)...\n"
                break

            # Pobierz nazwę użytkownika z pierwszego zdarzenia
            user_name = events[0].get('user_name', f"ID: {user_id}")

            # Przygotuj datę w ładniejszym formacie (DD.MM.YYYY)
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            detailed_info += f"\n📅 {formatted_date} - 👤 {user_name}:\n"

            # Wyświetl zdarzenia dla tego użytkownika i daty
            for i, event in enumerate(events):
                detailed_info += f"   {i + 1}. {event['type']}: {event['name']}\n"

            group_count += 1

        # Pokaż komunikat potwierdzenia
        reply = QMessageBox.question(
            self,
            "Potwierdzenie odwołania delegacji",
            f"Czy na pewno chcesz odwołać następujące delegacje (spotkania i szkolenia)?\n{detailed_info}\n"
            f"Łącznie: {len(events_to_cancel)} delegacji dla {len(user_date_pairs)} komórek",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply != QMessageBox.Yes:
            return

        # Pobierz identyfikator użytkownika
        _, user_app_id, _ = get_modifier_id()

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            canceled_count = 0

            # Przygotuj zbiór do śledzenia par użytkownik-data do aktualizacji
            affected_users_dates = set()

            # Dla każdego zdarzenia do odwołania
            for event in events_to_cancel:
                event_id = event['id']
                event_type = event['type']
                user_id = event['user_id']
                date_key = event.get('date_key')

                # Określ odpowiednią tabelę
                table_name = "p_t_zz_Spotkania" if event_type == "Spotkanie" else "p_t_zz_Szkolenia"

                # Aktualizuj status zdarzenia
                update_query = f"""
                UPDATE {table_name} 
                SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? 
                WHERE Id = ?
                """
                cursor.execute(update_query, (user_app_id, event_id))
                canceled_count += 1

                affected_users_dates.add((user_id, date_key))

                # ULEPSZENIE 2: Usuń zdarzenie z indeksu zdarzeń
                self.data_provider.delete_event_from_index(event_id, event_type)

                # ULEPSZENIE 3: Wyczyść cache dla tej pary (użytkownik, data)
                pair_cache_key = f"user_{user_id}_date_{date_key}"
                if hasattr(self.data_provider, 'cache') and pair_cache_key in self.data_provider.cache:
                    del self.data_provider.cache[pair_cache_key]

                # ULEPSZENIE 4: Usuń z list danych zdarzeń - używaj list comprehension dla wydajności
                if hasattr(self, 'events_data'):
                    self.events_data = [e for e in self.events_data if
                                        not (e.get('id') == event_id and e.get('type') == event_type)]

                # ULEPSZENIE 5: Usuń z all_events_data
                if hasattr(self, 'all_events_data'):
                    self.all_events_data = [e for e in self.all_events_data if
                                            not (e.get('id') == event_id and e.get('type') == event_type)]

            conn.commit()
            conn.close()

            # ULEPSZENIE 6: Wyczyść cache dla wszystkich zmienionych miesięcy
            for year, month in year_month_cache.keys():
                self.clear_events_cache(year, month)

            # ULEPSZENIE 7: Po usunięciu wszystkich zdarzeń, zapisz datę własnej modyfikacji
            try:
                # Pobierz najnowszą datę modyfikacji
                query = """
                    SELECT MAX(DataModyfikacji) as DataModyfikacji FROM p_v_zz_GrafikiPracy
                """
                conn = DatabaseConnector.get_connection()
                cursor = conn.cursor()
                cursor.execute(query)
                result = cursor.fetchone()
                conn.close()

                if result and result[0]:
                    # Zapisz tę datę jako własną modyfikację
                    self.last_self_modification_date = result[0]
                    self.last_modification_date = result[0]  # Aktualizuj również ostatnią znaną modyfikację
                    print(f"Zarejestrowano własną modyfikację z datą: {self.last_self_modification_date}")
            except Exception as e:
                print(f"Błąd podczas rejestrowania własnej modyfikacji: {e}")

            # Zmodyfikuj dane w komórkach i usuń ikony
            for user_id, date_str in affected_users_dates:
                # ULEPSZENIE 8: Pobierz nową listę zdarzeń dla tej pary (użytkownik, data) - z pominięciem cache
                remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                print(
                    f"Po usunięciu znaleziono {len(remaining_events)} pozostałych zdarzeń dla ({user_id}, {date_str})")

                # Filtruj tylko aktywne zdarzenia
                active_events = [e for e in remaining_events if str(e.get('status', '0')) != '0']
                print(f"Z tego {len(active_events)} aktywnych zdarzeń")

                # Sprawdź typy zdarzeń jakie pozostały
                has_meeting = any(
                    e.get('type') == 'Spotkanie' and str(e.get('status', '0')) != '0' for e in remaining_events)
                has_training = any(
                    e.get('type') == 'Szkolenie' and str(e.get('status', '0')) != '0' for e in remaining_events)
                has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)

                # Pobierz rok, miesiąc i dzień z date_str
                if not date_str or date_str.count('-') != 2:
                    continue

                year, month, day = date_str.split('-')
                day = int(day)
                col = 2 + day  # Kolumna odpowiadająca dniowi

                # Znajdź komórkę i zaktualizuj ją
                for row in range(self.table.rowCount()):
                    cell = self.table.item(row, col)
                    if not cell:
                        continue

                    cell_data = self.get_cell_data(cell)

                    # Sprawdź czy to komórka odpowiedniego użytkownika
                    if cell_data and str(cell_data.get('uzytkownik_id')) == str(user_id):
                        # ULEPSZENIE 9: Aktualizacja flag ikon - ustaw zgodnie z aktualnym stanem
                        cell_data['has_meeting'] = has_meeting
                        cell_data['has_training'] = has_training
                        cell_data['has_overtime'] = has_overtime

                        # Zapisz zaktualizowane dane
                        self.set_cell_data(cell, cell_data)

                        # ULEPSZENIE 10: Wymuś odświeżenie pojedynczej komórki zamiast całej tabeli
                        model_index = self.table.model().index(row, col)
                        self.table.update(model_index)
                        break

            # ULEPSZENIE 11: Odśwież tabelę zdarzeń zamiast ręcznego czyszczenia
            self.filter_events_table()

            # ULEPSZENIE 12: Wymuś odświeżenie tabeli grafiku
            self.table.viewport().update()

            # Przywróć zaznaczenie
            for top_row, left_col, bottom_row, right_col in saved_selections:
                selection_range = QTableWidgetSelectionRange(
                    top_row, left_col, bottom_row, right_col
                )
                self.table.setRangeSelected(selection_range, True)

            # Pokaż informację o odwołanych delegacjach
            QMessageBox.information(
                self,
                "Sukces",
                f"Pomyślnie odwołano {canceled_count} delegacji z {len(events_to_cancel)} znalezionych.",
                QMessageBox.Ok
            )

        except Exception as e:
            debug_print(f"Błąd podczas odwoływania delegacji: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(
                self,
                "Błąd",
                f"Wystąpił błąd podczas odwoływania delegacji: {str(e)}",
                QMessageBox.Ok
            )

    def clear_events_cache(self, year, month, user_id=None, date_str=None):
        """
        Czyści cache zdarzeń dla podanego roku i miesiąca oraz opcjonalnie dla konkretnego użytkownika i daty.

        Args:
            year: Rok
            month: Miesiąc
            user_id: (Opcjonalnie) ID użytkownika
            date_str: (Opcjonalnie) Data w formacie 'YYYY-MM-DD'
        """
        try:
            # Wyczyść cache w DataProvider
            if hasattr(self.data_provider, 'cache'):
                # Kluczowe cache dla danych miesięcznych
                cache_key = self.data_provider._get_cache_key("events", year, month)
                dict_cache_key = f"{cache_key}_as_dict"

                if cache_key in self.data_provider.cache:
                    del self.data_provider.cache[cache_key]
                    print(f"Wyczyszczono cache zdarzeń (krotki) dla {year}-{month}")

                if dict_cache_key in self.data_provider.cache:
                    del self.data_provider.cache[dict_cache_key]
                    print(f"Wyczyszczono cache zdarzeń (słowniki) dla {year}-{month}")

                # Jeśli podano konkretnego użytkownika i datę, usuń również dedykowany cache
                if user_id is not None and date_str is not None:
                    pair_cache_key = f"user_{user_id}_date_{date_str}"
                    if pair_cache_key in self.data_provider.cache:
                        del self.data_provider.cache[pair_cache_key]
                        print(f"Wyczyszczono cache dla pary ({user_id}, {date_str})")

                # Zaktualizuj timestamp ostatniego czyszczenia cache
                if hasattr(self.data_provider, 'cache_timestamps'):
                    self.data_provider.cache_timestamps[cache_key] = 0
                    self.data_provider.cache_timestamps[dict_cache_key] = 0

                # Dodatkowo usuń wszystkie cache pasujące do danego miesiąca
                keys_to_delete = []
                for key in self.data_provider.cache.keys():
                    if f"_{year}_{month}" in key:
                        keys_to_delete.append(key)

                for key in keys_to_delete:
                    del self.data_provider.cache[key]
                    print(f"Wyczyszczono dodatkowy cache: {key}")

        except Exception as e:
            print(f"Błąd podczas czyszczenia cache: {e}")

    def show_insert_change_dialog(self):
        """Pokazuje okno dialogowe do wstawiania zmian w grafiku"""
        # Pobierz aktualną datę z tabeli grafiku
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Błąd",
                "Nie wybrano miesiąca. Nie można dodać zmiany grafiku.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone komórki, aby ustalić dzień i użytkownika
        selected_cells = self.get_selected_schedule_cells()

        if not selected_cells:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono żadnych komórek do edycji.",
                QMessageBox.Ok
            )
            return

        # Grupuj komórki według użytkownika i dnia dla łatwiejszej edycji
        grouped_cells = self.group_cells_by_user_and_day(selected_cells)

        # Utwórz dialog
        dialog = ScheduleChangeDialog(self, grouped_cells, year, month)
        dialog.exec()

    def get_selected_schedule_cells(self):
        """Zwraca listę zaznaczonych komórek z siatki grafiku"""
        selected_cells = []
        selected_ranges = self.table.selectedRanges()

        for range_item in selected_ranges:
            for row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawdź czy to komórka z grafikiem
                    if col >= 3:
                        # Pobierz element tabeli
                        cell_item = self.table.item(row, col)
                        if not cell_item:
                            continue

                        # Pobierz dane z komórki
                        cell_data = self.get_cell_data(cell_item)
                        if not cell_data:
                            continue

                        # Dodaj dane do listy wybranych komórek
                        selected_cells.append(cell_data)

        return selected_cells

    def group_cells_by_user_and_day(self, cells):
        """Grupuje komórki według użytkownika i dnia dla łatwiejszej edycji"""
        grouped = {}
        for cell in cells:
            user_id = cell['user_id']
            date = cell['date']

            if user_id not in grouped:
                grouped[user_id] = {}

            if date not in grouped[user_id]:
                grouped[user_id][date] = []

            grouped[user_id][date].append(cell)

        return grouped

    def update_cell_after_event_deletion(self, user_id, date_str, deleted_event_type):
        """
        Aktualizuje komórkę grafiku po usunięciu zdarzenia.
        Zoptymalizowana wersja z poprawną obsługą statusu.
        """
        try:
            print(
                f"Aktualizacja komórki po usunięciu zdarzenia: user_id={user_id}, data={date_str}, typ={deleted_event_type}")

            # Pobierz rok, miesiąc i dzień z date_str
            if not date_str or date_str.count('-') != 2:
                print(f"Nieprawidłowy format daty: {date_str}")
                return

            year, month, day = date_str.split('-')
            day = int(day)
            month = int(month)
            year = int(year)

            # Wyczyść cache tylko dla tej pary (user_id, date_str)
            pair_cache_key = f"user_{user_id}_date_{date_str}"
            if hasattr(self.data_provider, 'cache') and pair_cache_key in self.data_provider.cache:
                del self.data_provider.cache[pair_cache_key]
                print(f"Wyczyszczono cache dla pary ({user_id}, {date_str})")

            # Pobierz zdarzenia dla tej pary użytkownik-data z indeksu
            # ale wymuszamy pobranie świeżych danych omijając cache
            remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)
            print(
                f"Znaleziono {len(remaining_events)} pozostałych zdarzeń dla użytkownika {user_id} na dzień {date_str}")

            # Filtruj tylko aktywne zdarzenia (status != 0) - KLUCZOWE POPRAWKA
            remaining_events = [e for e in remaining_events if str(e.get('status', '0')) != '0']
            print(f"Po filtrowaniu statusu: {len(remaining_events)} aktywnych zdarzeń")

            # Sprawdź, jakie typy zdarzeń pozostały
            has_meeting = any(e.get('type') == 'Spotkanie' for e in remaining_events)
            has_training = any(e.get('type') == 'Szkolenie' for e in remaining_events)
            has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)

            print(f"Stan po usunięciu: spotkania={has_meeting}, szkolenia={has_training}, nadgodziny={has_overtime}")

            # Znajdź odpowiednią komórkę w tabeli
            found = False
            for row in range(self.table.rowCount()):
                col = 2 + day  # Indeks kolumny odpowiadającej dniowi

                # Pobierz element z komórki i sprawdź dane
                cell = self.table.item(row, col)
                if not cell:
                    continue

                # Pobierz dane komórki
                cell_data = self.get_cell_data(cell)

                # Sprawdź, czy to komórka odpowiedniego użytkownika
                if cell_data and str(cell_data.get('uzytkownik_id')) == str(user_id):
                    print(f"Znaleziono komórkę ({row}, {col}) dla użytkownika {user_id}")

                    # Aktualizuj dane komórki
                    cell_data.update({
                        'has_meeting': has_meeting,
                        'has_training': has_training,
                        'has_overtime': has_overtime
                    })

                    # Zapisz zaktualizowane dane
                    self.set_cell_data(cell, cell_data)

                    found = True
                    break

            if not found:
                print(f"Nie znaleziono komórki dla użytkownika {user_id} i dnia {day}")

            # Odśwież pojedynczą komórkę zamiast całej tabeli
            if found:
                self.table.viewport().update()

        except Exception as e:
            print(f"Błąd podczas aktualizacji komórki: {e}")
            import traceback
            traceback.print_exc()

    def update_cell_icons_for_user_date(self, user_id, date_str):
        """
        Aktualizuje ikonki i dane w komórce grafiku dla określonego użytkownika i daty
        """
        try:
            # Pobierz rok, miesiąc i dzień z date_str
            if not date_str or date_str.count('-') != 2:
                debug_print(f"Nieprawidłowy format daty: {date_str}")
                return

            year, month, day = date_str.split('-')
            day = int(day)
            month = int(month)
            year = int(year)

            # Pobierz zdarzenia dla tej pary (użytkownik, data)
            events = self.data_provider.get_events_for_user_date(user_id, date_str)

            # Sprawdź typy zdarzeń
            has_meeting = any(e.get('type') == 'Spotkanie' for e in events)
            has_training = any(e.get('type') == 'Szkolenie' for e in events)
            has_overtime = any(e.get('type') == 'Nadgodziny' for e in events)

            # Znajdź odpowiednią komórkę w tabeli
            found = False
            for row in range(self.table.rowCount()):
                # Znajdź kolumnę z odpowiednim dniem
                col = 2 + day

                # Pobierz dane użytkownika z kolumny "Pracownik" (indeks 2)
                pracownik_item = self.table.item(row, 2)
                if not pracownik_item:
                    continue

                # Znajdź odpowiednią komórkę
                cell_item = self.table.item(row, col)
                if not cell_item:
                    continue

                # Sprawdź, czy to komórka dla tego użytkownika
                cell_data = cell_item.data(Qt.UserRole)
                if isinstance(cell_data, dict) and str(cell_data.get('user_id')) == str(user_id):
                    # Znaleźliśmy właściwą komórkę
                    debug_print(f"Znaleziono komórkę ({row}, {col}) dla użytkownika {user_id}")

                    # Aktualizuj dane komórki
                    cell_data.update({
                        'has_meeting': has_meeting,
                        'has_training': has_training,
                        'has_overtime': has_overtime
                    })

                    # Zapisz zaktualizowane dane
                    cell_item.setData(Qt.UserRole, cell_data)

                    # Aktualizuj flagi delegata
                    cell_item.setData(Qt.UserRole, has_overtime)
                    cell_item.setData(Qt.UserRole + 1, has_meeting or has_training)

                    found = True
                    break

                # Alternatywnie, jeśli dane nie są przechowywane jako słownik
                # sprawdź nazwy w kolumnie pracownika
                for key in self.processed_data.keys():
                    _, _, user_name, uid = key
                    if user_name == pracownik_item.text() and str(uid) == str(user_id):
                        # Znaleźliśmy właściwą komórkę
                        debug_print(f"Znaleziono komórkę ({row}, {col}) dla użytkownika {user_id}")

                        # Aktualizuj flagi delegata
                        cell_item.setData(Qt.UserRole, has_overtime)
                        cell_item.setData(Qt.UserRole + 1, has_meeting or has_training)

                        found = True
                        break

                if found:
                    break

            if not found:
                debug_print(f"Nie znaleziono komórki dla użytkownika {user_id} i dnia {day}")

            # Wymuś odświeżenie tabeli
            self.table.viewport().update()

        except Exception as e:
            debug_print(f"Błąd podczas aktualizacji ikon w komórce: {e}")
            import traceback
            traceback.print_exc()

    def update_table_icons_after_event_deletion(self, user_id, date_str, deleted_event_type=None):
        """
        Aktualizuje ikonki w komórkach grafiku po usunięciu zdarzenia.
        Używa update_cell_after_event_deletion jako głównej metody.
        """
        # Delegujemy do uniwersalnej metody
        self.update_cell_after_event_deletion(user_id, date_str, deleted_event_type)

    def show_add_overtime_dialog(self):
        """Pokazuje okno dialogowe do dodawania nadgodzin z niestandardowymi opcjami"""
        # Pobierz bieżącą datę z tabeli grafiku
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Błąd",
                "Nie wybrano miesiąca. Nie można dodać nadgodzin.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone komórki
        selected_ranges = self.table.selectedRanges()

        # Sprawdź czy mamy jakieś zaznaczenie
        if not selected_ranges:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono żadnej komórki. Zaznacz dokładnie jedną komórkę, aby dodać nadgodziny.",
                QMessageBox.Ok
            )
            return

        # Sprawdź liczbę zaznaczonych komórek
        selected_cells_count = 0
        for range_item in selected_ranges:
            selected_cells_count += (range_item.rowCount() * range_item.columnCount())

        # Jeśli zaznaczono więcej niż jedną komórkę, wyświetl komunikat i zakończ
        if selected_cells_count > 1:
            QMessageBox.warning(
                self,
                "Zbyt wiele zaznaczonych komórek",
                "Zaznaczono zbyt wiele komórek. Zaznacz dokładnie jedną komórkę, aby dodać nadgodziny.",
                QMessageBox.Ok
            )
            return

        # Pobierz dane zaznaczonej komórki bezpośrednio z tabeli
        range_item = selected_ranges[0]
        row = range_item.topRow()
        col = range_item.leftColumn()

        # Sprawdź czy kolumna jest poprawna (dni zaczynają się od kolumny 3)
        if col < 3:
            QMessageBox.warning(
                self,
                "Błąd",
                "Zaznacz komórkę z dniem miesiąca (nie z nagłówkiem).",
                QMessageBox.Ok
            )
            return

        # Pobierz element tabeli i dane z niego
        cell_item = self.table.item(row, col)
        if not cell_item:
            QMessageBox.warning(
                self,
                "Błąd",
                "Nie można odczytać danych z zaznaczonej komórki.",
                QMessageBox.Ok
            )
            return

        # Pobierz dane z komórki
        cell_data = self.get_cell_data(cell_item)
        if not cell_data:
            QMessageBox.warning(
                self,
                "Błąd",
                "Brak danych w zaznaczonej komórce.",
                QMessageBox.Ok
            )
            return

        # Pobierz podstawowe informacje o komórce
        selected_user_id = cell_data.get('uzytkownik_id')
        selected_user_name = cell_data.get('uzytkownik_dane')
        day = cell_data.get('day')
        date_str = cell_data.get('date_str')
        nr_kadrowy = cell_data.get('nr_kadrowy')
        start_hour = cell_data.get('start_hour')
        current_symbol = cell_data.get('symbol', '')

        if not selected_user_id or not day or not date_str:
            QMessageBox.warning(
                self,
                "Błąd",
                "Brak wymaganych danych w zaznaczonej komórce.",
                QMessageBox.Ok
            )
            return

        # Utwórz datę QDate
        selected_date = QDate.fromString(date_str, "yyyy-MM-dd")

        # Flaga określająca, czy to dzień wolny (brak danych lub pusty symbol)
        is_day_off = not current_symbol or current_symbol.strip() == ''

        # Jeśli nr_kadrowy jest None, spróbuj znaleźć w innych komórkach tego samego wiersza
        if nr_kadrowy is None:
            for day_col in range(3, self.table.columnCount() - 1):
                day_item = self.table.item(row, day_col)
                if day_item:
                    day_data = self.get_cell_data(day_item)
                    if day_data and 'nr_kadrowy' in day_data and day_data['nr_kadrowy']:
                        nr_kadrowy = day_data['nr_kadrowy']
                        break

        # Ustaw domyślną godzinę rozpoczęcia
        if start_hour is None:
            start_hour = 9 if is_day_off else 8

        # Pobierz lokalizację z symbolu
        current_location = 'h'  # Domyślna lokalizacja (home office)
        if current_symbol and ';' in current_symbol:
            parts = current_symbol.split(';')
            if parts[0] in ['h', 'p', 's']:
                current_location = parts[0]

        # Utwórz okno dialogowe
        dialog = QDialog(self)

        # Nazwy miesięcy po polsku
        polish_months = [
            "stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca",
            "lipca", "sierpnia", "września", "października", "listopada", "grudnia"
        ]

        month_name = polish_months[selected_date.month() - 1]
        dialog.setWindowTitle(f"Dodaj nadgodziny w dniu {selected_date.day()} {month_name} {selected_date.year()}")
        dialog.setMinimumWidth(600)

        layout = QVBoxLayout(dialog)

        # Informacja o pracowniku
        user_info_label = QLabel(f"Pracownik: {selected_user_name}")
        user_info_label.setStyleSheet("font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(user_info_label)

        # Informacja o numerze kadrowym
        if nr_kadrowy:
            kadrowy_info_label = QLabel(f"Numer kadrowy: {nr_kadrowy}")
            kadrowy_info_label.setStyleSheet("margin-bottom: 10px;")
            layout.addWidget(kadrowy_info_label)

        # Informacja o miesiącu rozliczenia
        settlement_month = month
        settlement_year = year
        settlement_info = QLabel(f"Miesiąc rozliczenia: {settlement_month:02d}.{settlement_year}")
        settlement_info.setStyleSheet("margin-bottom: 10px;")
        layout.addWidget(settlement_info)

        # Informacja o dniu wolnym (jeśli to dzień wolny)
        if is_day_off:
            day_off_info = QLabel("Zaznaczony dzień jest dniem wolnym pracownika.")
            day_off_info.setStyleSheet("color: blue; font-weight: bold; margin-bottom: 10px;")
            layout.addWidget(day_off_info)

        # Formularz wprowadzania
        form_frame = QFrame()
        form_frame.setFrameShape(QFrame.StyledPanel)
        form_frame.setFrameShadow(QFrame.Raised)
        form_layout = QGridLayout(form_frame)

        # Etykiety
        od_label = QLabel("od kiedy")
        ile_label = QLabel("ile godzin")
        typ_label = QLabel("typ")
        ld_label = QLabel("LD")
        zalegle_label = QLabel("czy zaległe")

        # Kontrolki wprowadzania
        time_combo = QComboBox()
        time_combo.setMinimumWidth(60)  # Zwiększona szerokość

        # Ustal domyślny czas
        if is_day_off:
            default_time = "09:00"  # Dla dnia wolnego
        else:
            # Oblicz koniec zmiany (godzina rozpoczęcia + 8 godzin)
            end_hour = (start_hour + 8) % 24
            default_time = f"{end_hour:02d}:00"

        # Dodaj opcje czasu
        for hour in range(0, 24):
            for minute in [0, 30]:
                time_combo.addItem(f"{hour:02d}:{minute:02d}", f"{hour:02d}:{minute:02d}")

        # Ustaw domyślny czas
        index = time_combo.findText(default_time)
        if index != -1:
            time_combo.setCurrentIndex(index)
        else:
            time_combo.setCurrentText(default_time)

        # Combo z liczbą godzin do 13.0
        hours_combo = QComboBox()
        hours_combo.setMinimumWidth(50)  # Zwiększona szerokość
        for hours in [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5,
                      10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0]:
            hours_combo.addItem(f"{hours:.1f}", hours)
        hours_combo.setCurrentIndex(1)  # Domyślnie 1.0

        # Typ: wypłata, odbiór, odpracowanie
        type_combo = QComboBox()
        type_combo.addItem("wypłata", "wypłata")
        type_combo.addItem("odbiór", "odbiór")
        type_combo.addItem("odpracowanie", "odpracowanie")

        # LD (lokalizacja): h, p, s
        ld_combo = QComboBox()
        ld_combo.addItem("h", "h")  # Hybrydowa
        ld_combo.addItem("p", "p")  # Praca zdalna
        ld_combo.addItem("s", "s")  # Stacjonarna

        # Ustaw domyślną lokalizację
        if current_location == 'h':
            ld_combo.setCurrentIndex(0)
        elif current_location == 'p':
            ld_combo.setCurrentIndex(1)
        elif current_location == 's':
            ld_combo.setCurrentIndex(2)

        # Czy zaległe
        overdue_combo = QComboBox()
        overdue_combo.addItem("nie", 0)
        overdue_combo.addItem("tak", 1)

        # Przycisk dodawania
        add_button = QPushButton("Dodaj")
        add_button.setStyleSheet("background-color: #333; color: white; font-weight: bold;")

        # Dodaj kontrolki do layoutu
        form_layout.addWidget(od_label, 0, 0)
        form_layout.addWidget(time_combo, 0, 1)
        form_layout.addWidget(ile_label, 0, 2)
        form_layout.addWidget(hours_combo, 0, 3)
        form_layout.addWidget(typ_label, 0, 4)
        form_layout.addWidget(type_combo, 0, 5)
        form_layout.addWidget(ld_label, 0, 6)
        form_layout.addWidget(ld_combo, 0, 7)
        form_layout.addWidget(zalegle_label, 0, 8)
        form_layout.addWidget(overdue_combo, 0, 9)
        form_layout.addWidget(add_button, 0, 10)

        # Dodaj formularz do głównego layoutu
        layout.addWidget(form_frame)

        # Funkcja dodawania nadgodzin
        def add_overtime():
            try:
                # Pobierz dane z formularza
                start_time = time_combo.currentText()
                hours = float(hours_combo.currentData())
                overtime_type = type_combo.currentData()
                location = ld_combo.currentData()  # Lokalizacja: h, p, s
                is_overdue = overdue_combo.currentData()

                # Data rozliczenia to pierwszy dzień bieżącego miesiąca
                settlement_date_str = f"{settlement_year}-{settlement_month:02d}-01"

                # Wywołaj procedurę składowaną z poprawnie zmapowanymi parametrami
                result = self.call_add_overtime_procedure(
                    selected_user_id,
                    selected_date.year(),
                    selected_date.month(),
                    selected_date.toString("yyyy-MM-dd"),
                    start_time,
                    hours,
                    settlement_date_str,
                    is_overdue,
                    overtime_type,
                    location,
                    nr_kadrowy
                )

                # Obsłuż wynik
                if result["success"]:
                    QMessageBox.information(dialog, "Sukces", result["message"], QMessageBox.Ok)
                    dialog.accept()  # Zamknij dialog po sukcesie
                else:
                    # W przypadku błędu pokazujemy oryginalny komunikat z procedury
                    QMessageBox.warning(dialog, "Błąd", result["message"], QMessageBox.Ok)
                    # Nie zamykamy okna dialogowego w przypadku błędu

            except Exception as e:
                QMessageBox.critical(dialog, "Błąd", f"Wystąpił błąd: {str(e)}", QMessageBox.Ok)

        # Podłącz funkcję do przycisku
        add_button.clicked.connect(add_overtime)

        # Pokaż dialog
        dialog.exec()

    def call_add_overtime_procedure(self, user_id, year, month, date_str, start_time, hours, settlement_date,
                                    is_overdue, overtime_type, location, nr_kadrowy):
        """
        Wywołuje procedurę składowaną p_P_ZZ_NadgodzinyWstawienie_v3 z poprawnym mapowaniem parametrów
        """
        try:
            # Mapowanie lokalizacji na wartości liczbowe: h - 1, p - 2, s - 3
            location_map = {'h': 1, 'p': 2, 's': 3}
            location_value = location_map.get(location, 1)  # Domyślnie 1 (h)

            # Mapowanie typu nadgodzin: wypłata i odbiór - NULL, odpracowanie - 1
            param_value = None
            if overtime_type == 'odpracowanie':
                param_value = 1

            # Określenie wartości @odebrane: 1 dla typu "odbiór", 0 dla pozostałych
            odebrane_value = 1 if overtime_type == 'odbiór' else 0

            # Oblicz datę i czas zakończenia
            start_datetime = datetime.strptime(f"{date_str} {start_time}", "%Y-%m-%d %H:%M")
            end_datetime = start_datetime + timedelta(hours=hours)
            end_time = end_datetime.strftime("%H:%M")

            # Utwórz połączenie do bazy danych
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # Przygotuj parametry dla procedury składowanej
            params = [
                nr_kadrowy,  # @Nr_Kadrowy - używamy pobranego numeru kadrowego
                year,  # @Rok
                month,  # @Miesiac
                date_str,  # @Data
                start_time,  # @DataOd
                end_time,  # @DataDo
                settlement_date,  # @MiesiacRozliczenia
                is_overdue,  # @Zalegle
                odebrane_value,  # @Odebrane - 1 dla odbioru, 0 dla innych
                location_value,  # @lokalizacja - zmapowana wartość (1, 2, 3)
            ]

            # Dodaj parametr @Parametr tylko dla odpracowania, w przeciwnym razie użyj NULL
            if param_value is not None:
                params.append(param_value)  # @Parametr - tylko dla odpracowania (wartość 1)
            else:
                params.append(None)  # Dla wypłaty i odbioru - NULL

            # Przygotuj wywołanie procedury składowanej z odpowiednią liczbą parametrów
            placeholders = ", ".join(["?"] * len(params))
            sql = f"{{CALL [dbo].[p_P_ZZ_NadgodzinyWstawienie_v3] ({placeholders})}}"

            # Wywołaj procedurę składowaną
            cursor.execute(sql, params)

            # Zmiana: Pobierz WSZYSTKIE wyniki z procedury
            all_results = []

            while True:
                rows = cursor.fetchall()
                if rows:
                    all_results.append(rows)

                # Sprawdź, czy są kolejne zestawy wyników
                if not cursor.nextset():
                    break

            # Szukaj identyfikatora dodanego wpisu - liczby większej od 100
            new_id = None
            success = False
            message = "Wystąpił nieznany błąd podczas dodawania nadgodzin."

            # Przeszukaj wszystkie zestawy wyników
            for result_set in all_results:
                for row in result_set:
                    for value in row:
                        # Konwertuj wartość na string dla bezpieczeństwa
                        value_str = str(value) if value is not None else ""

                        # Sprawdź, czy wartość jest liczbą
                        try:
                            value_int = int(value_str)
                            # Jeśli wartość jest większa od 100, to prawdopodobnie ID dodanego wpisu
                            if value_int >= 100:
                                new_id = value_int
                                success = True
                                message = f"Nadgodziny zostały pomyślnie dodane (ID: {new_id})."
                                break
                            # Jeśli wartość to 0, to też sukces, ale bez ID
                            elif value_int == 0:
                                success = True
                                message = "Nadgodziny zostały pomyślnie dodane."
                        except (ValueError, TypeError):
                            # Sprawdź, czy wartość to komunikat o błędzie
                            if value_str and "błąd" in value_str.lower():
                                success = False
                                message = value_str
                                break

                    if new_id is not None:
                        break

                if new_id is not None:
                    break

            # Zatwierdź transakcję i zamknij połączenie
            conn.commit()
            conn.close()

            if success and new_id:
                # Formatowanie daty do wyświetlenia (zamień YYYY-MM-DD na DD.MM.YYYY)
                display_date = ".".join(reversed(date_str.split("-")))

                # Pobierz informacje o użytkowniku
                user_info = self.user_info_map.get(user_id, {
                    'wydzial': 'Nieznany',
                    'przelozony': 'Nieznany',
                    'uzytkownik_dane': f"{user_id}"
                })
                user_name = user_info.get('uzytkownik_dane', f"{user_id}")

                # Utwórz obiekt nadgodzin bezpośrednio z danych przekazanych do procedury
                new_overtime = {
                    'type': 'Nadgodziny',
                    'topic': 'Nadgodziny',
                    'name': 'Nadgodziny',
                    'user_id': user_id,
                    'user_name': user_name,
                    'date': display_date,
                    'date_key': date_str,
                    'time_from': start_time,
                    'time_to': end_time,
                    'status': 'Aktywne',
                    'id': new_id
                }

                # Dodaj do all_events_data jeśli istnieje
                if hasattr(self, 'all_events_data'):
                    # Sprawdź czy już istnieje
                    exists = False
                    for event in self.all_events_data:
                        if event.get('id') == new_id and event.get('type') == 'Nadgodziny':
                            exists = True
                            break

                    if not exists:
                        self.all_events_data.append(new_overtime)
                        debug_print(f"Dodano nadgodziny do all_events_data")

                # Dodaj do indeksu zdarzeń w DataProvider
                if hasattr(self.data_provider, 'events_index'):
                    # Sprawdź czy już istnieje
                    event = self.data_provider.events_index.get_event_by_id(new_id)
                    if not event:
                        self.data_provider.events_index.add_event(new_overtime)
                        debug_print(f"Dodano nadgodziny (ID: {new_id}) do indeksu zdarzeń")
                    else:
                        debug_print(f"Nadgodziny (ID: {new_id}) już istnieją w indeksie zdarzeń")

                # NOWE: Wyczyść cache zdarzeń w DataProvider dla tego miesiąca
                event_date = datetime.strptime(date_str, "%Y-%m-%d")
                event_year = event_date.year
                event_month = event_date.month

                # Wyczyść cache danych zdarzeń dla tego miesiąca
                cache_key = self.data_provider._get_cache_key("events", event_year, event_month)
                dict_cache_key = f"{cache_key}_as_dict"

                if cache_key in self.data_provider.cache:
                    del self.data_provider.cache[cache_key]
                    debug_print(f"Wyczyszczono cache zdarzeń (krotki) dla {event_year}-{event_month}")

                if dict_cache_key in self.data_provider.cache:
                    del self.data_provider.cache[dict_cache_key]
                    debug_print(f"Wyczyszczono cache zdarzeń (słowniki) dla {event_year}-{event_month}")

                # Aktualizuj ikony w komórce grafiku
                self.update_table_icons_after_event_addition(user_id, date_str, "Nadgodziny")

                # Sprawdź, czy zdarzenie zostało poprawnie dodane do indeksu
                in_index = self.debug_check_event_in_index(new_id, 'Nadgodziny')

                # Dodaj do bieżących danych zdarzeń
                if hasattr(self, 'events_data'):
                    # Sprawdź czy już istnieje
                    exists = False
                    for event in self.events_data:
                        if event.get('id') == new_id and event.get('type') == 'Nadgodziny':
                            exists = True
                            break

                    if not exists:
                        self.events_data.append(new_overtime)
                        debug_print(f"Dodano nadgodziny do events_data")

                # Aktualizuj tabelę zdarzeń bezpośrednio
                if hasattr(self, 'events_table'):
                    # Sprawdź czy wpis już istnieje w tabeli
                    found = False
                    for row in range(self.events_table.rowCount()):
                        id_item = self.events_table.item(row, 0)
                        if id_item and id_item.data(Qt.UserRole) == new_id:
                            found = True
                            break

                    if not found:
                        row = self.events_table.rowCount()
                        self.events_table.insertRow(row)

                        # Id zdarzenia
                        id_item = QTableWidgetItem(str(new_id))
                        id_item.setData(Qt.UserRole, new_id)
                        self.events_table.setItem(row, 0, id_item)

                        # Typ
                        type_item = QTableWidgetItem("Nadgodziny")
                        type_item.setData(Qt.UserRole, new_id)
                        type_item.setBackground(QColor(255, 165, 0))  # Orange for Overtime
                        self.events_table.setItem(row, 1, type_item)

                        # Temat
                        topic_item = QTableWidgetItem("Nadgodziny")
                        topic_item.setData(Qt.UserRole, new_id)
                        self.events_table.setItem(row, 2, topic_item)

                        # Nazwa
                        name_item = QTableWidgetItem("Nadgodziny")
                        name_item.setData(Qt.UserRole, new_id)
                        self.events_table.setItem(row, 3, name_item)

                        # Użytkownik
                        user_item = QTableWidgetItem(user_name)
                        user_item.setData(Qt.UserRole, new_id)
                        user_item.setData(Qt.UserRole + 1, user_id)
                        self.events_table.setItem(row, 4, user_item)

                        # Data
                        date_item = QTableWidgetItem(display_date)
                        date_item.setData(Qt.UserRole, new_id)
                        self.events_table.setItem(row, 5, date_item)

                        # Od
                        time_from_item = QTableWidgetItem(start_time)
                        time_from_item.setData(Qt.UserRole, new_id)
                        self.events_table.setItem(row, 6, time_from_item)

                        # Do
                        time_to_item = QTableWidgetItem(end_time)
                        time_to_item.setData(Qt.UserRole, new_id)
                        self.events_table.setItem(row, 7, time_to_item)

                        # Status
                        status_item = QTableWidgetItem("Aktywne")
                        status_item.setData(Qt.UserRole, new_id)
                        self.events_table.setItem(row, 8, status_item)

                        # Przycisk usunięcia
                        delete_button = QPushButton("Usuń")
                        delete_button.setStyleSheet("""
                            background-color: #e74c3c;
                            color: white;
                            border-radius: 3px;
                            padding: 3px;
                            font-weight: bold;
                        """)

                        # Użyj closure, aby zachować aktualną wartość event_id i event_type
                        def create_delete_handler(eid, etype):
                            return lambda: self.delete_event(eid, etype)

                        delete_button.clicked.connect(create_delete_handler(new_id, "Nadgodziny"))
                        self.events_table.setCellWidget(row, 9, delete_button)

                        # Dopasuj wysokość wiersza
                        self.events_table.resizeRowToContents(row)

                        debug_print(f"Dodano wiersz do tabeli zdarzeń")

                # Wymuś odświeżenie tabeli grafiku
                self.table.viewport().update()

                # Zachowaj zaznaczenie
                selected_ranges = self.table.selectedRanges()
                for range_item in selected_ranges:
                    self.table.setRangeSelected(range_item, True)

            return {
                "success": success,
                "message": message,
                "new_id": new_id
            }

        except Exception as e:
            debug_print(f"Błąd podczas dodawania nadgodzin: {e}")
            import traceback
            traceback.print_exc()
            return {
                "success": False,
                "message": f"Wystąpił błąd: {str(e)}"
            }



    def debug_check_event_in_index(self, event_id, event_type='Nadgodziny'):
        """
        Sprawdza, czy zdarzenie o podanym ID istnieje w indeksie zdarzeń
        i wyświetla informacje diagnostyczne.

        Args:
            event_id: ID zdarzenia
            event_type: Typ zdarzenia (domyślnie 'Nadgodziny')

        Returns:
            bool: True jeśli znaleziono zdarzenie, False w przeciwnym wypadku
        """
        debug_print(f"\n--- DIAGNOSTYKA INDEKSU ZDARZEŃ ---")
        debug_print(f"Szukam zdarzenia o ID {event_id} i typie {event_type}")

        # Sprawdź w indeksie zdarzeń DataProvider
        if hasattr(self.data_provider, 'events_index'):
            # Sprawdź bezpośrednio przez indeks ID
            event = self.data_provider.events_index.get_event_by_id(event_id)
            if event:
                debug_print(f"ZNALEZIONO w indeksie ID: {event}")
                return True

            # Alternatywnie, przeszukaj wszystkie zdarzenia
            found_in_all = False
            for e in self.data_provider.events_index.all_events:
                if e.get('id') == event_id and e.get('type') == event_type:
                    debug_print(f"ZNALEZIONO w all_events: {e}")
                    found_in_all = True

            # Przeszukaj indeks typów
            found_in_type_index = False
            type_events = self.data_provider.events_index.type_index.get(event_type, [])
            for e in type_events:
                if e.get('id') == event_id:
                    debug_print(f"ZNALEZIONO w type_index: {e}")
                    found_in_type_index = True

            if not found_in_all and not found_in_type_index:
                debug_print("NIE ZNALEZIONO w indeksie zdarzeń")
                return False

            return found_in_all or found_in_type_index
        else:
            debug_print("BRAK indeksu zdarzeń w data_provider")
            return False

    def update_table_icons_after_event_addition(self, user_id, date_str, added_event_type=None):
        """
        Aktualizuje ikonki w komórkach grafiku po dodaniu zdarzenia.
        Zoptymalizowana wersja korzystająca z update_cell_data.
        """
        # Delegujemy do uniwersalnej metody
        self.update_cell_data(user_id, date_str, added_event_type, "add")

    # Nowa metoda do aktualizacji indeksu zdarzeń po dodaniu nadgodzin
    def update_overtime_in_index(self, overtime_id, user_id, date_str, start_time, end_time):
        try:
            # Pobierz informacje o użytkowniku
            user_info = self.user_info_map.get(user_id, {
                'wydzial': 'Nieznany',
                'przelozony': 'Nieznany',
                'uzytkownik_dane': f"{user_id}"
            })
            user_name = user_info.get('uzytkownik_dane', f"{user_id}")

            # Formatuj datę do wyświetlenia (zamień YYYY-MM-DD na DD.MM.YYYY)
            display_date = ".".join(reversed(date_str.split("-")))

            # Utwórz obiekt zdarzenia
            new_overtime = {
                'type': 'Nadgodziny',
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'user_name': user_name,
                'date': display_date,
                'date_key': date_str,
                'time_from': start_time,
                'time_to': end_time,
                'status': 'Wstawione',
                'id': overtime_id
            }

            # Poprawne wywołanie - używamy events_index zamiast bezpośrednio data_provider
            if hasattr(self.data_provider, 'events_index'):
                self.data_provider.events_index.add_event(new_overtime)

            # Dodaj również do listy wszystkich zdarzeń
            if hasattr(self, 'all_events_data'):
                self.all_events_data.append(new_overtime)

            debug_print(f"Dodano nadgodziny (ID: {overtime_id}) do indeksu zdarzeń")

        except Exception as e:
            debug_print(f"Błąd podczas aktualizacji indeksu zdarzeń po dodaniu nadgodzin: {str(e)}")

    def show_theme_settings(self):
        """Pokazuje okno dialogowe z ustawieniami motywu"""
        theme = "dark" if self.is_dark_theme else "light"
        dialog = ThemeSettingsDialog(self, theme, self.current_font, self.current_font_size)
        dialog.settings_changed.connect(self.apply_theme_settings)

        # Uruchom dialog
        if dialog.exec() == QDialog.Accepted:
            # Pobierz ustawienia bezpośrednio z dialogu
            theme = dialog.get_current_theme()
            font = dialog.font_combo.currentFont().family()
            font_size = dialog.font_size_spin.value()

            # Sprawdź, czy użytkownik chce zapisać ustawienia
            save_settings = dialog.save_settings_checkbox.isChecked()

            # Zapisz ustawienia
            self.save_theme_settings(theme, font, font_size, save_settings)


    def save_theme_settings(self, theme, font_family, font_size, save_to_db):
        """Zapisuje ustawienia motywu trwale"""
        # Zaktualizuj lokalne ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Jeśli zaznaczono opcję zapamiętania, zapisz w bazie
        if save_to_db:
            try:
                self.settings_db.save_settings(theme, font_family, font_size)
                debug_print(f"Ustawienia zostały zapisane do bazy danych: {theme}, {font_family}, {font_size}")
            except Exception as e:
                debug_print(f"Błąd podczas zapisywania ustawień: {e}")

        # Zastosuj ustawienia nawet jeśli nie zapisujemy do bazy
        self.apply_theme_settings(theme, font_family, font_size)

    def update_all_cell_icons(self):
        """Aktualizuje ikony we wszystkich komórkach grafiku"""
        # To jest nowa metoda, która aktualizuje wszystkie komórki po zmianie motywu
        try:
            # Pobierz aktualny rok i miesiąc
            current_data = self.date_combo.currentData()
            if not current_data:
                return

            year, month = current_data

            # Dla każdej komórki w tabeli
            for row in range(self.table.rowCount()):
                for col in range(3, self.table.columnCount() - 1):  # Pomijamy kolumny nagłówków i sumę RBH
                    # Pobierz dane komórki
                    cell_data = self.get_cell_data(row, col)
                    if cell_data:
                        user_id = cell_data.get('user_id')
                        date_str = cell_data.get('date_str')
                        if user_id and date_str:
                            # Aktualizuj ikony dla tej komórki
                            self.update_cell_icons(user_id, date_str)
        except Exception as e:
            debug_print(f"Błąd podczas aktualizacji wszystkich ikon: {e}")

    def update_cell_data(self, user_id, date_str, event_type=None, action="update"):
        """
        Uniwersalna metoda do aktualizacji danych komórki i ikon po różnych operacjach.
        Zoptymalizowana wersja korzystająca z ujednoliconego systemu danych.

        Args:
            user_id: ID użytkownika
            date_str: Data w formacie 'YYYY-MM-DD'
            event_type: Typ zdarzenia (opcjonalnie)
            action: Rodzaj operacji - "update", "add", "delete"
        """
        try:
            # Standardyzuj format daty
            date_str = self.data_provider._standardize_date(date_str)

            # Wyczyść cache dla miesiąca tej daty
            if date_str and date_str.count('-') == 2:
                year, month, _ = date_str.split('-')
                self.clear_events_cache(int(year), int(month))

            # Pobierz dzień z daty
            if not date_str or date_str.count('-') != 2:
                print(f"Nieprawidłowy format daty: {date_str}")
                return

            year, month, day = date_str.split('-')
            day = int(day)

            # Pobierz wszystkie zdarzenia dla tej pary (użytkownik, data)
            # Wymuszamy pobranie nowych danych z indeksu, bez użycia cache
            events = self.data_provider.get_events_for_user_date(user_id, date_str)

            # Sprawdź typy zdarzeń
            has_meeting = any(
                e.get('type') == 'Spotkanie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
            has_training = any(
                e.get('type') == 'Szkolenie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
            has_overtime = any(e.get('type') == 'Nadgodziny' for e in events)

            print(f"Stan dla komórki ({user_id}, {date_str}): "
                  f"spotkania={has_meeting}, szkolenia={has_training}, nadgodziny={has_overtime}")

            # Znajdź odpowiednią komórkę w tabeli
            found = False

            for row in range(self.table.rowCount()):
                col = 2 + day  # Kolumna odpowiadająca dniowi

                # Pobierz komórkę
                cell_item = self.table.item(row, col)
                if not cell_item:
                    continue

                # Pobierz dane komórki
                cell_data = self.get_cell_data(cell_item)

                # Sprawdź czy to komórka tego użytkownika
                if cell_data and str(cell_data.get('uzytkownik_id')) == str(user_id):
                    found = True
                else:
                    # Alternatywna metoda: Sprawdź przez nazwę użytkownika w wierszu
                    user_item = self.table.item(row, 2)  # Kolumna "Pracownik"
                    if not user_item:
                        continue

                    # Przeszukaj processed_data, aby znaleźć dopasowanie
                    for key in self.processed_data.keys():
                        _, _, user_name, uid = key
                        if user_name == user_item.text() and str(uid) == str(user_id):
                            found = True
                            break

                if found:
                    # Aktualizuj dane komórki
                    if cell_data:
                        cell_data.update({
                            'has_meeting': has_meeting,
                            'has_training': has_training,
                            'has_overtime': has_overtime
                        })
                    else:
                        # Jeśli nie ma danych, utwórz nowy słownik
                        cell_data = {
                            'uzytkownik_id': user_id,
                            'day': day,
                            'date_str': date_str,
                            'has_meeting': has_meeting,
                            'has_training': has_training,
                            'has_overtime': has_overtime
                        }

                    # Zapisz zaktualizowane dane
                    self.set_cell_data(cell_item, cell_data)

                    # Wymuś odświeżenie komórki
                    self.table.update(self.table.model().index(row, col))
                    print(f"Zaktualizowano komórkę ({row}, {col}) dla użytkownika {user_id}")
                    break

            if not found:
                print(f"Nie znaleziono komórki dla użytkownika {user_id} i dnia {day}")

            # Wymuś odświeżenie tabeli po zakończeniu
            self.table.viewport().update()

        except Exception as e:
            print(f"Błąd podczas aktualizacji komórki: {e}")
            import traceback
            traceback.print_exc()

    def clear_events_cache(self, year, month, user_id=None, date_str=None):
        """
        Czyści cache zdarzeń dla podanego roku i miesiąca oraz opcjonalnie dla konkretnego użytkownika i daty.
        """
        try:
            # Wyczyść cache w DataProvider
            if hasattr(self.data_provider, 'cache'):
                # Kluczowe cache dla danych miesięcznych
                cache_key = self.data_provider._get_cache_key("events", year, month)
                dict_cache_key = f"{cache_key}_as_dict"

                if cache_key in self.data_provider.cache:
                    del self.data_provider.cache[cache_key]
                    print(f"Wyczyszczono cache zdarzeń (krotki) dla {year}-{month}")

                if dict_cache_key in self.data_provider.cache:
                    del self.data_provider.cache[dict_cache_key]
                    print(f"Wyczyszczono cache zdarzeń (słowniki) dla {year}-{month}")

                # Jeśli podano konkretnego użytkownika i datę, usuń również dedykowany cache
                if user_id is not None and date_str is not None:
                    pair_cache_key = f"user_{user_id}_date_{date_str}"
                    if pair_cache_key in self.data_provider.cache:
                        del self.data_provider.cache[pair_cache_key]
                        print(f"Wyczyszczono cache dla pary ({user_id}, {date_str})")

                # Zaktualizuj timestamp ostatniego czyszczenia cache
                if hasattr(self.data_provider, 'cache_timestamps'):
                    self.data_provider.cache_timestamps[cache_key] = 0
                    self.data_provider.cache_timestamps[dict_cache_key] = 0

                # Dodatkowo usuń wszystkie cache pasujące do danego miesiąca
                keys_to_delete = []
                for key in self.data_provider.cache.keys():
                    if f"_{year}_{month}" in key:
                        keys_to_delete.append(key)

                for key in keys_to_delete:
                    del self.data_provider.cache[key]
                    print(f"Wyczyszczono dodatkowy cache: {key}")

        except Exception as e:
            print(f"Błąd podczas czyszczenia cache: {e}")

    def delete_event(self, event_id, event_type):
        """
        Ulepszona wersja metody usuwania zdarzeń z poprawną obsługą indeksu i cache.
        Zoptymalizowana pod kątem spójności i wydajności.
        """
        # Pokaż komunikat potwierdzenia
        reply = QMessageBox.question(
            self,
            "Potwierdzenie",
            f"Czy na pewno chcesz usunąć {event_type.lower()} o ID {event_id}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.Yes
        )

        if reply != QMessageBox.StandardButton.Yes:
            return

        # Najpierw znajdź wszystkie niezbędne dane o zdarzeniu przed usunięciem
        user_id = None
        date_key = None
        event_name = None
        user_name = None

        # Metoda 1: Szukaj w indeksie zdarzeń
        if hasattr(self.data_provider, 'events_index'):
            event = self.data_provider.events_index.get_event_by_id(event_id)
            if event and (event_type == 'all' or event.get('type') == event_type):
                user_id = event.get('user_id')
                date_key = event.get('date_key')
                event_name = event.get('name', '')
                user_name = event.get('user_name', '')

        # Metoda 2: Szukaj w bieżących danych zdarzeń
        if not user_id or not date_key:
            for event in self.events_data:
                if event.get('id') == event_id and (event_type == 'all' or event.get('type') == event_type):
                    user_id = event.get('user_id')
                    date_key = event.get('date_key')
                    event_name = event.get('name', '')
                    user_name = event.get('user_name', '')
                    break

        # Metoda 3: Szukaj we wszystkich danych zdarzeń
        if not user_id or not date_key:
            if hasattr(self, 'all_events_data'):
                for event in self.all_events_data:
                    if event.get('id') == event_id and (event_type == 'all' or event.get('type') == event_type):
                        user_id = event.get('user_id')
                        date_key = event.get('date_key')
                        event_name = event.get('name', '')
                        user_name = event.get('user_name', '')
                        break

        if not user_id or not date_key:
            QMessageBox.warning(
                self,
                "Błąd",
                f"Nie znaleziono zdarzenia o ID {event_id} i typie {event_type}.",
                QMessageBox.StandardButton.Ok
            )
            return

        # Formatuj datę do wyświetlenia (zamień YYYY-MM-DD na DD.MM.YYYY)
        display_date = date_key
        try:
            year, month, day = date_key.split('-')
            display_date = f"{day}.{month}.{year}"
        except:
            pass

        # Jeśli brak nazwy użytkownika, poszukaj w mapie użytkowników
        if not user_name and hasattr(self, 'user_info_map'):
            user_info = self.user_info_map.get(user_id, {})
            user_name = user_info.get('uzytkownik_dane', f"ID: {user_id}")

        # Jeśli nadal brak nazwy użytkownika, użyj ID jako ostateczności
        if not user_name:
            user_name = f"ID: {user_id}"


        print(f'Usuwanie zdarzenia: ID: {event_id}, Typ: {event_type}, Uzytkownik: {user_id}, Data: {date_key}')

        try:
            # Zapamiętaj bieżące zaznaczenie w tabeli grafiku
            current_selection = self.table.selectedRanges()

            # Pobierz identyfikator użytkownika
            _, user_app_id, _ = get_modifier_id()

            # Wykonaj operację w bazie danych
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # Określ odpowiednią tabelę i typ operacji w zależności od typu zdarzenia
            table_name = ""
            if event_type == "Spotkanie":
                table_name = "p_t_zz_Spotkania"
            elif event_type == "Szkolenie":
                table_name = "p_t_zz_Szkolenia"
            elif event_type == "Nadgodziny":
                table_name = "p_t_zz_Nadgodziny"

            if not table_name:
                QMessageBox.warning(
                    self,
                    "Błąd",
                    "Nieprawidłowy typ zdarzenia.",
                    QMessageBox.StandardButton.Ok
                )
                return

            # Usuń rekord z bazy danych
            if event_type in ["Spotkanie", "Szkolenie"]:
                # Dla spotkań i szkoleń zmieniamy status zamiast usuwać
                query = f"""UPDATE {table_name} 
                         SET Status = 0, 
                            DataDo = NULL, 
                            DataOd = Data, 
                            Modyfikujacy = ? 
                        WHERE Id = ?
                        """
                cursor.execute(query, (user_app_id, event_id))
            else:
                # Dla nadgodzin usuwamy rekord
                query = f"DELETE FROM {table_name} WHERE Id = ?"
                cursor.execute(query, (event_id,))

            conn.commit()
            conn.close()

            # WAŻNE: Wyczyść cache dla daty tego zdarzenia przed aktualizacją ikon
            if date_key and date_key.count('-') == 2:
                year, month, _ = date_key.split('-')
                self.clear_events_cache(int(year), int(month))

                # Usuń również konkretny wpis cache dla pary (user_id, date_key)
                pair_cache_key = f"user_{user_id}_date_{date_key}"
                if hasattr(self.data_provider, 'cache') and pair_cache_key in self.data_provider.cache:
                    del self.data_provider.cache[pair_cache_key]
                    print(f"Wyczyszczono cache dla pary ({user_id}, {date_key})")

            # Zbierz informacje o komórkach, które trzeba zaktualizować
            affected_users_dates = set()
            affected_users_dates.add((user_id, date_key))

            # Usuń z indeksu zdarzeń
            if hasattr(self.data_provider, 'events_index'):
                if self.data_provider.events_index.delete_event(event_id, event_type):
                    print(f"Usunięto zdarzenie {event_id} z indeksu zdarzeń")
                else:
                    print(f"Nie znaleziono zdarzenia {event_id} w indeksie zdarzeń")

            # Usuń z bieżących list danych - używaj comprehensions dla wydajności
            self.events_data = [e for e in self.events_data if
                                not (e.get('id') == event_id and e.get('type') == event_type)]

            # Usuń z all_events_data
            if hasattr(self, 'all_events_data'):
                self.all_events_data = [e for e in self.all_events_data if
                                        not (e.get('id') == event_id and e.get('type') == event_type)]

            # NAJWAŻNIEJSZA CZĘŚĆ: Sprawdź i zaktualizuj ikony w komórkach grafiku
            for user_id, date_str in affected_users_dates:
                # Pobierz nową listę zdarzeń dla tej pary (użytkownik, data) - z pominięciem cache
                remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                print(
                    f"Po usunięciu znaleziono {len(remaining_events)} pozostałych zdarzeń dla ({user_id}, {date_str})")

                # Filtruj tylko aktywne zdarzenia
                active_events = [e for e in remaining_events if str(e.get('status', '0')) != '0']
                print(f"Z tego {len(active_events)} aktywnych zdarzeń")

                # Sprawdź typy zdarzeń jakie pozostały
                has_meeting = any(
                    e.get('type') == 'Spotkanie' and str(e.get('status', '0')) != '0' for e in remaining_events)
                has_training = any(
                    e.get('type') == 'Szkolenie' and str(e.get('status', '0')) != '0' for e in remaining_events)
                has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)

                # Znajdź i zaktualizuj odpowiednią komórkę w tabeli grafiku
                found = False
                if date_str and date_str.count('-') == 2:
                    year, month, day = date_str.split('-')
                    day = int(day)

                    # Kolumna odpowiadająca dniowi miesiąca
                    col = 2 + day

                    # Przeszukaj wiersze, aby znaleźć odpowiedniego użytkownika
                    for row in range(self.table.rowCount()):
                        # Pobierz element z komórki dla tego dnia
                        cell_item = self.table.item(row, col)
                        if not cell_item:
                            continue

                        # Pobierz dane komórki
                        cell_data = self.get_cell_data(cell_item)
                        if not cell_data:
                            continue

                        # Sprawdź czy to komórka odpowiedniego użytkownika
                        if str(cell_data.get('uzytkownik_id', '')) == str(user_id):
                            # Znaleźliśmy właściwą komórkę - aktualizuj flagi
                            cell_data['has_meeting'] = has_meeting
                            cell_data['has_training'] = has_training
                            cell_data['has_overtime'] = has_overtime

                            # Zapisz zaktualizowane dane
                            self.set_cell_data(cell_item, cell_data)

                            # Wymuś odświeżenie komórki
                            self.table.update(self.table.model().index(row, col))

                            print(f"Zaktualizowano ikony w komórce ({row}, {col}) dla użytkownika {user_id}")
                            found = True
                            break

                    if not found:
                        print(f"Nie znaleziono komórki dla użytkownika {user_id} i dnia {day} miesiąca {month}.{year}")

            # Wymuś odświeżenie widoku wydarzeń
            self.filter_events_table()

            # Wymuś odświeżenie tabeli grafiku
            self.table.viewport().update()

            # Przywróć zaznaczenie w tabeli grafiku
            for range_item in current_selection:
                selection_range = QTableWidgetSelectionRange(
                    range_item.topRow(), range_item.leftColumn(),
                    range_item.bottomRow(), range_item.rightColumn()
                )
                self.table.setRangeSelected(selection_range, True)

            # Pokaż komunikat sukcesu
            QMessageBox.information(
                self,
                "Sukces",
                f"{event_type} o ID {event_id} zostało pomyślnie usunięte.",
                QMessageBox.StandardButton.Ok
            )

        except Exception as e:
            QMessageBox.critical(
                self,
                "Błąd",
                f"Wystąpił błąd podczas usuwania zdarzenia: {str(e)}",
                QMessageBox.StandardButton.Ok
            )
            import traceback
            traceback.print_exc()

    def apply_theme_settings(self, theme, font_family, font_size):
        """Stosuje wybrane ustawienia motywu z wykorzystaniem centralnych stylów"""
        # Zapamiętaj wybrane ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Zastosuj czcionkę do całej aplikacji
        font = QFont(font_family, font_size)
        QApplication.setFont(font)

        # Zastosuj główny styl dla całego okna aplikacji
        self.setStyleSheet(AppStyles.get_main_window_style(theme))

        # Przyciski
        self.theme_button.setStyleSheet(AppStyles.get_button_style(theme))
        self.refresh_button.setStyleSheet(AppStyles.get_button_style(theme))
        self.clear_filters_button.setStyleSheet(AppStyles.get_button_style(theme))
        self.insert_symbol_button.setStyleSheet(AppStyles.get_button_style(theme))
        self.cancel_delegation_button.setStyleSheet(AppStyles.get_button_style(theme))
        self.add_overtime_button.setStyleSheet(AppStyles.get_button_style(theme))

        # Przycisk ukrywania tabeli zdarzeń
        if hasattr(self, 'toggle_events_panel_button'):
            self.toggle_events_panel_button.setStyleSheet(AppStyles.get_button_style(theme))

        # Przycisk menu
        self.toggle_menu_button.setStyleSheet(AppStyles.get_button_style(theme))

        # Przycisk wstawiania zmian
        if hasattr(self, 'insert_change_button'):
            self.insert_change_button.setStyleSheet(AppStyles.get_button_style(theme))

        # Combobox z datami
        self.date_combo.setStyleSheet(AppStyles.get_combobox_style(theme))

        # Stylizacja nowych kontrolek ComboBox
        for combo_name in ['wydzial_combo', 'dtn_combo', 'rola_combo', 'jezyk_combo', 'etat_combo']:
            if hasattr(self, combo_name):
                combo = getattr(self, combo_name)
                combo.setStyleSheet(AppStyles.get_combobox_style(theme))
                combo.setFont(font)

        # Listy
        self.przelozony_list.setStyleSheet(AppStyles.get_list_style(theme))
        self.uzytkownik_list.setStyleSheet(AppStyles.get_list_style(theme))

        # Pola filtrów
        self.przelozony_filter.setStyleSheet(AppStyles.get_line_edit_style(theme))
        self.uzytkownik_filter.setStyleSheet(AppStyles.get_line_edit_style(theme))

        # Tabele
        self.table.setStyleSheet(AppStyles.get_table_style(theme))
        self.events_table.setStyleSheet(AppStyles.get_table_style(theme))

        # Lewy panel
        self._left_panel.setStyleSheet(AppStyles.get_left_panel_style(theme))

        # Filtry zdarzeń
        if hasattr(self, 'date_from'):
            self.date_from.setStyleSheet(AppStyles.get_date_edit_style(theme))
            self.date_to.setStyleSheet(AppStyles.get_date_edit_style(theme))
            self.topic_filter.setStyleSheet(AppStyles.get_line_edit_style(theme))
            self.name_filter.setStyleSheet(AppStyles.get_line_edit_style(theme))

        # Zastosuj czcionkę i rozmiar do etykiet
        for widget in self.findChildren(QLabel):
            widget.setFont(font)

        # Etykiety w panelu filtrów - specjalne stylowanie
        for label in self.findChildren(QLabel):
            if label.text() in ["Wydział:", "Przełożony:", "Użytkownik:"]:
                label.setStyleSheet(AppStyles.get_label_style(theme))
            elif label.text() == "Filtry":
                label.setStyleSheet(AppStyles.get_label_style(theme, is_title=True))

        # Aktualizacja czcionki w tabeli
        self.table.setFont(font)
        self.date_combo.setFont(font)

        # Aktualizacja czcionki w nagłówkach tabeli
        header_font = QFont(font_family, font_size)
        self.table.horizontalHeader().setFont(header_font)
        self.table.verticalHeader().setFont(header_font)

        # Aktualizacja czcionki w tabeli zdarzeń
        self.events_table.setFont(font)
        self.events_table.horizontalHeader().setFont(header_font)

        # Stylizacja numerów wierszy
        vertical_header_style = """
            QHeaderView::section {
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 3px;
            }
        """ if self.is_dark_theme else """
            QHeaderView::section {
                background-color: #e0e0e0;
                color: black;
                border: 1px solid #cccccc;
                padding: 3px;
            }
        """

        self.table.verticalHeader().setStyleSheet(vertical_header_style)
        self.events_table.verticalHeader().setStyleSheet(vertical_header_style)

        # Aktualizacja kolorów weekendów w nagłówku
        header = self.table.horizontalHeader()
        if isinstance(header, WeekendAwareHeaderView):
            header.dark_theme = self.is_dark_theme

            # Pobierz aktualny rok i miesiąc
            current_data = self.date_combo.currentData()
            if current_data:
                year, month_idx = current_data

                # Określ liczbę dni w miesiącu i znajdź weekendy
                days_in_month = 31  # domyślna wartość
                if month_idx in [4, 6, 9, 11]:
                    days_in_month = 30
                elif month_idx == 2:
                    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                        days_in_month = 29
                    else:
                        days_in_month = 28

                weekend_columns = []
                # Aktualizuj kolory weekendów
                for col in range(3, 3 + days_in_month):
                    day = col - 2
                    date = QDate(year, month_idx, day)
                    day_of_week = date.dayOfWeek()

                    if day_of_week >= 6:  # weekend
                        weekend_columns.append(col)
                        header_item = self.table.horizontalHeaderItem(col)
                        if header_item:
                            if self.is_dark_theme:
                                header_item.setForeground(QColor(255, 99, 71))  # Tomato red dla ciemnego motywu
                            else:
                                header_item.setForeground(QColor(220, 20, 60))  # Crimson dla jasnego motywu

                # Aktualizuj kolumny weekendowe
                header.set_weekend_columns(weekend_columns, self.is_dark_theme)

            # Wymuś odświeżenie widoku nagłówka
            header.viewport().update()

        # Wymuś pełne odświeżenie tabeli grafiku
        self.table.viewport().update()
        self.events_table.viewport().update()

        # Odśwież również ikony
        self.update_all_cell_icons()


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = WorkScheduleWindow()
    window.show()
    sys.exit(app.exec())
