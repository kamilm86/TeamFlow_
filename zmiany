Jasne, oczywiÅ›cie. Oto kompletny, poÅ‚Ä…czony kod ze wszystkich naszych ostatnich rozmÃ³w.
Ten skrypt jest gotowy do wklejenia i uruchomienia w jednym bloku w notatniku Jupyter. Zawiera wszystkie omÃ³wione elementy:
 * PrawidÅ‚owe zliczanie unikalnych rozmÃ³w (nunique).
 * AnalizÄ™ porÃ³wnawczÄ… YTD (rok do dziÅ›).
 * SzczegÃ³Å‚owÄ… analizÄ™ tematÃ³w w ujÄ™ciu YTD.
 * AnalizÄ™ miesiÄ…c do miesiÄ…ca (MoM) dla tematÃ³w.
 * AnalizÄ™ miesiÄ…ca rok do roku (YoY-M) dla tematÃ³w.
 * Wszystkie dodatkowe analizy i solidne podsumowanie biznesowe.
# ==============================================================================
# KROK 1: IMPORT BIBLIOTEK I USTAWIENIA WIZUALIZACJI
# ==============================================================================
import pandas as pd
import sqlalchemy as sa
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from dateutil.relativedelta import relativedelta # Do Å‚atwej manipulacji datami

# Ustawienia dla wykresÃ³w, aby byÅ‚y czytelne i estetyczne
sns.set_theme(style="whitegrid")
plt.rcParams['figure.figsize'] = (14, 7)
plt.rcParams['axes.titlesize'] = 18
plt.rcParams['axes.labelsize'] = 14
plt.rcParams['xtick.labelsize'] = 12
plt.rcParams['ytick.labelsize'] = 12
print("âœ… Biblioteki zaÅ‚adowane, styl wykresÃ³w ustawiony.")


# ==============================================================================
# KROK 2: WCZYTANIE DANYCH Z BAZY MS SQL SERVER
# ==============================================================================
# WypeÅ‚nij poniÅ¼sze zmienne swoimi danymi dostÄ™powymi
server_name = "TWOJ_SERWER"
database_name = "TWOJA_BAZA_DANYCH"
table_name = "NAZWA_TWOJEJ_TABELI_RAW_Z_TEMATAMI"

try:
    # Tworzenie connection stringa dla uwierzytelniania Windows
    connection_string = f"mssql+pyodbc://{server_name}/{database_name}?driver=ODBC+Driver+17+for+SQL+Server&trusted_connection=yes"
    engine = sa.create_engine(connection_string)
    
    query = f"SELECT * FROM {table_name}"
    df_raw = pd.read_sql(query, engine)
    
    print(f"âœ… PomyÅ›lnie poÅ‚Ä…czono i wczytano {len(df_raw)} rekordÃ³w z tabeli {table_name}.")

except Exception as e:
    print(f"âŒ BÅ‚Ä…d podczas poÅ‚Ä…czenia z bazÄ… danych: {e}")
    print("âš ï¸ TworzÄ™ przykÅ‚adowy, granularny zbiÃ³r danych z wieloma tematami na rozmowÄ™.")
    # Generowanie realistycznych danych przykÅ‚adowych
    date_rng_2025 = pd.to_datetime(pd.date_range(start='2025-01-01', end='2025-09-17', freq='15min'))
    date_rng_2024 = pd.to_datetime(pd.date_range(start='2024-01-01', end='2024-12-31', freq='12min'))
    all_dates = date_rng_2025.union(date_rng_2024)
    
    # Tworzymy bazÄ™ unikalnych poÅ‚Ä…czeÅ„
    df_calls = pd.DataFrame({
        'callid': range(len(all_dates)), 'Data': all_dates,
        'Kanal_kontakt': np.random.choice(['voice', 'czat', 'wideo'], len(all_dates), p=[0.7, 0.25, 0.05]),
        'czy_odebrane': np.random.choice([1, 0], len(all_dates), p=[0.85, 0.15]),
        'wejscie': np.random.choice(['ivr', 'bot', 'vendor'], len(all_dates), p=[0.5, 0.4, 0.1]),
        'gdzie_koniec': np.random.choice(['konsultant', 'bot', 'transfer'], len(all_dates), p=[0.7, 0.15, 0.15]),
        'czas_rozmowy': np.random.gamma(2, 150, len(all_dates)).astype(int)
    })
    df_calls.loc[df_calls['czy_odebrane'] == 0, 'czas_rozmowy'] = 0

    # Tworzymy tematy i Å‚Ä…czymy je z rozmowami
    tematy = ['Faktury', 'PÅ‚atnoÅ›ci', 'Problemy techniczne', 'Oferta', 'Reklamacje', 'Zmiana danych']
    df_topics_1 = df_calls[['callid']].copy()
    df_topics_1['Temat'] = np.random.choice(tematy, len(df_calls))
    df_topics_2 = df_calls[['callid']].sample(frac=0.3).copy() # 30% rozmÃ³w ma drugi temat
    df_topics_2['Temat'] = np.random.choice(tematy, len(df_topics_2))
    df_with_topics = pd.concat([df_topics_1, df_topics_2])
    
    # Finalne poÅ‚Ä…czenie danych
    df_raw = pd.merge(df_calls, df_with_topics, on='callid')

print("\n--- PrÃ³bka danych (wiersze mogÄ… mieÄ‡ to samo callid) ---")
display(df_raw.head())


# ==============================================================================
# KROK 3: PRZYGOTOWANIE DANYCH I IMPLEMENTACJA LOGIKI YTD
# ==============================================================================
print("\n--- RozpoczÄ™to przygotowanie danych ---")
df_raw['Data'] = pd.to_datetime(df_raw['Data'])
df_raw['Rok'] = df_raw['Data'].dt.year
df_raw['Miesiac'] = df_raw['Data'].dt.month
df_raw['Dzien_Roku'] = df_raw['Data'].dt.dayofyear
df_raw['Godzina'] = df_raw['Data'].dt.hour

current_year = df_raw['Rok'].max()
previous_year = current_year - 1
latest_date_cy = df_raw[df_raw['Rok'] == current_year]['Data'].max()
latest_day_of_year = latest_date_cy.dayofyear

print(f"Lata w analizie: {current_year}, {previous_year}")
print(f"Dane YTD do dnia: {latest_day_of_year} ({latest_date_cy.strftime('%Y-%m-%d')})")

df_ytd = df_raw[(df_raw['Dzien_Roku'] <= latest_day_of_year) & (df_raw['Rok'].isin([current_year, previous_year]))].copy()
print(f"âœ… Dane odfiltrowane. Liczba wierszy w zbiorze YTD: {len(df_ytd)}")


# ==============================================================================
# KROK 4: ANALIZA PORÃ“WNAWCZA (METRYKI GÅÃ“WNE)
# ==============================================================================
print("\n--- RozpoczÄ™to gÅ‚Ã³wnÄ… analizÄ™ porÃ³wnawczÄ… (YTD) ---")

# --- 4.1. OgÃ³lny Wolumen Interakcji (YTD) ---
total_volume_ytd = df_ytd.groupby('Rok')['callid'].nunique().reset_index().rename(columns={'callid': 'liczba_polaczen'})
vol_cy = total_volume_ytd.loc[total_volume_ytd['Rok'] == current_year, 'liczba_polaczen'].iloc[0]
vol_py = total_volume_ytd.loc[total_volume_ytd['Rok'] == previous_year, 'liczba_polaczen'].iloc[0]
yoy_change = ((vol_cy - vol_py) / vol_py) * 100

plt.figure(figsize=(10, 6))
ax = sns.barplot(data=total_volume_ytd, x='Rok', y='liczba_polaczen', palette='viridis')
ax.set_title(f'CaÅ‚kowity Wolumen Unikalnych Interakcji (YTD)\nZmiana: {yoy_change:.2f}%', fontsize=20)
for p in ax.patches:
    ax.annotate(f'{int(p.get_height()):,}', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', fontsize=14, color='black', xytext=(0, 10), textcoords='offset points')
plt.ylabel('Liczba Unikalnych PoÅ‚Ä…czeÅ„')
plt.xlabel('Rok')
plt.show()

# --- 4.2. Analiza Åšredniego Czasu ObsÅ‚ugi (AHT) (YTD) ---
df_calls_unique_ytd = df_ytd.drop_duplicates(subset=['callid']).copy()
df_answered_ytd = df_calls_unique_ytd[df_calls_unique_ytd['czy_odebrane'] == 1]
aht_ytd = df_answered_ytd.groupby('Rok')['czas_rozmowy'].mean().reset_index().rename(columns={'czas_rozmowy': 'Sredni_AHT_s'})

plt.figure(figsize=(10, 6))
ax = sns.barplot(data=aht_ytd, x='Rok', y='Sredni_AHT_s', palette='coolwarm')
ax.set_title('Åšredni Czas ObsÅ‚ugi - AHT (YTD)')
for p in ax.patches:
    ax.annotate(f'{p.get_height():.1f}s', (p.get_x() + p.get_width() / 2., p.get_height()), ha='center', va='center', fontsize=14, color='black', xytext=(0, 10), textcoords='offset points')
plt.ylabel('AHT (w sekundach)')
plt.xlabel('Rok')
plt.show()


# ==============================================================================
# KROK 5: ANALIZA ZMIAN W TEMATACH ROZMÃ“W (YTD)
# ==============================================================================
print("\n--- RozpoczÄ™to analizÄ™ tematÃ³w rozmÃ³w (YTD) ---")

# --- 5.1. Top Tematy i Ich Zmiana (YTD) ---
topic_counts_ytd = df_ytd.groupby(['Rok', 'Temat'])['callid'].count().reset_index().rename(columns={'callid': 'liczba_wzmianek'})
top_n = 6 # PokaÅ¼ top 6 tematÃ³w

fig, axes = plt.subplots(1, 2, figsize=(20, 8), sharey=True)
for i, year in enumerate([previous_year, current_year]):
    top_topics = topic_counts_ytd[topic_counts_ytd['Rok'] == year].nlargest(top_n, 'liczba_wzmianek')
    sns.barplot(ax=axes[i], data=top_topics, x='liczba_wzmianek', y='Temat', palette='magma')
    axes[i].set_title(f'Top {top_n} TematÃ³w w {year} (YTD)')
    axes[i].set_xlabel('Liczba Wzmianek')
plt.tight_layout()
plt.show()

# --- 5.2. NajwiÄ™ksze Wzrosty i Spadki TematÃ³w (YTD) ---
topic_pivot = topic_counts_ytd.pivot_table(index='Temat', columns='Rok', values='liczba_wzmianek', fill_value=0)
topic_pivot['zmiana_proc'] = ((topic_pivot[current_year] - topic_pivot[previous_year]) / topic_pivot[previous_year]) * 100
topic_pivot.replace([np.inf, -np.inf], 0, inplace=True)

top_growth = topic_pivot.nlargest(5, 'zmiana_proc')
top_decline = topic_pivot.nsmallest(5, 'zmiana_proc')

fig, axes = plt.subplots(1, 2, figsize=(20, 8))
sns.barplot(ax=axes[0], x=top_growth['zmiana_proc'], y=top_growth.index, palette='Greens_r')
axes[0].set_title('Top 5 WzrostÃ³w TematÃ³w (YoY %)')
axes[0].set_xlabel('Wzrost Procentowy')
sns.barplot(ax=axes[1], x=top_decline['zmiana_proc'], y=top_decline.index, palette='Reds_r')
axes[1].set_title('Top 5 SpadkÃ³w TematÃ³w (YoY %)')
axes[1].set_xlabel('Spadek Procentowy')
plt.tight_layout()
plt.show()

# --- 5.3. MiesiÄ™czna Mapa Cieplna TematÃ³w (YTD) ---
fig, axes = plt.subplots(2, 1, figsize=(18, 16), sharex=True)
for i, year in enumerate([previous_year, current_year]):
    monthly_topics = df_ytd[df_ytd['Rok'] == year].groupby(['Miesiac', 'Temat'])['callid'].count().unstack(fill_value=0)
    sns.heatmap(ax=axes[i], data=monthly_topics.T, cmap='YlGnBu', annot=True, fmt='d', linewidths=.5)
    axes[i].set_title(f'MiesiÄ™czna Mapa Cieplna TematÃ³w w {year} (YTD)')
    axes[i].set_ylabel('Temat')
plt.xlabel('MiesiÄ…c')
plt.tight_layout()
plt.show()


# ==============================================================================
# KROK 6: ANALIZA ZMIAN W TEMATACH (MoM i YoY-M)
# ==============================================================================
print("\n--- RozpoczÄ™to analizÄ™ tematÃ³w w ujÄ™ciu miesiÄ™cznym ---")

# --- 6.1. Przygotowanie - Identyfikacja miesiÄ™cy do porÃ³wnania ---
latest_date_in_data = df_raw['Data'].max()
last_full_month_date = latest_date_in_data - relativedelta(months=1) if latest_date_in_data.day > 5 else latest_date_in_data - relativedelta(months=2)
lfm_year, lfm_month = last_full_month_date.year, last_full_month_date.month

prev_month_date = last_full_month_date - relativedelta(months=1)
pm_year, pm_month = prev_month_date.year, prev_month_date.month

lfm_prev_year_date = last_full_month_date - relativedelta(years=1)
lfm_py_year, lfm_py_month = lfm_prev_year_date.year, lfm_prev_year_date.month

print(f"Ostatni peÅ‚ny miesiÄ…c: {lfm_year}-{lfm_month:02d}")
print(f"Poprzedni miesiÄ…c (do MoM): {pm_year}-{pm_month:02d}")
print(f"Ten sam miesiÄ…c, rok wczeÅ›niej (do YoY-M): {lfm_py_year}-{lfm_py_month:02d}")

# --- 6.2. Analiza MiesiÄ…c do MiesiÄ…ca (MoM) ---
df_mom = df_raw[((df_raw['Rok'] == lfm_year) & (df_raw['Miesiac'] == lfm_month)) | ((df_raw['Rok'] == pm_year) & (df_raw['Miesiac'] == pm_month))].copy()

if not df_mom.empty and len(df_mom['Rok'].unique()) > 1:
    mom_counts = df_mom.groupby(['Rok', 'Miesiac', 'Temat'])['callid'].count().unstack(level=[0, 1], fill_value=0)
    col_lfm = (lfm_year, lfm_month)
    col_pm = (pm_year, pm_month)
    if col_lfm in mom_counts.columns and col_pm in mom_counts.columns:
        mom_counts['zmiana_proc'] = ((mom_counts[col_lfm] - mom_counts[col_pm]) / mom_counts[col_pm]) * 100
        mom_counts.replace([np.inf, -np.inf], 0, inplace=True)
        
        fig, axes = plt.subplots(1, 2, figsize=(20, 8))
        sns.barplot(ax=axes[0], x=mom_counts.nlargest(5, 'zmiana_proc')['zmiana_proc'], y=mom_counts.nlargest(5, 'zmiana_proc').index, palette='Greens_r')
        axes[0].set_title(f'Wzrosty TematÃ³w (MoM): {lfm_month:02d}-{lfm_year} vs {pm_month:02d}-{pm_year}')
        sns.barplot(ax=axes[1], x=mom_counts.nsmallest(5, 'zmiana_proc')['zmiana_proc'], y=mom_counts.nsmallest(5, 'zmiana_proc').index, palette='Reds_r')
        axes[1].set_title(f'Spadki TematÃ³w (MoM)')
        plt.tight_layout()
        plt.show()
    else: print("âš ï¸ Brak wystarczajÄ…cych danych do porÃ³wnania MoM.")
else: print("âš ï¸ Brak danych dla wybranych miesiÄ™cy do analizy MoM.")

# --- 6.3. Analiza MiesiÄ…ca Rok do Roku (YoY-M) ---
df_yoy_m = df_raw[((df_raw['Rok'] == lfm_year) & (df_raw['Miesiac'] == lfm_month)) | ((df_raw['Rok'] == lfm_py_year) & (df_raw['Miesiac'] == lfm_py_month))].copy()

if not df_yoy_m.empty and len(df_yoy_m['Rok'].unique()) > 1:
    yoy_m_pivot = df_yoy_m.groupby(['Rok', 'Temat'])['callid'].count().unstack(level=0, fill_value=0)
    if lfm_year in yoy_m_pivot.columns and lfm_py_year in yoy_m_pivot.columns:
        yoy_m_pivot['zmiana_proc'] = ((yoy_m_pivot[lfm_year] - yoy_m_pivot[lfm_py_year]) / yoy_m_pivot[lfm_py_year]) * 100
        yoy_m_pivot.replace([np.inf, -np.inf], 0, inplace=True)
        
        fig, axes = plt.subplots(1, 2, figsize=(20, 8))
        sns.barplot(ax=axes[0], x=yoy_m_pivot.nlargest(5, 'zmiana_proc')['zmiana_proc'], y=yoy_m_pivot.nlargest(5, 'zmiana_proc').index, palette='Blues_r')
        axes[0].set_title(f'Wzrosty TematÃ³w (YoY): {lfm_month:02d}-{lfm_year} vs {lfm_month:02d}-{lfm_py_year}')
        sns.barplot(ax=axes[1], x=yoy_m_pivot.nsmallest(5, 'zmiana_proc')['zmiana_proc'], y=yoy_m_pivot.nsmallest(5, 'zmiana_proc').index, palette='Oranges_r')
        axes[1].set_title(f'Spadki TematÃ³w (YoY)')
        plt.tight_layout()
        plt.show()
    else: print("âš ï¸ Brak wystarczajÄ…cych danych do porÃ³wnania YoY dla wybranego miesiÄ…ca.")
else: print("âš ï¸ Brak danych dla wybranych miesiÄ™cy do analizy YoY-M.")


# ==============================================================================
# KROK 7: GÅÄ˜BSZA ANALIZA (BONUS)
# ==============================================================================
print("\n--- RozpoczÄ™to analizy dodatkowe (bonus) ---")

# --- 7.1. Dystrybucja Czasu Trwania RozmÃ³w ---
fig, axes = plt.subplots(1, 2, figsize=(20, 8), sharey=True)
sns.histplot(ax=axes[0], data=df_answered_ytd[df_answered_ytd['Rok'] == previous_year], x='czas_rozmowy', bins=50, kde=True)
axes[0].set_title(f'Dystrybucja Czasu RozmÃ³w w {previous_year} (YTD)')
axes[0].axvline(aht_ytd.loc[aht_ytd['Rok'] == previous_year, 'Sredni_AHT_s'].iloc[0], color='red', linestyle='--', label='Åšrednia (AHT)')
axes[0].legend()

sns.histplot(ax=axes[1], data=df_answered_ytd[df_answered_ytd['Rok'] == current_year], x='czas_rozmowy', bins=50, kde=True, color='orange')
axes[1].set_title(f'Dystrybucja Czasu RozmÃ³w w {current_year} (YTD)')
axes[1].axvline(aht_ytd.loc[aht_ytd['Rok'] == current_year, 'Sredni_AHT_s'].iloc[0], color='red', linestyle='--', label='Åšrednia (AHT)')
axes[1].legend()
plt.suptitle('PorÃ³wnanie Dystrybucji Czasu RozmÃ³w (YTD)', fontsize=22)
plt.show()

# --- 7.2. Analiza obciÄ…Å¼enia w ciÄ…gu dnia ---
hourly_volume_ytd = df_ytd.groupby(['Rok', 'Godzina'])['callid'].nunique().reset_index()
g = sns.FacetGrid(hourly_volume_ytd, col="Rok", height=6, aspect=1.5)
g.map(sns.barplot, "Godzina", "callid", order=range(24), palette=['skyblue', 'lightcoral'])
g.set_axis_labels("Godzina Dnia", "Liczba PoÅ‚Ä…czeÅ„")
g.set_titles(col_template="Rok {col_name}")
g.fig.suptitle('RozkÅ‚ad PoÅ‚Ä…czeÅ„ w CiÄ…gu Dnia (YTD)', y=1.03, fontsize=20)
plt.show()


# ==============================================================================
# KROK 8: PODSUMOWANIE I REKOMENDACJE BIZNESOWE
# ==============================================================================
print("\n\n" + "="*80)
print("ğŸ’¡ KOMPLEKSOWE PODSUMOWANIE WNIOSKÃ“W I REKOMENDACJE BIZNESOWE ğŸ’¡")
print("="*80)
print(f"""
Analiza porÃ³wnawcza dla okresu YTD oraz w ujÄ™ciu miesiÄ™cznym dostarcza wielowymiarowego obrazu dziaÅ‚ania infolinii:

### Perspektywa Strategiczna (Analiza YTD)

1.  **OgÃ³lny Wolumen:** ZaobserwowaliÅ›my {'wzrost' if yoy_change > 0 else 'spadek'} caÅ‚kowitego wolumenu unikalnych interakcji o **{yoy_change:.2f}%**. Jest to kluczowy wskaÅºnik ogÃ³lnego zapotrzebowania na wsparcie.
2.  **EfektywnoÅ›Ä‡ Operacyjna (AHT):** Åšredni czas obsÅ‚ugi zmieniÅ‚ siÄ™ z **{aht_ytd.loc[aht_ytd['Rok'] == previous_year, 'Sredni_AHT_s'].iloc[0]:.1f}s** na **{aht_ytd.loc[aht_ytd['Rok'] == current_year, 'Sredni_AHT_s'].iloc[0]:.1f}s**. NaleÅ¼y to skorelowaÄ‡ ze zmianami w tematyce - czy rozmowy stajÄ… siÄ™ bardziej skomplikowane?
3.  **DÅ‚ugofalowe Trendy w Tematach:** Analiza YTD pokazuje, Å¼e tematy takie jak **[wpisz temat z najwiÄ™kszym wzrostem YTD]** systematycznie zyskujÄ… na znaczeniu. MoÅ¼e to byÄ‡ sygnaÅ‚ do strategicznych zmian w produkcie, komunikacji lub procesach, aby zredukowaÄ‡ liczbÄ™ tych zapytaÅ„ w przyszÅ‚oÅ›ci.

### Perspektywa Taktyczna i Sezonowa (Analiza MiesiÄ…ca Rok do Roku - YoY-M)

4.  **Weryfikacja SezonowoÅ›ci:** PorÃ³wnanie miesiÄ…ca {lfm_month:02d}-{lfm_year} z {lfm_month:02d}-{lfm_py_year} pozwala oceniÄ‡, czy obecne trendy sÄ… anomaliÄ…, czy powtarzalnym wzorcem.
    - **Rekomendacja:** JeÅ›li np. temat 'Oferta' roÅ›nie co roku w tym samym miesiÄ…cu, moÅ¼na proaktywnie przygotowaÄ‡ zespÃ³Å‚ i kampanie. JeÅ›li wzrost jest w tym roku wyjÄ…tkowo wysoki, naleÅ¼y zbadaÄ‡ przyczynÄ™ (np. skutecznoÅ›Ä‡ nowej kampanii marketingowej).

### Perspektywa Operacyjna (Analiza MiesiÄ…c do MiesiÄ…ca - MoM)

5.  **System Wczesnego Ostrzegania:** PorÃ³wnanie miesiÄ…ca {lfm_month:02d}-{lfm_year} z {pm_month:02d}-{pm_year} to najlepszy barometr bieÅ¼Ä…cych problemÃ³w.
    - **Rekomendacja:** NagÅ‚y wzrost tematu **[wpisz temat z najwiÄ™kszym wzrostem MoM]** powinien byÄ‡ natychmiastowym sygnaÅ‚em dla odpowiedniego dziaÅ‚u (np. IT w przypadku 'ProblemÃ³w technicznych', FinansÃ³w dla 'Faktur'). Regularne monitorowanie tego wskaÅºnika pozwala na bÅ‚yskawiczne gaszenie "poÅ¼arÃ³w".

### Wnioski OgÃ³lne:

- **Od OgÃ³Å‚u do SzczegÃ³Å‚u:** AnalizÄ™ naleÅ¼y rozpoczynaÄ‡ od ogÃ³lnego wolumenu (YTD), a nastÄ™pnie zagÅ‚Ä™biaÄ‡ siÄ™ w przyczyny zmian, analizujÄ…c tematy w rÃ³Å¼nych horyzontach czasowych.
- **Klucz to Tematy:** Zrozumienie, **DLACZEGO** klienci siÄ™ kontaktujÄ… (tematy), jest waÅ¼niejsze niÅ¼ wiedza, **JAK CZÄ˜STO** to robiÄ… (wolumen).
- **ProaktywnoÅ›Ä‡:** PoÅ‚Ä…czenie tych trzech perspektyw analitycznych pozwala przejÅ›Ä‡ od reaktywnego odpowiadania na problemy do proaktywnego zarzÄ…dzania doÅ›wiadczeniem klienta.
""")
print("="*80)

