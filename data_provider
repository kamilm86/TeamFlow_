# data_provider_v2.py - ZMODYFIKOWANA WERSJA z dynamicznymi ikonami

from PySide6.QtCore import QObject, Signal
from db_connector import DatabaseConnector
from datetime import datetime, timedelta
import time
from debug_utils import debug_print, log_warning, log_error
from dataclasses import dataclass
from typing import Dict, List, Tuple, Optional, Any
from functools import lru_cache
from symbol_parser import parse_symbols_batch  # NOWY import

@dataclass
class MonthlyDataContainer:
    """Kontener na wszystkie dane miesiąca"""
    schedule_data: List[Any]  # Surowe dane grafiku
    events_data: List[Dict]  # Słowniki zdarzeń
    processed_data: Dict  # Przetworzone dane dla modelu
    events_cache: Dict[Tuple[int, str], List[Dict]]  # (user_id, date) -> [events]
    last_updated: float

    def __post_init__(self):
        if not hasattr(self, 'last_updated'):
            self.last_updated = time.time()


class DataProviderV2(QObject):
    """
    DataProvider z ograniczonym odświeżaniem ikon
    """
    data_changed = Signal(str, int, int)  # Typ danych, rok, miesiąc

    def __init__(self):
        super().__init__()
        self.db_connector = DatabaseConnector

        # Cache miesięczny
        self.monthly_cache: Dict[Tuple[int, int], MonthlyDataContainer] = {}

        # Cache dla ikon - UPROSZCZONY
        self._icons_cache_by_month: Dict[Tuple[int, int], Dict[Tuple[int, str], Dict]] = {}

        # Inicjalizacja managera kolumn
        from column_mapper import ColumnMapper
        self.column_mapper = ColumnMapper()

    def get_dynamic_icons_for_cell(self, user_id: int, date_str: str) -> Dict:
        """
        POPRAWIONA WERSJA: Zwraca ikony z cache lub oblicza je na podstawie aktywnych zdarzeń
        """
        try:
            year, month, _ = date_str.split('-')
            year, month = int(year), int(month)
        except:
            return {'spotkania': 0, 'szkolenia': 0, 'nadgodziny': 0}
        
        month_key = (year, month)
        cell_key = (user_id, date_str)
        
        # Sprawdź cache ikon
        if month_key in self._icons_cache_by_month:
            month_icons = self._icons_cache_by_month[month_key]
            if cell_key in month_icons:
                return month_icons[cell_key]
        
        # KLUCZOWA ZMIANA: Oblicz ikony na podstawie aktywnych zdarzeń
        events = self.get_events_for_user_date(user_id, date_str)  # Ta metoda już filtruje aktywne
        
        has_spotkania = any(
            e.get('type') == 'Spotkanie' 
            for e in events
        )
        has_szkolenia = any(
            e.get('type') == 'Szkolenie' 
            for e in events
        )
        has_nadgodziny = any(
            e.get('type') == 'Nadgodziny' 
            for e in events
        )
        
        result = {
            'spotkania': 1 if has_spotkania else 0,
            'szkolenia': 1 if has_szkolenia else 0,
            'nadgodziny': 1 if has_nadgodziny else 0
        }
        
        # Zapisz w cache
        if month_key not in self._icons_cache_by_month:
            self._icons_cache_by_month[month_key] = {}
        self._icons_cache_by_month[month_key][cell_key] = result
        
        # Debug dla pierwszych wywołań
        if user_id <= 100:  # Loguj tylko dla pierwszych użytkowników
            debug_print(f"Ikony dla {user_id}, {date_str}: {result} (na podstawie {len(events)} aktywnych zdarzeń)")
        
        return result

    def invalidate_specific_icons(self, user_date_pairs):
        """
        POPRAWIONA WERSJA: Wyczyść cache i wymuś przeładowanie
        """
        if not user_date_pairs:
            return
            
        # Wyczyść cache dla zmienionych miesięcy
        months_to_clear = set()
        for user_id, date_str in user_date_pairs:
            try:
                year, month, _ = date_str.split('-')
                months_to_clear.add((int(year), int(month)))
            except:
                continue
        
        # KLUCZOWE: Wyczyść cały cache miesięczny dla zmienionych miesięcy
        for year, month in months_to_clear:
            month_key = (year, month)
            if month_key in self.monthly_cache:
                del self.monthly_cache[month_key]
            if month_key in self._icons_cache_by_month:
                del self._icons_cache_by_month[month_key]
            
            debug_print(f"Wyczyszczono kompletny cache dla {year}-{month}")
        
        # Emituj sygnał odświeżenia
        for year, month in months_to_clear:
            self.data_changed.emit("icons", year, month)

    def invalidate_icons_cache(self, year: int, month: int):
        """
        ZMODYFIKOWANA: Czyści cache ikon dla miesiąca - BEZ NADMIERNEGO ODŚWIEŻANIA
        Używana tylko przy pełnym odświeżeniu danych (start, zmiana miesiąca, przycisk odśwież)
        """
        month_key = (year, month)
        
        # Wyczyść cache ikon
        if month_key in self._icons_cache_by_month:
            del self._icons_cache_by_month[month_key]
            debug_print(f"Wyczyszczono cache ikon dla {year}-{month}")
        
        # Odśwież dane zdarzeń w kontenerze
        if month_key in self.monthly_cache:
            container = self.monthly_cache[month_key]
            
            try:
                fresh_events = self._fetch_events_data(year, month)
                fresh_events_cache = self._build_events_cache(fresh_events)
                
                container.events_data = fresh_events
                container.events_cache = fresh_events_cache
                container.last_updated = time.time()
                
                debug_print(f"Odświeżono dane zdarzeń dla {year}-{month}")
                
            except Exception as e:
                log_error(f"Błąd podczas odświeżania zdarzeń dla {year}-{month}: {e}")
                if month_key in self.monthly_cache:
                    del self.monthly_cache[month_key]
        
        self.data_changed.emit("icons", year, month)

    def _get_or_load_monthly_data(self, year: int, month: int, use_cache: bool = True) -> Optional[MonthlyDataContainer]:
        """
        UPROSZCZONA WERSJA: Bez automatycznego wygasania cache
        """
        self._current_year = year
        self._current_month = month

        cache_key = (year, month)

        # Jeśli użytkownik chce użyć cache i istnieje - użyj go
        if use_cache and cache_key in self.monthly_cache:
            container = self.monthly_cache[cache_key]
            # ZMIANA: Zawsze zwróć cache jeśli istnieje (bez sprawdzania czasu)
            if not hasattr(self, '_last_cache_log') or time.time() - self._last_cache_log > 30:
                debug_print(f"Używam cache'owanych danych dla {year}-{month}")
                self._last_cache_log = time.time()
            return container

        # Ładuj dane tylko gdy:
        # 1. Nie ma cache (pierwszy raz)
        # 2. Użytkownik wymusił odświeżenie (use_cache=False)
        debug_print(f"Ładuję {'świeże' if cache_key in self.monthly_cache else 'nowe'} dane dla {year}-{month}")
        
        try:
            schedule_data = self._fetch_schedule_data(year, month)
            events_data = self._fetch_events_data(year, month)
            events_cache = self._build_events_cache(events_data)
            processed_data = self._build_processed_data_without_icons(schedule_data)

            container = MonthlyDataContainer(
                schedule_data=schedule_data,
                events_data=events_data,
                processed_data=processed_data,
                events_cache=events_cache,
                last_updated=time.time()  # Zachowaj dla informacji, ale nie używaj do wygasania
            )

            self.monthly_cache[cache_key] = container

            debug_print(f"Załadowano dane: {len(schedule_data)} wierszy grafiku, "
                        f"{len(events_data)} zdarzeń, {len(processed_data)} użytkowników")

            return container

        except Exception as e:
            log_error(f"Błąd podczas ładowania danych dla {year}-{month}: {e}", exception=e)
            return None
        
    def get_schedule_data(self, year: int, month: int, use_cache: bool = True) -> List[Any]:
        """Pobiera dane grafiku"""
        container = self._get_or_load_monthly_data(year, month, use_cache)
        return container.schedule_data if container else []

    def get_events_data(self, year: int, month: int, use_cache: bool = True,
                        as_dict: bool = True, build_index: bool = True) -> List[Dict]:
        """Pobiera dane zdarzeń"""
        container = self._get_or_load_monthly_data(year, month, use_cache)
        return container.events_data if container else []

    def get_processed_data(self, year: int, month: int) -> Dict:
        """Zwraca processed_data z dynamicznie obliczonymi ikonami"""
        container = self._get_or_load_monthly_data(year, month)
        if not container:
            return {}

        if not hasattr(container, '_icons_calculated'):
            self._update_dynamic_icons(container.processed_data, container.events_cache)
            container._icons_calculated = True
            debug_print("Obliczono ikony dynamicznie (pierwszy raz)")

        return container.processed_data

    def refresh_data(self, year: int, month: int):
        """
        PRZYCISK "Odśwież dane" - jedyny sposób na wymuszone przeładowanie
        """
        cache_key = (year, month)
        
        debug_print(f"UŻYTKOWNIK wymusza odświeżenie danych dla {year}-{month}")
        
        # Usuń cache dla tego miesiąca
        if cache_key in self.monthly_cache:
            del self.monthly_cache[cache_key]
        
        # Usuń cache ikon dla tego miesiąca  
        if cache_key in self._icons_cache_by_month:
            del self._icons_cache_by_month[cache_key]

        # Wymuś przeładowanie
        container = self._get_or_load_monthly_data(year, month, use_cache=False)

        if container:
            self.data_changed.emit("schedule", year, month)
            self.data_changed.emit("events", year, month)
            self.data_changed.emit("icons", year, month)

    def _update_dynamic_icons(self, processed_data: Dict, events_cache: Dict):
        """
        ZOPTYMALIZOWANA WERSJA: Batch processing ikon
        """
        debug_print("Obliczam ikony dynamicznie (BATCH PROCESSING)...")

        # OPTYMALIZACJA: Przygotuj batch operacje
        icon_updates = {}  # {(user_id, day): {'spotkania': bool, 'szkolenia': bool, 'nadgodziny': bool}}

        for key, user_data in processed_data.items():
            user_id = key[3]
            days_data = user_data.get('days', {})

            for day, day_data in days_data.items():
                date_str = f"{self._current_year}-{self._current_month:02d}-{day:02d}"
                cache_key = (user_id, date_str)
                events = events_cache.get(cache_key, [])

                # Filtruj aktywne zdarzenia
                active_events = [e for e in events if str(e.get('status', '1')) != '0']

                # Sprawdź typy zdarzeń w jednym przejściu
                has_spotkania = False
                has_szkolenia = False
                has_nadgodziny = False

                for event in active_events:
                    event_type = event.get('type')
                    if event_type == 'Spotkanie':
                        has_spotkania = True
                    elif event_type == 'Szkolenie':
                        has_szkolenia = True
                    elif event_type == 'Nadgodziny':
                        has_nadgodziny = True

                # Zapisz aktualizacje
                icon_updates[(user_id, day)] = {
                    'spotkania': has_spotkania,
                    'szkolenia': has_szkolenia,
                    'nadgodziny': has_nadgodziny,
                    'active_events': active_events
                }

        # BATCH UPDATE: Aplikuj wszystkie zmiany na raz
        debug_print(f"Aplikuję {len(icon_updates)} aktualizacji ikon...")

        for key, user_data in processed_data.items():
            user_id = key[3]
            days_data = user_data.get('days', {})

            for day, day_data in days_data.items():
                update_key = (user_id, day)
                if update_key in icon_updates:
                    updates = icon_updates[update_key]
                    day_data['spotkania'] = 1 if updates['spotkania'] else 0
                    day_data['szkolenia'] = 1 if updates['szkolenia'] else 0
                    day_data['nadgodziny'] = 1 if updates['nadgodziny'] else 0
                    day_data['events'] = updates['active_events']

        debug_print(f"Zakończono batch processing ikon dla {len(icon_updates)} komórek")

    def get_performance_stats(self):
        """
        NOWA METODA: Zwraca statystyki wydajności
        """
        stats = {
            'monthly_cache_size': len(self.monthly_cache),
            'icons_cache_size': len(self._icons_cache_by_month),
            'total_memory_mb': 0  # Można dodać rzeczywiste pomiary pamięci
        }

        # Dodaj statystyki cache symboli
        try:
            from symbol_parser import get_cache_info
            stats['symbol_cache'] = get_cache_info()
        except:
            stats['symbol_cache'] = "Niedostępne"

        return stats

    def _build_processed_data_without_icons(self, schedule_data: List[Any]) -> Dict:
        """
        ZOPTYMALIZOWANA WERSJA: Buduje processed_data z batch processing symboli
        """
        debug_print(f"Rozpoczynam przetwarzanie {len(schedule_data)} wierszy grafiku (ZOPTYMALIZOWANE)")

        processed_data = {}

        # NOWA OPTYMALIZACJA 1: Batch processing symboli
        # Zbierz wszystkie unikalne symbole
        unique_symbols = set()
        for row in schedule_data:
            try:
                mapped_row = self.column_mapper.map_schedule_row_to_dict(row)
                symbol = mapped_row.get('symbol', '')
                if symbol:
                    unique_symbols.add(symbol)
            except:
                continue

        # Parsuj symbole w batchu
        debug_print(f"Parsowanie {len(unique_symbols)} unikalnych symboli w batchu...")
        symbols_cache = parse_symbols_batch(list(unique_symbols))

        debug_print(f"Cache symboli utworzony: {len(symbols_cache)} wpisów")

        # NOWA OPTYMALIZACJA 2: Przetwarzanie wierszy z cache symboli
        for row in schedule_data:
            try:
                mapped_row = self.column_mapper.map_schedule_row_to_dict(row)

                wydzial = mapped_row.get('wydzial', '')
                przelozony = mapped_row.get('przelozony', '')
                przelozony_imie_nazwisko = mapped_row.get('przelozony_imie_nazwisko', '')
                uzytkownik_dane = mapped_row.get('uzytkownik_dane', '')
                uzytkownik_id = mapped_row.get('uzytkownik_id', 0)
                nr_kadrowy = mapped_row.get('nr_kadrowy', '')
                data_str = mapped_row.get('data_str', '')
                symbol = mapped_row.get('symbol', '')

                id_wpisu = mapped_row.get('id_wpisu', '')
                rola_nazwa = mapped_row.get('rola_nazwa', '')
                pod_rola_nazwa = mapped_row.get('pod_rola_nazwa', '')
                etat = mapped_row.get('etat', '')
                jezyk = mapped_row.get('jezyk', '')
                korekta = mapped_row.get('korekta', '')
                dtn = mapped_row.get('dtn', '')
                lokalizacja_domyslna = mapped_row.get('lokalizacja_domyslna', '')

                # OPTYMALIZACJA: Użyj cache symboli zamiast parsowania za każdym razem
                if symbol and symbol in symbols_cache:
                    parsed_symbol = symbols_cache[symbol]
                else:
                    # Fallback - parsuj bezpośrednio jeśli nie ma w cache
                    from symbol_parser import parse_symbol
                    parsed_symbol = parse_symbol(symbol)

                start_hour = parsed_symbol.get('start_hour')
                hours = parsed_symbol.get('work_hours')

                key = (wydzial, przelozony, uzytkownik_dane, uzytkownik_id)

                if key not in processed_data:
                    processed_data[key] = {
                        'days': {},
                        'total_hours': 0,
                        'rola_nazwa': rola_nazwa,
                        'pod_rola_nazwa': pod_rola_nazwa,
                        'etat': etat,
                        'jezyk': jezyk,
                        'korekta': korekta,
                        'dtn': dtn,
                        'przelozony_imie_nazwisko': przelozony_imie_nazwisko,
                        'nr_kadrowy': nr_kadrowy,
                        'lokalizacja_domyslna': lokalizacja_domyslna
                    }

                if data_str:
                    day = int(data_str.split('-')[2])

                    processed_data[key]['days'][day] = {
                        'symbol': symbol,
                        'hours': hours if hours is not None else 0,
                        'id': id_wpisu,
                        'start_hour': start_hour,
                        'nr_kadrowy': nr_kadrowy,
                        'spotkania': 0,  # Placeholder - będzie obliczone dynamicznie
                        'szkolenia': 0,  # Placeholder
                        'nadgodziny': 0,  # Placeholder
                        'events': []  # Placeholder
                    }

                    if hours is not None:
                        processed_data[key]['total_hours'] += hours

            except Exception as e:
                log_error(f"Błąd podczas przetwarzania wiersza: {e}")
                continue

        debug_print(f"OPTYMALIZACJA: Przetworzono {len(processed_data)} użytkowników z cache symboli")
        return processed_data

    @lru_cache(maxsize=100)
    def _get_month_cache_key(self, year: int, month: int) -> tuple:
        """Cache key dla miesiąca"""
        return (year, month)

    def clear_symbol_cache(self):
        """
        NOWA METODA: Czyści cache symboli gdy jest za duży
        """
        try:
            from symbol_parser import clear_symbol_cache, get_cache_info

            cache_info = get_cache_info()
            debug_print(f"Cache symboli przed czyszczeniem: {cache_info}")

            # Wyczyść cache jeśli jest za duży
            parse_cache = cache_info.get('parse_symbol')
            if parse_cache and parse_cache.currsize > 1500:  # Jeśli cache > 1500 wpisów
                clear_symbol_cache()
                debug_print("Wyczyszczono cache symboli (był za duży)")

        except Exception as e:
            log_error(f"Błąd czyszczenia cache symboli: {e}")

    def get_events_for_user_date(self, user_id: int, date_str: str) -> List[Dict]:
        """
        ZOPTYMALIZOWANA WERSJA: Lepsze cache i walidacja
        """
        # Szybka walidacja
        if not date_str or not user_id or date_str.count('-') != 2:
            return []

        try:
            year, month, _ = date_str.split('-')
            year, month = int(year), int(month)
        except (ValueError, TypeError):
            return []

        # Optymalizacja: użyj cached month key
        month_key = self._get_month_cache_key(year, month)

        # Pobierz kontener z cache
        container = self.monthly_cache.get(month_key)
        if not container:
            # Spróbuj załadować dane
            container = self._get_or_load_monthly_data(year, month)
            if not container:
                return []

        cache_key = (user_id, self._standardize_date(date_str))
        events = container.events_cache.get(cache_key, [])

        # OPTYMALIZACJA: Filtruj w jednym przejściu
        active_events = []
        for event in events:
            status = str(event.get('status', '1'))
            if status != '0':  # Tylko aktywne zdarzenia
                active_events.append(event)

        # Debug tylko dla pierwszych wywołań
        if user_id <= 10 and len(events) != len(active_events):
            debug_print(
                f"DataProvider: Przefiltrowano {len(events)} -> {len(active_events)} aktywnych zdarzeń dla ({user_id}, {date_str})")

        return active_events

    def _fetch_schedule_data(self, year: int, month: int) -> List[Any]:
        """Pobiera dane grafiku z bazy"""
        query = """
        SELECT * FROM [dbo].[fn_GetScheduleData](?, ?) 
        ORDER BY WydzialGrafik, PrzelozonyDane, UzytkownikDane, Data
        """

        conn = self.db_connector.get_connection()
        cursor = conn.cursor()
        cursor.execute(query, (year, month))
        schedule_data = cursor.fetchall()
        conn.close()

        return schedule_data

    def _fetch_events_data(self, year: int, month: int) -> List[Dict]:
        """Pobiera wszystkie zdarzenia miesiąca"""
        query = """
        SELECT * FROM [dbo].[fn_GetEventsData](?, ?) 
        """

        conn = self.db_connector.get_connection()
        cursor = conn.cursor()
        cursor.execute(query, (year, month))
        raw_events = cursor.fetchall()
        conn.close()

        events_dicts = []
        for row in raw_events:
            try:
                event = self.column_mapper.map_events_row_to_dict(row)

                if 'event_type' in event:
                    event['type'] = event['event_type']
                if 'event_id' in event:
                    event['id'] = event['event_id']

                raw_date = event.get('date', '')
                if hasattr(raw_date, 'strftime'):
                    event['date_display'] = raw_date.strftime('%d.%m.%Y')
                    event['date_key'] = raw_date.strftime('%Y-%m-%d')
                elif isinstance(raw_date, str) and raw_date:
                    event['date_display'] = self._format_date_display(raw_date)
                    event['date_key'] = self._standardize_date(raw_date)

                time_from = event.get('time_from')
                time_to = event.get('time_to')

                if hasattr(time_from, 'strftime'):
                    event['time_from'] = time_from.strftime('%H:%M')
                elif isinstance(time_from, str) and 'T' in time_from:
                    event['time_from'] = time_from.split(' ')[1][:5]
                elif time_from:
                    event['time_from'] = str(time_from)

                if hasattr(time_to, 'strftime'):
                    event['time_to'] = time_to.strftime('%H:%M')
                elif isinstance(time_to, str) and 'T' in time_to:
                    event['time_to'] = time_to.split(' ')[1][:5]
                elif time_to:
                    event['time_to'] = str(time_to)

                if event.get('type') and event.get('id') is not None:
                    events_dicts.append(event)

            except Exception as e:
                log_error(f"Błąd konwersji zdarzenia: {e}")
                continue

        return events_dicts

    def _build_events_cache(self, events_data: List[Dict]) -> Dict[Tuple[int, str], List[Dict]]:
        """Buduje cache zdarzeń"""
        events_cache = {}

        for event in events_data:
            user_id = event.get('user_id')
            date_key = self._standardize_date(event.get('date_key', ''))

            if user_id and date_key:
                cache_key = (user_id, date_key)
                if cache_key not in events_cache:
                    events_cache[cache_key] = []
                events_cache[cache_key].append(event)

        return events_cache

    def clear_cache(self):
        """
        Tylko do czyszczenia przy STARCIE aplikacji lub ZMIANIE miesiąca
        """
        cache_count = len(self.monthly_cache)
        icons_count = len(self._icons_cache_by_month)
        
        self.monthly_cache.clear()
        self._icons_cache_by_month.clear()
        
        debug_print(f"Wyczyszczono cache przy starcie/zmianie miesiąca: {cache_count} miesięcy, {icons_count} cache ikon")

    def on_month_change(self, new_year: int, new_month: int):
        """
        NOWA METODA: Wywoływana przy zmianie miesiąca w interface
        """
        debug_print(f"ZMIANA MIESIĄCA na {new_year}-{new_month}")
        
        # Przy zmianie miesiąca możemy wyczyścić cache innych miesięcy żeby oszczędzić pamięć
        # ale ZACHOWAĆ cache aktualnego miesiąca jeśli istnieje
        current_key = (new_year, new_month)
        
        # Zachowaj cache aktualnego miesiąca
        current_cache = self.monthly_cache.get(current_key)
        current_icons = self._icons_cache_by_month.get(current_key, {})
        
        # Wyczyść wszystkie inne
        self.monthly_cache.clear()
        self._icons_cache_by_month.clear()
        
        # Przywróć cache aktualnego miesiąca jeśli istniał
        if current_cache:
            self.monthly_cache[current_key] = current_cache
            self._icons_cache_by_month[current_key] = current_icons
            debug_print(f"Zachowano cache dla aktualnego miesiąca {new_year}-{new_month}")
        
        debug_print(f"Wyczyszczono cache przy zmianie miesiąca, pozostawiono cache dla {new_year}-{new_month}")

    def _format_date_display(self, date_str: str) -> str:
        """Formatuje datę z YYYY-MM-DD na DD.MM.YYYY"""
        if not date_str:
            return ""
        try:
            if '-' in date_str and len(date_str.split('-')) == 3:
                year, month, day = date_str.split('-')
                return f"{day}.{month}.{year}"
        except Exception as e:
            log_warning(f"Błąd formatowania daty: {e}")
        return date_str

    def _standardize_date(self, date_obj) -> str:
        """Standaryzuje format daty do 'YYYY-MM-DD'"""
        if not date_obj:
            return ''

        if isinstance(date_obj, str):
            if 'T' in date_obj:
                return date_obj.split('T')[0]
            elif ' ' in date_obj:
                return date_obj.split(' ')[0]
            elif len(date_obj) == 10 and date_obj.count('-') == 2:
                return date_obj
            elif len(date_obj) == 10 and date_obj.count('.') == 2:
                parts = date_obj.split('.')
                if len(parts) == 3:
                    return f"{parts[2]}-{parts[1]}-{parts[0]}"
            return date_obj

        if hasattr(date_obj, 'strftime'):
            return date_obj.strftime('%Y-%m-%d')

        return ''
    


    def invalidate_complete_cache_for_pairs(self, user_date_pairs):
        """
        NOWA METODA: Kompletne czyszczenie cache dla par (user_id, date_str)
        Usuwa z wszystkich poziomów cache'owania
        """
        if not user_date_pairs:
            return
            
        # Wyczyść cache miesięczny
        months_to_clear = set()
        for user_id, date_str in user_date_pairs:
            try:
                year, month, _ = date_str.split('-')
                months_to_clear.add((int(year), int(month)))
            except:
                continue
        
        # Wyczyść kompletny cache miesięczny
        for year, month in months_to_clear:
            month_key = (year, month)
            if month_key in self.monthly_cache:
                # Usuń z kontenera miesięcznego
                container = self.monthly_cache[month_key]
                
                # Przebuduj events_cache bez usuniętych zdarzeń
                new_events_cache = {}
                for cache_key, events in container.events_cache.items():
                    if cache_key not in user_date_pairs:
                        new_events_cache[cache_key] = events
                
                container.events_cache = new_events_cache
                container.last_updated = time.time()
            
            # Wyczyść cache ikon
            if month_key in self._icons_cache_by_month:
                month_icons = self._icons_cache_by_month[month_key]
                for user_id, date_str in user_date_pairs:
                    cell_key = (user_id, date_str)
                    if cell_key in month_icons:
                        del month_icons[cell_key]
        
        debug_print(f"Kompletnie wyczyszczono cache dla {len(user_date_pairs)} par")
