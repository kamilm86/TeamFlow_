# schedule_edit_dialogs.py
from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel,
                               QPushButton, QComboBox, QGroupBox, QRadioButton,
                               QFontComboBox, QSpinBox, QCheckBox, QWidget,
                               QTabWidget, QGridLayout, QMessageBox, QLineEdit,
                               QApplication, QSpacerItem, QSizePolicy,
                               QTableWidget, QTableWidgetItem, QHeaderView, QDialogButtonBox)
from PySide6.QtCore import Qt, Signal, QTimer, QDate
from PySide6.QtGui import QFont, QColor
from styles import AppStyles
from debug_utils import debug_print, log_error
from app_settings import app_settings
from db_connector import get_modifier_id

class DateTableWidgetItem(QTableWidgetItem):
    """Niestandardowy element tabeli do sortowania dat chronologicznie."""
    def __init__(self, date_str):
        # Format wyświetlania: DD.MM.YYYY
        super().__init__(QDate.fromString(date_str, "yyyy-MM-dd").toString("dd.MM.yyyy"))
        # Przechowujemy obiekt QDate do poprawnego sortowania
        self.date = QDate.fromString(date_str, "yyyy-MM-dd")

    def __lt__(self, other):
        # Porównaj obiekty QDate zamiast tekstu
        return self.date < other.date

class DayOfWeekItem(QTableWidgetItem):
    """Niestandardowy element tabeli do sortowania dni tygodnia."""
    def __init__(self, qdate_obj):
        day_names = ["Pon", "Wt", "Śr", "Czw", "Pt", "Sob", "Nd"]
        super().__init__(day_names[qdate_obj.dayOfWeek() - 1])
        # Przechowujemy numer dnia tygodnia (1-7) do sortowania
        self.day_of_week = qdate_obj.dayOfWeek()

    def __lt__(self, other):
        # Porównaj numery dni tygodnia
        return self.day_of_week < other.day_of_week

class ThemeSettingsDialog(QDialog):
    """
    Dialog do wyboru ustawień motywu aplikacji.
    """
    settings_changed = Signal(str, str, int)

    def __init__(self, parent=None, current_theme="dark", current_font="", current_font_size=9):
        super().__init__(parent)
        self.parent_widget = parent  # Zapisz rodzica

        self.setWindowTitle("Ustawienia motywu")
        self.setMinimumWidth(300)

        self.current_theme = current_theme
        self.current_font = current_font
        self.current_font_size = current_font_size

        self.setup_ui()  # Najpierw UI
        self.apply_dialog_theme()  # Potem styl zgodny z przekazanym/rodzica

        # Podłączenie sygnałów do natychmiastowej zmiany - PO setup_ui i apply_dialog_theme
        self.dark_theme_radio.toggled.connect(self.apply_immediate_changes)
        # Unikamy podwójnego wywołania przy przełączaniu radio, wystarczy jeden sygnał
        # self.light_theme_radio.toggled.connect(self.apply_immediate_changes)
        self.font_combo.currentFontChanged.connect(self.apply_immediate_changes)
        self.font_size_spin.valueChanged.connect(self.apply_immediate_changes)

    def apply_dialog_theme(self):  # Ta metoda stylizuje dialog na podstawie motywu rodzica lub current_theme
        """Stosuje motyw dla samego okna dialogowego."""
        theme_to_apply = self.current_theme  # Domyślnie użyj przekazanego motywu

        # Jeśli dialog ma rodzica i rodzic ma informację o motywie, użyj jej
        # To jest na wypadek, gdyby current_theme nie było zsynchronizowane
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            theme_to_apply = "dark" if self.parent_widget.is_dark_theme else "light"

        # Jeśli aktualnie wybrane radio buttony wskazują inny motyw, użyj go
        # To jest kluczowe dla odświeżania "na żywo"
        if hasattr(self, 'dark_theme_radio') and self.dark_theme_radio.isChecked():
            theme_to_apply = "dark"
        elif hasattr(self, 'light_theme_radio') and self.light_theme_radio.isChecked():
            theme_to_apply = "light"

        self.setStyleSheet(AppStyles.get_dialog_style(theme_to_apply))

        # Odśwież style przycisków w dialogu, bo get_dialog_style ich nie obejmuje
        button_style = AppStyles.get_button_style(theme_to_apply)
        if hasattr(self, 'ok_button'): self.ok_button.setStyleSheet(button_style)
        if hasattr(self, 'cancel_button'): self.cancel_button.setStyleSheet(button_style)

    def setup_ui(self):  # Tutaj tylko tworzymy widgety
        main_layout = QVBoxLayout(self)

        theme_group = QGroupBox("Motyw")
        theme_layout = QVBoxLayout()
        self.dark_theme_radio = QRadioButton("Ciemny")
        self.light_theme_radio = QRadioButton("Jasny")

        if self.current_theme == "dark":
            self.dark_theme_radio.setChecked(True)
        else:  # Domyślnie lub jeśli light
            self.light_theme_radio.setChecked(True)

        theme_layout.addWidget(self.dark_theme_radio)
        theme_layout.addWidget(self.light_theme_radio)
        theme_group.setLayout(theme_layout)

        font_group = QGroupBox("Czcionka")
        font_layout = QVBoxLayout()
        font_type_layout = QHBoxLayout()
        font_type_label = QLabel("Typ czcionki:")
        self.font_combo = QFontComboBox()
        if self.current_font:
            self.font_combo.setCurrentFont(QFont(self.current_font))
        font_type_layout.addWidget(font_type_label)
        font_type_layout.addWidget(self.font_combo)

        font_size_layout = QHBoxLayout()
        font_size_label = QLabel("Rozmiar czcionki:")
        self.font_size_spin = QSpinBox()
        self.font_size_spin.setRange(6, 24)
        self.font_size_spin.setValue(self.current_font_size)
        font_size_layout.addWidget(font_size_label)
        font_size_layout.addWidget(self.font_size_spin)

        font_layout.addLayout(font_type_layout)
        font_layout.addLayout(font_size_layout)
        font_group.setLayout(font_layout)

        self.save_settings_checkbox = QCheckBox("Zapamiętaj ustawienia")
        self.save_settings_checkbox.setChecked(True)

        buttons_layout = QHBoxLayout()
        self.ok_button = QPushButton("OK")
        self.cancel_button = QPushButton("Anuluj")

        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

        buttons_layout.addStretch()
        buttons_layout.addWidget(self.ok_button)
        buttons_layout.addWidget(self.cancel_button)

        main_layout.addWidget(theme_group)
        main_layout.addWidget(font_group)
        main_layout.addWidget(self.save_settings_checkbox)
        main_layout.addLayout(buttons_layout)

    def apply_immediate_changes(self):
        """Aplikuje zmiany natychmiastowo podczas wybierania opcji W TYM SAMYM DIALOGU"""
        if not hasattr(self, 'font_combo') or not hasattr(self, 'font_size_spin') or not hasattr(self,
                                                                                                 'dark_theme_radio'):
            return

        selected_theme = "dark" if self.dark_theme_radio.isChecked() else "light"
        font_family = self.font_combo.currentFont().family()
        font_size = self.font_size_spin.value()

        # Emituj sygnał dla głównego okna, aby ono zaktualizowało swoje style
        self.settings_changed.emit(selected_theme, font_family, font_size)

        # Zaktualizuj styl samego dialogu ThemeSettingsDialog "na żywo"
        # Musimy przekazać wybrany motyw, a niekoniecznie ten z rodzica
        # (bo właśnie go zmieniamy)
        current_dialog_theme_choice = self.get_current_theme_choice()  # Użyj wyboru z radio buttonów

        # Zastosuj pełny styl dialogu na nowo
        self.setStyleSheet(AppStyles.get_dialog_style(current_dialog_theme_choice))

        # Zastosuj style dla przycisków, które nie są objęte get_dialog_style
        button_style = AppStyles.get_button_style(current_dialog_theme_choice)
        if hasattr(self, 'ok_button'): self.ok_button.setStyleSheet(button_style)
        if hasattr(self, 'cancel_button'): self.cancel_button.setStyleSheet(button_style)

        # Może być konieczne odświeżenie stylów dla kontrolek wewnątrz groupboxów,
        # jeśli dziedziczenie nie zadziała idealnie po zmianie głównego stylu dialogu.
        # Na przykład:
        # self.font_combo.setStyleSheet(AppStyles.get_combobox_style(current_dialog_theme_choice))
        # self.font_size_spin.setStyleSheet(AppStyles.get_line_edit_style(current_dialog_theme_choice)) # SpinBox często dziedziczy styl LineEdit
        # self.dark_theme_radio.setStyleSheet(AppStyles.get_checkbox_style(current_dialog_theme_choice)) # RadioButton często jak CheckBox
        # self.light_theme_radio.setStyleSheet(AppStyles.get_checkbox_style(current_dialog_theme_choice))
        # To jest bardziej granularne i może być potrzebne, jeśli prosty self.setStyleSheet() nie wystarczy.

        # Dla pewności można wymusić odświeżenie wyglądu, choć zmiana stylesheetu powinna to zrobić.
        self.update()

    def get_current_theme_choice(self):  # Zmieniono nazwę, aby odróżnić od current_theme przy inicjalizacji
        """Zwraca nazwę aktualnie wybranego motywu w tym dialogu."""
        if hasattr(self, 'dark_theme_radio') and self.dark_theme_radio.isChecked():
            return "dark"
        elif hasattr(self, 'light_theme_radio') and self.light_theme_radio.isChecked():
            return "light"
        # Fallback na current_theme, jeśli radio buttony nie są jeszcze dostępne
        return self.current_theme


class InsertSymbolDialog(QDialog):
    """Dialog do wyboru symbolu z kontekstowym blokowaniem opcji."""
    symbol_selected = Signal(str)

    # ZMIANA: Dodano argument 'selected_cells_data'
    def __init__(self, parent=None, selected_cells_data=None):
        super().__init__(parent)
        self.parent_widget = parent
        self.setWindowTitle("Wstaw symbol")
        self.setMinimumWidth(300)
        self.setMinimumHeight(250)

        self.selected_symbol = ""
        self.user_role = getattr(self.parent_widget, 'current_user_role', "")
        self.valid_symbols = set()
        self.parent_font = QApplication.font()
        if self.parent_widget: self.parent_font = self.parent_widget.font()

        # --- NOWA LOGIKA: Sprawdź, czy włączamy tryb "Tylko CO dla DTN" ---
        self.dtn_co_only_mode = False
        if self.user_role in ['Lider', 'Lider OUT'] and selected_cells_data:
            # Sprawdź, czy WSZYSTKIE zaznaczone komórki należą do wydziału DTN
            if all(cell.get('wydzial', '').strip().lower() == 'dtn' for cell in selected_cells_data):
                self.dtn_co_only_mode = True
        # --- KONIEC NOWEJ LOGIKI ---

        self.setup_ui()
        self.apply_dialog_theme()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu InsertSymbolDialog."""
        actual_theme = "dark"
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            actual_theme = "dark" if self.parent_widget.is_dark_theme else "light"

        # debug_print(f"InsertSymbolDialog ('{self.windowTitle()}'): Stosuję motyw '{actual_theme}'")

        # Ustaw ogólny styl dialogu (powinien zawierać QDialog#InsertSymbolDialogInstance)
        self.setStyleSheet(AppStyles.get_dialog_style(actual_theme))

        # Styl dla przycisków i innych kontrolek w tym dialogu
        button_style_qss = AppStyles.get_button_style(actual_theme)
        line_edit_style_qss = AppStyles.get_line_edit_style(actual_theme)
        tab_widget_style_qss = self._get_tab_widget_style(actual_theme)  # Dedykowana metoda dla QTabWidget

        if hasattr(self, 'symbol_input'):
            self.symbol_input.setStyleSheet(line_edit_style_qss)

        if hasattr(self, 'tabs'):
            self.tabs.setStyleSheet(tab_widget_style_qss)
            # Można dodatkowo ostylować przyciski wewnątrz zakładek, jeśli to konieczne
            # i jeśli nie dziedziczą poprawnie stylu z button_style_qss
            for i in range(self.tabs.count()):
                tab_content_widget = self.tabs.widget(i)
                if tab_content_widget:
                    buttons_in_tab = tab_content_widget.findChildren(QPushButton)
                    for btn in buttons_in_tab:
                        btn.setStyleSheet(button_style_qss)  # Użyj głównego stylu przycisków
                        # lub dedykowanego mniejszego stylu

        if hasattr(self, 'cancel_button'):
            self.cancel_button.setStyleSheet(button_style_qss)

        # Styl dla etykiet, jeśli potrzeba specyficznego
        label_style_qss = AppStyles.get_label_style(actual_theme)
        if hasattr(self, 'instruction_label'): self.instruction_label.setStyleSheet(label_style_qss)
        if hasattr(self, 'input_label'): self.input_label.setStyleSheet(label_style_qss)
        if hasattr(self, 'validation_label'): self.validation_label.setStyleSheet(label_style_qss)

        self.style().unpolish(self)
        self.style().polish(self)
        self.update()

    def _get_tab_widget_style(self, theme):
        """Zwraca styl dla QTabWidget i QTabBar zgodny z motywem."""
        # Pobierz kolory z AppStyles
        main_bg = AppStyles.DARK_BACKGROUND_MAIN if theme == "dark" else AppStyles.LIGHT_BACKGROUND_MAIN
        control_bg = AppStyles.DARK_BACKGROUND_CONTROLS if theme == "dark" else AppStyles.LIGHT_BACKGROUND_CONTROLS
        text_color = AppStyles.DARK_TEXT_PRIMARY if theme == "dark" else AppStyles.LIGHT_TEXT_PRIMARY
        border_color = AppStyles.DARK_BORDER_SECONDARY if theme == "dark" else AppStyles.LIGHT_BORDER_PRIMARY
        accent_color = AppStyles.ACCENT_COLOR_DARK if theme == "dark" else AppStyles.ACCENT_COLOR_LIGHT

        # Dla jasnego motywu zakładki mogą mieć nieco inne tło niż sam dialog
        tab_bar_bg = control_bg if theme == "dark" else AppStyles.LIGHT_BACKGROUND_HOVER
        tab_pane_bg = control_bg  # Tło zawartości zakładki

        return f"""
            QTabWidget::pane {{
                border: 1px solid {border_color};
                border-top: none; /* Łączy się z QTabBar */
                background-color: {tab_pane_bg};
                border-bottom-left-radius: {AppStyles.BORDER_RADIUS};
                border-bottom-right-radius: {AppStyles.BORDER_RADIUS};
            }}
            QTabBar::tab {{
                background-color: {tab_bar_bg};
                color: {text_color};
                border: 1px solid {border_color};
                border-bottom: none; 
                padding: 5px 10px;
                margin-right: 1px;
                border-top-left-radius: {AppStyles.BORDER_RADIUS};
                border-top-right-radius: {AppStyles.BORDER_RADIUS};
            }}
            QTabBar::tab:selected {{
                background-color: {accent_color};
                color: {'white' if theme == "dark" else AppStyles.LIGHT_BACKGROUND_CONTROLS}; /* Poprawiony kolor tekstu dla jasnego motywu */
                /* border-bottom: 1px solid {accent_color}; */ /* Usuwamy, bo pane ma border-top */
            }}
            QTabBar::tab:!selected {{
                background-color: {main_bg if theme == "dark" else AppStyles.LIGHT_BACKGROUND_MAIN};
                 /* margin-top: 2px; */ /* Można usunąć dla płaskiego wyglądu */
            }}
            QTabBar::tab:hover:!selected {{
                background-color: {AppStyles.DARK_BACKGROUND_HOVER if theme == "dark" else AppStyles.LIGHT_BACKGROUND_HOVER};
            }}
        """

    def setup_ui(self):
        main_layout = QVBoxLayout(self)

        self.instruction_label = QLabel("Wpisz symbol lub wybierz z poniższych zakładek")
        self.instruction_label.setStyleSheet("color: gray; font-style: italic;")
        self.instruction_label.setFont(self.parent_font)
        main_layout.addWidget(self.instruction_label)

        input_layout = QHBoxLayout()
        self.input_label = QLabel("Symbol:")
        self.input_label.setFont(self.parent_font)

        self.symbol_input = QLineEdit()
        self.symbol_input.setMaxLength(5)
        font = QFont(self.parent_font)
        font.setBold(True)
        font.setPointSize(font.pointSize() + 2)
        self.symbol_input.setFont(font)
        self.symbol_input.textChanged.connect(self.on_symbol_input_changed)
        self.symbol_input.returnPressed.connect(self.check_and_accept)
        input_layout.addWidget(self.input_label)
        input_layout.addWidget(self.symbol_input)
        main_layout.addLayout(input_layout)

        self.tabs = QTabWidget()
        self.tabs.setFont(self.parent_font)

        # Dynamiczne tworzenie zakładek na podstawie ustawień z bazy
        self.valid_symbols.clear()
        symbol_categories = app_settings.SYMBOL_CATEGORIES

        # Tworzy wszystkie zakładki, a uprawnienia są sprawdzane dla każdego przycisku osobno
        for category_name, symbols_dict in symbol_categories.items():
            symbols_list = list(symbols_dict.items())
            self.add_tab_with_symbols(symbols_list, category_name)
            # Dodaje wszystkie symbole do listy walidacji (dla wpisywania ręcznego)
            for symbol_key in symbols_dict.keys():
                self.valid_symbols.add(symbol_key)

        buttons_layout = QHBoxLayout()
        self.cancel_button = QPushButton("Anuluj")
        self.cancel_button.setFont(self.parent_font)
        self.cancel_button.clicked.connect(self.reject)

        self.validation_label = QLabel("")
        self.validation_label.setFont(self.parent_font)

        buttons_layout.addWidget(self.validation_label)
        buttons_layout.addStretch()
        buttons_layout.addWidget(self.cancel_button)

        main_layout.addWidget(self.tabs)
        main_layout.addLayout(buttons_layout)
        self.symbol_input.setFocus()

    def add_tab_with_symbols(self, symbols, tab_name):
        """Dodaje zakładkę z symbolami, uwzględniając uprawnienia i tryb DTN."""
        tab = QWidget()
        tab_layout = QGridLayout(tab)
        tab_layout.setSpacing(5)

        for idx, (symbol, desc) in enumerate(symbols):
            button = QPushButton(symbol)
            button.setFont(self.parent_font)
            button.setProperty("symbol", symbol)
            button.setFocusPolicy(Qt.NoFocus)
            button.clicked.connect(self.on_symbol_button_clicked)

            # --- ZMIENIONA LOGIKA: Sprawdzanie uprawnień do symbolu ---
            is_generally_allowed = app_settings.has_symbol_permission(self.user_role, symbol)

            # Jeśli jest w trybie "tylko CO dla DTN", zablokuj wszystko oprócz CO
            if self.dtn_co_only_mode:
                if symbol.upper() == 'CO' and is_generally_allowed:
                    button.setEnabled(True)
                    button.setToolTip(desc)
                else:
                    button.setEnabled(False)
                    button.setToolTip(f"Dla wydziału DTN dozwolony jest tylko symbol 'CO'.")
            # W przeciwnym razie, działaj jak dotychczas
            elif is_generally_allowed:
                button.setEnabled(True)
                button.setToolTip(desc)
            else:
                button.setEnabled(False)
                button.setToolTip(f"{desc}\n(Brak uprawnień dla Twojej roli)")
            # --- KONIEC ZMIENIONEJ LOGIKI ---

            row = idx // 4
            col = idx % 4
            tab_layout.addWidget(button, row, col)

        tab_layout.addItem(QSpacerItem(10, 10, QSizePolicy.Expanding, QSizePolicy.Expanding), (len(symbols) // 4) + 1,
                           0, 1, 4)
        self.tabs.addTab(tab, tab_name)

    def on_symbol_button_clicked(self):
        """Obsługuje kliknięcie przycisku z symbolem"""
        button = self.sender()  # Pobierz obiekt, który wysłał sygnał
        if button:
            symbol = button.property("symbol")
            if symbol:
                self.accept_symbol(symbol)

    def on_symbol_input_changed(self, text):
        """Obsługuje zmianę symbolu wpisanego z klawiatury"""
        # Konwersja do dużych liter
        uppercase_text = text.upper()
        if text != uppercase_text:
            # Blokuj sygnał, aby uniknąć nieskończonej pętli
            self.symbol_input.blockSignals(True)
            self.symbol_input.setText(uppercase_text)
            self.symbol_input.blockSignals(False)

        self.selected_symbol = uppercase_text.strip()

        # Sprawdź, czy symbol jest na liście dostępnych
        if self.selected_symbol:
            if self.selected_symbol in self.valid_symbols:
                self.validation_label.setText("Symbol prawidłowy")
                self.validation_label.setStyleSheet("color: green;")
            else:
                self.validation_label.setText("Symbol niedostępny!")
                self.validation_label.setStyleSheet("color: red;")
        else:
            self.validation_label.setText("")

    def accept_symbol(self, symbol):
        """Akceptuje symbol i zamyka dialog"""
        self.selected_symbol = symbol

        # Blokuj sygnał, aby uniknąć wywołania on_symbol_input_changed
        self.symbol_input.blockSignals(True)
        self.symbol_input.setText(symbol)
        self.symbol_input.blockSignals(False)

        # Aktualizuj etykietę walidacji
        self.validation_label.setText("Symbol prawidłowy")
        self.validation_label.setStyleSheet("color: green;")

        # Wywołaj metodę sprawdzającą
        self.check_and_accept()

    def check_and_accept(self):
        """Sprawdza symbol i uprawnienia przed zamknięciem okna."""
        # --- POCZĄTEK ZMIANY: Dodatkowa walidacja uprawnień ---
        if self.selected_symbol and self.selected_symbol in self.valid_symbols:
            if app_settings.has_symbol_permission(self.user_role, self.selected_symbol):
                super().accept()
            else:
                QMessageBox.warning(self, "Brak uprawnień",
                                    f"Twoja rola ('{self.user_role}') nie ma uprawnień do użycia symbolu '{self.selected_symbol}'.",
                                    QMessageBox.Ok)
        # --- KONIEC ZMIANY ---
        elif self.selected_symbol:
            QMessageBox.warning(self, "Nieprawidłowy symbol",
                                f"Symbol '{self.selected_symbol}' nie jest poprawnym symbolem.", QMessageBox.Ok)
        else:
            QMessageBox.warning(self, "Brak symbolu", "Proszę wpisać lub wybrać symbol.", QMessageBox.Ok)

            self.selected_symbol = ""
            self.symbol_input.setText("")
            self.symbol_input.setFocus()

    def get_selected_symbol(self):
        """Zwraca wybrany symbol"""
        return self.selected_symbol


class ReasonDialog(QDialog):
    """Prosty dialog do wpisania i pobrania powodu zmiany."""

    def __init__(self, parent=None):
        super().__init__(parent)

        # --- POCZĄTEK POPRAWKI ---
        # Odwołujemy się do poprawnego atrybutu 'determined_theme' z okna nadrzędnego
        self.is_dark_theme = (parent.determined_theme == 'dark')
        # --- KONIEC POPRAWKI ---

        self.setWindowTitle("Powód zmiany lokalizacji")
        self.setMinimumWidth(350)

        layout = QVBoxLayout(self)
        layout.addWidget(QLabel("Proszę podać powód zmiany lokalizacji:"))

        self.reason_input = QLineEdit("Na prośbę doradcy")
        layout.addWidget(self.reason_input)

        self.button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        self.button_box.accepted.connect(self.accept)
        self.button_box.rejected.connect(self.reject)
        layout.addWidget(self.button_box)

        self.apply_styles()

    def getReason(self):
        """Zwraca tekst wpisany przez użytkownika."""
        return self.reason_input.text()

    def apply_styles(self):
        theme = "dark" if self.is_dark_theme else "light"
        self.setStyleSheet(AppStyles.get_dialog_style(theme))
        for button in self.button_box.buttons():
            button.setStyleSheet(AppStyles.get_button_style(theme))
        self.reason_input.setStyleSheet(AppStyles.get_line_edit_style(theme))


class ScheduleChangeDialog(QDialog):
    """Dialog do edycji zmian w grafiku"""

    def __init__(self, parent=None, grouped_cells=None, year=None, month=None):
        super().__init__(parent)
        self.parent_widget = parent
        self.determined_theme = "dark"
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            self.determined_theme = "dark" if self.parent_widget.is_dark_theme else "light"
        self.setWindowTitle("Wstaw zmianę grafiku")
        self.setMinimumWidth(1000)
        self.setMinimumHeight(600)
        self.grouped_cells = grouped_cells
        self.year = year
        self.month = month
        self.flattened_cells = self.flatten_grouped_cells(grouped_cells)
        self.user_role = getattr(self.parent_widget, 'current_user_role', "Użytkownik")
        self.default_button_style = AppStyles.get_button_style(self.determined_theme)
        self.reason_cache = {}
        self.setup_ui()
        self.apply_dialog_theme()

    def apply_dialog_theme(self):
        actual_theme = self.determined_theme
        self.setStyleSheet(AppStyles.get_dialog_style(actual_theme))

        # Pobierz style z centralnej klasy
        button_style = AppStyles.get_button_style(actual_theme)
        combobox_style = AppStyles.get_combobox_style(actual_theme)
        checkbox_style = AppStyles.get_checkbox_style(actual_theme)  # Pobierz styl dla checkboxów

        # Styl dla panelu "Zastosuj dla wszystkich"
        if hasattr(self, 'all_time_button'):
            self.all_time_button.setStyleSheet(button_style)
            self.all_hours_button.setStyleSheet(button_style)
            self.all_location_combo.setStyleSheet(combobox_style)

            # --- POCZĄTEK POPRAWKI ---
            # Zastosuj styl do checkboxów w tym panelu
            self.apply_location_check.setStyleSheet(checkbox_style)
            self.apply_time_check.setStyleSheet(checkbox_style)
            self.apply_hours_check.setStyleSheet(checkbox_style)
            # --- KONIEC POPRAWKI ---

            # Znajdź przycisk "Zastosuj dla wszystkich" wewnątrz grupy i zastosuj styl
            apply_all_button = self.findChild(QGroupBox).findChild(QPushButton)
            if apply_all_button:
                apply_all_button.setStyleSheet(button_style)

        # Styl dla przycisku "Zamknij"
        if hasattr(self, 'close_button'):
            self.close_button.setStyleSheet(button_style)

        # Style dla kontrolek w tabeli
        if hasattr(self, 'cells_table'):
            self.cells_table.setStyleSheet(AppStyles.get_tablewidget_style(actual_theme))
            for row in range(self.cells_table.rowCount()):
                for col_idx in [4, 5, 6, 7]:
                    widget = self.cells_table.cellWidget(row, col_idx)
                    if isinstance(widget, QComboBox):
                        widget.setStyleSheet(combobox_style)
                    elif isinstance(widget, QPushButton):
                        widget.setStyleSheet(button_style)

    def flatten_grouped_cells(self, grouped_cells):
        flattened = []
        if not grouped_cells: return flattened
        for user_id, dates in grouped_cells.items():
            for date, cells in dates.items():
                flattened.extend(cells)
        return flattened

    def _create_apply_all_group(self):
        group = QGroupBox("Zastosuj dla wszystkich (z uwzględnieniem uprawnień)")
        layout = QHBoxLayout()
        group.setLayout(layout)

        # Lokalizacja
        self.apply_location_check = QCheckBox("Lokalizacja:")
        layout.addWidget(self.apply_location_check)
        self.all_location_combo = QComboBox()
        self.all_location_combo.addItem("SBC (s)", "s")
        self.all_location_combo.addItem("Przystanek (p)", "p")
        self.all_location_combo.addItem("HomeOffice (h)", "h")
        layout.addWidget(self.all_location_combo)
        layout.addSpacing(15)

        # Godzina rozpoczęcia
        self.apply_time_check = QCheckBox("Godzina rozp.:")
        layout.addWidget(self.apply_time_check)
        self.all_time_button = QPushButton("Wybierz")
        self.all_time_button.setProperty("field_type", "hour")
        self.all_time_button.clicked.connect(self.show_digit_selection)  # <-- Ujednolicony sposób
        layout.addWidget(self.all_time_button)
        layout.addSpacing(15)

        # Liczba godzin
        self.apply_hours_check = QCheckBox("Liczba godzin:")
        layout.addWidget(self.apply_hours_check)
        self.all_hours_button = QPushButton("Wybierz")
        self.all_hours_button.setProperty("field_type", "hours")
        self.all_hours_button.clicked.connect(self.show_digit_selection)  # <-- Ujednolicony sposób
        layout.addWidget(self.all_hours_button)

        layout.addStretch()

        apply_all_button = QPushButton("Zastosuj dla wszystkich")
        apply_all_button.clicked.connect(self._apply_all_changes)
        layout.addWidget(apply_all_button)

        return group

    def setup_ui(self):
        main_layout = QVBoxLayout(self)
        apply_all_group = self._create_apply_all_group()
        main_layout.addWidget(apply_all_group)
        self.cells_table = QTableWidget()
        self.cells_table.setColumnCount(9)
        self.cells_table.setHorizontalHeaderLabels(
            ["Data", "Dzień tyg.", "Użytkownik", "Symbol", "Lokalizacja", "Godzina rozp.", "Liczba godzin", "Akcje",
             "Status"])
        self.cells_table.setSortingEnabled(True)
        self.cells_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.cells_table.horizontalHeader().setStretchLastSection(True)
        self.cells_table.setRowCount(len(self.flattened_cells))

        for row, cell in enumerate(self.flattened_cells):
            permissions = self.parent_widget._get_permission_for_cell(cell)
            date_str = cell.get('date_str', '')
            date_item = DateTableWidgetItem(date_str)
            date_item.setFlags(date_item.flags() & ~Qt.ItemIsEditable)
            date_item.setData(Qt.UserRole, row)
            self.cells_table.setItem(row, 0, date_item)
            qdate_obj = QDate.fromString(date_str, "yyyy-MM-dd")
            day_name_item = DayOfWeekItem(qdate_obj)
            day_name_item.setFlags(day_name_item.flags() & ~Qt.ItemIsEditable)
            day_name_item.setTextAlignment(Qt.AlignCenter)
            self.cells_table.setItem(row, 1, day_name_item)
            user_name = cell.get('uzytkownik_dane', 'Nieznany')
            self.cells_table.setItem(row, 2, QTableWidgetItem(user_name))
            self.cells_table.item(row, 2).setFlags(self.cells_table.item(row, 2).flags() & ~Qt.ItemIsEditable)
            symbol = cell.get('symbol', '')
            self.cells_table.setItem(row, 3, QTableWidgetItem(symbol))
            self.cells_table.item(row, 3).setFlags(self.cells_table.item(row, 3).flags() & ~Qt.ItemIsEditable)

            from symbol_parser import parse_symbol
            parsed_symbol = parse_symbol(symbol)

            # --- POCZĄTEK NOWEJ LOGIKI ---
            can_edit_location = permissions['can_edit_location']
            cell_date = QDate.fromString(date_str, "yyyy-MM-dd")

            # Jeśli rola to 'Lider' i data jest przeszła, zablokuj edycję lokalizacji
            if self.user_role == 'Lider' and cell_date < QDate.currentDate():
                can_edit_location = False
            # --- KONIEC NOWEJ LOGIKI ---

            location_code = parsed_symbol.get('location') or cell.get('lokalizacja_domyslna')
            start_hour = parsed_symbol.get('start_hour')
            parsed_hours = parsed_symbol.get('work_hours')
            if parsed_hours is not None:
                work_hours = parsed_hours
            else:
                work_hours = cell.get('etat', 8.0)
            try:
                work_hours = int(float(work_hours))
            except (ValueError, TypeError):
                work_hours = 8

            location_combo = QComboBox()
            location_combo.addItem("SBC (s)", "s")
            location_combo.addItem("mPrzystanek (p)", "p")
            location_combo.addItem("HomeOffice (h)", "h")

            if location_code and location_code in ['h', 's', 'p']:
                location_combo.setCurrentIndex({'s': 0, 'p': 1, 'h': 2}.get(location_code))
            else:
                location_combo.setCurrentIndex(-1)

            location_combo.setEnabled(can_edit_location)  # Użyj nowej, zweryfikowanej zmiennej
            self.cells_table.setCellWidget(row, 4, location_combo)

            time_button = QPushButton(str(start_hour) if start_hour is not None else "")
            time_button.setProperty("cell_index", row)
            time_button.setProperty("field_type", "hour")
            time_button.clicked.connect(self.show_digit_selection)
            time_button.setEnabled(permissions['can_edit_hours'])
            self.cells_table.setCellWidget(row, 5, time_button)

            hours_button = QPushButton(str(work_hours))
            hours_button.setProperty("cell_index", row)
            hours_button.setProperty("field_type", "hours")
            hours_button.clicked.connect(self.show_digit_selection)
            hours_button.setEnabled(permissions['can_edit_hours'])
            self.cells_table.setCellWidget(row, 6, hours_button)

            apply_button = QPushButton("Zastosuj")
            apply_button.setProperty("cell_index", row)
            apply_button.clicked.connect(self.apply_change_by_index)
            apply_button.setEnabled(any(permissions.values()) and start_hour is not None)
            self.cells_table.setCellWidget(row, 7, apply_button)

            status_item = QTableWidgetItem("")
            status_item.setFlags(status_item.flags() & ~Qt.ItemIsEditable)
            status_item.setTextAlignment(Qt.AlignCenter)
            self.cells_table.setItem(row, 8, status_item)

        main_layout.addWidget(self.cells_table)
        button_layout = QHBoxLayout()
        self.close_button = QPushButton("Zamknij")
        self.close_button.clicked.connect(self.close)
        button_layout.addStretch()
        button_layout.addWidget(self.close_button)
        main_layout.addLayout(button_layout)
        self.cells_table.sortByColumn(0, Qt.AscendingOrder)

    def show_digit_selection(self):
        target_button = self.sender()
        if not target_button: return
        field_type = target_button.property("field_type")
        is_hour = (field_type == "hour")
        values = list(range(24)) if is_hour else list(range(1, 14))
        title = "Wybierz godzinę rozp." if is_hour else "Wybierz liczbę godzin"

        dialog = DigitSelectionDialog(self, title, values, current_theme=self.determined_theme)
        if dialog.exec() == QDialog.Accepted:
            selected_value = dialog.get_selected_value()

            # --- POCZĄTEK POPRAWKI: Logika włączania/wyłączania przycisku "Zastosuj" ---
            # Ustaw tekst przycisku (pusty, jeśli wyczyszczono)
            target_button.setText(str(selected_value) if selected_value is not None else "")

            # Jeśli zmieniano godzinę rozpoczęcia, zaktualizuj stan przycisku "Zastosuj"
            if is_hour:
                row = target_button.property("cell_index")
                if row is not None:
                    apply_button = self.cells_table.cellWidget(row, 7)
                    if apply_button:
                        # Sprawdź, czy użytkownik nadal ma ogólne uprawnienia
                        original_index = self.cells_table.item(row, 0).data(Qt.UserRole)
                        cell_data = self.flattened_cells[original_index]
                        permissions = self.parent_widget._get_permission_for_cell(cell_data)

                        # Włącz przycisk tylko, jeśli są uprawnienia ORAZ wybrano godzinę
                        apply_button.setEnabled(any(permissions.values()) and selected_value is not None)
            # --- KONIEC POPRAWKI ---

    def _reset_button_state(self, button):
        button.setText("Zastosuj")
        button.setStyleSheet(self.default_button_style)
        button.setEnabled(True)

    def apply_change_by_index(self):
        button = self.sender()
        if not button: return
        # Znajdź wizualny wiersz, w którym jest przycisk
        for row in range(self.cells_table.rowCount()):
            if self.cells_table.cellWidget(row, 7) == button:
                self._apply_change_for_row(row)
                return

    def _apply_change_for_row(self, visual_row_index):
        """Stosuje zmianę dla konkretnego wiersza, implementując logikę wyjątków lokalizacyjnych."""
        button = self.cells_table.cellWidget(visual_row_index, 7)
        if not button or not button.isEnabled(): return

        status_item = self.cells_table.item(visual_row_index, 8)

        try:
            item = self.cells_table.item(visual_row_index, 0)
            if not item: raise ValueError("Nie można odnaleźć elementu w wierszu.")
            original_data_index = item.data(Qt.UserRole)
            cell_data = self.flattened_cells[original_data_index]

            # Inicjalizacja danych
            user_id = cell_data.get('uzytkownik_id')
            nr_kadrowy = cell_data.get('nr_kadrowy')
            user_name = cell_data.get('uzytkownik_dane')
            date_str = cell_data.get('date_str')
            q_date = QDate.fromString(date_str, "yyyy-MM-dd")
            _, modyfikujacy_id, _, _, _ = get_modifier_id()
            location_map = {'h': 1, 's': 3, 'p': 2}
            default_location_code = cell_data.get('lokalizacja_domyslna')

            location_combo = self.cells_table.cellWidget(visual_row_index, 4)
            time_button = self.cells_table.cellWidget(visual_row_index, 5)
            hours_button = self.cells_table.cellWidget(visual_row_index, 6)

            from symbol_parser import parse_symbol, build_symbol
            original_parsed_symbol = parse_symbol(cell_data.get('symbol', ''))

            new_location_code = location_combo.currentData()
            new_start_hour = int(time_button.text())
            new_work_hours = int(hours_button.text())

            original_location_code = original_parsed_symbol.get('location') or default_location_code
            loc_changed = new_location_code != original_location_code
            is_reverting_to_default = loc_changed and (new_location_code == default_location_code)

            reason_for_change = ""
            if loc_changed:
                # Sprawdź, czy już pytaliśmy o powód dla tego użytkownika
                if user_id in self.reason_cache:
                    reason_for_change = self.reason_cache[user_id]
                else:
                    # Jeśli nie, otwórz okno dialogowe
                    reason_dialog = ReasonDialog(self)
                    if reason_dialog.exec() == QDialog.Accepted:
                        reason_for_change = reason_dialog.getReason()
                        # Zapisz powód w pamięci podręcznej dla kolejnych zmian tego użytkownika
                        self.reason_cache[user_id] = reason_for_change
                    else:
                        # Użytkownik anulował wpisanie powodu, więc przerywamy całą operację
                        status_item.setText("Anulowano")
                        status_item.setForeground(QColor("gray"))
                        return

            button.setEnabled(False)
            button.setText("Przetwarzanie...")
            QApplication.processEvents()

            result = {}
            new_symbol = build_symbol(
                location=new_location_code, start_hour=new_start_hour, work_hours=new_work_hours,
                special_symbol=original_parsed_symbol.get('special_symbol')
            )

            if loc_changed:
                exact_exception, range_exception = self.parent_widget._check_location_exception(user_id, q_date)
                new_location_id = location_map.get(new_location_code, 1)

                if is_reverting_to_default:
                    if range_exception:
                        result = {"success": False,
                                  "message": "Ten dzień jest częścią wielodniowego wyjątku. Zaktualizuj go ręcznie, aby kontynuować."}
                    else:
                        result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year, self.month,
                                                                                   date_str, new_symbol)
                        if result.get("success") and exact_exception:
                            params = (None, modyfikujacy_id, None, None, None, None, 3, exact_exception['Id'])
                            self.parent_widget._manage_location_exception(params)
                else:
                    if exact_exception:
                        if exact_exception['Lokalizacja'] == new_location_id:
                            result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year,
                                                                                         self.month, date_str,
                                                                                         new_symbol)
                        else:
                            result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year,
                                                                                       self.month, date_str, new_symbol)
                            if result.get("success"):
                                params = (
                                user_id, modyfikujacy_id, date_str, date_str, new_location_id, "Zmiana z TeamFlowApp",
                                2, exact_exception['Id'])
                                self.parent_widget._manage_location_exception(params)
                    elif range_exception:
                        if range_exception['Lokalizacja'] != new_location_id:
                            result = {"success": False,
                                      "message": "Istnieje wyjątek w zakresie dat z inną lokalizacją. Edytuj lub usuń go, aby kontynuować."}
                        else:
                            result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year,
                                                                                       self.month, date_str, new_symbol)
                    else:
                        result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year, self.month,
                                                                                   date_str, new_symbol)
                        if result.get("success"):
                            params = (
                            user_id, modyfikujacy_id, date_str, date_str, new_location_id, "Wpis z TeamFlowApp", 1,
                            None)
                            self.parent_widget._manage_location_exception(params)
            else:
                result = self.parent_widget._call_import_changes_procedure(nr_kadrowy, self.year, self.month, date_str,
                                                                           new_symbol)

            if loc_changed and result.get("success"):
                overtime_events = self.parent_widget.data_provider.get_events_for_user_date(user_id, date_str)
                overtime_events = [e for e in overtime_events if e.get('type') == 'Nadgodziny']
                if overtime_events:
                    ot_dialog = OvertimeLocationDialog(self, overtime_events, new_location_code, self.determined_theme)
                    if ot_dialog.exec() == QDialog.Accepted:
                        location_changes = ot_dialog.get_selected_locations()
                        if location_changes:
                            self.parent_widget._update_multiple_overtime_locations(location_changes)

            if result.get("success", False):
                status_item.setText("Sukces ✅");
                status_item.setForeground(QColor("green"))
                returned_symbol = result.get('returned_symbol', new_symbol)
                self.cells_table.item(visual_row_index, 3).setText(returned_symbol)
                self.parent_widget._update_cells_with_new_symbols([(user_id, date_str, returned_symbol)])
                self.parent_widget.schedule_model.layoutChanged.emit()

                # --- POCZĄTEK KLUCZOWEJ POPRAWKI ---
                # Zaktualizuj wewnętrzną pamięć dialogu o nowy, zapisany symbol.
                self.flattened_cells[original_data_index]['symbol'] = returned_symbol
                # --- KONIEC KLUCZOWEJ POPRAWKI ---

            else:
                status_item.setText("Porażka ❌");
                status_item.setForeground(QColor("red"))
                error_msg = result.get("message", "Nieznany błąd.")
                QMessageBox.warning(self, "Błąd", f"👤 {user_name} ({self.format_date(date_str)}):\n{error_msg}",
                                    QMessageBox.Ok)

        except Exception as e:
            if status_item: status_item.setText("Porażka ❌"); status_item.setForeground(QColor("red"))
            log_error(f"Błąd krytyczny w _apply_change_for_row: {e}", exception=e)
            QMessageBox.critical(self, "Błąd krytyczny", f"Wystąpił nieoczekiwany błąd: {str(e)}", QMessageBox.Ok)
        finally:
            QTimer.singleShot(2000, lambda b=button: self._reset_button_state(b))

    def format_date(self, date_str):
        try:
            year, month, day = date_str.split('-')
            return f"{day}.{month}.{year}"
        except:
            return date_str

    def _apply_all_changes(self):
        if not any([self.apply_location_check.isChecked(), self.apply_time_check.isChecked(),
                    self.apply_hours_check.isChecked()]):
            QMessageBox.warning(self, "Brak wyboru",
                                "Proszę zaznaczyć, które atrybuty chcesz zastosować dla wszystkich.")
            return

        if (self.apply_time_check.isChecked() and self.all_time_button.text() == "Wybierz") or \
                (self.apply_hours_check.isChecked() and self.all_hours_button.text() == "Wybierz"):
            QMessageBox.warning(self, "Brak danych", "Proszę wybrać wartości dla zaznaczonych atrybutów.")
            return

        reply = QMessageBox.question(self, "Potwierdzenie",
                                     "Czy na pewno chcesz zastosować wybrane zmiany dla wszystkich widocznych wierszy?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.No:
            return

        # Pętla aktualizująca UI, a następnie wywołująca zapis
        for row in range(self.cells_table.rowCount()):
            # Najpierw zaktualizuj wizualnie kontrolki w wierszu
            self._update_row_widgets_from_global_settings(row)
            # Następnie spróbuj zapisać zmiany dla tego wiersza
            self._apply_change_for_row(row)


    def _update_row_widgets_from_global_settings(self, visual_row):
        item = self.cells_table.item(visual_row, 0)
        if not item: return
        original_data_index = item.data(Qt.UserRole)
        cell_data = self.flattened_cells[original_data_index]
        permissions = self.parent_widget._get_permission_for_cell(cell_data)

        if self.apply_location_check.isChecked() and permissions['can_edit_location']:
            combo = self.cells_table.cellWidget(visual_row, 4)
            new_location = self.all_location_combo.currentData()
            combo.setCurrentIndex(combo.findData(new_location))
        if self.apply_time_check.isChecked() and permissions['can_edit_hours']:
            time_btn = self.cells_table.cellWidget(visual_row, 5)
            new_start_hour = self.all_time_button.text()
            time_btn.setText(new_start_hour)
        if self.apply_hours_check.isChecked() and permissions['can_edit_hours']:
            hours_btn = self.cells_table.cellWidget(visual_row, 6)
            new_work_hours = self.all_hours_button.text()
            hours_btn.setText(new_work_hours)


class DigitSelectionDialog(QDialog):
    """Dialog do wyboru cyfry z siatki przycisków."""

    def __init__(self, parent=None, title="Wybierz wartość", values=None, current_theme="dark"):
        super().__init__(parent)
        self.parent_widget = parent
        self.current_theme = current_theme
        self.setWindowTitle(title)
        self.setModal(True)
        self.selected_value = None
        if values is None: values = list(range(10))
        self.values = values
        self.setObjectName("DigitSelectionDialogInstance")
        self.setup_ui()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu DigitSelectionDialog."""
        # --- TUTAJ BYŁ BŁĄD ---
        actual_theme = self.current_theme  # POPRAWKA: Użyj 'self.current_theme'
        # --- KONIEC POPRAWKI ---

        self.setStyleSheet(AppStyles.get_dialog_style(actual_theme))
        button_style_qss = AppStyles.get_button_style(actual_theme)

        if hasattr(self, 'grid_layout'):
            for i in range(self.grid_layout.count()):
                widget = self.grid_layout.itemAt(i).widget()
                if isinstance(widget, QPushButton):
                    widget.setStyleSheet(button_style_qss)
                    widget.style().unpolish(widget)
                    widget.style().polish(widget)

        if hasattr(self, 'cancel_button'):
            self.cancel_button.setStyleSheet(button_style_qss)
            self.cancel_button.style().unpolish(self.cancel_button)
            self.cancel_button.style().polish(self.cancel_button)

        self.style().unpolish(self)
        self.style().polish(self)
        self.update()

    def setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)
        self.grid_layout = QGridLayout()
        self.grid_layout.setSpacing(5)
        cols = min(6, len(self.values))
        if cols == 0: cols = 1
        for i, value in enumerate(self.values):
            row, col = i // cols, i % cols
            button = QPushButton(str(value))
            button.setMinimumSize(25, 25)
            button.setProperty("value", value)
            button.clicked.connect(self.on_value_selected)
            self.grid_layout.addWidget(button, row, col)
        main_layout.addLayout(self.grid_layout)

        # --- POCZĄTEK POPRAWKI: Dodanie przycisku "Wyczyść" ---
        self.clear_button = QPushButton("Wyczyść")
        self.clear_button.clicked.connect(self.on_clear_selected)
        # --- KONIEC POPRAWKI ---

        self.cancel_button = QPushButton("Anuluj")
        self.cancel_button.clicked.connect(self.reject)
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        button_layout.addWidget(self.clear_button)  # <-- Dodano przycisk
        button_layout.addWidget(self.cancel_button)
        main_layout.addLayout(button_layout)
        self.adjustSize()
        self.apply_dialog_theme()

    def on_value_selected(self):
        """Obsługuje wybór wartości"""
        button = self.sender()
        if button:
            self.selected_value = button.property("value")
            self.accept()

    def on_clear_selected(self):
        """Obsługuje wyczyszczenie wartości."""
        self.selected_value = None
        self.accept()

    def get_selected_value(self):
        """Zwraca wybraną wartość"""
        return self.selected_value

class OvertimeLocationDialog(QDialog):
    """Dialog do indywidualnej edycji lokalizacji dla wykrytych nadgodzin."""

    def __init__(self, parent, overtime_events, current_shift_location, current_theme="dark"):
        super().__init__(parent)
        self.setWindowTitle("Zmiana lokalizacji a nadgodziny")
        self.setMinimumWidth(450)  # Zwiększamy szerokość
        self.theme = current_theme
        self.events = overtime_events
        self.location_combos = []  # Będziemy przechowywać tu referencje do ComboBoxów

        self.setup_ui(current_shift_location)
        self.apply_styles()

    def setup_ui(self, current_shift_location):
        layout = QVBoxLayout(self)

        info_text = (f"Wykryto {len(self.events)} wpis(y) nadgodzin w tym dniu. "
                     f"Lokalizacja w grafiku została zmieniona na <b>'{current_shift_location.upper()}'</b>.<br><br>"
                     "Dla każdego wpisu nadgodzin możesz ustawić inną lokalizację.")
        layout.addWidget(QLabel(info_text))

        # Używamy QGridLayout dla lepszego ułożenia kontrolek
        grid_layout = QGridLayout()
        grid_layout.setSpacing(10)

        # Nagłówki
        grid_layout.addWidget(QLabel("<b>Godziny nadliczbowe</b>"), 0, 0)
        grid_layout.addWidget(QLabel("<b>Obecna lokalizacja</b>"), 0, 1)
        grid_layout.addWidget(QLabel("<b>Nowa lokalizacja</b>"), 0, 2)

        # Dane dla każdego wpisu nadgodzin
        for i, event in enumerate(self.events):
            row = i + 1
            # Informacje o godzinach
            event_label = QLabel(f"{event.get('time_from', '?')} - {event.get('time_to', '?')}")

            # Aktualna lokalizacja nadgodzin (zakładamy, że jest w danych zdarzenia)
            current_ot_location_code = event.get('location', 'b/d')  # 'b/d' - brak danych
            location_map = {'h': 'Home Office', 's': 'SBC', 'p': 'Przystanek'}
            current_ot_location_label = QLabel(location_map.get(current_ot_location_code, "Nieznana"))

            # Menu wyboru nowej lokalizacji
            location_combo = QComboBox()
            location_combo.addItem("Bez zmian", "skip")
            location_combo.addItem(f"Jak w grafiku ({current_shift_location.upper()})", current_shift_location)
            location_combo.addItem("Home Office (h)", "h")
            location_combo.addItem("SBC (s)", "s")
            location_combo.addItem("Przystanek (p)", "p")

            # Ustaw domyślnie "Bez zmian"
            location_combo.setCurrentIndex(0)

            self.location_combos.append(location_combo)  # Zapisz referencję

            grid_layout.addWidget(event_label, row, 0)
            grid_layout.addWidget(current_ot_location_label, row, 1)
            grid_layout.addWidget(location_combo, row, 2)

        layout.addLayout(grid_layout)

        button_box = QHBoxLayout()
        self.ok_button = QPushButton("Zatwierdź zmiany")
        self.cancel_button = QPushButton("Anuluj")
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)
        button_box.addStretch()
        button_box.addWidget(self.cancel_button)
        button_box.addWidget(self.ok_button)
        layout.addLayout(button_box)

    def apply_styles(self):
        self.setStyleSheet(AppStyles.get_dialog_style(self.theme))
        for button in self.findChildren(QPushButton):
            button.setStyleSheet(AppStyles.get_button_style(self.theme))
        for combo in self.findChildren(QComboBox):
            combo.setStyleSheet(AppStyles.get_combobox_style(self.theme))
        for box in self.findChildren(QGroupBox):
            box.setStyleSheet(f"""
                QGroupBox {{
                    border: 1px solid {'#495057' if self.theme == 'dark' else '#ced4da'};
                    border-radius: 4px;
                    margin-top: 10px;
                }}
                QGroupBox::title {{
                    subcontrol-origin: margin;
                    subcontrol-position: top left;
                    padding: 0 3px;
                    left: 10px;
                }}
            """)

    def get_selected_locations(self):
        """Zwraca listę zmian w formacie [(event_id, nowa_lokalizacja), ...]."""
        changes = []
        for i, combo in enumerate(self.location_combos):
            selected_loc = combo.currentData()
            if selected_loc != "skip":  # Zapisujemy tylko te, które faktycznie mają być zmienione
                event_id = self.events[i]['id']
                changes.append((event_id, selected_loc))
        return changes
