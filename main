import sys
import time
import getpass
from datetime import datetime, timedelta
from typing import List, Dict

# --- GŁÓWNE IMPORTY (NIEZBĘDNE PRZY STARCIE) ---
from PySide6.QtWidgets import (QApplication, QMainWindow, QTableView,
                               QVBoxLayout, QHBoxLayout, QWidget, QLabel, QComboBox,
                               QPushButton, QHeaderView, QAbstractItemView, QListWidget,
                               QListWidgetItem, QLineEdit, QDialog, QCheckBox, QFrame, QDateEdit,
                               QMessageBox, QSplitter, QStyledItemDelegate, QFileDialog,
                               QGridLayout, QSizePolicy, QScrollArea, QGroupBox)
from PySide6.QtCore import Qt, Signal, QDate, QTimer, QEvent, QObject
from packaging.version import parse as parse_version
from PySide6.QtGui import QShortcut, QKeySequence, QFont, QColor, QStandardItem, QStandardItemModel

from data_provider import DataProvider
from db_connector import DatabaseConnector, get_modifier_id, load_all_app_settings
from config import APP_VERSION, SQL_OBJECTS
from app_settings import app_settings
from settings_db import SettingsDatabase
from styles import AppStyles
from column_definitions import ColumnDefinitions
from schedule_model import ScheduleTableModel, ROLE_DATA
from events_model import EventsTableModel
from split_table_view import SplitTableView
from schedule_delegates import OvertimeItemDelegate
from events_delegates import ButtonDelegate
from debug_utils import debug_print, log_warning, log_error, setup_logging, close_log_file
from symbol_parser import parse_symbol, build_symbol, get_symbol_description



class ScheduleKeyboardFilter(QObject):
    """
    Dedykowany filtr zdarzeń klawiatury dla tabeli grafiku z obsługa:
    - dwucyfrowych godzin i wieloznakowych symboli (z buforowaniem)
    - modyfikacji liczby godzin (+/-/=) z poprawnym odświeżaniem bilansu.
    """

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self._digit_buffer = ""
        self._buffer_timer = QTimer()
        self._buffer_timer.setSingleShot(True)
        self._buffer_timer.timeout.connect(self._process_digit_buffer_on_timeout)
        self._buffer_timeout = 1200
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1200

        # Bufor i timer dla wieloznakowych symboli
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1200

    def eventFilter(self, obj, event):
        """Główna metoda filtrująca zdarzenia klawiatury."""
        if not (hasattr(self.main_window, 'table') and
                hasattr(self.main_window.table, 'schedule_view') and
                obj == self.main_window.table.schedule_view and
                event.type() == QEvent.KeyPress):
            return False

        key = event.key()
        role = self.main_window.current_user_role

        if key in (Qt.Key_Plus, Qt.Key_Equal, Qt.Key_Minus):
            self._clear_digit_buffer()
            self._clear_char_buffer()
            # ZMIANA: Odwołanie do app_settings
            if app_settings.has_permission(role, 'schedule_keyboard_edit'):
                self._handle_hour_modification(key)
            return True

        # ZMIANA: Odwołanie do app_settings
        can_edit_hours_symbols = app_settings.has_permission(role, 'schedule_keyboard_edit')

        is_digit_key = (Qt.Key_0 <= key <= Qt.Key_9)
        is_char_key = (Qt.Key_A <= key <= Qt.Key_Z)
        is_delete_key = key in [Qt.Key_Delete, Qt.Key_Backspace]
        is_escape_key = key == Qt.Key_Escape

        if not can_edit_hours_symbols and (is_digit_key or is_char_key or is_delete_key):
            return True

        if is_digit_key or is_char_key or is_delete_key:
            if not self._validate_selected_cells():
                return True

        if is_digit_key:
            self._handle_digit_input(key - Qt.Key_0)
            return True

        if is_char_key:
            self._handle_char_input(event.text())
            return True

        if is_delete_key:
            # ZMIANA: Odwołanie do app_settings
            if app_settings.has_permission(role, 'action_delete_symbol'):
                self.main_window.clear_selected_cells()
            self._clear_digit_buffer()
            self._clear_char_buffer()
            return True

        if is_escape_key:
            self._clear_digit_buffer()
            self._clear_char_buffer()
            self.main_window.table.schedule_view.clearSelection()
            return True

        if key in [Qt.Key_Space, Qt.Key_Enter, Qt.Key_Return, Qt.Key_Tab]:
            return True

        return False

    def _handle_hour_modification(self, key):
        """Obsługuje zwiększanie/zmniejszanie liczby godzin (+/-/=) z uwzględnieniem uprawnień."""
        selected_cells_data = self.main_window.table.get_data_for_selected_cells()
        if not selected_cells_data: return

        updated_info = []
        error_messages = []
        skipped_count = 0
        permission_denied_count = 0
        current_user_role = self.main_window.current_user_role  # Pobierz rolę bieżącego użytkownika

        for cell_data in selected_cells_data:
            permissions = self.main_window._get_permission_for_cell(cell_data)
            if not permissions['can_edit_hours']:
                permission_denied_count += 1
                continue

            system_pracy = cell_data.get('system_czasu_pracy', '')

            # --- POCZĄTEK ZMIANY ---
            # Sprawdź system pracy, ale zezwól na edycję dla roli 'Pracownik WPR'
            is_equivalent_system = system_pracy.strip().lower() == 'równoważny'
            if not is_equivalent_system and current_user_role != 'Pracownik WPR':
                skipped_count += 1
                continue
            # --- KONIEC ZMIANY ---

            current_symbol = cell_data.get('symbol', '')
            if not current_symbol: continue

            try:
                parsed = parse_symbol(current_symbol)
                if parsed.get('work_hours') is None: continue

                current_hours = int(parsed['work_hours'])
                new_hours = min(12, current_hours + 1) if key in (Qt.Key_Plus, Qt.Key_Equal) else max(1,
                                                                                                      current_hours - 1)
                if new_hours == current_hours: continue

                new_symbol = build_symbol(
                    location=parsed.get('location'), start_hour=parsed.get('start_hour'),
                    work_hours=new_hours, special_symbol=parsed.get('special_symbol')
                )

                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self.main_window._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )

                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"👤 {cell_data.get('uzytkownik_dane')}: {result.get('message', 'Błąd zapisu.')}")
            except (ValueError, TypeError) as e:
                log_warning(f"Błąd modyfikacji godzin dla symbolu '{current_symbol}': {e}")
                error_messages.append(f"👤 {cell_data.get('uzytkownik_dane')}: Błąd aplikacji: {e}")

        if permission_denied_count > 0:
            self.main_window.statusBar().showMessage(
                f"Pominięto {permission_denied_count} komórek z powodu braku uprawnień do zmiany godzin.", 4000)

        if updated_info:
            self.main_window._update_cells_with_new_symbols(updated_info)
            self.main_window.schedule_model.layoutChanged.emit()
            self.main_window.statusBar().showMessage(f"Zmieniono liczbę godzin dla {len(updated_info)} komórek.", 4000)

        if error_messages:
            QMessageBox.warning(self.main_window, "Błędy podczas zapisu",
                                "Wystąpiły następujące błędy:\\n\\n" + "\\n".join(error_messages))
        elif not updated_info and skipped_count > 0 and skipped_count == len(selected_cells_data):
            self.main_window.statusBar().showMessage("Operacja dozwolona tylko dla Równoważnego Systemu Czasu Pracy.",
                                                     5000)

    def _handle_char_input(self, char: str):
        self._clear_digit_buffer()
        self._char_buffer += char.upper()
        self.main_window.statusBar().showMessage(f"Wpisywanie symbolu: {self._char_buffer}", self._char_buffer_timeout)
        if len(self._char_buffer) >= 3:
            self._char_buffer_timer.stop()
            self._process_char_buffer()
        else:
            self._char_buffer_timer.start(self._char_buffer_timeout)

    def _process_char_buffer(self):
        symbol = self._char_buffer
        self._clear_char_buffer()
        if not symbol: return

        # Krok 1: Sprawdź, czy symbol jest w ogóle poprawny
        if symbol in self.main_window.get_all_valid_symbols():

            # --- POCZĄTEK POPRAWKI ---
            # Krok 2: Sprawdź, czy bieżąca rola ma uprawnienia do tego symbolu
            current_role = self.main_window.current_user_role
            if app_settings.has_symbol_permission(current_role, symbol):
                self.main_window.apply_symbol_from_keyboard(symbol)
            else:
                # Symbol jest poprawny, ale użytkownik nie ma uprawnień
                self.main_window.statusBar().showMessage(
                    f"Brak uprawnień do użycia symbolu '{symbol}' dla Twojej roli.", 4000)
            # --- KONIEC POPRAWKI ---

        else:
            # Symbol jest nieprawidłowy
            self.main_window.statusBar().showMessage(f"Błąd: Symbol '{symbol}' jest nieprawidłowy!", 4000)

    def _handle_digit_input(self, digit: int):
        self._clear_char_buffer()
        self._digit_buffer += str(digit)
        self.main_window.statusBar().showMessage(f"Wpisywanie godziny: {self._digit_buffer}", self._buffer_timeout)

        if len(self._digit_buffer) == 1:
            if int(self._digit_buffer) >= 3:
                self.main_window.quick_edit_selected_cells(int(self._digit_buffer))
                self._clear_digit_buffer()
            else:
                self._buffer_timer.start(self._buffer_timeout)
        elif len(self._digit_buffer) == 2:
            self._buffer_timer.stop()
            potential_hour = int(self._digit_buffer)
            hour = potential_hour if 0 <= potential_hour <= 23 else int(self._digit_buffer[0])
            self.main_window.quick_edit_selected_cells(hour)
            self._clear_digit_buffer()
        else:
            self._buffer_timer.stop()
            self.main_window.quick_edit_selected_cells(digit)
            self._clear_digit_buffer()

    def _process_digit_buffer_on_timeout(self):
        if self._digit_buffer:
            self.main_window.quick_edit_selected_cells(int(self._digit_buffer))
            self._clear_digit_buffer()

    def _clear_digit_buffer(self):
        self._digit_buffer = ""
        if self._buffer_timer.isActive(): self._buffer_timer.stop()
        if self.main_window.statusBar().currentMessage().startswith("Wpisywanie godziny:"):
            self.main_window.statusBar().clearMessage()

    def _clear_char_buffer(self):
        self._char_buffer = ""
        if self._char_buffer_timer.isActive(): self._char_buffer_timer.stop()
        if self.main_window.statusBar().currentMessage().startswith("Wpisywanie symbolu:"):
            self.main_window.statusBar().clearMessage()

    def _validate_selected_cells(self) -> bool:
        selected_cells_data = self.main_window.table.get_data_for_selected_cells()
        if not selected_cells_data: return False
        return self.main_window._can_modify_cells(selected_cells_data)


class CustomMultiComboBox(QComboBox):
    """Niestandardowy ComboBox z obsługa wielokrotnego wyboru (wersja poprawiona)."""
    selection_changed = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)

        self._selected_items = set()
        self._select_all_text = "-Wszystkie-"

        # Konfiguracja modelu
        self.setModel(QStandardItemModel(self))

        # Konfiguracja wyglądu
        self.setEditable(True)
        self.lineEdit().setReadOnly(True)
        self.setEditText("-Wszystkie-")
        self.setSizeAdjustPolicy(QComboBox.AdjustToContents)

        # Używamy filtra zdarzeń do przechwytywania kliknięć, co zapobiega zamykaniu listy
        self.view().viewport().installEventFilter(self)
        self.lineEdit().installEventFilter(self)

        # Delegat jest potrzebny do poprawnego renderowania
        self.setItemDelegate(QStyledItemDelegate(self))

    def eventFilter(self, obj, event):
        # Przechwytujemy kliknięcie myszą w polu tekstowym, aby pokazać listę
        if obj == self.lineEdit() and event.type() == QEvent.MouseButtonPress:
            self.showPopup()
            return True

        # Przechwytujemy zwolnienie przycisku myszy na liście (widoku)
        if obj == self.view().viewport() and event.type() == QEvent.MouseButtonRelease:
            index = self.view().indexAt(event.position().toPoint())  # Użyj .position().toPoint() zamiast .pos()
            if index.isValid():
                self.handle_item_pressed(index)
            return True

        return False

    def handle_item_pressed(self, index):
        """Logika zaznaczania/odznaczania elementu."""
        item = self.model().itemFromIndex(index)
        if not item:
            return

        if item.text() == self._select_all_text:
            # Logika dla przycisku "Zaznacz wszystkie"
            is_checked = (item.checkState() == Qt.Checked)
            new_state = Qt.Unchecked if is_checked else Qt.Checked
            for i in range(1, self.model().rowCount()):
                self.model().item(i).setCheckState(new_state)
        else:
            # Logika dla zwykłego elementu
            current_state = item.checkState()
            item.setCheckState(Qt.Checked if current_state == Qt.Unchecked else Qt.Unchecked)

        self._rebuild_selected_items()
        self.update_display_text()

        self.selection_changed.emit()

    def _rebuild_selected_items(self):
        """Przebudowuje zbiór zaznaczonych elementów na podstawie stanu modelu."""
        self._selected_items.clear()
        all_selected = True
        # Pętla od 1, aby pominąć element "Zaznacz wszystkie"
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.checkState() == Qt.Checked:
                self._selected_items.add(item.text())
            else:
                all_selected = False

        # Aktualizuj stan checkboxa "Zaznacz wszystkie"
        if self.model().rowCount() > 0:
            select_all_item = self.model().item(0)
            select_all_item.setCheckState(Qt.Checked if all_selected else Qt.Unchecked)

    def hidePopup(self):
        """Aktualizuje tekst po zamknięciu listy."""
        self.update_display_text()
        super().hidePopup()

    def add_items(self, items):
        """Dodaje elementy do ComboBoxa."""
        self.clear()

        select_all_item = QStandardItem(self._select_all_text)
        select_all_item.setCheckable(True)
        self.model().appendRow(select_all_item)

        for item_text in sorted(items):
            item = QStandardItem(item_text)
            item.setCheckable(True)
            self.model().appendRow(item)

        self.update_display_text()

    def showPopup(self):
        """Pokaż menu rozwijane z dostosowaną szerokością."""
        super().showPopup()

        width = self.view().sizeHintForColumn(0) + 20
        width = min(width, 450)
        self.view().setMinimumWidth(width)

    def clear(self):
        """Czyści listę elementów."""
        self.model().clear()
        self._selected_items.clear()
        self.setEditText("-Wszystkie-")

    def clear_selection(self):
        """Czyści zaznaczenie wszystkich elementów."""
        for i in range(self.model().rowCount()):
            self.model().item(i).setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()

    def get_selected_items(self):
        """Zwraca listę zaznaczonych elementów."""
        return list(self._selected_items)

    def select_items(self, items_to_select):
        """Zaznacza programowo określone elementy na liście."""
        lookup = set(items_to_select)
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.text() in lookup:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()

    def update_display_text(self):
        """Aktualizuje tekst wyświetlany w comboboxie."""
        if not self._selected_items or len(self._selected_items) == (self.model().rowCount() - 1):
            self.setEditText("-Wszystkie-")
        else:
            self.setEditText(f"Wybrano {len(self._selected_items)} z {self.model().rowCount() - 1}")

class UpdateRequiredDialog(QDialog):
    """Modalne okno informujące o konieczności aktualizacji i wymuszające zamknięcie."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Wymagana aktualizacja")
        self.setModal(True)
        self.setWindowFlags(Qt.Dialog | Qt.CustomizeWindowHint | Qt.WindowTitleHint)

        self.countdown = 15

        layout = QVBoxLayout(self)
        info_label = QLabel(
            "<b>Dostępna jest nowa wersja aplikacji.</b><br><br>"
            "Aby zapewnić spójność danych i dostęp do nowych funkcji, dalsza praca na tej wersji nie jest możliwa.<br>"

        )
        info_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(info_label)

        self.countdown_label = QLabel(f"Aplikacja zostanie zamknięta za {self.countdown} sekund...")
        self.countdown_label.setAlignment(Qt.AlignCenter)
        self.countdown_label.setStyleSheet("font-weight: bold; color: #e74c3c;")
        layout.addWidget(self.countdown_label)

        self.timer = QTimer(self)
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.update_countdown)
        self.timer.start()

    def update_countdown(self):
        self.countdown -= 1
        self.countdown_label.setText(f"Aplikacja zostanie zamknięta za {self.countdown} sekund...")
        if self.countdown <= 0:
            self.timer.stop()
            self.accept()


class WorkScheduleWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        self.settings_db = SettingsDatabase()

        try:
            current_windows_user = getpass.getuser().lower()
        except Exception:
            current_windows_user = "unknown_user"

        self.user_settings = self.settings_db.load_settings(login_windows=current_windows_user)
        debug_print(f"ZAŁADOWANE USTAWIENIA UŻYTKOWNIKA: {self.user_settings}")

        self.is_dark_theme = self.user_settings.get('theme') == 'dark'
        self.current_font = self.user_settings.get('font_family', 'Segoe UI')
        self.current_font_size = self.user_settings.get('font_size', 9)
        self.import_grupa = self.user_settings.get('import_grupa', 3)
        self.import_funkcja = self.user_settings.get('import_funkcja', 1)
        self.column_definitions = ColumnDefinitions()
        self.default_visible_columns = self.column_definitions.DEFAULT_VISIBLE_COLUMNS
        saved_columns = self.user_settings.get('visible_columns')
        self.visible_columns = saved_columns if saved_columns else self.default_visible_columns.copy()
        self.show_comment_column = self.user_settings.get('show_schedule_comment', False)

        self.staffing_details_win = None
        self.current_user_role = None
        self.last_left_panel_width = 260
        self.data_provider = DataProvider()
        self.employee_columns = self.column_definitions.get_ui_display_columns()

        self.setWindowTitle("TeamFlowApp")
        if self.user_settings.get('is_maximized'):
            pass
        else:
            width, height = self.user_settings.get('window_size', (1600, 800))
            self.setGeometry(100, 100, width, height)

        self._selection_timer = QTimer()
        self._selection_timer.setSingleShot(True)
        self._selection_timer.timeout.connect(self._handle_selection_change)
        self._selection_debounce_delay = 50

        font = QFont(self.current_font, self.current_font_size)
        QApplication.setFont(font)

        self.schedule_model = ScheduleTableModel(self)
        self.schedule_model.set_visible_columns(self.visible_columns)
        self.events_model = EventsTableModel(self)

        self.setup_ui()  # Ta metoda musi być przed setup_table_properties

        self.table.set_model(self.schedule_model)
        self.events_table.setModel(self.events_model)

        self.manage_columns_button.clicked.connect(self.show_column_select_dialog)

        if self.table.employees_view.selectionModel():
            self.table.employees_view.selectionModel().selectionChanged.connect(self.on_selection_changed)
        if self.table.schedule_view.selectionModel():
            self.table.schedule_view.selectionModel().selectionChanged.connect(self.on_selection_changed)

        self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font, self.current_font_size)

        # --- POCZĄTEK POPRAWKI: Przywrócenie brakujących skrótów ---
        self.shortcut_f1 = QShortcut(QKeySequence(Qt.Key_F1), self)
        self.shortcut_f1.activated.connect(self.toggle_left_panel)

        self.shortcut_f2 = QShortcut(QKeySequence(Qt.Key_F2), self)
        self.shortcut_f2.activated.connect(self.toggle_events_panel)

        self.shortcut_f3 = QShortcut(QKeySequence(Qt.Key_F3), self)
        self.shortcut_f3.activated.connect(self.show_insert_change_dialog)

        # Skrót dla "Wstaw nieobecność" jest często F4
        self.shortcut_f4 = QShortcut(QKeySequence(Qt.Key_F4), self)
        self.shortcut_f4.activated.connect(self.show_insert_symbol_dialog)

        self.shortcut_insert = QShortcut(QKeySequence(Qt.Key_Insert), self)
        self.shortcut_insert.activated.connect(self.show_add_overtime_dialog)

        self.shortcut_f12 = QShortcut(QKeySequence(Qt.Key_F12), self)
        self.shortcut_f12.activated.connect(self.clear_special_symbol_from_selected_cells)
        # --- KONIEC POPRAWKI ---

        self.start_full_initialization()

        debug_print("=== APLIKACJA URUCHOMIONA W TRYBIE AUTOMATYCZNYM ===")

    def manage_ui_state(self, enabled: bool):
        """Włącza lub wyłącza kluczowe elementy interfejsu użytkownika."""
        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(enabled)

        action_buttons = [
            self.settings_button, self.refresh_button, self.show_audit_button,
            self.staffing_details_button, self.schedule_control_button,
            self.manage_columns_button, self.toggle_events_panel_button,
            self.insert_change_button, self.insert_symbol_button,
            self.cancel_delegation_button, self.add_overtime_button
        ]
        for button in action_buttons:
            if hasattr(self, button.objectName()):
                button.setEnabled(enabled)

        if hasattr(self, 'date_combo'):
            self.date_combo.setEnabled(enabled)

    def start_full_initialization(self):
        """Uruchamia pełną inicjalizację po sprawdzeniu wersji i uprawnień."""
        self.load_data_button.setText("Sprawdzanie uprawnień...")
        self.load_data_button.setEnabled(False)
        QApplication.processEvents()

        if not self.check_user_permissions():
            QTimer.singleShot(10, self.close)
            return

        self.manage_ui_state(enabled=True)
        self.load_data_button.setVisible(False)
        self.refresh_button.setVisible(True)

        self.setup_table_properties()
        self.setup_keyboard_editing()

        self.setup_date_combo()
        self.load_initial_data()

        self.check_timer = QTimer(self)
        self.check_timer.timeout.connect(self.check_for_new_data)
        self.check_timer.start(60000)

    def check_if_update_is_required(self) -> bool:
        """Sprawdza wersję aplikacji na podstawie załadowanych ustawień."""
        # Porównujemy wersje. Funkcja zwraca tylko wynik, nie zamyka już aplikacji.
        return parse_version(APP_VERSION) != parse_version(app_settings.REQUIRED_VERSION)

    def show_staffing_details_window(self):
        from staffing_details_window import StaffingDetailsWindow
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Brak danych", "Proszę wybrać miesiąc, aby wyświetlić szczegóły obsady.",
                                QMessageBox.Ok)
            return
        year, month = current_data
        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            self.staffing_details_win.activateWindow()
            self.staffing_details_win.raise_()
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.update_for_new_month_or_filters(year, month)
        else:
            self.staffing_details_win = StaffingDetailsWindow(
                self, self.data_provider, year, month, self.import_grupa, self.import_funkcja
            )
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.show()

    def setup_keyboard_editing(self):
        """Konfiguruje edycję klawiatury dla komórek grafiku"""
        if not app_settings.has_permission(self.current_user_role, 'schedule_keyboard_edit'):
            debug_print(f"Edycja klawiatury wyłączona - rola '{self.current_user_role}' nie ma uprawnień.")
            return

        self.keyboard_filter = ScheduleKeyboardFilter(self)
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            self.table.schedule_view.installEventFilter(self.keyboard_filter)
            debug_print(f"Włączono edycję klawiatury dla roli: {self.current_user_role}")

    def cleanup_keyboard_filter(self):
        """Czyści filtr klawiatury przy zamykaniu aplikacji"""
        if hasattr(self, 'keyboard_filter'):
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.removeEventFilter(self.keyboard_filter)
            del self.keyboard_filter
            debug_print("Wyczyszczono filtr klawiatury")

    def _should_ask_for_confirmation(self) -> bool:
        """
        Sprawdza, czy należy wyświetlić okno dialogowe z prośbą o potwierdzenie.
        Zwraca False, jeśli grafik nie jest opublikowany (praca "na brudno"), True w przeciwnym wypadku.
        """
        current_data = self.date_combo.currentData()
        if not current_data:
            return True  # W razie wątpliwości, dla bezpieczeństwa pytaj

        year, month = current_data
        is_published = self.data_provider.is_schedule_published(year, month)

        # Pytamy o potwierdzenie tylko wtedy, gdy grafik JEST opublikowany.
        return is_published

    def _get_permission_for_cell(self, cell_data: dict) -> dict:
        permissions = {'can_edit_hours': False, 'can_edit_symbol': False, 'can_edit_location': False,
                       'can_delete': False}
        if not cell_data: return permissions

        user_role, user_dept = self.current_user_role, self.current_user_department
        target_role, target_dept = cell_data.get('rola_nazwa'), cell_data.get('wydzial')

        # --- POCZĄTEK NOWEJ LOGIKI ---
        # Specjalna reguła: Lider i Lider OUT mogą wstawić symbol 'CO' osobom z wydziału DTN.
        # Przyznajemy im tylko uprawnienie do edycji symbolu w tym konkretnym przypadku.
        if user_role in ['Lider', 'Lider OUT'] and target_dept and target_dept.strip().lower() == 'dtn':
            return {'can_edit_hours': False, 'can_edit_symbol': True, 'can_edit_location': False, 'can_delete': False}
        # --- KONIEC NOWEJ LOGIKI ---

        if user_role == 'Pracownik WPR':
            return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}

        is_in_same_department = False
        if user_dept and target_dept:
            if target_dept.strip().lower().startswith(user_dept.strip().lower()):
                is_in_same_department = True

        if not is_in_same_department: return permissions

        if user_role == 'Lider OUT':
            return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}

        if user_role == 'Lider':
            if target_role == 'Lider':
                return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}
            else:
                return {'can_edit_hours': False, 'can_edit_symbol': True, 'can_edit_location': True,
                        'can_delete': False}

        return permissions

    def quick_edit_selected_cells(self, start_hour):
        """Szybka edycja zaznaczonych komórek z klawiatury"""
        try:
            if not app_settings.has_permission(self.current_user_role, 'schedule_keyboard_edit'):
                return

            selected_cells_data = self.table.get_data_for_selected_cells()
            if not self._can_modify_cells(selected_cells_data) or not selected_cells_data:
                return

            schedule_cells = [cell for cell in selected_cells_data if isinstance(cell, dict) and 'date_str' in cell and 'uzytkownik_id' in cell]
            if not schedule_cells:
                return

            grouped_changes = {}
            for cell_data in schedule_cells:
                user_id, user_name, date_str = cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane', ''), cell_data.get('date_str')
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str
                user_key = (user_id, user_name)
                if user_key not in grouped_changes:
                    grouped_changes[user_key] = []
                grouped_changes[user_key].append(formatted_date)

            changes_info = f"Zmiana godziny rozpoczęcia na {start_hour}:00 dla:\n\n"
            for (user_id, user_name), dates in grouped_changes.items():
                changes_info += f"🧑 {user_name}:\n"
                dates_str = ", ".join(sorted(dates))
                changes_info += f"   📅 {dates_str}\n\n"
            changes_info += f"Łącznie: {len(schedule_cells)} komórek"

            reply = QMessageBox.Yes  # Domyślnie zakładamy, że użytkownik się zgadza
            if self._should_ask_for_confirmation():
                reply = QMessageBox.question(self, "Potwierdzenie szybkiej edycji", changes_info, QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
            if reply == QMessageBox.Yes:
                self._apply_quick_changes(schedule_cells, start_hour)
        except Exception as e:
            log_error(f"Błąd podczas szybkiej edycji: {e}")
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas edycji: {str(e)}", QMessageBox.Ok)

    def _apply_quick_changes(self, schedule_cells, start_hour):
        """Stosuje szybką zmianę godziny z indywidualnym sprawdzaniem uprawnień."""
        updated_info, error_messages, skipped_employees = [], [], []

        for cell_data in schedule_cells:
            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_edit_hours']:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue

            current_symbol = cell_data.get('symbol', '')
            parsed = parse_symbol(current_symbol)
            try:
                work_hours = int(float(cell_data.get('etat', 8.0)))
            except (ValueError, TypeError):
                work_hours = 8

            new_symbol = build_symbol(
                location=parsed.get('location') or cell_data.get('lokalizacja_domyslna'),
                start_hour=start_hour,
                work_hours=parsed.get('work_hours') or work_hours,
                special_symbol=parsed.get('special_symbol')
            )
            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"🧑 {cell_data.get('uzytkownik_dane')}: {result.get('message', 'Błąd zapisu.')}")
            except Exception as e:
                log_error(f"Błąd krytyczny w _apply_quick_changes: {e}")
                error_messages.append(f"🧑 {cell_data.get('uzytkownik_dane')}: Błąd aplikacji: {e}")

        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.schedule_model.layoutChanged.emit()

        success_msg = f"Zmieniono godzinę rozpoczęcia dla {len(updated_info)} komórek."
        if skipped_employees:
            QMessageBox.information(self, "Częściowy sukces",
                                    f"{success_msg}\n\nPominięto {len(skipped_employees)} komórek z powodu braku uprawnień dla:\n"
                                    f"- {', '.join(set(skipped_employees))}")
        elif updated_info:
            self.statusBar().showMessage(success_msg, 4000)

        if error_messages:
            QMessageBox.warning(self, "Błędy podczas zapisu",
                                "Wystąpiły następujące błędy:\n\n" + "\n".join(error_messages))

    def _show_keyboard_edit_results(self, successful_updates, failed_updates, error_messages, start_hour):
        """Pokazuje wyniki edycji klawiatury - uproszczone komunikaty"""
        if successful_updates > 0:
            message = f"Pomyślnie zaktualizowano {successful_updates} komórek (cyfra: {start_hour})"
            if failed_updates > 0:
                message += f"\n\n⚠️ {failed_updates} aktualizacji nie powiodło się"
                if error_messages:
                    message += ":\n" + "\n".join(error_messages[:3])
                    if len(error_messages) > 3:
                        message += f"\n... i {len(error_messages) - 3} więcej błędów"
            QMessageBox.information(self, "Edycja klawiatury", message, QMessageBox.Ok)
        else:
            message = f"Nie udało się zaktualizować żadnej komórki (cyfra: {start_hour})"
            if error_messages:
                message += f"\n\nBłędy:\n" + "\n".join(error_messages[:5])
            QMessageBox.warning(self, "Błąd edycji klawiatury", message, QMessageBox.Ok)

    def _prepare_deletion_summary_message(self, schedule_cells: list) -> str:
        """
        Przygotowuje sformatowaną wiadomość podsumowującą, które symbole zostaną usunięte,
        grupując je według użytkownika i dat.
        """
        if not schedule_cells:
            return "Nie wybrano żadnych komórek z symbolami do usunięcia."
        grouped_deletions = {}
        for cell_data in schedule_cells:
            user_name = cell_data.get('uzytkownik_dane', 'Nieznany Użytkownik')
            date_str = cell_data.get('date_str', 'Nieznana Data')
            symbol = cell_data.get('symbol', '??')
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except ValueError:
                formatted_date = date_str
            if user_name not in grouped_deletions:
                grouped_deletions[user_name] = []
            grouped_deletions[user_name].append(f"{formatted_date} (symbol: {symbol})")

        summary_lines = ["Czy na pewno chcesz usunąć symbole dla następujących pozycji?\n"]
        for user_name, date_symbol_list in grouped_deletions.items():
            summary_lines.append(f"🧑 {user_name}:")
            for date_with_symbol in sorted(date_symbol_list):
                summary_lines.append(f"   • {date_with_symbol}")
            summary_lines.append("")
        summary_lines.append(f"Łącznie zostanie wyczyszczonych: {len(schedule_cells)} komórek.")
        return "\n".join(summary_lines)

    def clear_selected_cells(self):
        try:
            if hasattr(self, 'keyboard_filter') and hasattr(self.keyboard_filter, '_buffer_timer'):
                self.keyboard_filter._buffer_timer.stop()
                self.keyboard_filter._digit_buffer = ""

            selected_cells_data = self.table.get_data_for_selected_cells()
            if not selected_cells_data:
                return

            schedule_cells = [cell for cell in selected_cells_data if cell.get('symbol', '').strip()]
            if not schedule_cells:
                QMessageBox.information(self, "Brak symboli do usunięcia", "Zaznaczone komórki są już puste.", QMessageBox.Ok)
                return

            # Wstępne sprawdzenie (można pominąć, bo i tak sprawdzamy w pętli, ale zostawiamy dla szybkiego feedbacku)
            if not any(self._get_permission_for_cell(c)['can_delete'] for c in schedule_cells):
                 QMessageBox.warning(self, "Brak uprawnień", "Nie posiadasz uprawnień do usunięcia symboli dla żadnej z zaznaczonych osób.")
                 return

            user_date_pairs = {(cell.get('uzytkownik_id'), cell.get('date_str')) for cell in schedule_cells}
            events_to_cancel = self._find_events_to_cancel(user_date_pairs)

            reply = QMessageBox.Yes
            if self._should_ask_for_confirmation():
                confirmation_message = self._prepare_deletion_summary_message(schedule_cells)
                if events_to_cancel:
                    grouped_events = self._group_events_by_user_date(events_to_cancel)
                    delegations_info = self._prepare_delegations_description(grouped_events)
                    confirmation_message += f"\n\n{delegations_info}"
                reply = QMessageBox.question(self, "Potwierdzenie usunięcia", confirmation_message, QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

            if reply == QMessageBox.Yes:
                if events_to_cancel: self._cancel_delegations(events_to_cancel)
                self._clear_cells_symbols(schedule_cells)
        except Exception as e:
            log_error(f"Błąd podczas czyszczenia komórek: {e}", exception=e)
            QMessageBox.critical(self, "Błąd krytyczny", f"Wystąpił nieoczekiwany błąd: {str(e)}")


    def _clear_cells_symbols(self, schedule_cells: list):
        """Usuwa symbole z indywidualnym sprawdzaniem uprawnień."""
        successful_updates, failed_updates = 0, 0
        error_messages, affected_pairs, skipped_employees = [], [], []

        for cell_data in schedule_cells:
            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_delete']:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue

            user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get('date_str'), cell_data.get('nr_kadrowy')

            if not all([user_id, date_str, nr_kadrowy]):
                failed_updates += 1
                error_messages.append(f"Niekompletne dane dla komórki: user_id={user_id}, data={date_str}, nr_kadrowy={nr_kadrowy}.")
                continue

            try:
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol="")
                if result.get('success', False):
                    successful_updates += 1
                    affected_pairs.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    failed_updates += 1
                    error_msg = result.get('message', 'Nieznany błąd.')
                    error_messages.append(f"Pracownik {nr_kadrowy} (dnia {date_str}): {error_msg}")
            except Exception as e:
                failed_updates += 1
                error_messages.append(f"{nr_kadrowy} ({date_str}): Błąd krytyczny - {str(e)}")
                log_error(f"Krytyczny błąd podczas usuwania symbolu dla {user_id}, {date_str}: {e}", exception=e)

        if successful_updates > 0:
            self._update_cells_with_new_symbols(affected_pairs)

        self._show_clear_symbols_results(successful_updates, failed_updates, error_messages, skipped_employees)

    def _show_clear_symbols_results(self, successful_updates: int, failed_updates: int, error_messages: list,
                                    skipped_employees: list):
        """
        Wyświetla użytkownikowi podsumowanie operacji usuwania symboli,
        uwzględniając komórki pominięte z powodu braku uprawnień.
        """
        title = ""
        full_message = ""

        # Komunikat o sukcesach
        if successful_updates > 0:
            full_message += f"Pomyślnie usunięto symbole z {successful_updates} komórek.\\n"

        # Komunikat o pominiętych pracownikach z powodu braku uprawnień
        if skipped_employees:
            # Używamy set(), aby uniknąć duplikatów nazwisk w komunikacie
            unique_skipped = set(skipped_employees)
            full_message += (f"\\nPominięto {len(skipped_employees)} komórek z powodu braku uprawnień dla:\\n"
                             f"- {', '.join(unique_skipped)}\\n")

        # Komunikat o błędach
        if failed_updates > 0:
            title = "Częściowy sukces" if successful_updates > 0 or skipped_employees else "Błąd usuwania"
            error_list_str = "\\n - " + "\\n - ".join(error_messages[:10])
            full_message += f"\\nNie udało się usunąć {failed_updates} symboli z powodu błędów:{error_list_str}"
            if len(error_messages) > 10:
                full_message += f"\\n... i {len(error_messages) - 10} więcej błędów."

        elif successful_updates > 0 or skipped_employees:
            title = "Zakończono operację"

        # Wyświetl komunikat tylko, jeśli cokolwiek się wydarzyło
        if full_message:
            # Jeśli nie było błędów ani pominięć, pokaż tylko informację na pasku statusu
            if successful_updates > 0 and failed_updates == 0 and not skipped_employees:
                self.statusBar().showMessage(full_message.strip(), 4000)
            else:
                # W przeciwnym razie, pokaż pełne okno dialogowe z podsumowaniem
                QMessageBox.information(self, title, full_message.strip())

    def set_cell_data(self, row, col, data_dict):
        """Ustawia dane w komórce modelu."""
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return False

        if not isinstance(data_dict, dict):
            log_error(f"Błąd: data_dict nie jest słownikiem: {type(data_dict)}")
            return False

        # Utwórz indeks modelu dla podanej pozycji
        index = self.schedule_model.index(row, col)
        if not index.isValid():
            return False

        # Ustaw dane w modelu
        return self.schedule_model.setData(index, data_dict, Qt.UserRole)

    def on_data_changed(self, data_type, year, month):
        """Obsługuje powiadomienie o zmianie danych z DataProvider."""
        current_data = self.date_combo.currentData()
        if not (current_data and current_data == (year, month)):
            return

        if data_type == "schedule":
            self.update_table_content()
        elif data_type == "events":
            # Po prostu odświeżamy tabelę zdarzeń, jeśli coś się w nich zmieniło
            self.on_selection_changed()

    def log_time(self, label, start_time):
        """Pomocnicza funkcja do logowania czasu"""
        end_time = time.time()
        elapsed = end_time - start_time
        debug_print(f"[CZAS] {label}: {elapsed:.3f} sekundy")
        return end_time

    def setup_ui(self):
        """Ustawia interfejs użytkownika"""
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(10, 0, 10, 0)
        main_layout.setSpacing(0)
        top_bar = self.setup_top_bar(main_layout)
        main_layout.addWidget(top_bar)
        middle_splitter = self.setup_middle_section(main_layout)
        main_layout.addWidget(middle_splitter, 1)
        self.setCentralWidget(central_widget)

    def setup_top_bar(self, main_layout):
        top_bar_frame = QFrame()
        top_bar_frame.setFrameShape(QFrame.StyledPanel)
        top_bar_frame.setFrameShadow(QFrame.Raised)
        top_bar_frame.setFixedHeight(50)
        top_bar_layout = QHBoxLayout(top_bar_frame)
        top_bar_layout.setContentsMargins(5, 5, 5, 5)
        top_bar_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        self.toggle_menu_button = QPushButton("☰")
        self.toggle_menu_button.setFixedSize(32, 32)
        self.toggle_menu_button.setToolTip("Pokaż/ukryj panel filtrów (F1)")
        self.toggle_menu_button.clicked.connect(self.toggle_left_panel)
        top_bar_layout.addWidget(self.toggle_menu_button)

        self.settings_button = QPushButton("Ustawienia")
        self.settings_button.clicked.connect(self.show_settings_dialog)
        top_bar_layout.addWidget(self.settings_button)

        top_bar_layout.addWidget(self.create_separator())

        top_bar_layout.addWidget(QLabel("Miesiąc:"))
        self.date_combo = QComboBox()
        self.date_combo.setMinimumWidth(120)
        # --- POCZĄTEK POPRAWKI: Pozostawiono tylko jedno, poprawne podłączenie ---
        self.date_combo.currentIndexChanged.connect(self.refresh_data)
        # --- KONIEC POPRAWKI ---
        top_bar_layout.addWidget(self.date_combo)

        self.load_data_button = QPushButton("🚀 Pobierz Dane")
        self.load_data_button.setToolTip("Kliknij, aby połączyć się z bazą i załadować dane.")
        top_bar_layout.addWidget(self.load_data_button)
        self.load_data_button.setVisible(True)

        self.refresh_button = QPushButton("Odśwież")
        self.refresh_button.setToolTip("Odśwież dane dla bieżących filtrów")
        self.refresh_button.clicked.connect(self.refresh_data)
        top_bar_layout.addWidget(self.refresh_button)
        self.refresh_button.setVisible(False)

        self.export_button = QPushButton("Eksportuj do Excel")
        self.export_button.setToolTip("Zapisz aktualny widok grafiku do pliku CSV")
        self.export_button.clicked.connect(self.export_schedule_to_csv)
        top_bar_layout.addWidget(self.export_button)

        self.show_audit_button = QPushButton("Historia Zmian")
        self.show_audit_button.clicked.connect(self.show_audit_log_window)
        top_bar_layout.addWidget(self.show_audit_button)

        self.staffing_details_button = QPushButton("Obsada")
        self.staffing_details_button.clicked.connect(self.show_staffing_details_window)
        top_bar_layout.addWidget(self.staffing_details_button)

        self.schedule_control_button = QPushButton("Zarządzaj Grafikiem")
        self.schedule_control_button.clicked.connect(self.show_schedule_control_dialog)
        top_bar_layout.addWidget(self.schedule_control_button)

        top_bar_layout.addStretch()

        return top_bar_frame

    def create_separator(self):
        separator = QFrame()
        separator.setFrameShape(QFrame.VLine)
        separator.setFrameShadow(QFrame.Sunken)
        return separator

    def setup_date_combo(self):
        """Konfiguruje combobox z datami, uwzględniając uprawnienia."""
        self.date_combo.blockSignals(True)
        current_date = datetime.now()
        months_to_show = []
        year, month = current_date.year, current_date.month

        for i in range(3, 0, -1):
            prev_month, prev_year = (month - i, year)
            while prev_month <= 0:
                prev_month += 12
                prev_year -= 1
            months_to_show.append((prev_year, prev_month))

        months_to_show.append((year, month))

        if self.can_see_next_month:
            next_month, next_year = (month + 1, year)
            if next_month > 12:
                next_month = 1
                next_year += 1
            months_to_show.append((next_year, next_month))

        current_index = self.date_combo.currentIndex()
        if current_index == -1:
            current_index = 3

        self.date_combo.clear()
        for y, m in months_to_show:
            self.date_combo.addItem(f"{y}-{m:02d}", (y, m))

        self.date_combo.setCurrentIndex(min(current_index, self.date_combo.count() - 1))
        self.date_combo.blockSignals(False)

    def setup_middle_section(self, main_layout):
        """Tworzy środkową sekcję z filtrem i tabelami"""
        main_splitter = QSplitter(Qt.Horizontal)
        main_splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.setup_left_panel()
        right_panel = self.setup_right_panel()
        main_splitter.addWidget(self._left_panel)
        main_splitter.addWidget(right_panel)

        # Ustawienie rozmiarów początkowych
        main_splitter.setSizes([260, 1200])
        self.main_splitter = main_splitter

        self.main_splitter.setStretchFactor(0, 0)
        self.main_splitter.setStretchFactor(1, 1)

        return main_splitter

    def setup_left_panel(self):
        """Tworzy lewy panel z filtrami wewnątrz QScrollArea dla pełnej elastyczności."""
        self._left_panel = QWidget()
        self._left_panel.setMinimumSize(0, 0)
        panel_main_layout = QVBoxLayout(self._left_panel)
        panel_main_layout.setContentsMargins(0, 0, 0, 0)
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.NoFrame)
        filter_container = QWidget()
        filters_layout = QVBoxLayout(filter_container)
        filters_layout.setContentsMargins(10, 10, 10, 10)
        filters_layout.setSpacing(6)

        # --- POCZĄTEK ZMIAN ---

        presence_group = QGroupBox("Obecni w pracy w dniu:")
        presence_group.setCheckable(True)
        presence_group.setChecked(False)
        self.filter_by_presence_check = presence_group

        presence_layout = QGridLayout(presence_group)
        presence_layout.setContentsMargins(5, 10, 5, 5)

        self.presence_date_edit = QDateEdit(QDate.currentDate())
        self.presence_date_edit.setCalendarPopup(True)
        self.presence_date_edit.setDisplayFormat("dd.MM.yyyy")

        # 1. Zmiana QComboBox na CustomMultiComboBox
        self.presence_location_combo = CustomMultiComboBox()
        # Dodajemy opcje jako lista stringów
        location_items = [
            "Home Office (h)",
            "SBC (s)",
            "mPrzystanek (p)",
            "Bez lokalizacji"
        ]
        self.presence_location_combo.add_items(location_items)

        theme = "dark" if self.is_dark_theme else "light"
        self.presence_date_edit.setStyleSheet(AppStyles.get_date_edit_style(theme))
        self.presence_location_combo.setStyleSheet(AppStyles.get_combobox_style(theme))

        presence_layout.addWidget(QLabel("Data:"), 0, 0)
        presence_layout.addWidget(self.presence_date_edit, 0, 1)
        presence_layout.addWidget(QLabel("Lokalizacja:"), 1, 0)
        presence_layout.addWidget(self.presence_location_combo, 1, 1)

        presence_layout.setColumnStretch(2, 1)

        filters_layout.addWidget(presence_group)

        # 2. Zmiana podłączanych sygnałów
        self.filter_by_presence_check.toggled.connect(self.filter_data)
        self.presence_date_edit.dateChanged.connect(self.filter_data)
        self.presence_location_combo.selection_changed.connect(self.filter_data)

        # --- KONIEC ZMIAN ---

        separator = QFrame()
        separator.setFrameShape(QFrame.HLine)
        separator.setFrameShadow(QFrame.Sunken)
        filters_layout.addWidget(separator)

        self.add_horizontal_filter("Grupa:", "grupa_main_filter_combo", filters_layout)
        self.add_horizontal_filter("Wydział:", "wydzial_combo", filters_layout)
        self.add_horizontal_search_filter("Przełożony:", "przelozony_filter", filters_layout)
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)
        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.przelozony_list)

        self.add_horizontal_search_filter("Użytkownik:", "uzytkownik_filter", filters_layout)
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)
        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.uzytkownik_list)

        self.add_horizontal_filter("LD:", "default_location_combo", filters_layout)
        self.add_horizontal_filter("System Pracy:", "system_czasu_pracy_combo", filters_layout)
        self.add_horizontal_filter("Rola:", "rola_combo", filters_layout)
        self.add_horizontal_filter("Język:", "jezyk_combo", filters_layout)
        self.add_horizontal_filter("Etat:", "etat_combo", filters_layout)
        self.add_horizontal_filter("DTN:", "dtn_combo", filters_layout)

        self.clear_filters_button = QPushButton("Wyczyść filtry")
        self.clear_filters_button.clicked.connect(self.clear_filters)
        filters_layout.addStretch()
        filters_layout.addWidget(self.clear_filters_button)

        scroll_area.setWidget(filter_container)
        panel_main_layout.addWidget(scroll_area)

    def add_horizontal_filter(self, label_text, combo_name, parent_layout):
        """Dodaje filtr w układzie poziomym (etykieta + kontrolka w jednej linii)"""
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)
        filter_layout.setSpacing(4)
        filter_label = QLabel(label_text)
        filter_label.setFixedWidth(80)
        filter_layout.addWidget(filter_label)
        combo = CustomMultiComboBox()
        combo.setFixedHeight(24)
        combo.view().setMaximumWidth(240)
        combo.selection_changed.connect(self.filter_data)
        setattr(self, combo_name, combo)
        filter_layout.addWidget(combo, 1)
        parent_layout.addLayout(filter_layout)

    def add_horizontal_search_filter(self, label_text, filter_name, parent_layout):
        """Dodaje filtr wyszukiwania w układzie poziomym"""
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)
        filter_layout.setSpacing(4)
        filter_label = QLabel(label_text)
        filter_label.setFixedWidth(80)
        filter_layout.addWidget(filter_label)
        text_edit = QLineEdit()
        text_edit.setPlaceholderText(f"Filtruj {label_text.lower()[:-1]}...")
        text_edit.setFixedHeight(24)
        setattr(self, filter_name, text_edit)
        filter_layout.addWidget(text_edit, 1)
        parent_layout.addLayout(filter_layout)

    def load_initial_data(self):
        """Uruchamia proces ładowania danych po pierwszym wyświetleniu okna."""
        debug_print("Uruchamianie leniwego ładowania danych początkowych...")
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data
            # Użyj atrybutów obiektu zamiast wartości z kontrolek
            self.update_data(year, month, self.import_grupa, self.import_funkcja, use_async=True)
            self.update_filter_dates()

    def setup_right_panel(self):
        """Tworzy prawy panel z tabelami"""
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)
        right_splitter = QSplitter(Qt.Vertical)
        schedule_frame = self.setup_schedule_section()
        events_frame = self.setup_events_section()
        right_splitter.addWidget(schedule_frame)
        right_splitter.addWidget(events_frame)
        right_splitter.setSizes([650, 350])
        right_layout.addWidget(right_splitter)
        return right_panel

    def setup_schedule_section(self):
        """Tworzy sekcję grafiku (górna część prawego panelu) używając SplitTableView."""
        schedule_frame = QFrame()
        schedule_layout = QVBoxLayout(schedule_frame)
        schedule_layout.setContentsMargins(5, 5, 5, 5)

        self.table = SplitTableView()
        schedule_layout.addWidget(self.table)

        # Tworzymy przycisk i kontener na pozostałe przyciski
        self.manage_columns_button = QPushButton("Zarządzaj kolumnami")
        button_frame = self.setup_schedule_buttons()
        button_layout = button_frame.layout()

        # Wstawiamy przycisk zarządzania kolumnami na początek layoutu z przyciskami
        if isinstance(button_layout, QHBoxLayout):
            button_layout.insertWidget(0, self.manage_columns_button)

        # --- POCZĄTEK POPRAWKI ---
        # Dodajemy kontener z WSZYSTKIMI przyciskami do layoutu sekcji grafiku - TYLKO RAZ.
        # Usunięto zduplikowaną linię, która powodowała błąd.
        schedule_layout.addWidget(button_frame)
        # --- KONIEC POPRAWKI ---

        return schedule_frame

    def setup_schedule_buttons(self):
        """Tworzy przyciski akcji dla sekcji grafiku"""
        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setContentsMargins(0, 0, 0, 0)
        button_frame.setFixedHeight(40)
        button_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.toggle_events_panel_button = QPushButton("Ukryj zdarzenia↓")
        self.toggle_events_panel_button.setToolTip("Ukryj panel zdarzeń (dla większego widoku grafiku) (F2)")
        self.toggle_events_panel_button.clicked.connect(self.toggle_events_panel)
        self.location_exception_button = QPushButton("Wyjątki lokalizacyjne")
        self.location_exception_button.setToolTip("Zarządzaj wyjątkami od domyślnej lokalizacji pracy")
        self.location_exception_button.clicked.connect(self.show_location_exception_dialog)
        button_layout.addWidget(self.location_exception_button)
        button_layout.addStretch()
        self.insert_change_button = QPushButton("Wstaw zmianę")
        self.insert_change_button.setToolTip("Wstaw zmianę grafiku (F3)")
        self.insert_change_button.clicked.connect(self.show_insert_change_dialog)
        button_layout.addWidget(self.insert_change_button)
        self.insert_symbol_button = QPushButton("Wstaw nieobecność")
        self.insert_symbol_button.setToolTip("Wstaw nieobecność (F4)")
        self.insert_symbol_button.clicked.connect(self.show_insert_symbol_dialog)
        button_layout.addWidget(self.insert_symbol_button)
        self.cancel_delegation_button = QPushButton("Odwołaj delegacje")
        self.cancel_delegation_button.setToolTip("Odwołaj delegacje dla zaznaczonych komórek (F5)")
        self.cancel_delegation_button.clicked.connect(self.cancel_delegations)
        button_layout.addWidget(self.cancel_delegation_button)
        self.add_overtime_button = QPushButton("Dodaj nadgodziny")
        self.add_overtime_button.setShortcut("Insert")
        self.add_overtime_button.setToolTip("Dodaj nadgodziny dla zaznaczonych komórek (Insert)")
        self.add_overtime_button.clicked.connect(self.show_add_overtime_dialog)
        button_layout.addWidget(self.add_overtime_button)
        # Usunięto redundantny warunek, widoczność jest zarządzana przez update_buttons_visibility
        return button_frame

    def setup_events_section(self):
        """Tworzy sekcję zdarzeń używając QTableView i od razu konfiguruje jej kolumny."""
        events_frame = QFrame()
        events_frame.setFrameShape(QFrame.Shape.StyledPanel)
        events_frame.setFrameShadow(QFrame.Shadow.Raised)
        events_layout = QVBoxLayout(events_frame)
        events_layout.setContentsMargins(5, 5, 5, 5)

        filters_frame = self.setup_events_filters()
        events_layout.addWidget(filters_frame)

        self.events_table = QTableView()
        self.events_table.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.events_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.events_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)

        events_layout.addWidget(self.events_table)
        return events_frame

    def setup_events_filters(self):
        """Konfiguruje filtry dla tabeli zdarzeń"""
        events_filter_frame = QFrame()
        events_filter_layout = QHBoxLayout(events_filter_frame)
        events_filter_layout.setContentsMargins(0, 0, 0, 0)

        # Filtry daty od-do
        date_from_label = QLabel("Data od:")
        self.date_from = QDateEdit()
        self.date_from.setMinimumWidth(100)
        self.date_from.setDisplayFormat("dd.MM.yyyy")
        self.date_from.setDate(QDate.currentDate().addDays(-30))
        self.date_from.setCalendarPopup(True)
        self.date_from.setStyleSheet(AppStyles.get_date_edit_style("dark" if self.is_dark_theme else "light"))

        date_to_label = QLabel("Data do:")
        self.date_to = QDateEdit()
        self.date_to.setMinimumWidth(100)
        self.date_to.setDisplayFormat("dd.MM.yyyy")
        self.date_to.setDate(QDate.currentDate())
        self.date_to.setCalendarPopup(True)
        self.date_to.setStyleSheet(AppStyles.get_date_edit_style("dark" if self.is_dark_theme else "light"))

        # Filtr tematu
        topic_label = QLabel("Temat:")
        self.topic_filter = QLineEdit()
        self.topic_filter.setPlaceholderText("Filtruj po temacie...")
        self.topic_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))

        # Filtr nazwy
        name_label = QLabel("Nazwa:")
        self.name_filter = QLineEdit()
        self.name_filter.setPlaceholderText("Filtruj po nazwie...")
        self.name_filter.setStyleSheet(AppStyles.get_line_edit_style("dark" if self.is_dark_theme else "light"))

        # Checkboxy do filtrowania typów zdarzeń
        self.meetings_checkbox = QCheckBox("Spotkania")
        self.meetings_checkbox.setChecked(True)
        self.meetings_checkbox.stateChanged.connect(self.filter_events_table)

        self.trainings_checkbox = QCheckBox("Szkolenia")
        self.trainings_checkbox.setChecked(True)
        self.trainings_checkbox.stateChanged.connect(self.filter_events_table)

        self.overtime_checkbox = QCheckBox("Nadgodziny")
        self.overtime_checkbox.setChecked(True)
        self.overtime_checkbox.stateChanged.connect(self.filter_events_table)

        # Podłącz sygnały zmiany daty bezpośrednio do filtrowania
        self.date_from.dateChanged.connect(self.filter_events_table)
        self.date_to.dateChanged.connect(self.filter_events_table)
        self.topic_filter.textChanged.connect(self.filter_events_table)
        self.name_filter.textChanged.connect(self.filter_events_table)

        # Dodaj kontrolki do layoutu filtrów zdarzeń
        events_filter_layout.addWidget(date_from_label)
        events_filter_layout.addWidget(self.date_from)
        events_filter_layout.addWidget(date_to_label)
        events_filter_layout.addWidget(self.date_to)
        events_filter_layout.addWidget(topic_label)
        events_filter_layout.addWidget(self.topic_filter)
        events_filter_layout.addWidget(name_label)
        events_filter_layout.addWidget(self.name_filter)
        events_filter_layout.addWidget(self.meetings_checkbox)
        events_filter_layout.addWidget(self.trainings_checkbox)
        events_filter_layout.addWidget(self.overtime_checkbox)
        events_filter_layout.addStretch()

        return events_filter_frame

    def setup_events_table_columns(self):
        """Konfiguruje kolumny dla tabeli zdarzeń."""
        header = self.events_table.horizontalHeader()
        header.setSectionsClickable(True)
        self.events_table.setSortingEnabled(True)

        for i in range(self.events_table.model().columnCount()):
            header.setSectionResizeMode(i, QHeaderView.ResizeToContents)
        header.setSectionResizeMode(9, QHeaderView.Fixed)
        self.events_table.setColumnWidth(9, 50)
        header.setSectionResizeMode(3, QHeaderView.Stretch)
        header.setSectionResizeMode(2, QHeaderView.Stretch)

    def setup_table_properties(self):
        """Konfiguruje właściwości tabel i tworzy delegatów z ustawieniami."""
        self.events_table.setSortingEnabled(True)
        self.events_table.sortByColumn(0, Qt.AscendingOrder)
        if hasattr(self.table, 'employees_view'):
            self.table.employees_view.setSortingEnabled(True)
            self.table.employees_view.sortByColumn(-1, Qt.AscendingOrder)
        self.last_sort_column = 0
        self.last_sort_order = Qt.AscendingOrder
        if hasattr(self.table, 'employees_view') and hasattr(self.table.employees_view, 'horizontalHeader'):
            self.table.employees_view.horizontalHeader().sortIndicatorChanged.connect(self.on_sort_changed)
        if hasattr(self.events_table, 'horizontalHeader'):
            self.events_table.horizontalHeader().sortIndicatorChanged.connect(self.on_events_sort_changed)
            self.setup_events_table_columns()
        view_settings = {
            'show_special_symbol': self.user_settings.get('show_special_symbol', True),
            'show_location_symbol': self.user_settings.get('show_location_symbol', True),
            'special_symbol_position': self.user_settings.get('special_symbol_position', 'top_left'),
            'location_symbol_position': self.user_settings.get('location_symbol_position', 'bottom_left')
        }
        overtime_delegate = OvertimeItemDelegate(settings=view_settings)
        self.table.schedule_view.setItemDelegate(overtime_delegate)
        button_delegate = ButtonDelegate(parent=self, button_text="Usuń", is_dark_theme=self.is_dark_theme)
        button_delegate.button_clicked.connect(self.delete_event_from_row)
        self.events_table.setItemDelegateForColumn(9, button_delegate)

    def toggle_left_panel(self):
        """Przełącza widoczność lewego panelu filtrów z zapamiętywaniem rozmiaru."""
        current_sizes = self.main_splitter.sizes()

        # Sprawdź, czy lewy panel jest zwinięty (jego rozmiar jest bliski zeru)
        if current_sizes[0] < 10:
            # Rozwiń panel do ostatniej znanej lub domyślnej szerokości
            right_width = max(0, sum(current_sizes) - self.last_left_panel_width)
            self.main_splitter.setSizes([self.last_left_panel_width, right_width])
        else:
            # Zwiń panel, zapamiętując jego aktualną szerokość
            self.last_left_panel_width = current_sizes[0]
            self.main_splitter.setSizes([0, sum(current_sizes)])

    # def toggle_left_panel(self):
    #     """Przełącza widoczność lewego panelu filtrów"""
    #     if self.left_panel_visible:
    #         # Ukryj panel
    #         self.left_panel_width = self._left_panel.width()  # Zapamiętaj bieżącą szerokość
    #         self._left_panel.setFixedWidth(0)
    #         self._left_panel.setVisible(False)  # WAŻNE: Ukryj panel całkowicie
    #         self.left_panel_visible = False
    #         self.toggle_menu_button.setText("☲")  # Zmień ikonę na "pokaż menu"
    #         self.toggle_menu_button.setToolTip("Pokaż panel filtrów")
    #     else:
    #         # Pokaż panel
    #         self._left_panel.setVisible(True)  # WAŻNE: Najpierw pokaż panel
    #         self._left_panel.setMinimumWidth(200)
    #         self._left_panel.setMaximumWidth(250)
    #
    #         # Sprawdź czy mamy zapamiętaną szerokość
    #         if hasattr(self, 'left_panel_width'):
    #             self._left_panel.setFixedWidth(self.left_panel_width)
    #         else:
    #             self._left_panel.setFixedWidth(200)  # Domyślna szerokość
    #
    #         self.left_panel_visible = True
    #         self.toggle_menu_button.setText("☰")  # Przywróć ikonę "burger menu"
    #         self.toggle_menu_button.setToolTip("Pokaż/ukryj panel filtrów (F1)")
    #
    #     # DODANE: Wymuś ponowne rozłożenie splittera
    #     current_sizes = self.main_splitter.sizes()
    #     if not self.left_panel_visible:
    #         # Gdy ukrywamy panel, dajemy całą przestrzeń prawemu panelowi
    #         self.main_splitter.setSizes([0, sum(current_sizes)])
    #     else:
    #         # Gdy pokazujemy panel, przywracamy proporcje
    #         if hasattr(self, 'left_panel_width'):
    #             right_size = sum(current_sizes) - self.left_panel_width
    #             self.main_splitter.setSizes([self.left_panel_width, right_size])
    #         else:
    #             # Domyślnie 20% - 80%
    #             total = sum(current_sizes)
    #             self.main_splitter.setSizes([int(total * 0.2), int(total * 0.8)])
    #
    #     # Wymuś aktualizację widoku
    #     self.main_splitter.update()
    #
    #     # DODANE: Odśwież układ całego okna
    #     QApplication.processEvents()
    #     self.update()

    def toggle_events_panel(self):
        """Przełącza widoczność panelu zdarzeń (dolny panel)"""
        right_splitter = self.centralWidget().findChild(QSplitter, self.main_splitter.objectName()).widget(1).findChild(
            QSplitter)
        if not right_splitter: return

        sizes = right_splitter.sizes()
        if sizes[1] > 0:
            self.events_panel_height = sizes[1]
            right_splitter.setSizes([sum(sizes), 0])
            self.toggle_events_panel_button.setText("Pokaż zdarzenia↑")
        else:
            schedule_height = right_splitter.height() - getattr(self, 'events_panel_height', 300)
            right_splitter.setSizes([schedule_height, getattr(self, 'events_panel_height', 300)])
            self.toggle_events_panel_button.setText("Ukryj zdarzenia↓")

    def export_schedule_to_csv(self):
        """Zbiera aktualnie widoczne dane z grafiku i eksportuje je do pliku CSV."""
        if not self.schedule_model or self.schedule_model.rowCount() == 0:
            QMessageBox.warning(self, "Brak danych", "Brak danych do wyeksportowania.")
            return

        default_filename = f"grafik_{self.year}-{self.month:02d}.csv"

        file_path, _ = QFileDialog.getSaveFileName(self, "Zapisz plik Excel (CSV)", default_filename,
                                                   "Pliki CSV (*.csv);;Wszystkie pliki (*)")

        if not file_path:
            return

        try:
            import csv

            headers = self.schedule_model._column_headers[:len(self.visible_columns)]
            days_in_month = self.schedule_model._days_in_month
            for day in range(1, days_in_month + 1):
                headers.append(str(day))

            data_rows = []
            visible_keys = self.schedule_model._keys

            for key in visible_keys:
                # --- POCZĄTEK POPRAWKI: Usunięto podkreślenie z self.processed_data ---
                row_data = self.processed_data.get(key, {})
                # --- KONIEC POPRAWKI ---
                row_to_write = []

                for col_id in self.visible_columns:
                    if col_id == 'wydzial':
                        row_to_write.append(key[0])
                    elif col_id == 'przelozony':
                        row_to_write.append(key[1])
                    elif col_id == 'uzytkownik_dane':
                        row_to_write.append(key[2])
                    else:
                        row_to_write.append(str(row_data.get(col_id, '')))

                days_data = row_data.get('days', {})
                for day in range(1, days_in_month + 1):
                    symbol = days_data.get(day, {}).get('symbol', '')
                    row_to_write.append(symbol)

                data_rows.append(row_to_write)

            with open(file_path, 'w', newline='', encoding='utf-8-sig') as csv_file:
                writer = csv.writer(csv_file, delimiter=';')
                writer.writerow(headers)
                writer.writerows(data_rows)

            QMessageBox.information(self, "Eksport zakończony",
                                    f"Dane zostały pomyślnie zapisane w pliku:\n{file_path}")

        except Exception as e:
            log_error(f"Błąd podczas eksportu do CSV: {e}", exception=e)
            QMessageBox.critical(self, "Błąd eksportu", f"Wystąpił nieoczekiwany błąd:\n{e}")

    def show_column_select_dialog(self):
        """Wyświetla dialog wyboru kolumn."""
        from column_select_dialog import ColumnSelectDialog

        try:
            if not hasattr(self, 'schedule_model'):
                QMessageBox.warning(self, "Błąd", "Model danych nie jest zainicjalizowany.", QMessageBox.Ok)
                return

            dialog = ColumnSelectDialog(
                self, self.employee_columns, self.visible_columns, self.default_visible_columns,
                user_role=self.current_user_role, is_comment_column_checked=self.show_comment_column
            )

            if dialog.exec() == QDialog.Accepted:
                selected_columns = dialog.get_selected_columns()
                show_comment_state = dialog.get_comment_column_state()

                self.visible_columns = selected_columns
                self.show_comment_column = show_comment_state

                self.user_settings['visible_columns'] = self.visible_columns
                self.user_settings['show_schedule_comment'] = self.show_comment_column

                self.settings_db.save_settings(self.user_settings)

                self.schedule_model.set_visible_columns(self.visible_columns)
                self.schedule_model.set_show_comment_column(self.show_comment_column)
                self.refresh_column_configuration()
                if hasattr(self, 'table'):
                    self.table.set_model(self.schedule_model)
                    self.table.adjust_employees_table_width()
                    self._apply_dynamic_sizes()

                # --- DODANA LINIA ---
                self.apply_default_sort()  # Przywróć domyślne sortowanie
                # --- KONIEC ZMIANY ---

        except Exception as e:
            log_error(f"Błąd w show_column_select_dialog: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas zmiany kolumn: {str(e)}", QMessageBox.Ok)

    def _apply_dynamic_sizes(self):
        """Ustawia dynamiczne rozmiary w zależności od rozmiaru czcionki ORAZ zapisanych ustawień."""
        if not hasattr(self, 'table') or not self.table.employees_view.model() or self.schedule_model.rowCount() == 0:
            return

        # --- POCZĄTEK ZMIANY: Logika szerokości kolumn ---
        saved_widths = self.user_settings.get('column_widths', {})

        # Zastosuj zapisane szerokości
        visible_columns = self.schedule_model.get_visible_columns()
        for i, col_id in enumerate(visible_columns):
            if col_id in saved_widths:
                self.table.employees_view.setColumnWidth(i, saved_widths[col_id])
        # --- KONIEC ZMIANY ---

        font_size = self.current_font_size
        width_map = {7: 35, 8: 40, 9: 45, 10: 50, 11: 55, 12: 60}
        day_column_width = width_map.get(font_size, 40)
        height_map = {7: 25, 8: 25, 9: 25, 10: 28, 11: 28, 12: 30}
        row_height = height_map.get(font_size, 25)
        header_height_map = {7: 30, 8: 35, 9: 35, 10: 38, 11: 40, 12: 42}
        header_height = header_height_map.get(font_size, 35)

        self.table.set_header_height(header_height)
        header = self.table.schedule_view.horizontalHeader()
        model = self.table.employees_view.model()
        special_widths = {"Suma\\nRBH": 45, "Bilans\\nRBH": 45, "Komentarz": 300}

        for logical_index in range(model.columnCount()):
            header_text = model.headerData(logical_index, Qt.Horizontal, Qt.DisplayRole)
            width_to_set = special_widths.get(header_text, day_column_width)
            header.resizeSection(logical_index, width_to_set)

        days_in_month = model._days_in_month
        employee_cols_count = len(model.get_visible_columns())
        for day in range(1, 32):
            logical_index = employee_cols_count + (day - 1)
            if logical_index < model.columnCount():
                header.setSectionHidden(logical_index, day > days_in_month)

        self.table._force_sync_heights(row_height)

    def showEvent(self, event):
        """Automatycznie wywoływane przez Qt, gdy okno jest pokazywane po raz pierwszy."""
        super().showEvent(event)
        if not hasattr(self, '_initial_layout_done'):
            debug_print("Wykryto showEvent - jednorazowe ustawianie szerokości splittera.")
            self.table.adjust_employees_table_width()
            self._initial_layout_done = True

    def delete_event_from_row(self, row):
        """Usuwa zdarzenie na podstawie indeksu wiersza w tabeli zdarzeń."""
        if not hasattr(self, 'events_model') or not self.events_model:
            return
        event = self.events_model.get_event(row)
        if not event:
            return
        event_id = event.get('id')
        event_type = event.get('type')
        if not event_id or not event_type:
            return
        self.delete_event(event_id, event_type)

    def on_sort_changed(self, logical_index, order):
        """Obsługuje zmianę sortowania w tabeli grafiku"""
        self.last_sort_column = logical_index
        self.last_sort_order = order
        debug_print(
            f"Tabela grafiku: Sortowanie po kolumnie {logical_index}, kolejność: {'rosnąco' if order == Qt.AscendingOrder else 'malejąco'}")

    def on_events_sort_changed(self, logical_index, order):
        """Obsługuje zmianę sortowania w tabeli zdarzeń"""
        debug_print(
            f"Tabela zdarzeń: Sortowanie po kolumnie {logical_index}, kolejność: {'rosnąco' if order == Qt.AscendingOrder else 'malejąco'}")

    def update_buttons_visibility(self):
        """Aktualizuje widoczność przycisków na podstawie roli użytkownika"""
        is_next_month_selected = False
        current_data = self.date_combo.currentData()
        if current_data:
            selected_year, selected_month = current_data
            today = QDate.currentDate()
            next_month_date = today.addMonths(1)
            if selected_year == next_month_date.year() and selected_month == next_month_date.month():
                is_next_month_selected = True

        # Użycie centralnej funkcji do zarządzania widocznością przycisków
        if hasattr(self, 'add_overtime_button'):
            self.add_overtime_button.setVisible(
                app_settings.has_permission(self.current_user_role, 'button_add_overtime'))
        if hasattr(self, 'staffing_details_button'):
            self.staffing_details_button.setVisible(
                app_settings.has_permission(self.current_user_role, 'button_staffing_details'))
        if hasattr(self, 'show_audit_button'):
            self.show_audit_button.setVisible(app_settings.has_permission(self.current_user_role, 'button_show_audit'))
        if hasattr(self, 'schedule_control_button'):
            can_see_button = app_settings.has_permission(self.current_user_role, 'button_schedule_control')
            self.schedule_control_button.setVisible(can_see_button and is_next_month_selected)

    def show_audit_log_window(self):
        """Tworzy i pokazuje okno historii zmian."""
        # Leniwe importowanie
        from audit_log_window import AuditLogWindow

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Proszę najpierw wybrać miesiąc.")
            return

        year, month = current_data

        def _get_filtered_audit_data():
            full_data = self.data_provider.get_schedule_audit_data(year, month)
            selected_cells = self.table.get_data_for_selected_cells()
            if selected_cells:
                allowed_users_dates = set()
                for cell in selected_cells:
                    if (user_id := cell.get('uzytkownik_id')) and (date_str := cell.get('date_str')):
                        date_obj = QDate.fromString(date_str, "yyyy-MM-dd").toPython()
                        allowed_users_dates.add((user_id, date_obj))
                return [row for row in full_data if
                        row.get('Data') and (int(row.get('Uzytkownik')), row.get('Data').date()) in allowed_users_dates]
            else:
                visible_user_ids = {key[3] for key in self.schedule_model._keys}
                filtered_by_visibility = [row for row in full_data if row.get('Uzytkownik') is not None and int(
                    row.get('Uzytkownik')) in visible_user_ids]
                sorted_data = sorted(filtered_by_visibility, key=lambda x: x.get('DataModyfikacji'), reverse=True)
                return sorted_data[:50]

        selected_cells = self.table.get_data_for_selected_cells()
        is_limited = not selected_cells
        limit_count = 50
        initial_filtered_data = _get_filtered_audit_data()
        if not initial_filtered_data:
            QMessageBox.information(self, "Informacja", "Brak historii zmian dla wybranych filtrów / zaznaczenia.")
            return

        dialog = AuditLogWindow(initial_filtered_data, self.is_dark_theme, self, is_limited_view=is_limited, year=year,
                                month=month, limit=limit_count)

        def on_refresh_requested():
            self.data_provider.clear_audit_cache(year, month)
            fresh_filtered_data = _get_filtered_audit_data()
            dialog.update_model_data(fresh_filtered_data)
            QMessageBox.information(dialog, "Odświeżono", "Historia zmian została zaktualizowana.")

        dialog.refresh_requested.connect(on_refresh_requested)
        dialog.exec()

    def check_user_permissions(self):
        """Sprawdza uprawnienia użytkownika i zapisuje je w atrybutach klasy."""
        user_id, user_app_id, user_app_role, visible_next_month, user_department = get_modifier_id()
        self.current_user_id = user_id
        self.current_user_app_id = user_app_id
        self.current_user_role = user_app_role
        self.can_see_next_month = visible_next_month
        self.current_user_department = user_department

        if not app_settings.has_permission(user_app_role, 'app_access'):
            QMessageBox.critical(self, "Brak uprawnień",
                                 f"Nie masz uprawnień do korzystania z tej aplikacji.\n\nTwoja rola: {user_app_role}",
                                 QMessageBox.Ok)
            return False

        self.update_buttons_visibility()
        debug_print(f"Zalogowano jako: {user_app_id} ({user_app_role}), Wydział: {self.current_user_department}")
        return True

    def _can_modify_cells(self, selected_cells_data: list) -> bool:
        """
        Sprawdza, czy użytkownik ma jakiekolwiek uprawnienia do modyfikacji
        ZAZNACZONYCH komórek. Zwraca True, jeśli choć jedna komórka jest edytowalna.
        """
        if not selected_cells_data:
            return False

        # Sprawdzamy, czy istnieje choć jedna komórka, do której użytkownik ma jakiekolwiek prawo
        can_modify_anything = False
        for cell_data in selected_cells_data:
            permissions = self._get_permission_for_cell(cell_data)
            if any(permissions.values()):
                can_modify_anything = True
                break  # Wystarczy jedna komórka, przerywamy pętlę

        if not can_modify_anything:
            QMessageBox.warning(self, "Brak uprawnień",
                                "Nie posiadasz uprawnień do edycji grafiku dla żadnej z zaznaczonych osób lub komórek.")
            return False

        return True

    def show_insert_symbol_dialog(self):
        """Pokazuje okno dialogowe do wstawiania symbolu nieobecności."""
        if not app_settings.has_permission(self.current_user_role, 'schedule_cell_actions'):
            self.statusBar().showMessage("Brak uprawnień do wstawiania symboli.", 3000)
            return

        # --- POCZĄTEK POPRAWKI: Przywrócenie brakującego importu ---
        from schedule_edit_dialogs import InsertSymbolDialog
        # --- KONIEC POPRAWKI ---

        selected_cells_data = self.get_selected_cells_data()
        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono żadnych komórek do edycji.", QMessageBox.Ok)
            return

        dialog = InsertSymbolDialog(self, selected_cells_data=selected_cells_data)

        if dialog.exec():
            selected_symbol = dialog.get_selected_symbol()
            schedule_cells = [cell for cell in selected_cells_data if
                              isinstance(cell, dict) and 'date_str' in cell and 'uzytkownik_id' in cell]

            if not self._can_modify_cells(schedule_cells):
                return

            if not schedule_cells:
                QMessageBox.warning(self, "Brak komórek do edycji", "Nie zaznaczono żadnych komórek grafiku do edycji.",
                                    QMessageBox.Ok)
                return

            grouped_changes = self._group_cells_for_symbol_changes(schedule_cells)
            changes_info = self._prepare_symbol_changes_description(grouped_changes, selected_symbol)
            user_date_pairs = {(cell.get('uzytkownik_id'), cell.get('date_str')) for cell in schedule_cells if
                               cell.get('uzytkownik_id') and cell.get('date_str')}
            events_to_cancel = self._find_events_to_cancel(user_date_pairs)
            delegations_info = ""
            if events_to_cancel:
                grouped_events = self._group_events_by_user_date(events_to_cancel)
                delegations_info = self._prepare_delegations_description(grouped_events)

            complete_info = f"Czy na pewno chcesz wprowadzić następujące zmiany?\n\n{changes_info}"
            if delegations_info:
                complete_info += f"\n{delegations_info}"
            complete_info += f"\n\nŁącznie: {len(schedule_cells)} komórek zmieni symbol"
            if events_to_cancel:
                complete_info += f", {len(events_to_cancel)} zdarzeń zostanie odwołanych"

            reply = QMessageBox.Yes
            if self._should_ask_for_confirmation():
                reply = QMessageBox.question(self, "Potwierdzenie wstawienia nieobecności", complete_info,
                                             QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
            if reply == QMessageBox.Yes:
                self._apply_absence_symbol_changes(schedule_cells, selected_symbol, events_to_cancel)

    def _group_cells_for_symbol_changes(self, schedule_cells):
        """Grupuje komórki dla komunikatu potwierdzenia."""
        grouped_changes = {}
        for cell_data in schedule_cells:
            user_id, user_name, date_str, current_symbol = cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane', ''), cell_data.get('date_str'), cell_data.get('symbol', '').strip()
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str
            user_key = (user_id, user_name)
            if user_key not in grouped_changes:
                grouped_changes[user_key] = {}
            if formatted_date not in grouped_changes[user_key]:
                grouped_changes[user_key][formatted_date] = []
            grouped_changes[user_key][formatted_date].append({'current_symbol': current_symbol, 'cell_data': cell_data})
        return grouped_changes

    def _prepare_symbol_changes_description(self, grouped_changes, new_special_symbol):
        """Przygotowuje opis zmian symboli do komunikatu."""
        changes_info = ""
        for (user_id, user_name), dates in grouped_changes.items():
            changes_info += f"\n👤 {user_name}:\n"
            for date, cells in dates.items():
                changes_info += f"   📅 {date}: "
                # Pokaż przykład jak będzie wyglądał nowy symbol
                example_cell = cells[0]['cell_data']
                current_symbol = cells[0]['current_symbol']
                # Przewiduj jak będzie wyglądał nowy symbol
                predicted_symbol = self._predict_new_symbol(current_symbol, new_special_symbol, example_cell)
                if len(cells) == 1:
                    changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                else:
                    # Jeśli wiele komórek w tym dniu
                    current_symbols = [cell['current_symbol'] for cell in cells]
                    unique_symbols = set(current_symbols)
                    if len(unique_symbols) == 1:
                        changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                    else:
                        symbols_str = ", ".join([f"{s}" for s in unique_symbols])
                        changes_info += f"[{symbols_str}] -> {predicted_symbol}\n"
        return changes_info

    def _predict_new_symbol(self, current_symbol: str, special_symbol: str, cell_data: dict) -> str:
        """Przewiduje, jak będzie wyglądał nowy symbol po modyfikacji, z uwzględnieniem systemu równoważnego."""

        parsed_current = parse_symbol(current_symbol)

        # Domyślnie zachowujemy istniejące godziny
        final_start_hour = parsed_current.get('start_hour')
        final_work_hours = parsed_current.get('work_hours')

        # Sprawdzamy warunki do zmiany godzin
        system_pracy = cell_data.get('system_czasu_pracy', '').strip().lower()
        is_equivalent_system = (system_pracy == 'równoważny')
        is_absence_symbol = special_symbol.upper() in app_settings.get_absence_symbols()

        if is_equivalent_system and is_absence_symbol:
            # W systemie równoważnym, wstawienie absencji
            # ustawia liczbę godzin na wartość z etatu pracownika.

            # Pobierz etat i upewnij się, że jest to liczba całkowita
            final_work_hours = int(cell_data.get('etat'))

        # Logika zachowania lokalizacji (pozostaje bez zmian)
        SYMBOLS_PRESERVING_LOCATION = {"DYS", "T", "BC", "S", "P", "PR", "PD", "HO", "DK", "DZ", "BK", "BO", "CW", "MW"}
        final_location = None
        if special_symbol in SYMBOLS_PRESERVING_LOCATION or special_symbol is None:
            final_location = parsed_current.get('location') or cell_data.get('lokalizacja_domyslna')

        # Budowanie finalnego symbolu
        new_symbol = build_symbol(
            location=final_location,
            start_hour=final_start_hour,
            work_hours=final_work_hours,
            special_symbol=special_symbol
        )

        if not new_symbol.strip() and special_symbol and special_symbol.strip():
            return special_symbol.strip()
        return new_symbol.strip() if new_symbol else ""

    def _find_events_to_cancel(self, user_date_pairs):
        """Znajduje zdarzenia do odwołania dla podanych par użytkownik-data"""
        events_to_cancel = []
        for user_id, date_str in user_date_pairs:
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)
            for event in user_events:
                event_type, event_id, event_status = event.get('type', ''), event.get('id'), event.get('status')
                if not event_type or event_id is None: continue
                if event_status is not None: event_status = str(event_status)
                if event_type in ['Spotkanie', 'Szkolenie', 'Nadgodziny'] and event_status != '0':
                    events_to_cancel.append({
                        'id': event_id, 'type': event_type, 'user_id': user_id, 'date': date_str,
                        'date_key': event.get('date_key', date_str), 'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),
                    })
        return events_to_cancel

    def _group_events_by_user_date(self, events_to_cancel):
        """Grupuje zdarzenia według użytkownika i daty"""
        grouped_events = {}
        for event in events_to_cancel:
            key = (event['user_id'], event['date'])
            if key not in grouped_events:
                grouped_events[key] = []
            grouped_events[key].append(event)
        return grouped_events

    def _apply_absence_symbol_changes(self, schedule_cells, special_symbol, events_to_cancel):
        try:
            if events_to_cancel: self._cancel_delegations(events_to_cancel)
            successful_updates, failed_updates = 0, 0
            error_messages, affected_pairs, skipped_employees = [], [], []

            for cell_data in schedule_cells:
                # --- POCZĄTEK NOWEJ WERYFIKACJI ---
                target_dept = cell_data.get('wydzial', '').strip().lower()
                if self.current_user_role in ['Lider',
                                              'Lider OUT'] and target_dept == 'dtn' and special_symbol.upper() != 'CO':
                    # Dodaj do pominiętych z odpowiednim komunikatem i przejdź do następnej komórki
                    skipped_employees.append(f"{cell_data.get('uzytkownik_dane', 'Nieznany')} (Tylko 'CO' dla DTN)")
                    continue
                # --- KONIEC NOWEJ WERYFIKACJI ---

                permissions = self._get_permission_for_cell(cell_data)
                if not permissions['can_edit_symbol']:
                    skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                    continue

                user_id, date_str, nr_kadrowy, current_symbol = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy'), cell_data.get('symbol', '')
                if not all([user_id, date_str, nr_kadrowy]):
                    failed_updates += 1
                    error_messages.append(f"Brak danych dla komórki: U:{user_id} D:{date_str} NRK:{nr_kadrowy}")
                    continue

                new_symbol = self._build_new_symbol_with_absence_fixed(current_symbol, special_symbol, cell_data)
                try:
                    year_val, month_val, _ = map(int, date_str.split('-'))
                    result = self._call_import_changes_procedure(nr_kadrowy=nr_kadrowy, rok=year_val, miesiac=month_val,
                                                                 data=date_str, symbol=new_symbol)
                    if result['success']:
                        successful_updates += 1
                        affected_pairs.append((user_id, date_str, result.get('returned_symbol')))
                    else:
                        failed_updates += 1
                        error_messages.append(f"{nr_kadrowy} ({date_str}): {result.get('message', 'Nieznany błąd')}")
                except Exception as e_proc:
                    failed_updates += 1
                    error_messages.append(f"{nr_kadrowy} ({date_str}): {str(e_proc)}")
                    log_error(f"Błąd procedury importu dla {user_id}, {date_str}: {e_proc}", exception=e_proc)

            if successful_updates > 0:
                self._update_cells_with_new_symbols(affected_pairs)

            self._show_symbol_change_results(successful_updates, failed_updates, error_messages, events_to_cancel,
                                             skipped_employees)
        except Exception as e:
            log_error(f"Błąd podczas wstawiania nieobecności: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas wstawiania nieobecności: {str(e)}",
                                 QMessageBox.Ok)

    def clear_special_symbol_from_selected_cells(self):
        """Usuwa symbol specjalny (F12) z poprawnym sprawdzaniem uprawnień."""
        if not app_settings.has_permission(self.current_user_role, 'action_clear_special_symbol'):
            self.statusBar().showMessage("Brak uprawnień do wykonania tej operacji.", 3000)
            return

        selected_cells_data = self.table.get_data_for_selected_cells()
        if not self._can_modify_cells(selected_cells_data) or not selected_cells_data: return

        cells_to_modify = [cell for cell in selected_cells_data if
                           parse_symbol(cell.get('symbol', '')).get('special_symbol')]
        if not cells_to_modify:
            QMessageBox.information(self, "Brak zmian",
                                    "W zaznaczonych komórkach nie ma symboli specjalnych do usunięcia.")
            return

        reply = QMessageBox.question(self, "Potwierdzenie operacji",
                                     f"Czy na pewno chcesz usunąć symbole specjalne z {len(cells_to_modify)} komórek?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if reply != QMessageBox.Yes: return

        updated_info, error_messages = [], []
        for cell_data in cells_to_modify:
            parsed = parse_symbol(cell_data.get('symbol', ''))
            final_location = parsed.get('location') or cell_data.get('lokalizacja_domyslna')
            final_start_hour, final_work_hours = parsed.get('start_hour'), parsed.get('work_hours')
            new_symbol = "" if final_start_hour is None and final_work_hours is None else build_symbol(
                location=final_location, start_hour=final_start_hour, work_hours=final_work_hours, special_symbol=None)
            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month),
                                                             data=date_str, symbol=new_symbol)
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"{cell_data.get('uzytkownik_dane')}: {result.get('message', 'Błąd zapisu.')}")
            except Exception as e:
                log_error(f"Błąd w clear_special_symbol_from_selected_cells: {e}")
                error_messages.append(f"{cell_data.get('uzytkownik_dane')}: Błąd aplikacji: {e}")
        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Pomyślnie usunięto symbole specjalne z {len(updated_info)} komórek.", 4000)
            self.schedule_model.layoutChanged.emit()
        if error_messages:
            QMessageBox.warning(self, "Błędy podczas zapisu",
                                f"Wystąpiły następujące błędy:\n\n" + "\n".join(error_messages))

    def _build_new_symbol_with_absence_fixed(self, current_symbol, special_symbol, cell_data):
        """Buduje nowy symbol z absencją, poprawnie obsługując puste i wypełnione komórki."""
        return self._predict_new_symbol(current_symbol, special_symbol, cell_data)

    def _add_location_exception_batch(self, params_list: list):
        """Dodaje serię wyjątków w jednej transakcji dla wydajności i bezpieczeństwa."""
        errors = []
        conn = None
        try:
            # Krok 1: Otwórz połączenie TYLKO RAZ
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            query = f"EXEC {SQL_OBJECTS['p_lokalizacjewyjatki']} ?, ?, ?, ?, ?, ?, ?, ?"

            # Krok 2: Wykonaj wszystkie operacje w pętli
            for params in params_list:
                try:
                    cursor.execute(query, params)
                except Exception as e:
                    # Zbierz informacje o błędach, które wystąpiły
                    date_str = params[2]  # Data jest na 3. pozycji w krotce
                    errors.append(f"Dzień {date_str}: {e}")

            # Krok 3: Zatwierdź wszystkie udane operacje JEDNYM poleceniem
            conn.commit()

            return {"success": not errors, "errors": errors}

        except Exception as e:
            log_error(f"Błąd krytyczny podczas wsadowego dodawania wyjątków: {e}", exception=e)
            return {"success": False, "errors": [str(e)]}
        finally:
            # Krok 4: Zamknij połączenie na samym końcu
            if conn:
                conn.close()

    def _check_location_exception(self, user_id, change_date):
        """Sprawdza wyjątek lokalizacyjny dla konkretnego dnia używając nowej funkcji TVF."""
        debug_print(
            f"--- Sprawdzanie wyjątku (TVF) dla Użytkownika ID: {user_id}, Data: {change_date.toString('yyyy-MM-dd')} ---")
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            date_str = change_date.toString("yyyy-MM-dd")

            # Wywołanie nowej funkcji tabelarycznej
            fn_name = SQL_OBJECTS.get('fn_getlocationexceptions', 'dbo.fn_GetLocationExceptions')
            query = f"SELECT * FROM {fn_name}(?, ?, ?)"
            cursor.execute(query, (user_id, date_str, date_str))

            results = [dict(zip([column[0] for column in cursor.description], row)) for row in cursor.fetchall()]
            conn.close()

            debug_print(f"Znaleziono {len(results)} wpisów w bazie danych przez TVF.")

            exact_match = None
            range_match = None
            py_change_date = change_date.toPython()

            for row_dict in results:
                data_od = row_dict['Dataod'].date()
                data_do = row_dict['Datado'].date() if row_dict['Datado'] else None
                if data_od == py_change_date and data_do and data_do == py_change_date:
                    exact_match = row_dict
                    break
                if data_od <= py_change_date and (not data_do or data_do >= py_change_date):
                    range_match = row_dict

            debug_print(
                f"Zwracam: exact_match={'TAK' if exact_match else 'NIE'}, range_match={'TAK' if range_match else 'NIE'}")
            return exact_match, range_match

        except Exception as e:
            log_error(f"Błąd podczas sprawdzania wyjątków lokalizacyjnych (TVF): {e}", exception=e)
            return None, None

    def _manage_location_exception(self, params):
        """Zarządza dodawaniem, edycją i usuwaniem wyjątków lokalizacyjnych."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            query = f"EXEC {SQL_OBJECTS['p_lokalizacjewyjatki']} ?, ?, ?, ?, ?, ?, ?, ?"
            cursor.execute(query, params)

            # --- POCZĄTEK KLUCZOWEJ POPRAWKI ---
            # Ta pętla zmusza sterownik do poczekania na pełne wykonanie procedury na serwerze,
            # zanim przejdzie do zamknięcia połączenia. Przetwarza wszystkie "ukryte" komunikaty
            # i zestawy wyników, które procedura mogłaby wygenerować.
            while cursor.nextset():
                pass
            # --- KONIEC KLUCZOWEJ POPRAWKI ---

            conn.commit()
            conn.close()
            return {"success": True}
        except Exception as e:
            log_error(f"Błąd podczas zarządzania wyjątkiem lokalizacyjnym: {e}", exception=e)
            return {"success": False, "message": str(e)}

    def _call_import_changes_procedure(self, nr_kadrowy, rok, miesiac, data, symbol):
        """Wywołuje procedurę i bardziej niezawodnie interpretuje jej wyniki."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(
                f"EXEC {SQL_OBJECTS['p_importzmianynaserwer']} @Nr_Kadrowy = ?, @Rok = ?, @Miesiac = ?, @Data = ?, @Symbol = ?, @CzyPobieranieSugestii = ?",
                (nr_kadrowy, rok, miesiac, data, symbol, None))

            all_results = []
            while True:
                try:
                    rows = cursor.fetchall()
                    if rows: all_results.extend(rows)
                    if not cursor.nextset(): break
                except Exception:
                    break
            conn.commit()
            conn.close()

            returned_symbol, success, message = symbol, True, "Operacja zakończona pomyślnie"
            for row in all_results:
                if row and len(row) > 0 and row[0] is not None:
                    raw_value = row[0]
                    if isinstance(raw_value, int) and raw_value == 0: continue
                    value_str = str(raw_value).strip()
                    if not value_str or value_str == "0": continue

                    is_likely_a_symbol = ' ' not in value_str and len(value_str) <= 50
                    if is_likely_a_symbol:
                        returned_symbol = value_str
                    else:
                        success, message = False, value_str
                        break
            if success:
                self._update_modification_date()
            return {"success": success, "message": message, "returned_symbol": returned_symbol}
        except Exception as e:
            log_error(f"Błąd procedury ImportZmianNaSerwer: {e}")
            return {"success": False, "message": f"Błąd bazy danych: {str(e)}", "returned_symbol": symbol}

    def _process_and_apply_changes(self, change_requests: list, success_message_template: str):
        """
        NOWA, CENTRALNA METODA: Przetwarza listę żądań zmian, wywołuje procedurę,
        a następnie zbiera i wyświetla wyniki (sukcesy na pasku statusu, błędy w oknie).

        Args:
            change_requests (list): Lista słowników, każdy z kluczami:
                                    nr_kadrowy, rok, miesiac, data, symbol, user_id, user_name.
            success_message_template (str): Szablon wiadomości o sukcesie, np. "Zastosowano symbol dla {} komórek."
        """
        if not change_requests:
            return

        updated_info = []
        error_messages = []

        for req in change_requests:
            try:
                result = self._call_import_changes_procedure(
                    nr_kadrowy=req['nr_kadrowy'],
                    rok=req['rok'],
                    miesiac=req['miesiac'],
                    data=req['data'],
                    symbol=req['symbol']
                )
                if result.get('success'):
                    updated_info.append((req['user_id'], req['data'], result.get('returned_symbol')))
                else:
                    error_msg = result.get('message', 'Nieznany błąd')
                    error_messages.append(f"👤 {req.get('user_name', req['nr_kadrowy'])} ({req['data']}): {error_msg}")
            except Exception as e:
                log_error(f"Błąd krytyczny podczas przetwarzania żądania zmiany: {req}", exception=e)
                error_messages.append(f"👤 {req.get('user_name', req['nr_kadrowy'])} ({req['data']}): {e}")

        # Aktualizuj UI dla udanych operacji
        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(success_message_template.format(len(updated_info)), 4000)
            self.schedule_model.layoutChanged.emit()  # Wymuś odświeżenie sum i bilansu

        # Wyświetl jedno okno ze wszystkimi błędami
        if error_messages:
            QMessageBox.warning(
                self,
                "Błędy podczas zapisu",
                f"Wystąpiły następujące błędy i niektóre zmiany nie zostały zapisane:\n\n" + "\n".join(error_messages),
                QMessageBox.Ok
            )

    def _update_cells_with_new_symbols(self, updated_cells_info: list):
        """Aktualizuje komórki w modelu na podstawie danych zwróconych przez procedurę."""
        if not updated_cells_info or not hasattr(self, 'schedule_model'): return
        for user_id, date_str, new_symbol in updated_cells_info:
            if new_symbol is not None:
                self._update_single_cell_in_model(user_id, date_str, new_symbol, self.year, self.month)
        debug_print(f"Zaktualizowano {len(updated_cells_info)} komórek w modelu.")

    def _update_single_cell_in_model(self, user_id, date_str, new_symbol, year, month):
        """Aktualizuje jedną komórkę w modelu i wymusza jej odświeżenie."""
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model: return False
            row_index = -1
            for idx, key in enumerate(self.schedule_model._keys):
                if str(key[3]) == str(user_id):
                    row_index = idx
                    break
            if row_index == -1: return False

            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)
            if int(year_str) != year or int(month_str) != month: return False

            col_index = len(self.schedule_model.get_visible_columns()) + day - 1
            model_index = self.schedule_model.index(row_index, col_index)
            if model_index.isValid():
                return self.schedule_model.setData(model_index, new_symbol, Qt.EditRole)
            return False
        except Exception as e:
            log_error(f"Błąd aktualizacji komórki {user_id}/{date_str}: {e}")
            return False

    def _get_location_exceptions(self, user_id, start_date, end_date):
        """Pobiera wyjątki lokalizacyjne dla użytkownika w danym zakresie dat używając funkcji TVF."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            fn_name = SQL_OBJECTS.get('fn_getlocationexceptions', 'dbo.fn_GetLocationExceptions')
            query = f"SELECT * FROM {fn_name}(?, ?, ?)"
            cursor.execute(query, (user_id, start_date.toString("yyyy-MM-dd"), end_date.toString("yyyy-MM-dd")))
            results = [dict(zip([column[0] for column in cursor.description], row)) for row in cursor.fetchall()]
            conn.close()
            return sorted(results, key=lambda x: x['Dataod'], reverse=True)
        except Exception as e:
            log_error(f"Błąd podczas pobierania wyjątków (TVF): {e}", exception=e)
            return []

    def show_location_exception_dialog(self):
        """Otwiera okno do zarządzania wyjątkami lokalizacyjnymi."""
        from location_exception_dialog import LocationExceptionDialog

        selected_cells = self.get_selected_cells_data()
        if not selected_cells:
            QMessageBox.warning(self, "Brak zaznaczenia", "Proszę zaznaczyć przynajmniej jedną komórkę pracownika.")
            return

        user_ids = {cell['uzytkownik_id'] for cell in selected_cells}
        if len(user_ids) > 1:
            QMessageBox.warning(self, "Wielu użytkowników", "Proszę zaznaczyć komórki tylko dla jednego pracownika.")
            return

        user_id = user_ids.pop()
        user_name = selected_cells[0]['uzytkownik_dane']

        # --- ZMIANA: Określ zakres dat z zaznaczenia ---
        dates = [QDate.fromString(cell['date_str'], "yyyy-MM-dd") for cell in selected_cells]
        selection_range = {'start': min(dates), 'end': max(dates)}

        dialog = LocationExceptionDialog(self, user_id, user_name, selection_range)
        dialog.data_changed.connect(self.refresh_data)
        dialog.exec()

    def check_for_new_data(self):
        """Sprawdza nowe dane i wersję, używając jednego połączenia z bazą."""
        conn = None
        try:
            # Krok 1: Otwórz JEDNO połączenie na początku
            conn = DatabaseConnector.get_connection()

            # Krok 2: Załaduj ustawienia, przekazując istniejące połączenie
            if not load_all_app_settings(existing_conn=conn):
                log_warning("Nie udało się odświeżyć ustawień aplikacji w tle.")
                return

            # Krok 3: Sprawdź wersję (korzystając z już załadowanych danych)
            is_update_forced = app_settings.FORCE_UPDATE
            is_version_obsolete = self.check_if_update_is_required()
            if is_update_forced or is_version_obsolete:
                debug_print(
                    f"Wykryto polecenie zdalnej aktualizacji (force: {is_update_forced}, obsolete: {is_version_obsolete}). Zamykanie aplikacji.")
                self.check_timer.stop()
                dialog = UpdateRequiredDialog(self)
                dialog.exec()
                self.close()
                return

            # Krok 4: Sprawdź daty modyfikacji, używając wciąż tego samego połączenia
            current_date_data = self.date_combo.currentData()
            if not current_date_data: return
            year, month = current_date_data
            if not hasattr(self, 'last_modification_date') or not self.last_modification_date:
                self._update_modification_date()  # Ta metoda otworzy własne połączenie, ale tylko raz na początku
                return

            cursor = conn.cursor()
            cursor.execute(
                f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['grafikipracy']} WHERE Rok = ? AND Miesiac = ?",
                (year, month))
            schedule_max_date = cursor.fetchone()[0]
            cursor.execute(f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['fn_geteventsdata']}(?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]

            new_data_types = []
            if schedule_max_date and schedule_max_date > self.last_modification_date:
                new_data_types.append("grafiku")
            if events_max_date and events_max_date > self.last_modification_date:
                new_data_types.append("zdarzeń")
            if new_data_types:
                latest_overall_modification = max(d for d in [schedule_max_date, events_max_date] if d)
                is_self_change = False
                if hasattr(self, 'last_self_modification_date') and self.last_self_modification_date:
                    if abs(latest_overall_modification - self.last_self_modification_date) < timedelta(seconds=2):
                        is_self_change = True
                if not is_self_change:
                    change_type_text = " i ".join(new_data_types)
                    self.refresh_button.setText(f"Nowe dane {change_type_text}!")
                    self.refresh_button.setToolTip(
                        f"Wykryto zmiany w sekcji: {change_type_text}. Kliknij, aby załadować.")
                    new_data_style = "QPushButton { background-color: #f39c12; color: white; font-weight: bold; border: 1px solid #e67e22; } QPushButton:hover { background-color: #e67e22; }"
                    self.refresh_button.setStyleSheet(new_data_style)
                    self.check_timer.stop()
                else:
                    self.last_modification_date = latest_overall_modification

        except Exception as e:
            log_error(f"Błąd podczas sprawdzania nowych danych: {e}", exception=e)
        finally:
            # Krok 5: Zawsze zamknij połączenie na końcu
            if conn:
                try:
                    conn.close()
                except Exception as e:
                    log_warning(f"Problem z zamknięciem połączenia w check_for_new_data: {e}")

    def _save_current_filter_settings(self):
        """Zapisuje aktualny stan filtrów do słownika ustawień i do bazy danych."""
        if not hasattr(self, 'user_settings'):
            return

        # Zaktualizuj słownik o bieżący stan filtrów
        self.user_settings['last_filters'] = self.get_current_filters_state()

        # Zapisz cały, zaktualizowany słownik w bazie danych
        self.settings_db.save_settings(self.user_settings)
        debug_print("Zapisano bieżący stan filtrów do bazy danych.")

    def refresh_data(self):
        """Wymusza odświeżenie danych z bazy, najpierw zapisując aktualny stan filtrów."""
        # Krok 1: Zapisz aktualne ustawienia filtrów do bazy danych
        self._save_current_filter_settings()

        self.refresh_button.setText("Odśwież")
        self.refresh_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.refresh_button.setToolTip("Odśwież dane")

        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            self.data_provider.clear_monthly_cache(year, month)

            self.update_data(year, month, self.import_grupa, self.import_funkcja, use_async=True)

            self._update_modification_date()
            if hasattr(self, 'check_timer'):
                self.check_timer.start(60000)

    def _update_modification_date(self):
        """Aktualizuje datę ostatniej modyfikacji po dokonaniu zmian."""
        try:
            current_date_data = self.date_combo.currentData()
            if not current_date_data: return
            year, month = current_date_data
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(
                f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['grafikipracy']} WHERE Rok = ? AND Miesiac = ?",
                (year, month))
            schedule_max_date = cursor.fetchone()[0]
            cursor.execute(f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['fn_geteventsdata']}(?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]
            conn.close()
            all_dates = [d for d in [schedule_max_date, events_max_date] if d is not None]
            if not all_dates: return
            latest_modification = max(all_dates)
            self.last_self_modification_date = latest_modification
            self.last_modification_date = latest_modification
        except Exception as e:
            log_error(f"Błąd podczas aktualizacji daty modyfikacji: {e}", exception=e)

    def filter_data(self):
        """Filtruje dane grafiku i aktualizuje widok."""
        if not hasattr(self, 'schedule_model') or not self.schedule_model or getattr(self, '_updating_filters', False):
            return
        self._updating_filters = True
        try:
            self.update_cross_filters()
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)
            self.apply_default_sort()
        finally:
            self._updating_filters = False
            current_data = self.date_combo.currentData()
            if current_data and self.staffing_details_win and not self.staffing_details_win.isHidden():
                year, month = current_data
                self.staffing_details_win.update_for_new_month_or_filters(year, month)

    def filter_events_table(self):
        """Filtruje tabelę zdarzeń na podstawie zaznaczonych filtrów i zakresów dat."""
        try:
            if not hasattr(self, 'events_model') or not self.events_model: return
            if not hasattr(self, 'events_data') or not self.events_data:
                self.events_model.update_data([])
                return

            filtered_data = self.events_data.copy()
            allowed_types = []
            if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked(): allowed_types.append(
                'Spotkanie')
            if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked(): allowed_types.append(
                'Szkolenie')
            if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked(): allowed_types.append(
                'Nadgodziny')

            if allowed_types: filtered_data = [e for e in filtered_data if e.get('type') in allowed_types]

            topic_filter = self.topic_filter.text().lower() if hasattr(self, 'topic_filter') else ""
            if topic_filter: filtered_data = [e for e in filtered_data if
                                              topic_filter in str(e.get('topic', '')).lower()]

            name_filter = self.name_filter.text().lower() if hasattr(self, 'name_filter') else ""
            if name_filter: filtered_data = [e for e in filtered_data if name_filter in str(e.get('name', '')).lower()]

            date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
            date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None
            if date_from_str: filtered_data = [e for e in filtered_data if e.get('date_key', '') >= date_from_str]
            if date_to_str: filtered_data = [e for e in filtered_data if e.get('date_key', '') <= date_to_str]

            self.events_model.filtered_update(filtered_data)
        except Exception as e:
            log_error(f"Błąd podczas filtrowania zdarzeń: {str(e)}")

    def show_schedule_control_dialog(self):
        """Pokazuje odpowiednie okno dialogowe w zależności od roli użytkownika."""
        from schedule_control_dialog import ScheduleControlDialog, SuggestionsOutDialog

        # Główny przycisk jest już chroniony przez 'button_schedule_control'.
        # Poniższa logika jedynie decyduje, które okno pokazać dla uprawnionego użytkownika.
        # Jest to akceptowalne, ponieważ nie nadaje dodatkowych uprawnień.
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Proszę najpierw wybrać miesiąc.")
            return

        year, month = current_data

        if self.current_user_role == "Pracownik WPR":
            dialog = ScheduleControlDialog(self, year, month)
        elif self.current_user_role == "Lider OUT":
            dialog = SuggestionsOutDialog(self, year, month)
        else:
            # Ten komunikat nie powinien się pojawić, jeśli przycisk jest poprawnie ukryty,
            # ale zostawiamy go jako zabezpieczenie.
            QMessageBox.information(self, "Brak dostępu", "Twoja rola nie ma dostępu do tej funkcji.")
            return

        dialog.data_refresh_needed.connect(self.refresh_data)
        dialog.exec()

    def show_insert_change_dialog(self):
        """Pokazuje okno dialogowe do wstawiania zmian w grafiku"""
        if not app_settings.has_permission(self.current_user_role, 'schedule_cell_actions'):
            self.statusBar().showMessage("Brak uprawnień do wstawiania zmian.", 3000)
            return

        from schedule_edit_dialogs import ScheduleChangeDialog
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Nie wybrano miesiąca. Nie można dodać zmiany grafiku.", QMessageBox.Ok)
            return

        year, month = current_data
        selected_cells = self.table.get_data_for_selected_cells()

        if not selected_cells:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono żadnych komórek do edycji.", QMessageBox.Ok)
            return

        grouped_cells = self.group_cells_by_user_and_day(selected_cells)

        # --- ZMIANA: Usunięto argument 'permission_checker' ---
        # Dialog będzie teraz bezpośrednio odwoływał się do metody w oknie głównym.
        dialog = ScheduleChangeDialog(self, grouped_cells, year, month)
        dialog.exec()

    def show_add_overtime_dialog(self):
        """Pokazuje okno dialogowe do dodawania nadgodzin."""
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Nie wybrano miesiąca.", QMessageBox.Ok)
            return
        year, month = current_data
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not self._can_modify_cells(selected_cells_data) or not selected_cells_data or len(selected_cells_data) > 1:
            QMessageBox.warning(self, "Błąd zaznaczenia", "Zaznacz dokładnie jedną komórkę, aby dodać nadgodziny.",
                                QMessageBox.Ok)
            return

        cell_data = selected_cells_data[0]
        selected_user_id, selected_user_name, day, date_str, nr_kadrowy, start_hour, current_symbol, lokalizacja_domyslna = (
            cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane'), cell_data.get('day'),
            cell_data.get('date_str'), cell_data.get('nr_kadrowy'), cell_data.get('start_hour'),
            cell_data.get('symbol', ''), cell_data.get('lokalizacja_domyslna', 'h')
        )

        if not all([selected_user_id, day, date_str]):
            QMessageBox.warning(self, "Błąd", "Brak wymaganych danych w zaznaczonej komórce.", QMessageBox.Ok)
            return

        selected_date = QDate.fromString(date_str, "yyyy-MM-dd")
        is_day_off = not current_symbol or current_symbol.strip() == ''
        if start_hour is None: start_hour = 9 if is_day_off else 8

        parsed_symbol = parse_symbol(current_symbol)
        current_location = parsed_symbol.get('location') if parsed_symbol and parsed_symbol.get(
            'location') else lokalizacja_domyslna

        dialog = QDialog(self)
        polish_months = ["stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca", "lipca", "sierpnia", "września",
                         "października", "listopada", "grudnia"]
        dialog.setWindowTitle(
            f"Dodaj nadgodziny w dniu {selected_date.day()} {polish_months[selected_date.month() - 1]} {selected_date.year()}")
        dialog.setMinimumWidth(300)
        layout = QVBoxLayout(dialog)
        layout.addWidget(QLabel(f"Pracownik: {selected_user_name}"))
        if nr_kadrowy: layout.addWidget(QLabel(f"Numer kadrowy: {nr_kadrowy}"))
        layout.addWidget(QLabel(f"Miesiąc rozliczenia: {month:02d}.{year}"))
        if is_day_off: layout.addWidget(QLabel("Zaznaczony dzień jest dniem wolnym pracownika."))

        form_frame = QFrame()
        form_layout = QGridLayout(form_frame)
        time_combo = QComboBox()
        for h in range(24):
            for m in [0, 30]:
                time_combo.addItem(f"{h:02d}:{m:02d}")
        default_time = f"{(start_hour + 8) % 24:02d}:00" if not is_day_off else "09:00"
        time_combo.setCurrentText(default_time)

        hours_combo = QComboBox()
        for h in [i * 0.5 for i in range(1, 27)]: hours_combo.addItem(f"{h:.1f}", h)
        hours_combo.setCurrentIndex(1)

        type_combo, ld_combo, overdue_combo = QComboBox(), QComboBox(), QComboBox()
        type_combo.addItems(["wypłata", "odbiór", "odpracowanie"])
        ld_combo.addItems(["h", "p", "s"])
        ld_combo.setCurrentText(current_location)
        overdue_combo.addItems(["nie", "tak"])
        add_button = QPushButton("Dodaj")

        form_layout.addWidget(QLabel("od kiedy"), 0, 0);
        form_layout.addWidget(time_combo, 0, 1)
        form_layout.addWidget(QLabel("ile godzin"), 0, 2);
        form_layout.addWidget(hours_combo, 0, 3)
        form_layout.addWidget(QLabel("typ"), 0, 4);
        form_layout.addWidget(type_combo, 0, 5)
        form_layout.addWidget(QLabel("LD"), 0, 6);
        form_layout.addWidget(ld_combo, 0, 7)
        form_layout.addWidget(QLabel("czy zaległe"), 0, 8);
        form_layout.addWidget(overdue_combo, 0, 9)
        form_layout.addWidget(add_button, 0, 10)
        layout.addWidget(form_frame)

        def add_overtime():
            result = self.call_add_overtime_procedure_fixed(
                selected_user_id, selected_date.year(), selected_date.month(),
                selected_date.toString("yyyy-MM-dd"), time_combo.currentText(),
                float(hours_combo.currentData()), f"{year}-{month:02d}-01",
                overdue_combo.currentIndex(), type_combo.currentText(),
                ld_combo.currentText(), nr_kadrowy
            )
            if result["success"]:
                self.statusBar().showMessage("Pomyślnie dodano nadgodziny.", 3000)
                dialog.accept()
            else:
                QMessageBox.warning(dialog, "Błąd", result["message"], QMessageBox.Ok)

        add_button.clicked.connect(add_overtime)
        dialog.exec()

    def show_settings_dialog(self):
        """Pokazuje okno dialogowe ustawień aplikacji."""
        from settings_dialog import AppSettingsDialog

        dialog = AppSettingsDialog(self, settings=self.user_settings)
        dialog.live_theme_changed.connect(self.apply_theme_settings)
        # --- PODŁĄCZENIE NOWEGO SYGNAŁU ---
        dialog.import_requested.connect(self.on_import_requested)

        if dialog.exec() == QDialog.Accepted:
            # Ta część wykona się po kliknięciu "OK" lub "Importuj teraz"
            new_settings = dialog.get_current_settings()
            should_save = new_settings.pop('save_to_db', False)

            self.user_settings.update(new_settings)

            self.is_dark_theme = self.user_settings.get('theme') == 'dark'
            self.current_font = self.user_settings.get('font_family')
            self.current_font_size = self.user_settings.get('font_size')

            self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font,
                                      self.current_font_size)
            self.setup_table_properties()
            self.table.schedule_view.viewport().update()

            if should_save:
                self.settings_db.save_settings(self.user_settings)
                debug_print(f"Zapisano ustawienia z dialogu.")

    def on_import_requested(self, grupa, funkcja):
        """Obsługuje żądanie importu z okna ustawień."""
        debug_print(f"Otrzymano żądanie importu z ustawieniami: Grupa={grupa}, Funkcja={funkcja}")

        # Zaktualizuj atrybuty w głównym oknie
        self.import_grupa = grupa
        self.import_funkcja = funkcja

        # Wywołaj odświeżenie danych
        self.refresh_data()

    def _update_model_with_new_symbols(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje symbole bezpośrednio w modelu
        """
        try:
            if not updated_symbols or not hasattr(self, 'schedule_model'):
                return

            processed_data = self.schedule_model.get_processed_data()
            if not processed_data:
                return

            updated_count = 0
            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Znajdź klucz użytkownika w processed_data
                target_key = None
                for key in processed_data.keys():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        target_key = key
                        break

                if not target_key:
                    debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                    continue

                # Oblicz dzień z daty
                try:
                    year_str, month_str, day_str = date_str.split('-')
                    day = int(day_str)

                    if int(year_str) != year or int(month_str) != month:
                        continue

                except ValueError:
                    continue

                # Aktualizuj symbol w processed_data
                user_data = processed_data[target_key]
                days_data = user_data.setdefault('days', {})
                day_data = days_data.setdefault(day, {})

                old_symbol = day_data.get('symbol', '')
                day_data['symbol'] = new_symbol

                # Przelicz godziny na podstawie nowego symbolu
                from symbol_parser import parse_symbol
                parsed = parse_symbol(new_symbol)
                day_data['hours'] = parsed.get('work_hours', 0) or 0
                day_data['start_hour'] = parsed.get('start_hour')

                # Aktualizuj total_hours użytkownika
                old_hours = 0
                if old_symbol:
                    old_parsed = parse_symbol(old_symbol)
                    old_hours = old_parsed.get('work_hours', 0) or 0

                new_hours = day_data['hours']
                user_data['total_hours'] = (user_data.get('total_hours', 0) or 0) - old_hours + new_hours

                updated_count += 1
                debug_print(
                    f"Model: Zaktualizowano {user_id}/{day}: '{old_symbol}' -> '{new_symbol}' ({old_hours}h -> {new_hours}h)")

            debug_print(f"Zaktualizowano {updated_count} komórek w modelu")

        except Exception as e:
            log_error(f"Błąd aktualizacji modelu: {e}")

    def _update_data_provider_cache(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje cache w DataProvider
        """
        try:
            if not updated_symbols or not hasattr(self.data_provider, 'monthly_cache'):
                return

            month_key = (year, month)
            if month_key not in self.data_provider.monthly_cache:
                return

            container = self.data_provider.monthly_cache[month_key]

            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Aktualizuj processed_data w kontenerze
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):
                        try:
                            year_str, month_str, day_str = date_str.split('-')
                            day = int(day_str)

                            if int(year_str) == year and int(month_str) == month:
                                days_data = user_data.setdefault('days', {})
                                day_data = days_data.setdefault(day, {})
                                day_data['symbol'] = new_symbol

                                # Przelicz godziny
                                from symbol_parser import parse_symbol
                                parsed = parse_symbol(new_symbol)
                                day_data['hours'] = parsed.get('work_hours', 0) or 0
                                day_data['start_hour'] = parsed.get('start_hour')

                                debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")
                                break
                        except:
                            continue

        except Exception as e:
            log_error(f"Błąd aktualizacji DataProvider cache: {e}")

    def _force_full_refresh(self):
        """Fallback - pełne odświeżenie danych"""
        try:
            current_data = self.date_combo.currentData()
            if current_data:
                year, month = current_data
                self.data_provider.refresh_data(year, month)
                self.update_table_content()
        except Exception as e:
            log_error(f"Błąd pełnego odświeżenia: {e}")

    def _force_refresh_specific_cells(self, affected_pairs, year, month):
        """
        POPRAWIONA METODA: Wymusza odświeżenie konkretnych komórek w widoku
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycję komórki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajdź wiersz użytkownika w modelu
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnę dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymusza odświeżenie komórki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej komórki
                        self.schedule_model.dataChanged.emit(model_index, model_index,
                                                             [Qt.DisplayRole, Qt.BackgroundRole])

                        # Metoda 2: Wymuś update widoku dla tej komórki
                        self.table.schedule_view.update(model_index)

                        refreshed_cells += 1
                        debug_print(f"Odświeżono komórkę tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"Błąd odświeżania komórki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymuś całościowy update viewport jeśli zmieniono jakieś komórki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po odświeżeniu {refreshed_cells} komórek")

                # DODATKOWE: Wymuś też odświeżenie tabeli pracowników (dla sum RBH)
                if hasattr(self.table, 'employees_view'):
                    self.table.employees_view.viewport().update()

        except Exception as e:
            log_error(f"Błąd podczas wymuszania odświeżenia komórek tabeli: {e}")

    def _update_model_cells_directly(self, updated_symbols, year, month):
        """
        Aktualizuje symbole bezpośrednio w modelu i DataProvider

        Args:
            updated_symbols (dict): Słownik {(user_id, date_str): symbol}
            year (int): Rok
            month (int): Miesiąc
        """
        try:
            if not updated_symbols:
                return

            updated_count = 0

            # AKTUALIZACJA 1: Schedule Model processed_data
            if hasattr(self, 'schedule_model') and self.schedule_model:
                processed_data = self.schedule_model.get_processed_data()

                if processed_data:
                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        if self._update_single_cell_in_processed_data(processed_data, user_id, date_str, new_symbol,
                                                                      year, month):
                            updated_count += 1

            # AKTUALIZACJA 2: DataProvider cache (jeśli istnieje)
            if hasattr(self.data_provider, 'monthly_cache'):
                month_key = (year, month)
                if month_key in self.data_provider.monthly_cache:
                    container = self.data_provider.monthly_cache[month_key]

                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        self._update_single_cell_in_data_provider(container, user_id, date_str, new_symbol, year, month)

            debug_print(f"Zaktualizowano {updated_count} komórek w modelu")

        except Exception as e:
            log_error(f"Błąd bezpośredniej aktualizacji modelu: {e}")

    def _update_single_cell_in_processed_data(self, processed_data, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczą komórkę w processed_data

        Returns:
            bool: True jeśli zaktualizowano
        """
        try:
            # Znajdź klucz użytkownika
            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if not target_key:
                debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                return False

            # Oblicz dzień
            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)

            if int(year_str) != year or int(month_str) != month:
                return False

            # Aktualizuj symbol
            user_data = processed_data[target_key]
            days_data = user_data.setdefault('days', {})
            day_data = days_data.setdefault(day, {})

            old_symbol = day_data.get('symbol', '')
            day_data['symbol'] = new_symbol

            # Przelicz godziny i inne parametry
            from symbol_parser import parse_symbol
            parsed = parse_symbol(new_symbol)
            day_data['hours'] = parsed.get('work_hours', 0) or 0
            day_data['start_hour'] = parsed.get('start_hour')

            debug_print(f"Model: {user_id}/{day} '{old_symbol}' -> '{new_symbol}'")
            return True

        except Exception as e:
            log_error(f"Błąd aktualizacji komórki processed_data {user_id}/{date_str}: {e}")
            return False

    def _update_single_cell_in_data_provider(self, container, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczą komórkę w DataProvider cache
        """
        try:
            if not hasattr(container, 'processed_data') or not container.processed_data:
                return

            # Podobna logika jak dla processed_data w modelu
            processed_data = container.processed_data

            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if target_key:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)

                if int(year_str) == year and int(month_str) == month:
                    user_data = processed_data[target_key]
                    days_data = user_data.setdefault('days', {})
                    day_data = days_data.setdefault(day, {})
                    day_data['symbol'] = new_symbol

                    # Przelicz godziny
                    from symbol_parser import parse_symbol
                    parsed = parse_symbol(new_symbol)
                    day_data['hours'] = parsed.get('work_hours', 0) or 0
                    day_data['start_hour'] = parsed.get('start_hour')

                    debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")

        except Exception as e:
            log_error(f"Błąd aktualizacji DataProvider cache: {e}")

    def _force_refresh_table_cells(self, affected_pairs, year, month):
        """
        WYMUSZA odświeżenie konkretnych komórek w widoku tabeli

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
            year (int): Rok
            month (int): Miesiąc
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycję komórki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajdź wiersz użytkownika
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnę dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymuś odświeżenie komórki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej komórki
                        self.schedule_model.dataChanged.emit(model_index, model_index, [])

                        # Metoda 2: Wymuś update widoku (backup)
                        self.table.schedule_view.update(model_index)

                        # Metoda 3: Invalidate item (backup)
                        if hasattr(self.table.schedule_view, 'setDirtyRegion'):
                            rect = self.table.schedule_view.visualRect(model_index)
                            if not rect.isEmpty():
                                self.table.schedule_view.viewport().update(rect)

                        refreshed_cells += 1
                        debug_print(f"Odświeżono komórkę tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"Błąd odświeżania komórki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymuś całościowy update viewport jeśli zmieniono jakieś komórki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po odświeżeniu {refreshed_cells} komórek")

        except Exception as e:
            log_error(f"Błąd podczas wymuszania odświeżenia komórek tabeli: {e}")

    def _find_user_row_in_model(self, user_id):
        """
        POPRAWIONA METODA: Znajduje indeks wiersza dla danego użytkownika w modelu
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return -1

            # Pobierz klucze z modelu
            if hasattr(self.schedule_model, '_keys'):
                keys = self.schedule_model._keys
            else:
                return -1

            user_id_str = str(user_id)

            for row_index, key in enumerate(keys):
                if len(key) > 3 and str(key[3]) == user_id_str:
                    return row_index

            return -1

        except Exception as e:
            log_error(f"Błąd podczas szukania wiersza użytkownika {user_id}: {e}")
            return -1

    def _update_local_events_for_cells(self, affected_pairs):
        """
        Aktualizuje lokalny events_data tylko dla zmienionych komórek

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
        """
        try:
            if not hasattr(self, 'events_data'):
                return

            # Sprawdź czy jakieś z zmienionych komórek są obecnie zaznaczone
            if not hasattr(self, 'table'):
                return

            current_selection = self.table.get_data_for_selected_cells()
            selected_pairs = set()

            for cell_data in current_selection:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    selected_pairs.add((user_id, date_str))

            # Sprawdź czy któraś ze zmienionych komórek jest zaznaczona
            intersection = set(affected_pairs) & selected_pairs

            if intersection:
                debug_print(f"Zaktualizowano {len(intersection)} zmienionych komórek w events_data")
                # Jeśli tak, odśwież events_data tylko dla zaznaczonych komórek
                self.on_selection_changed()

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji lokalnych events: {e}")

    def _show_symbol_change_results(self, successful_updates: int, failed_updates: int, error_messages: list,
                                    events_to_cancel: list, skipped_employees: list):
        """
        Wyświetla uzytkownikowi podsumowanie operacji wstawiania symboli,
        uwzględniając komórki pominięte z powodu braku uprawnień.
        """
        title = ""
        full_message = ""

        # Komunikat o sukcesach
        if successful_updates > 0:
            full_message += f"Pomyślnie zaktualizowano {successful_updates} komórek."
            if events_to_cancel:
                full_message += f" i odwołano {len(events_to_cancel)} delegacji."
            full_message += "\n"

        # Komunikat o pominiętych z powodu braku uprawnień
        if skipped_employees:
            full_message += f"\nPominięto {len(skipped_employees)} komórek z powodu braku uprawnień dla:\n- {', '.join(set(skipped_employees))}\n"

        # Komunikat o błędach
        if failed_updates > 0:
            title = "Częściowy sukces" if successful_updates > 0 or skipped_employees else "Błąd aktualizacji"
            error_list_str = "\n - " + "\n - ".join(error_messages[:10])
            full_message += f"\nNie udało się zaktualizować {failed_updates} komórek z powodu błędów:{error_list_str}"
            if len(error_messages) > 10:
                full_message += f"\n... i {len(error_messages) - 10} więcej błędów."
        elif successful_updates > 0 or skipped_employees:
            title = "Zakończono operację"

        # Wyświetl komunikat tylko jeśli coś się wydarzyło
        if full_message:
            # Jeśli nie było błędów i pominięć, pokaż tylko info na pasku statusu
            if successful_updates > 0 and failed_updates == 0 and not skipped_employees:
                self.statusBar().showMessage(full_message.strip(), 4000)
            else:
                QMessageBox.information(self, title, full_message.strip())

    def _prepare_delegations_description(self, grouped_events, max_groups=10):
        """
        Przygotowuje opis delegacji do odwołania.

        Args:
            grouped_events: Słownik zdarzeń pogrupowanych według użytkownika i daty
            max_groups: Maksymalna liczba grup do wyświetlenia

        Returns:
            str: Opis delegacji do odwołania
        """
        delegations_info = ""

        if not grouped_events:
            return delegations_info

        delegations_info += "\nNastępujące delegacje zostaną automatycznie odwołane:\n"

        # Licznik dla ograniczenia liczby wyświetlanych grup
        group_count = 0

        for (user_id, date_str), events in grouped_events.items():
            # Ograniczenie liczby wyświetlanych grup
            if group_count >= max_groups:
                delegations_info += f"\n...oraz więcej zdarzeń dla innych użytkowników/dni ({len(grouped_events) - max_groups} więcej grup)...\n"
                break

            # Pobierz nazwę użytkownika z pierwszego zdarzenia
            user_name = events[0].get('user_name', f"ID: {user_id}")

            # Przygotuj datę w ładniejszym formacie (DD.MM.YYYY)
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            delegations_info += f"   👤 {user_name} - 📅 {formatted_date}:\n"

            # Wyświetl zdarzenia dla tego użytkownika i daty
            for i, event in enumerate(events):
                delegations_info += f"      {i + 1}. {event['type']}: {event['name']}\n"

            group_count += 1

        return delegations_info

    def filter_processed_data(self):
        """Filtruje przetworzone dane na podstawie wszystkich filtrów."""
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return {}

        # Pobranie stanu filtrów (bez zmian)
        show_only_at_work = self.filter_by_presence_check.isChecked()
        selected_locations = []
        if show_only_at_work:
            selected_date = self.presence_date_edit.date()
            selected_locations_text = self.presence_location_combo.get_selected_items()
            location_map = {
                "Home Office (h)": "h",
                "SBC (s)": "s",
                "mPrzystanek (p)": "p",
                "Bez lokalizacji": "none"
            }
            selected_locations = {location_map.get(text) for text in selected_locations_text}

        selected_wydzialy = set(self.wydzial_combo.get_selected_items())
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)
        selected_dtn = self.dtn_combo.get_selected_items()
        selected_role = self.rola_combo.get_selected_items()
        selected_jezyki = self.jezyk_combo.get_selected_items()
        selected_etaty = self.etat_combo.get_selected_items()
        selected_scp = self.system_czasu_pracy_combo.get_selected_items()
        selected_grupy = self.grupa_main_filter_combo.get_selected_items()
        selected_locations_default = self.default_location_combo.get_selected_items()

        allowed_depts_from_groups = set()
        if selected_grupy:
            group_mapping = app_settings.get_group_mapping()
            for group_name in selected_grupy:
                allowed_depts_from_groups.update(group_mapping.get(group_name, set()))
            if selected_wydzialy:
                selected_wydzialy = selected_wydzialy.intersection(allowed_depts_from_groups)
            else:
                selected_wydzialy = allowed_depts_from_groups

        filtered_data = {}
        for key, data in self.processed_data.items():
            if show_only_at_work:
                # --- POCZĄTEK POPRAWKI ---
                # Krok 1: Jeśli pracownik ma DTN=1, od razu go pomiń
                if data.get('dtn', 0) == 1:
                    continue
                # --- KONIEC POPRAWKI ---

                day_to_check = selected_date.day()
                day_data = data.get('days', {}).get(day_to_check, {})
                symbol = day_data.get('symbol', '')
                parsed = parse_symbol(symbol)
                special_symbol = parsed.get('special_symbol')
                is_working_today = False

                if symbol and (not special_symbol or special_symbol not in app_settings.get_absence_symbols()):
                    is_working_today = True

                if not is_working_today and day_data.get('nadgodziny', 0) > 0:
                    is_working_today = True

                if not is_working_today:
                    continue

                if selected_locations:
                    shift_location = parsed.get('location') or "none"
                    if shift_location not in selected_locations:
                        continue

            # Standardowe filtry (bez zmian)
            passes_standard_filters = (
                    (not selected_locations_default or data.get(
                        'lokalizacja_domyslna') in selected_locations_default) and
                    (not selected_wydzialy or key[0] in selected_wydzialy) and
                    (not selected_przelozeni or key[1] in selected_przelozeni) and
                    (not selected_uzytkownicy or str(key[2]) in selected_uzytkownicy) and
                    (not selected_dtn or str(data.get('dtn', '')) in selected_dtn) and
                    (not selected_role or data.get('rola_nazwa', '') in selected_role) and
                    (not selected_jezyki or data.get('jezyk', '') in selected_jezyki) and
                    (not selected_etaty or str(data.get('etat', '')) in selected_etaty) and
                    (not selected_scp or data.get('system_czasu_pracy', '') in selected_scp)
            )

            if not passes_standard_filters:
                continue

            filtered_data[key] = data

        return filtered_data

    def _cancel_delegations(self, events_to_cancel_input: List[Dict]):
        debug_print(f"Rozpoczynam _cancel_delegations dla {len(events_to_cancel_input)} zdarzeń.")
        if not events_to_cancel_input:
            return 0

        successful_db_updates = 0
        # Lista par (user_id, date_key) dla zdarzeń, które zostały pomyślnie zaktualizowane w DB
        affected_user_date_pairs_for_refresh = set()

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            _, user_app_id, _, _, _ = get_modifier_id()

            for event_details in events_to_cancel_input:
                event_id = event_details.get('id')
                event_type = event_details.get('type')
                user_id_for_event = event_details.get('user_id')  # Użyj user_id z event_details
                date_key_for_event = event_details.get('date_key', event_details.get('date'))

                if not event_id or not event_type or not user_id_for_event or not date_key_for_event:
                    log_warning(f"Pominięto zdarzenie z niepełnymi danymi w _cancel_delegations: {event_details}")
                    continue

                table_name = ""
                if event_type == "Spotkanie":
                    table_name = SQL_OBJECTS['spotkania']
                elif event_type == "Szkolenie":
                    table_name = SQL_OBJECTS['szkolenia']
                elif event_type == "Nadgodziny":
                    table_name = SQL_OBJECTS['nadgodziny']

                if not table_name:
                    log_warning(f"Nieznany typ zdarzenia w _cancel_delegations: {event_type}")
                    continue

                try:
                    if event_type in ["Spotkanie", "Szkolenie"]:
                        update_query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                        cursor.execute(update_query, (user_app_id, event_id))
                    else:  # Nadgodziny
                        delete_query = f"DELETE FROM {table_name} WHERE Id = ?"
                        cursor.execute(delete_query, (event_id,))

                    if cursor.rowcount > 0:
                        successful_db_updates += 1
                        affected_user_date_pairs_for_refresh.add((user_id_for_event, date_key_for_event))
                        debug_print(f"DB: Pomyślnie zaktualizowano/usunięto {event_type} ID {event_id}")
                    else:
                        log_warning(f"DB: Nie znaleziono {event_type} ID {event_id} do aktualizacji/usunięcia.")

                except Exception as db_err:
                    log_error(f"Błąd DB podczas odwoływania {event_type} ID {event_id}: {db_err}", exception=db_err)

            if successful_db_updates > 0:
                conn.commit()
                debug_print(f"DB: Zatwierdzono {successful_db_updates} zmian.")
                # Rejestrujemy, że to my dokonaliśmy zmiany w bazie danych
                self._update_modification_date()
            conn.close()

        except Exception as e:
            log_error(f"Generalny błąd w _cancel_delegations podczas operacji DB: {e}", exception=e)
            return 0  # Zwróć 0 jeśli wystąpił błąd przed aktualizacją UI

        # Jeśli były jakiekolwiek udane aktualizacje w DB
        if affected_user_date_pairs_for_refresh:
            debug_print(
                f"_cancel_delegations: Uruchamiam odświeżanie DataProvider dla {len(affected_user_date_pairs_for_refresh)} par.")
            # Krok 1: Unieważnij i odśwież cache DataProvider dla dotkniętych zdarzeń/miesięcy
            self.data_provider.invalidate_complete_cache_for_pairs(list(affected_user_date_pairs_for_refresh))

            # Krok 2: Odśwież tabelę zdarzeń - on_selection_changed użyje świeżych danych z DataProvider
            # Ta metoda zaktualizuje self.events_data i self.events_model
            debug_print(f"_cancel_delegations: Uruchamiam on_selection_changed() w celu odświeżenia tabeli zdarzeń.")
            selected_cells_data = self.table.get_data_for_selected_cells()  # Pobierz aktualnie zaznaczone komórki
            if selected_cells_data:
                self.on_selection_changed()  # To powinno teraz poprawnie wyczyścić zdarzenia
            else:  # Jeśli nic nie jest zaznaczone, wyczyść tabelę zdarzeń ręcznie
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])
                debug_print("_cancel_delegations: Brak zaznaczenia, wyczyszczono tabelę zdarzeń.")

            # Krok 3: Zaktualizuj ikony w tabeli grafiku na podstawie świeżych danych z DataProvider
            if hasattr(self, 'schedule_model'):
                debug_print(
                    f"_cancel_delegations: Uruchamiam aktualizację ikon grafiku dla {len(affected_user_date_pairs_for_refresh)} par.")
                for user_id, date_str in affected_user_date_pairs_for_refresh:
                    # Pobierz aktualne aktywne zdarzenia dla tej komórki z DataProvider
                    # DataProvider powinien teraz mieć świeże dane po invalidate_complete_cache_for_pairs
                    remaining_active_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                    has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_active_events)
                    has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_active_events)
                    has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_active_events)

                    self.schedule_model.update_cell_icons_directly(
                        user_id, date_str, has_meetings, has_trainings, has_overtime
                    )

            # Wymuś odświeżenie widoków tabel, jeśli to konieczne
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        debug_print(f"_cancel_delegations: Zakończono, pomyślnie przetworzono w DB: {successful_db_updates} zdarzeń.")
        return successful_db_updates

    def update_filter_dates(self):
        """Aktualizuje daty filtrowania do pierwszego i ostatniego dnia wybranego miesiąca"""
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # KLUCZOWA POPRAWKA: Blokuj sygnały przed zmianą dat
        self.date_from.blockSignals(True)
        self.date_to.blockSignals(True)

        try:
            # Pierwszy dzień miesiąca
            first_day = QDate(year, month, 1)
            self.date_from.setDate(first_day)

            # Ostatni dzień miesiąca
            if month == 12:
                next_month = QDate(year + 1, 1, 1)
            else:
                next_month = QDate(year, month + 1, 1)

            last_day = next_month.addDays(-1)
            self.date_to.setDate(last_day)

        finally:
            # ZAWSZE odblokuj sygnały
            self.date_from.blockSignals(False)
            self.date_to.blockSignals(False)

        # Wywołaj filtrowanie tylko RAZ po wszystkich zmianach
        self.filter_events_table()

    # def on_date_combo_changed(self):
    #     """
    #     Obsługuje zmianę miesiąca w ComboBox, ładując dane dla nowego okresu.
    #     """
    #     current_data = self.date_combo.currentData()
    #     if current_data:
    #         year, month = current_data
    #
    #         if self.staffing_details_win and not self.staffing_details_win.isHidden():
    #             self.staffing_details_win.update_for_new_month_or_filters(year, month)
    #
    #         if hasattr(self.data_provider, 'on_month_change'):
    #             self.data_provider.on_month_change(year, month)
    #
    #         # --- POCZĄTEK POPRAWKI ---
    #         # Użyj zapisanych atrybutów 'import_grupa' i 'import_funkcja'
    #         self.update_data(year, month, self.import_grupa, self.import_funkcja, use_async=True)
    #         # --- KONIEC POPRAWKI ---
    #
    #         self.update_filter_dates()
    #         self.update_buttons_visibility()

    def update_data(self, year, month, grupa, funkcja, use_async=True):
        """
        NOWA WERSJA: Ładowanie danych z opcją async

        Args:
            year: Rok
            month: Miesiąc
            use_async: Czy użyć asynchronicznego ładowania (domyślnie True)
        """
        debug_print(f"Rozpoczynam ładowanie danych dla {year}-{month} (async={use_async})")

        self.year = year
        self.month = month

        # Sprawdź czy modele zostały zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            debug_print("Tworzę nowy model grafiku")
            self.schedule_model = ScheduleTableModel(self)
            self.schedule_model.set_theme(self.is_dark_theme)

            ui_columns = self.column_definitions.get_ui_display_columns()
            visible_cols = self.visible_columns
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

        if not hasattr(self, 'events_model') or not self.events_model:
            debug_print("Tworzę nowy model zdarzeń")
            self.events_model = EventsTableModel(self)
            self.events_model.set_theme(self.is_dark_theme)

        # KLUCZOWA ZMIANA: Użyj async loading dla dużych zbiorów danych
        if use_async:
            self._load_data_async(year, month)
        else:
            self._load_data_sync(year, month)

    def _load_data_sync(self, year, month):
        """
        Synchroniczne ładowanie danych (fallback), teraz spójne z logiką asynchroniczną.
        """
        debug_print(f"Ładowanie synchroniczne dla {year}-{month}")

        try:
            if hasattr(self, 'statusBar'):
                self.statusBar().showMessage(f"Ładowanie danych {year}-{month}...")

            # Krok 1: Pobierz kontener z danymi bazowymi
            container = self.data_provider._get_or_load_monthly_data(
                year, month, self.import_grupa, self.import_funkcja, use_cache=False
            )

            if container:
                # Krok 2: Pobierz przetworzone dane z nałożonymi ikonami
                processed_data_with_icons = self.data_provider.get_processed_data(
                    year, month, self.import_grupa, self.import_funkcja
                )

                # Krok 3: Zastosuj wszystkie dane
                self._apply_loaded_data({
                    'schedule_data': container.schedule_data,
                    'events_data': container.events_data,
                    'processed_data': processed_data_with_icons,  # Używamy danych z ikonami
                    'year': year,
                    'month': month
                })
            else:
                log_error("Nie udało się pobrać danych z DataProvider w trybie synchronicznym.")

        except Exception as e:
            log_error(f"Błąd podczas synchronicznego ładowania: {e}", exception=e)

        finally:
            if hasattr(self, 'statusBar'):
                self.statusBar().clearMessage()

    def _load_data_async(self, year, month):
        """Asynchroniczne ładowanie danych z progress dialogiem."""
        # Leniwe importowanie
        from progress_dialog import LoadingProgressDialog

        debug_print(f"Uruchamiam async ładowanie dla {year}-{month}")
        self.loading_dialog = LoadingProgressDialog(
            self, self.data_provider, year, month, self.import_grupa, self.import_funkcja
        )
        self.loading_dialog.loading_completed.connect(self._on_async_data_loaded)
        self.loading_dialog.loading_cancelled.connect(self._on_async_loading_cancelled)
        self.loading_dialog.loading_failed.connect(self._on_async_loading_failed)
        self.loading_dialog.exec()
        if hasattr(self, 'loading_dialog'):
            self.loading_dialog.deleteLater()
            delattr(self, 'loading_dialog')


    def _on_async_data_loaded(self, data):
        """Obsługuje pomyślne załadowanie danych async."""
        debug_print("Otrzymano dane z async loading")
        try:
            self._apply_loaded_data(data)
            debug_print("Pomyślnie zastosowano dane z async loading")
        except Exception as e:
            log_error(f"Błąd podczas stosowania załadowanych danych: {e}")

    def _on_async_loading_cancelled(self):
        """Obsługuje anulowanie ładowania."""
        debug_print("Async loading został anulowany przez użytkownika")

    def _on_async_loading_failed(self, error_message):
        """Obsługuje błędy async loading."""
        debug_print(f"Async loading failed: {error_message}")
        QMessageBox.critical(self, "Błąd ładowania danych", f"Nie udało się załadować danych:\\n{error_message}\\n\\nSpróbuj ponownie lub skontaktuj się z administratorem.", QMessageBox.Ok)
        try:
            debug_print("Próbuję fallback do synchronicznego ładowania")
            self._load_data_sync(self.year, self.month)
        except Exception as e:
            log_error(f"Fallback loading też nie powiódł się: {e}")

    def _apply_loaded_data(self, data):
        """Aplikuje nowo załadowane dane do modeli i UI."""
        if data is None:
            log_error("Błąd: _apply_loaded_data otrzymało puste dane (None).")
            return

        schedule_data = data.get('schedule_data', [])
        events_data = data.get('events_data', [])
        processed_data = data.get('processed_data', {})
        year = data.get('year')
        month = data.get('month')

        if not all([processed_data, year, month]):
            log_error(f"Niekompletne dane przekazane do _apply_loaded_data: rok={year}, miesiac={month}")
            return

        self.raw_data = schedule_data
        self.all_events_data = events_data
        self.processed_data = processed_data
        self.schedule_model.update_data(self.processed_data, year, month)
        self.events_data = []
        if hasattr(self, 'events_model'):
            self.events_model.update_data([])

        # --- POCZĄTEK ZMIANY: Uproszczona logika przywracania filtrów ---
        # Usunięto warunek dla '_preserved_filter_state', teraz zawsze ładujemy z user_settings.
        last_filters = self.user_settings.get('last_filters')
        if last_filters:
            self.restore_filters_state(last_filters)
        else:
            # Ten blok uruchomi się tylko przy pierwszym wczytaniu, jeśli nie ma zapisanych filtrów
            self.update_filters()
            self.filter_data()
        # --- KONIEC ZMIANY ---

        self.apply_default_sort()
        self._apply_dynamic_sizes()

    def apply_default_sort(self):
        """
        Ręcznie sortuje dane w modelu zgodnie z domyślną, wielopoziomową
        kolejnością i wymusza odświeżenie widoku.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model._processed_data:
            return

        debug_print("Aplikowanie domyślnego, wielopoziomowego sortowania...")

        # Pobieramy klucze i pełne dane do sortowania
        keys_to_sort = self.schedule_model._keys
        processed_data = self.schedule_model._processed_data

        # Sortujemy klucze według docelowej kolejności
        sorted_keys = sorted(keys_to_sort, key=lambda k: (
            processed_data[k].get('dtn', 0),  # 1. Po DTN
            k[0] or '',  # 2. Po Wydziale
            k[1] or '',  # 3. Po Przełożonym
            k[2] or ''  # 4. Po Użytkowniku
        ))

        # Ustawiamy nową, posortowaną listę kluczy w modelu
        self.schedule_model._keys = sorted_keys

        # Informujemy widok, że układ modelu uległ całkowitej zmianie
        self.schedule_model.layoutChanged.emit()
        debug_print("Zakończono domyślne sortowanie. Widok został odświeżony.")

    def clear_events_cache(self, year, month):
        """
        Czyści cache zdarzeń dla danego miesiąca - UPROSZCZONA WERSJA

        Args:
            year: Rok
            month: Miesiąc
        """
        # POPRAWKA: Deleguj TYLKO do DataProvider, bez dodatkowych akcji
        if hasattr(self.data_provider, 'invalidate_icons_cache'):
            self.data_provider.invalidate_icons_cache(year, month)
            debug_print(f"Wyczyszczono cache zdarzeń dla {year}-{month}")
        else:
            debug_print(f"DataProvider nie ma metody invalidate_icons_cache")

    def get_events_for_user_date(self, user_id, date_str):
        """
        UPROSZCZONA METODA: Deleguje do DataProvider
        """
        return self.data_provider.get_events_for_user_date(user_id, date_str)

    def refresh_column_configuration(self):
        """Odświeża konfigurację kolumn z ColumnDefinitions"""
        # ZMODYFIKOWANE: Używaj self.column_definitions zamiast column_manager
        # Pobierz zaktualizowane dane kolumn
        ui_columns = self.column_definitions.get_ui_display_columns()
        visible_cols = self.visible_columns

        # Aktualizuj referencje w głównej klasie
        self.employee_columns = ui_columns

        # Aktualizuj model
        if hasattr(self, 'schedule_model') and self.schedule_model:
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

            # Jeśli tabela już istnieje, zaktualizuj widok
            if hasattr(self, 'table') and self.table:
                self.table.set_model(self.schedule_model)
                # Dostosuj szerokość tabeli pracowników
                self.table.adjust_employees_table_width()

    def setup_event_table_columns(self):
        """
        Konfiguruje szerokości kolumn tabeli zdarzeń.
        Wyodrębnione z metody update_data dla lepszej czytelności.
        """
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Użytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

    def show_loading_indicator(self, message="Ładowanie..."):
        """
        Pokazuje wskaźnik ładowania w UI
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().showMessage(message)

        # Wyłącz niektóre kontrolki podczas ładowania
        self.date_combo.setEnabled(False)
        self.refresh_button.setEnabled(False)

        if hasattr(self, 'left_panel_visible') and self.left_panel_visible:
            self._left_panel.setEnabled(False)

    def hide_loading_indicator(self):
        """
        Ukrywa wskaźnik ładowania
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().clearMessage()

        # Włącz z powrotem kontrolki
        self.date_combo.setEnabled(True)
        self.refresh_button.setEnabled(True)

        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(True)

    def get_loading_preferences(self):
        """
        Zwraca preferencje użytkownika dotyczące ładowania
        """
        # Można dodać ustawienia w settings_db dla kontroli async loading
        # Na razie zawsze async dla dużych zbiorów danych
        return {
            'use_async_threshold': 1000,  # Użyj async dla >1000 wierszy
            'show_progress_dialog': True,
            'auto_fallback_to_sync': True
        }




    def update_cross_filters(self):
        """
        Aktualizuje filtry wzajemnie, ale zamiast przebudowywać listy,
        jedynie ukrywa/pokazuje istniejące elementy, aby zachować pozycję przewijania.
        """
        if not getattr(self, '_cross_filtering_enabled', True):
            return

        if not hasattr(self, 'processed_data') or not self.processed_data:
            return

        if getattr(self, '_updating_cross_filters', False):
            return

        self._updating_cross_filters = True
        try:
            # Pobranie aktualnych wyborów (logika bez zmian)
            selected_wydzialy = self.wydzial_combo.get_selected_items()
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

            # === AKTUALIZACJA LISTY PRZEŁOŻONYCH ===
            if hasattr(self, 'przelozony_list'):
                # Oblicz, którzy przełożeni powinni być widoczni (logika bez zmian)
                available_przelozeni = set()
                if selected_wydzialy:
                    for key in self.processed_data.keys():
                        if key[0] in selected_wydzialy and key[1]:
                            available_przelozeni.add(key[1])
                else:
                    for key in self.processed_data.keys():
                        if key[1]: available_przelozeni.add(key[1])

                # NOWA LOGIKA: Pokaż/ukryj elementy zamiast przebudowywać listę
                for i in range(self.przelozony_list.count()):
                    item = self.przelozony_list.item(i)
                    item.setHidden(item.text() not in available_przelozeni)

            # === AKTUALIZACJA LISTY UŻYTKOWNIKÓW ===
            if hasattr(self, 'uzytkownik_list'):
                # Oblicz, którzy użytkownicy powinni być widoczni (logika bez zmian)
                available_uzytkownicy = set()
                for key in self.processed_data.keys():
                    wydzial, przelozony, uzytkownik_dane, _ = key
                    if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                            (not selected_przelozeni or przelozony in selected_przelozeni):
                        if uzytkownik_dane: available_uzytkownicy.add(str(uzytkownik_dane))

                # NOWA LOGIKA: Pokaż/ukryj elementy zamiast przebudowywać listę
                for i in range(self.uzytkownik_list.count()):
                    item = self.uzytkownik_list.item(i)
                    item.setHidden(item.text() not in available_uzytkownicy)

        except Exception as e:
            log_error(f"Błąd podczas cross-filtrowania: {e}", exception=e)
        finally:
            self._updating_cross_filters = False

    def update_list_safely(self, list_widget, items, selected_items):
        """
        Bezpiecznie aktualizuje QListWidget, blokując sygnały na czas modyfikacji.
        """
        if not list_widget:
            return

        list_widget.blockSignals(True)
        try:
            # Zapamiętanie, co jest aktualnie widoczne z pola wyszukiwania
            search_text = ""
            if list_widget is self.przelozony_list:
                search_text = self.przelozony_filter.text().lower()
            elif list_widget is self.uzytkownik_list:
                search_text = self.uzytkownik_filter.text().lower()

            list_widget.clear()
            for item_text in sorted(items):
                item = QListWidgetItem(item_text)
                list_widget.addItem(item)
                if item_text in selected_items:
                    item.setSelected(True)

                # Przywrócenie ukrycia na podstawie filtra wyszukiwania
                if search_text and search_text not in item_text.lower():
                    item.setHidden(True)

        finally:
            list_widget.blockSignals(False)

    def get_current_filters_state(self):
        """Zapisuje aktualnie wybrane wartości ze wszystkich ISTNIEJĄCYCH filtrów do słownika."""
        state = {
            'grupa': self.grupa_main_filter_combo.currentText(),
            'wydzial': self.wydzial_combo.get_selected_items(),
            'przelozony': self.get_list_selected_items(self.przelozony_list),
            'uzytkownik': self.get_list_selected_items(self.uzytkownik_list),
            'lokalizacja_domyslna': self.default_location_combo.get_selected_items(),
            'system_czasu_pracy': self.system_czasu_pracy_combo.get_selected_items(),
            'rola': self.rola_combo.get_selected_items(),
            'jezyk': self.jezyk_combo.get_selected_items(),
            'etat': self.etat_combo.get_selected_items(),
            'dtn': self.dtn_combo.get_selected_items(),
        }
        debug_print(f"Zapisano stan filtrów: {state}")
        return state

    def restore_filters_state(self, state):
        """
        Przywraca zapisany stan filtrów po załadowaniu nowych danych.
        """
        debug_print("Rozpoczynam przywracanie stanu filtrów...")

        self._cross_filtering_enabled = False

        try:
            self.update_filters()

            self.grupa_main_filter_combo.blockSignals(True)
            self.grupa_main_filter_combo.setCurrentText(state.get('grupa', '(Wszyscy)'))
            self.grupa_main_filter_combo.blockSignals(False)

            self.wydzial_combo.select_items(state.get('wydzial', []))
            self.default_location_combo.select_items(state.get('lokalizacja_domyslna', []))
            self.system_czasu_pracy_combo.select_items(state.get('system_czasu_pracy', []))
            self.rola_combo.select_items(state.get('rola', []))
            self.jezyk_combo.select_items(state.get('jezyk', []))
            self.etat_combo.select_items(state.get('etat', []))
            self.dtn_combo.select_items(state.get('dtn', []))

            przelozeni_items = self._get_unique_values_for_filter('przelozony')
            uzytkownicy_items = self._get_unique_values_for_filter('uzytkownik_dane')
            self.update_list_safely(self.przelozony_list, przelozeni_items, state.get('przelozony', []))
            self.update_list_safely(self.uzytkownik_list, uzytkownicy_items, state.get('uzytkownik', []))

        finally:
            self._cross_filtering_enabled = True
            debug_print("Zakończono przywracanie stanu filtrów.")

        debug_print("Uruchamiam filtrowanie po przywróceniu stanu.")
        self.filter_data()

    def _get_unique_values_for_filter(self, filter_key):
        """
        Pobiera unikalne wartości dla danego filtra z aktualnie załadowanych,
        pełnych danych w self.processed_data.
        """
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return set()

        unique_values = set()

        key_map = {
            'wydzial': 0,
            'przelozony': 1,
            'uzytkownik_dane': 2
        }

        if filter_key in key_map:
            key_index = key_map[filter_key]
            for key_tuple in self.processed_data.keys():
                if len(key_tuple) > key_index and key_tuple[key_index]:
                    unique_values.add(str(key_tuple[key_index]))
        else:
            for data_dict in self.processed_data.values():
                value = data_dict.get(filter_key)
                # --- POPRAWIONY WARUNEK ---
                # Sprawdzamy, czy wartość nie jest None, co poprawnie uwzględni zero.
                if value is not None and value != '':
                    unique_values.add(str(value))

        return unique_values

    def clear_filters(self):
        """Czyści wszystkie filtry i aktualizuje model."""
        self._cross_filtering_enabled = False
        try:
            combo_names_to_clear = [
                'grupa_main_filter_combo', 'wydzial_combo', 'dtn_combo',
                'rola_combo', 'jezyk_combo', 'etat_combo',
                'system_czasu_pracy_combo',
                'default_location_combo'
            ]
            for combo_name in combo_names_to_clear:
                if hasattr(self, combo_name):
                    getattr(self, combo_name).clear_selection()

            # reszta metody bez zmian...
            if hasattr(self, 'przelozony_list'): self.przelozony_list.clearSelection()
            if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.clearSelection()
            if hasattr(self, 'przelozony_filter'): self.przelozony_filter.clear()
            if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.clear()

            self._cross_filtering_enabled = True
            self.update_filters()
            self.filter_data()

        finally:
            self._cross_filtering_enabled = True

    def filter_przelozony_list(self, text):
        """
        Filtruje listę przełożonych na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'przelozony_list'):
            return

        text = text.lower()
        for i in range(self.przelozony_list.count()):
            item = self.przelozony_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_uzytkownik_list(self, text):
        """
        Filtruje listę użytkowników na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'uzytkownik_list'):
            return

        text = text.lower()
        for i in range(self.uzytkownik_list.count()):
            item = self.uzytkownik_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def update_filtered_table(self):
        """
        Aktualizuje widok tabeli na podstawie zaznaczonych filtrów
        """
        # Bezpośrednio aktualizuj całą tabelę z przefiltrowanymi danymi
        self.update_table_content()

    def get_list_selected_items(self, list_widget):
        """
        Zwraca teksty zaznaczonych elementów z listy.
        POPRAWKA: Zmieniono nazwę metody z get_selected_items na get_list_selected_items,
        aby uniknąć konfliktu z metodą get_selected_items w CustomMultiComboBox.

        Args:
            list_widget: QListWidget do pobrania zaznaczonych elementów

        Returns:
            list: Lista zaznaczonych tekstów
        """
        if not list_widget:
            return []

        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item and item.isSelected():
                selected.append(item.text())
        return selected

    def update_filters(self):
        """
        Wypełnia wszystkie filtry na podstawie załadowanych danych.
        WERSJA POPRAWIONA: Zawiera kompletną logikę dla wszystkich filtrów.
        """
        try:
            if not hasattr(self, 'processed_data') or not self.processed_data:
                debug_print("Brak danych do wypełnienia filtrów, pomijam.")
                return

            debug_print("Rozpoczynam pełną aktualizację filtrów...")

            # Zapamiętanie bieżących wyborów, aby je przywrócić po odświeżeniu list
            selected_grupy = self.grupa_main_filter_combo.get_selected_items()
            selected_wydzialy = self.wydzial_combo.get_selected_items()
            selected_dtn = self.dtn_combo.get_selected_items()
            selected_role = self.rola_combo.get_selected_items()
            selected_jezyki = self.jezyk_combo.get_selected_items()
            selected_etaty = self.etat_combo.get_selected_items()
            selected_scp = self.system_czasu_pracy_combo.get_selected_items()
            selected_locations = self.default_location_combo.get_selected_items()

            # Filtr "Grupa"
            group_mapping = self.data_provider.get_department_to_group_mapping()
            self.grupa_main_filter_combo.add_items(sorted(group_mapping.keys()))
            self.grupa_main_filter_combo.select_items(selected_grupy)

            # Filtr "Wydział"
            wydzialy = sorted(set(key[0] for key in self.processed_data.keys() if key[0]))
            self.wydzial_combo.add_items(wydzialy)
            self.wydzial_combo.select_items(selected_wydzialy)

            # Filtr "Lokalizacja Domyślna"
            locations = sorted(set(data.get('lokalizacja_domyslna', '') for data in self.processed_data.values() if
                                   data.get('lokalizacja_domyslna')))
            self.default_location_combo.add_items(locations)
            self.default_location_combo.select_items(selected_locations)

            # Filtr "System Pracy"
            scp_values = sorted(set(data.get('system_czasu_pracy', '') for data in self.processed_data.values() if
                                    data.get('system_czasu_pracy', '')))
            self.system_czasu_pracy_combo.add_items(scp_values)
            self.system_czasu_pracy_combo.select_items(selected_scp)

            # Filtr "Rola"
            role_values = sorted(
                set(data.get('rola_nazwa', '') for data in self.processed_data.values() if data.get('rola_nazwa', '')))
            self.rola_combo.add_items(role_values)
            self.rola_combo.select_items(selected_role)

            # Filtr "Język"
            jezyki_values = sorted(
                set(data.get('jezyk', '') for data in self.processed_data.values() if data.get('jezyk', '')))
            self.jezyk_combo.add_items(jezyki_values)
            self.jezyk_combo.select_items(selected_jezyki)

            # Filtr "Etat"
            etaty_values = set(str(data.get('etat', '')) for data in self.processed_data.values() if
                               data.get('etat') is not None and str(data.get('etat', '')))
            sorted_etaty = sorted(etaty_values, key=lambda x: float(x) if x.replace('.', '', 1).isdigit() else 0)
            self.etat_combo.add_items(sorted_etaty)
            self.etat_combo.select_items(selected_etaty)

            # Filtr "DTN"
            dtn_values = sorted(set(str(data['dtn']) for data in self.processed_data.values() if data.get('dtn') is not None), key=int)
            self.dtn_combo.add_items(dtn_values)
            self.dtn_combo.select_items(selected_dtn)

            # Aktualizacja list dynamicznych (Przełożony, Użytkownik)
            self.update_przelozony_filter()
            self.update_uzytkownik_filter()

            debug_print("Zakończono pełną aktualizację wszystkich filtrów.")

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji filtrów: {e}", exception=e)

    def update_przelozony_filter(self, selected_przelozeni=None):
        """
        Aktualizuje listę przełożonych na podstawie wybranych wydziałów.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_przelozeni: Lista zaznaczonych przełożonych (opcjonalnie)
        """
        if not hasattr(self, 'przelozony_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiętaj bieżącą selekcję jeśli nie podano
        if selected_przelozeni is None:
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)

        self.przelozony_list.clear()

        # Pobierz wybrane wydziały
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []

        # Zbiór unikalnych przełożonych
        przelozeni = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, _, _ = key

            # Jeśli nie wybrano wydziałów lub wydział pasuje do filtra
            if not selected_wydzialy or wydzial in selected_wydzialy:
                # Dodaj przełożonego do zbioru (tylko niepuste wartości)
                if przelozony:
                    przelozeni.add(przelozony)

        # Dodaj posortowanych przełożonych do listy
        for przelozony in sorted(przelozeni):
            item = QListWidgetItem(przelozony)
            self.przelozony_list.addItem(item)

            # Przywróć zaznaczenie jeśli było
            if przelozony in selected_przelozeni:
                item.setSelected(True)

    def update_uzytkownik_filter(self, selected_uzytkownicy=None):
        """
        Aktualizuje listę użytkowników na podstawie wybranych wydziałów i przełożonych.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_uzytkownicy: Lista zaznaczonych użytkowników (opcjonalnie)
        """
        if not hasattr(self, 'uzytkownik_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiętaj bieżącą selekcję jeśli nie podano
        if selected_uzytkownicy is None:
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

        self.uzytkownik_list.clear()

        # Pobierz wybrane wydziały i przełożonych
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self,
                                                                                            'przelozony_list') else []

        # Zbiór unikalnych użytkowników (użyj stringa jako tekstowej reprezentacji)
        uzytkownicy = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, uzytkownik_dane, _ = key

            # Sprawdź czy dane pasują do filtrów
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni):
                # Dodaj użytkownika do zbioru (tylko niepuste wartości)
                if uzytkownik_dane:
                    # Konwertuj do stringa dla spójności
                    uzytkownicy.add(str(uzytkownik_dane))

        # Dodaj posortowanych użytkowników do listy
        for uzytkownik in sorted(uzytkownicy):
            item = QListWidgetItem(uzytkownik)
            self.uzytkownik_list.addItem(item)

            # Przywróć zaznaczenie jeśli było
            if uzytkownik in selected_uzytkownicy:
                item.setSelected(True)

    def update_table_content(self):
        """
        Aktualizuje zawartość tabeli grafiku używając modelu danych.
        Zoptymalizowana wersja wykorzystująca precyzyjne aktualizacje.
        """
        # Sprawdź czy modele zostały zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # Ustaw rok i miesiąc w modelu (jeśli jeszcze nie są ustawione)
        if self.schedule_model._year != year or self.schedule_model._month != month:
            # Pobierz dane dla wybranego roku i miesiąca
            schedule_data = self.data_provider.get_schedule_data(year, month, self.import_grupa, self.import_funkcja)

            # Aktualizuj model - to wywoła zoptymalizowaną metodę update_data
            self.schedule_model.update_data(schedule_data, year, month)
            self._apply_dynamic_sizes()
        else:
            # Jeśli rok i miesiąc nie uległy zmianie, tylko zastosuj filtry
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

    def get_cell_color_by_time(self, hour):
        """
        Zwraca kolor tła komórki na podstawie godziny rozpoczęcia.
        Godziny są mapowane na kolory w bardziej czytelnej palecie.

        Args:
            hour (int): Godzina rozpoczęcia zmiany (0-23)

        Returns:
            QColor: Kolor tła komórki
        """
        # Domyślny kolor (przezroczysty) gdy godzina nie jest zdefiniowana
        if hour is None or hour < 0 or hour > 23:
            return QColor(255, 255, 255, 0)  # Przezroczysty

        # Mapowanie godzin na kolory - zharmonizowana paleta
        if hour == 5:
            return QColor(204, 255, 255)  # Jasny błękit (bardzo jasny cyjan)
        elif hour == 6:
            return QColor(204, 255, 255)  # Jasny błękit (bardzo jasny cyjan)
        elif hour == 7:
            return QColor(0, 255, 255)  # Cyjan (akwamaryna)
        elif hour == 8:
            return QColor(0, 204, 255)  # Jasny błękit (niebieskozielony)
        elif hour == 9:
            return QColor(0, 255, 0)  # Limonkowy (czysty zielony)
        elif hour == 10:
            return QColor(153, 204, 0)  # Oliwkowy (żółtozielony)
        elif hour == 11:
            return QColor(204, 255, 204)  # Bardzo jasny zielony (miętowy)
        elif hour == 12:
            return QColor(255, 255, 153)  # Bardzo jasny żółty (kremowy)
        elif hour == 13:
            return QColor(255, 204, 153)  # Jasny łososiowy (brzoskwiniowy)
        elif hour == 14:
            return QColor(255, 153, 0)  # Ciemny pomarańczowy
        elif hour == 15:
            return QColor(255, 0, 255)  # Magenta (fuksja)
        elif hour == 16:
            return QColor(204, 0, 0)  # Ciemnoczerwony
        elif hour == 17:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 18:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 19:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 20:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 21:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 22:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 23:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 0:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour in [1, 2, 3, 4]:
            return QColor(51, 51, 51)  # Ciemny szary

        # Domyślny kolor dla innych wartości
        return QColor(255, 255, 255, 0)  # Przezroczysty

    def on_selection_changed(self, selected=None, deselected=None):
        """
        POPRAWIONA WERSJA: Debounced selection handling
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # DODANE: Sprawdź czy nie jesteśmy w trakcie aktualizacji
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        # NOWE: Zastop poprzedni timer i uruchom nowy (debouncing)
        if hasattr(self, '_selection_timer'):
            self._selection_timer.stop()
            self._selection_timer.start(self._selection_debounce_delay)

    def _handle_selection_change(self):
        """
        NOWA METODA: Faktyczna obsługa zmiany zaznaczenia (wywoływana po debounce)
        """
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        self._updating_selection = True

        try:
            debug_print("Zmiana zaznaczenia - aktualizuję tabelę zdarzeń...")

            # Pobierz dane dla zaznaczonych komórek
            selected_cells_data = self.table.get_data_for_selected_cells()
            debug_print(f"Zaznaczono {len(selected_cells_data)} komórek")

            if selected_cells_data and len(selected_cells_data) > 0:
                # MAMY ZAZNACZONE KOMÓRKI - pokaż zdarzenia
                events = []

                for cell_data in selected_cells_data:
                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')

                    if user_id and date_str:
                        # --- ZMIANA: Usuwamy przekazywanie self.import_grupa i self.import_funkcja ---
                        user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                        for event in user_events:
                            local_event = self._convert_dp_event_to_local(event)
                            events.append(local_event)

                debug_print(f"Pobrano {len(events)} aktywnych zdarzeń dla zaznaczonych komórek")

                # Zaktualizuj events_data
                self.events_data = events

                # Aktualizuj model zdarzeń
                if hasattr(self, 'events_model'):
                    self.events_model.update_data(self.events_data)

                    # WAŻNE: Zastosuj filtry po aktualizacji danych
                    self.filter_events_table()
            else:
                # BRAK ZAZNACZENIA - wyczyść tabelę zdarzeń
                debug_print("Brak zaznaczenia - czyszczę tabelę zdarzeń")
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])

            # DODANE: Wymuś odświeżenie widoku tabeli zdarzeń
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        finally:
            self._updating_selection = False

    def clear_events_on_startup(self):
        """
        NOWA METODA: Czyści tabelę zdarzeń przy starcie aplikacji
        """
        debug_print("Czyszczę tabelę zdarzeń przy starcie aplikacji")

        # Wyczyść dane zdarzeń
        self.events_data = []

        # Wyczyść model zdarzeń jeśli istnieje
        if hasattr(self, 'events_model') and self.events_model:
            self.events_model.update_data([])

        # Odśwież widok tabeli zdarzeń
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

    def _convert_dp_event_to_local(self, dp_event):
        """
        NOWA METODA: Konwertuje format zdarzenia z DataProvider na lokalny format UI
        """
        try:
            # Skonwertuj datę z YYYY-MM-DD na DD.MM.YYYY
            date_key = dp_event.get('date_key', dp_event.get('date', ''))
            if date_key and '-' in date_key:
                year, month, day = date_key.split('-')
                display_date = f"{day}.{month}.{year}"
            else:
                display_date = dp_event.get('date_display', date_key)

            # Skonwertuj czas z formatu bazy na HH:MM
            time_from = dp_event.get('time_from', '')
            time_to = dp_event.get('time_to', '')

            if time_from and 'T' in time_from:
                time_from = time_from.split('T')[1].split(':')[0] + ':' + time_from.split('T')[1].split(':')[1]
            elif time_from and ' ' in time_from:
                time_from = time_from.split(' ')[1][:5]

            if time_to and 'T' in time_to:
                time_to = time_to.split('T')[1].split(':')[0] + ':' + time_to.split('T')[1].split(':')[1]
            elif time_to and ' ' in time_to:
                time_to = time_to.split(' ')[1][:5]

            # Pobierz nazwę użytkownika
            user_name = dp_event.get('user_name', '')
            if not user_name:
                user_id = dp_event.get('user_id')
                if user_id and hasattr(self, 'user_info_map') and user_id in self.user_info_map:
                    user_name = self.user_info_map[user_id].get('uzytkownik_dane', f"ID: {user_id}")
                else:
                    user_name = f"ID: {user_id}"

            # Utwórz zdarzenie w lokalnym formacie
            local_event = {
                'type': dp_event.get('event_type', dp_event.get('type', '')),
                'topic': dp_event.get('topic', ''),
                'name': dp_event.get('name', ''),
                'user_id': dp_event.get('user_id'),
                'user_name': user_name,
                'date': display_date,
                'date_key': date_key,
                'time_from': time_from,
                'time_to': time_to,
                'status': dp_event.get('status', ''),
                'id': dp_event.get('event_id', dp_event.get('id'))
            }

            return local_event

        except Exception as e:
            log_error(f"Błąd konwersji zdarzenia: {e}")
            # Zwróć zdarzenie w oryginalnym formacie w przypadku błędu
            return dp_event

    def temporarily_disable_filters(self):
        """Tymczasowo wyłącza filtry zdarzeń aby zapewnić wyświetlenie wszystkich danych"""
        # Zapamiętaj obecny stan filtrów
        self._saved_filters = {
            'meetings': self.meetings_checkbox.isChecked() if hasattr(self, 'meetings_checkbox') else True,
            'trainings': self.trainings_checkbox.isChecked() if hasattr(self, 'trainings_checkbox') else True,
            'overtime': self.overtime_checkbox.isChecked() if hasattr(self, 'overtime_checkbox') else True,
            'topic': self.topic_filter.text() if hasattr(self, 'topic_filter') else "",
            'name': self.name_filter.text() if hasattr(self, 'name_filter') else "",
            'date_from': self.date_from.date() if hasattr(self, 'date_from') else None,
            'date_to': self.date_to.date() if hasattr(self, 'date_to') else None
        }

        # Ustaw wszystkie filtry na wartości, które pokazują wszystkie dane
        if hasattr(self, 'meetings_checkbox'):
            self.meetings_checkbox.setChecked(True)
        if hasattr(self, 'trainings_checkbox'):
            self.trainings_checkbox.setChecked(True)
        if hasattr(self, 'overtime_checkbox'):
            self.overtime_checkbox.setChecked(True)
        if hasattr(self, 'topic_filter'):
            self.topic_filter.setText("")
        if hasattr(self, 'name_filter'):
            self.name_filter.setText("")

        # Daty zostawiamy bez zmian, filtrowanie będzie nadpisane przez model

        debug_print("Tymczasowo wyłączono filtry zdarzeń")

    def restore_filters(self):
        """Przywraca filtry zdarzeń do ich poprzedniego stanu"""
        if not hasattr(self, '_saved_filters'):
            return

        # Przywróć filtry do ich poprzedniego stanu
        if hasattr(self, 'meetings_checkbox') and 'meetings' in self._saved_filters:
            self.meetings_checkbox.setChecked(self._saved_filters['meetings'])
        if hasattr(self, 'trainings_checkbox') and 'trainings' in self._saved_filters:
            self.trainings_checkbox.setChecked(self._saved_filters['trainings'])
        if hasattr(self, 'overtime_checkbox') and 'overtime' in self._saved_filters:
            self.overtime_checkbox.setChecked(self._saved_filters['overtime'])
        if hasattr(self, 'topic_filter') and 'topic' in self._saved_filters:
            self.topic_filter.setText(self._saved_filters['topic'])
        if hasattr(self, 'name_filter') and 'name' in self._saved_filters:
            self.name_filter.setText(self._saved_filters['name'])

        # Nie przywracamy dat, aby zapewnić spójność z zaznaczonymi komórkami

        debug_print("Przywrócono filtry zdarzeń")

        # Wymuś odświeżenie z nowymi filtrami
        self.filter_events_table()

    def diagnose_events_table(self):
        """Metoda diagnostyczna do sprawdzenia stanu tabeli zdarzeń"""
        debug_print("\n=== DIAGNOSTYKA TABELI ZDARZEŃ ===")

        if not hasattr(self, 'events_table') or not self.events_table:
            log_error("ERROR: Brak obiektu events_table!")
            return

        if not hasattr(self, 'events_model') or not self.events_model:
            log_error("ERROR: Brak obiektu events_model!")
            return

        # Sprawdź model
        debug_print(
            f"events_model ma {self.events_model.rowCount()} wierszy i {self.events_model.columnCount()} kolumn")
        debug_print(f"Dane w events_model: {len(self.events_model._data)} zdarzeń")
        debug_print(f"Przefiltrowane dane w events_model: {len(self.events_model._filtered_data)} zdarzeń")

        # Sprawdź filtry
        debug_print("\nAktualne filtry:")
        if hasattr(self, 'meetings_checkbox'):
            debug_print(f"Spotkania: {self.meetings_checkbox.isChecked()}")
        if hasattr(self, 'trainings_checkbox'):
            debug_print(f"Szkolenia: {self.trainings_checkbox.isChecked()}")
        if hasattr(self, 'overtime_checkbox'):
            debug_print(f"Nadgodziny: {self.overtime_checkbox.isChecked()}")
        if hasattr(self, 'topic_filter'):
            debug_print(f"Filtr tematu: '{self.topic_filter.text()}'")
        if hasattr(self, 'name_filter'):
            debug_print(f"Filtr nazwy: '{self.name_filter.text()}'")

        # Sprawdź przykładowe dane
        if self.events_model._data:
            debug_print("\nPrzykładowe zdarzenie z danych (przed filtrowaniem):")
            debug_print(self.events_model._data[0])

        if self.events_model._filtered_data:
            debug_print("\nPrzykładowe zdarzenie z danych po filtrowaniu:")
            debug_print(self.events_model._filtered_data[0])

        # Sprawdź widok
        debug_print(f"\nWidok events_table: {self.events_table.model().rowCount()} wierszy")

        debug_print("=== KONIEC DIAGNOSTYKI TABELI ZDARZEŃ ===\n")

    def standardize_date(self, date_obj):
        """
        Standaryzuje format daty do 'YYYY-MM-DD' dla porównań
        """
        if not date_obj:
            return ''

        # Jeśli to już string, wyciągnij tylko datę
        if isinstance(date_obj, str):
            # Obsługa różnych formatów
            if 'T' in date_obj:  # Format ISO 'YYYY-MM-DDThh:mm:ss'
                return date_obj.split('T')[0]
            elif ' ' in date_obj:  # Format 'YYYY-MM-DD hh:mm:ss'
                return date_obj.split(' ')[0]
            elif len(date_obj) == 10 and date_obj.count('-') == 2:  # Format 'YYYY-MM-DD'
                return date_obj
            # Jeśli nie dopasowano do żadnego formatu, zwróć oryginalny string
            return date_obj

        # Jeśli to obiekt datetime, skonwertuj na string
        if hasattr(date_obj, 'strftime'):
            return date_obj.strftime('%Y-%m-%d')

        # W przypadku nieznanego typu, zwróć pusty string
        return ''

    def diagnose_table_view(self):
        """Metoda diagnostyczna do sprawdzenia stanu SplitTableView"""
        if not hasattr(self, 'table') or not self.table:
            log_error("ERROR: Brak obiektu table!")
            return

        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            log_error("ERROR: Brak obiektu schedule_model!")
            return

        debug_print("\n=== DIAGNOSTYKA TABELI ===")

        # Sprawdź model
        debug_print(f"Model ma {self.schedule_model.rowCount()} wierszy i {self.schedule_model.columnCount()} kolumn")
        debug_print(f"Widoczne kolumny: {self.schedule_model.get_visible_columns()}")

        # Sprawdź widoki
        debug_print(
            f"Employees view ma {self.table.employees_view.model().rowCount()} wierszy i {self.table.employees_view.model().columnCount()} kolumn")
        debug_print(
            f"Schedule view ma {self.table.schedule_view.model().rowCount()} wierszy i {self.table.schedule_view.model().columnCount()} kolumn")

        # Sprawdź kolumny w employees_view
        for col in range(self.table.employees_view.model().columnCount()):
            hidden = self.table.employees_view.isColumnHidden(col)
            width = self.table.employees_view.columnWidth(col)
            debug_print(f"Kolumna {col} w employees_view: ukryta={hidden}, szerokość={width}px")

        # Sprawdź przykładowe dane w pierwszym wierszu
        if self.schedule_model.rowCount() > 0:
            debug_print("\nPrzykładowe dane z pierwszego wiersza:")
            for col in range(len(self.schedule_model.get_visible_columns())):
                index = self.schedule_model.index(0, col)
                text = self.schedule_model.data(index, Qt.DisplayRole)
                debug_print(f"Kolumna {col}: '{text}'")

        debug_print("=== KONIEC DIAGNOSTYKI ===\n")

    def diagnose_application_state(self):
        """Wykonuje pełną diagnostykę stanu aplikacji i wyświetla szczegółowe informacje"""
        try:
            debug_print("\n===== DIAGNOSTYKA STANU APLIKACJI =====")

            # 1. Sprawdź tabele i dane
            debug_print("\n--- TABELA GRAFIKU ---")
            debug_print(f"Liczba wierszy: {self.table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.table.columnCount()}")

            # Sprawdź pierwsze 3 wiersze i kolumny dla przykładu
            debug_print("\nPrzykładowe komórki z tabeli grafiku:")
            for row in range(min(3, self.table.rowCount())):
                for col in range(min(6, self.table.columnCount())):
                    item = self.table.item(row, col)
                    if item:
                        debug_print(f"[{row},{col}] Tekst: {item.text()}")
                        user_role_data = item.data(Qt.UserRole)
                        user_role_2 = item.data(Qt.UserRole + 2)
                        user_role_3 = item.data(Qt.UserRole + 3)
                        debug_print(
                            f"  UserRole: {type(user_role_data)}, UserRole+2: {user_role_2}, UserRole+3: {user_role_3}")
                        if isinstance(user_role_data, dict):
                            debug_print(f"  Zawartość: {user_role_data}")
                    else:
                        debug_print(f"[{row},{col}] Brak elementu")

            debug_print("\n--- TABELA ZDARZEŃ ---")
            debug_print(f"Liczba wierszy: {self.events_table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.events_table.columnCount()}")

            # Sprawdź zawartość events_data
            debug_print(
                f"\nLiczba zdarzeń w events_data: {len(self.events_data) if hasattr(self, 'events_data') else 'Brak'}")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print("Pierwsze zdarzenie:")
                for key, value in self.events_data[0].items():
                    debug_print(f"  {key}: {value}")

            # Sprawdź pierwsze 3 wiersze tabeli zdarzeń
            debug_print("\nPrzykładowe wiersze z tabeli zdarzeń:")
            for row in range(min(3, self.events_table.rowCount())):
                row_data = []
                for col in range(self.events_table.columnCount() - 1):  # Pomijamy ostatnią kolumnę z przyciskami
                    item = self.events_table.item(row, col)
                    if item:
                        row_data.append(f"{col}:{item.text()}")
                debug_print(f"Wiersz {row}: {', '.join(row_data)}")

            # 2. Sprawdź delegaty i style
            debug_print("\n--- DELEGATY I STYLE ---")
            item_delegate = self.table.itemDelegate()
            debug_print(f"Delegat tabeli grafiku: {item_delegate.__class__.__name__}")
            if isinstance(item_delegate, OvertimeItemDelegate):
                debug_print("  Delegat OvertimeItemDelegate poprawnie przypisany")
            else:
                debug_print("  UWAGA: Delegat OvertimeItemDelegate nie jest przypisany!")

            # 3. Sprawdź filtrowanie danych
            debug_print("\n--- FILTROWANIE DANYCH ---")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print(f"Liczba zdarzeń przed filtrowaniem: {len(self.events_data)}")
                # Sprawdź, czy metoda filter_events_table jest wywoływana
                debug_print("Spróbuj wykonać filter_events_table:")
                try:
                    self.filter_events_table()
                    debug_print("  Metoda filter_events_table wykonana bez błędów")
                except Exception as e:
                    debug_print(f"  BŁĄD podczas wykonywania filter_events_table: {e}")

            debug_print("\n===== KONIEC DIAGNOSTYKI =====\n")

        except Exception as e:
            debug_print(f"BŁĄD podczas diagnostyki: {e}")
            import traceback
            traceback.print_exc()


    def _get_current_event_filter_params(self):
        """
        Pobiera bieżące parametry filtrowania zdarzeń.

        Returns:
            dict: Parametry filtrowania
        """
        filter_params = {}

        # Dodaj filtr typów zdarzeń
        allowed_types = []
        if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
            allowed_types.append('Spotkanie')
        if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
            allowed_types.append('Szkolenie')
        if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
            allowed_types.append('Nadgodziny')

        if allowed_types:
            filter_params['allowed_types'] = allowed_types

        # Dodaj filtry tematu i nazwy
        topic_filter = self.topic_filter.text().lower() if hasattr(self,
                                                                   'topic_filter') and self.topic_filter.text() else None
        name_filter = self.name_filter.text().lower() if hasattr(self,
                                                                 'name_filter') and self.name_filter.text() else None

        if topic_filter:
            filter_params['topic'] = topic_filter
        if name_filter:
            filter_params['name'] = name_filter

        # Dodaj filtry zakresu dat
        date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
        date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

        if date_from_str:
            filter_params['date_from'] = date_from_str
        if date_to_str:
            filter_params['date_to'] = date_to_str

        return filter_params

    def find_cell_position(self, user_id, date_str):
        """
        Znajduje pozycję komórki dla podanego użytkownika i daty, korzystając z modelu.

        Args:
            user_id: ID użytkownika
            date_str: Data w formacie YYYY-MM-DD

        Returns:
            tuple: (wiersz, dzień) lub (-1, -1) jeśli nie znaleziono
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return -1, -1

        # Pobierz dzień z daty
        try:
            year, month, day_str = date_str.split('-')
            day = int(day_str)
        except:
            return -1, -1

        # Pobierz liczbę wierszy w modelu
        row_count = self.schedule_model.rowCount()

        # Dla każdego wiersza sprawdź, czy odpowiada szukanemu użytkownikowi
        for row in range(row_count):
            # Pobierz ID użytkownika z pierwszej kolumny
            index = self.schedule_model.index(row, 0)
            user_data = self.schedule_model.data(index, Qt.UserRole)

            if isinstance(user_data, dict) and str(user_data.get('uzytkownik_id', '')) == str(user_id):
                return row, day

        return -1, -1

    def _get_cell_data_for_user_date_pairs(self, user_date_pairs: list) -> list:
        """
        Na podstawie listy par (user_id, date_str) odnajduje i zwraca
        pełne dane komórek z modelu grafiku.
        """
        if not self.schedule_model or not user_date_pairs:
            return []

        cells_data_to_return = []
        user_row_map = {str(key[3]): idx for idx, key in enumerate(self.schedule_model._keys)}

        for user_id, date_str in user_date_pairs:
            row = user_row_map.get(str(user_id))
            if row is not None:
                try:
                    day = int(date_str.split('-')[2])
                    col_offset = len(self.schedule_model.get_visible_columns())
                    col = col_offset + day - 1

                    index = self.schedule_model.index(row, col)

                    # --- ZMIANA: Poprawne odwołanie do ROLE_DATA ---
                    cell_data = self.schedule_model.data(index, ROLE_DATA)

                    if isinstance(cell_data, dict):
                        cells_data_to_return.append(cell_data)
                except (ValueError, IndexError) as e:
                    log_warning(f"Nie udało się znaleźć danych dla komórki ({user_id}, {date_str}): {e}")

        return cells_data_to_return

    def cancel_delegations(self):
        """
        POPRAWIONA WERSJA: Odwołuje delegacje z pełnym odświeżaniem ikon i tabeli zdarzeń
        """
        debug_print("\n=== ROZPOCZYNAM OPERACJĘ ODWOŁYWANIA DELEGACJI ===")

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Brak danych",
                "Nie wybrano miesiąca lub brak dostępnych danych do wyświetlenia.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone komórki
        selected_cells_data = self.get_selected_cells_data()

        if not self._can_modify_cells(selected_cells_data):
            return  # Zatrzymaj operację, jeśli użytkownik nie ma uprawnień

        if not selected_cells_data:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono żadnych komórek. Zaznacz komórki, dla których chcesz odwołać delegacje.",
                QMessageBox.Ok
            )
            return

        # Zbierz pary (user_id, date_str) z zaznaczonych komórek
        user_date_pairs = []
        for cell_data in selected_cells_data:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if user_id and date_str:
                user_date_pairs.append((user_id, date_str))

        if not user_date_pairs:
            QMessageBox.information(
                self,
                "Brak danych",
                "Nie znaleziono danych dla zaznaczonych komórek.",
                QMessageBox.Ok
            )
            return

        debug_print(f"Sprawdzam delegacje dla {len(user_date_pairs)} par (użytkownik, data)")

        # Znajdź delegacje do odwołania
        events_to_cancel = []
        grouped_events = {}

        for user_id, date_str in user_date_pairs:
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

            for event in user_events:
                event_type = event.get('type', '')
                event_id = event.get('id')
                event_status = event.get('status')

                if not event_type or event_id is None:
                    continue

                if event_status is not None:
                    event_status = str(event_status)

                if event_type in ['Spotkanie', 'Szkolenie', 'Nadgodziny'] and event_status != '0':
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('user_name', ''),
                    })

                    key = (user_id, date_str)
                    if key not in grouped_events:
                        grouped_events[key] = []
                    grouped_events[key].append(event)

        debug_print(f"Znaleziono {len(events_to_cancel)} delegacji do odwołania")

        if not events_to_cancel:
            QMessageBox.information(
                self,
                "Brak delegacji",
                "Nie znaleziono delegacji do odwołania dla zaznaczonych komórek.",
                QMessageBox.Ok
            )
            return

        # Pokaż potwierdzenie
        delegations_info = self._prepare_delegations_description(grouped_events)
        confirm_message = f"Czy na pewno chcesz odwołać następujące delegacje?\n\n{delegations_info}\n"
        confirm_message += f"Łącznie: {len(events_to_cancel)} delegacji dla {len(user_date_pairs)} komórek"

        reply = QMessageBox.question(
            self,
            "Potwierdzenie odwołania delegacji",
            confirm_message,
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply != QMessageBox.Yes:
            debug_print("=== OPERACJA ANULOWANA PRZEZ UŻYTKOWNIKA ===")
            return

        try:
            # Odwołaj delegacje w bazie danych
            canceled_count = self._cancel_delegations(events_to_cancel)

            if canceled_count > 0:
                # KLUCZOWA ZMIANA 1: Usuń zdarzenia z lokalnych danych
                affected_pairs = []
                for event in events_to_cancel:
                    user_id = event.get('user_id')
                    date_str = event.get('date_key', event.get('date'))
                    if user_id and date_str:
                        affected_pairs.append((user_id, date_str))

                    # Usuń z events_data (tabela zdarzeń)
                    if hasattr(self, 'events_data'):
                        self.events_data = [e for e in self.events_data
                                            if not (e.get('id') == event.get('id') and
                                                    e.get('type') == event.get('type'))]

                    # Usuń z all_events_data
                    if hasattr(self, 'all_events_data'):
                        self.all_events_data = [e for e in self.all_events_data
                                                if not (e.get('id') == event.get('id') and
                                                        e.get('type') == event.get('type'))]

                # KLUCZOWA ZMIANA 2: Odśwież model zdarzeń
                if hasattr(self, 'events_model') and hasattr(self, 'events_data'):
                    self.events_model.update_data(self.events_data)
                    debug_print(f"Zaktualizowano model zdarzeń - pozostało {len(self.events_data)} zdarzeń")

                # KLUCZOWA ZMIANA 3: Wyczyść cache i odśwież ikony
                affected_pairs = list(set(affected_pairs))  # Usuń duplikaty

                # Wyczyść cache zdarzeń w DataProvider
                self.data_provider.invalidate_icons_cache(year, month)

                # Odśwież konkretne ikony
                self.data_provider.invalidate_specific_icons(affected_pairs)
                debug_print(f"Odświeżono ikony dla {len(affected_pairs)} zmienionych komórek")

                # KLUCZOWA ZMIANA 4: Odśwież model grafiku dla zmienionych komórek
                if hasattr(self, 'schedule_model'):
                    for user_id, date_str in affected_pairs:
                        # Aktualizuj wskaźniki zdarzeń w modelu
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', False)
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', False)
                        self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', False)

                # KLUCZOWA ZMIANA 5: Wymuś odświeżenie widoków
                if hasattr(self, 'table'):
                    if hasattr(self.table, 'schedule_view'):
                        self.table.schedule_view.viewport().update()
                    if hasattr(self.table, 'employees_view'):
                        self.table.employees_view.viewport().update()

                if hasattr(self, 'events_table'):
                    self.events_table.viewport().update()

                # KLUCZOWA ZMIANA 6: Kompleksowe odświeżenie po odwołaniu delegacji
                # 1. Kompletne czyszczenie cache
                if hasattr(self.data_provider, 'invalidate_complete_cache_for_pairs'):
                    self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)

                # 2. Aktualizuj ikony w modelu grafiku
                if hasattr(self, 'schedule_model'):
                    for user_id, date_str in affected_pairs:
                        # Sprawdź pozostałe zdarzenia w lokalnych danych
                        remaining_events = [e for e in self.events_data
                                            if e.get('user_id') == user_id and e.get('date_key') == date_str]

                        # Oblicz ikony na podstawie pozostałych zdarzeń
                        has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                        has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                        has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)

                        # Aktualizuj ikony w modelu
                        self.schedule_model.update_cell_icons_directly(
                            user_id, date_str, has_meetings, has_trainings, has_overtime
                        )

                # 3. Odśwież tabelę zdarzeń dla zaznaczonych komórek
                selected_cells = self.table.get_data_for_selected_cells()
                if selected_cells:
                    self.on_selection_changed()
                else:
                    self.events_data = []
                    if hasattr(self, 'events_model'):
                        self.events_model.update_data([])

                QMessageBox.information(
                    self,
                    "Sukces",
                    f"Pomyślnie odwołano {canceled_count} delegacji z {len(events_to_cancel)} znalezionych.",
                    QMessageBox.Ok
                )

                debug_print(f"=== ZAKOŃCZONO POMYŚLNIE - ODWOŁANO {canceled_count} DELEGACJI ===")
            else:
                QMessageBox.warning(
                    self,
                    "Brak zmian",
                    "Nie udało się odwołać żadnej delegacji. Sprawdź logi aplikacji.",
                    QMessageBox.Ok
                )


        except Exception as e:

            log_error(f"Błąd podczas odwoływania delegacji: {e}")

            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas odwoływania delegacji: {str(e)}", QMessageBox.Ok)

    def delete_events_for_cells(self, cells_data: list):
        """
        Wyszukuje wszystkie zdarzenia dla podanych komórek, prosi o potwierdzenie
        i odwołuje je. Zwraca True, jeśli użytkownik potwierdził usunięcie.
        """
        if not cells_data:
            return False

        # Zbierz unikalne pary (użytkownik, data) z zaznaczonych komórek
        user_date_pairs = set()
        for cell_data in cells_data:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if user_id and date_str:
                user_date_pairs.add((user_id, date_str))

        # Znajdź wszystkie zdarzenia do odwołania dla tych par
        events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        if not events_to_cancel:
            # Jeśli nie ma zdarzeń do usunięcia, nic więcej nie rób
            return False

        # Przygotuj i pokaż okno dialogowe z potwierdzeniem
        grouped_events = self._group_events_by_user_date(events_to_cancel)
        delegations_info = self._prepare_delegations_description(grouped_events)

        reply = QMessageBox.question(
            self,
            "Potwierdzenie usunięcia zdarzeń",
            f"Wstawienie tego symbolu wymaga odwołania istniejących zdarzeń (spotkań, nadgodzin itp.).\n\n{delegations_info}\nCzy chcesz kontynuować?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply == QMessageBox.Yes:
            # Jeśli użytkownik się zgodzi, odwołaj delegacje
            self._cancel_delegations(events_to_cancel)
            return True
        else:
            # Jeśli użytkownik anuluje, zwróć informację o tym
            self.statusBar().showMessage("Operacja anulowana przez użytkownika.", 3000)
            return False

    def get_data_from_model(self, row, col):
        """
        Pobiera dane z komórki modelu na podstawie wierszy i kolumn.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny

        Returns:
            dict: Dane komórki lub pusty słownik
        """
        if not hasattr(self, 'schedule_model'):
            return {}

        # Pobierz dane z modelu
        index = self.schedule_model.index(row, col)
        cell_data = self.schedule_model.data(index, Qt.UserRole)

        # Upewnij się, że dane są słownikiem
        if not isinstance(cell_data, dict):
            return {}

        return cell_data

    def get_selected_cells_data(self):
        """
        Pobiera dane dla zaznaczonych komórek z modelu.

        Returns:
            list: Lista danych zaznaczonych komórek
        """
        if not hasattr(self, 'table') or not self.table:
            return []

        # Deleguj do metody w SplitTableView, która już obsługuje model
        return self.table.get_data_for_selected_cells()

    def update_model_after_data_change(self, user_id, date_str):
        """
        Aktualizuje dane w modelu po zmianach w bazie danych.

        Args:
            user_id: ID użytkownika
            date_str: Data w formacie YYYY-MM-DD
        """
        if not user_id or not date_str:
            return

        # Pobierz rok i miesiąc z daty
        if date_str.count('-') != 2:
            return

        year, month, _ = date_str.split('-')
        try:
            year = int(year)
            month = int(month)
        except ValueError:
            return

        # Pobierz aktualne dane z DataProvider - wymuś odświeżenie cache
        self.data_provider.clear_cache()
        schedule_data = self.data_provider.get_schedule_data(year, month, use_cache=False)

        # Aktualizuj model
        if schedule_data and hasattr(self, 'schedule_model'):
            # Aktualizuj model bezpośrednio
            self.schedule_model.update_data(schedule_data, year, month)

            # Zaktualizuj przefiltrowane dane
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

            # Odśwież widok
            if hasattr(self, 'table'):
                self.table.update()

    def setup_model_connections(self):
        """
        Łączy sygnały modeli z obsługą interfejsu użytkownika.
        """
        # Połącz zmiany w modelach z aktualizacją interfejsu
        if hasattr(self, 'schedule_model'):
            self.schedule_model.dataChanged.connect(self.on_schedule_data_changed)

        if hasattr(self, 'events_model'):
            self.events_model.dataChanged.connect(self.on_events_data_changed)

    def on_schedule_data_changed(self, topLeft, bottomRight):
        """
        Obsługuje zmianę danych w modelu grafiku.

        Args:
            topLeft: Indeks górnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Odśwież widok
        if hasattr(self, 'table'):
            self.table.update()

        # Jeśli zmieniło się zaznaczenie, zaktualizuj tabelę zdarzeń
        if self.table.selection_changed.receivers() > 0:
            selected_rows = self.table.get_selected_rows()
            if selected_rows:
                self.on_selection_changed()

    def on_events_data_changed(self, topLeft, bottomRight):
        """
        Obsługuje zmianę danych w modelu zdarzeń.

        Args:
            topLeft: Indeks górnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Odśwież tabelę zdarzeń
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()



    def get_selected_schedule_cells(self):
        """Zwraca listę zaznaczonych komórek z siatki grafiku"""
        selected_cells = []
        selected_ranges = self.table.selectedRanges()

        for range_item in selected_ranges:
            for row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawdź czy to komórka z grafikiem
                    if col >= 3:
                        # Pobierz element tabeli
                        cell_item = self.table.item(row, col)
                        if not cell_item:
                            continue

                        # Pobierz dane z komórki
                        cell_data = self.get_cell_data(cell_item)
                        if not cell_data:
                            continue

                        # Dodaj dane do listy wybranych komórek
                        selected_cells.append(cell_data)

        return selected_cells

    def group_cells_by_user_and_day(self, cells):
        """Grupuje komórki według użytkownika i dnia dla łatwiejszej edycji"""
        grouped = {}
        for cell in cells:
            # ZMIANA: Dostosuj do nowej struktury danych z modelu
            user_id = cell.get('uzytkownik_id')  # Zmieniono z 'user_id'
            date_str = cell.get('date_str')  # Zmieniono z 'date'

            if not user_id or not date_str:
                continue

            if user_id not in grouped:
                grouped[user_id] = {}

            if date_str not in grouped[user_id]:
                grouped[user_id][date_str] = []

            grouped[user_id][date_str].append(cell)

        return grouped

    def delete_event(self, event_id, event_type):
        """Wersja z weryfikacją uprawnień przed usunięciem."""
        # Krok 1: Znajdź komórki, których dotyczy zmiana
        affected_pairs = []
        event_to_delete = None
        # Przeszukujemy dane zdarzeń (te aktualnie wyświetlane w tabeli)
        for event in (self.events_data or []):
            if event.get('id') == event_id and event.get('type') == event_type:
                user_id = event.get('user_id')
                date_key = event.get('date_key')
                if user_id and date_key:
                    affected_pairs.append((user_id, date_key))
                    event_to_delete = event
                    break  # Zakładamy unikalne ID, więc możemy przerwać

        if not event_to_delete:
            QMessageBox.warning(self, "Błąd", "Nie można odnaleźć zdarzenia do usunięcia.")
            return

        # Krok 2: Pobierz pełne dane komórek i przeprowadź walidację uprawnień
        cells_to_check = self._get_cell_data_for_user_date_pairs(affected_pairs)
        if not self._can_modify_cells(cells_to_check):
            return  # Zatrzymaj, jeśli brak uprawnień

        # Krok 3: Poproś o potwierdzenie (jeśli walidacja przeszła pomyślnie)
        reply = QMessageBox.question(
            self, "Potwierdzenie",
            f"Czy na pewno chcesz usunąć {event_type.lower()} o ID {event_id}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.Yes
        )

        if reply != QMessageBox.StandardButton.Yes:
            return

        # Krok 4: Wykonaj operację usunięcia (istniejąca logika)
        try:
            _, user_app_id, _, _, _ = get_modifier_id()
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            table_name = ""
            if event_type == "Spotkanie":
                table_name = SQL_OBJECTS['spotkania']
            elif event_type == "Szkolenie":
                table_name = SQL_OBJECTS['szkolenia']
            elif event_type == "Nadgodziny":
                table_name = SQL_OBJECTS['nadgodziny']
            else:
                return

            if event_type in ["Spotkanie", "Szkolenie"]:
                query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                cursor.execute(query, (user_app_id, event_id))
            else:
                query = f"DELETE FROM {table_name} WHERE Id = ?"
                cursor.execute(query, (event_id,))

            conn.commit()
            conn.close()
            self._update_modification_date()

            self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)

            if hasattr(self, 'schedule_model'):
                for user_id, date_str in affected_pairs:
                    remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                    has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                    has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                    has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)
                    self.schedule_model.update_cell_icons_directly(
                        user_id, date_str, has_meetings, has_trainings, has_overtime
                    )
            self.statusBar().showMessage(f"Usunięto zdarzenie o ID {event_id}.", 3000)

            self.on_selection_changed()

        except Exception as e:
            log_error(f"Błąd podczas usuwania zdarzenia: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas usuwania zdarzenia: {str(e)}",
                                 QMessageBox.StandardButton.Ok)

    # def show_add_overtime_dialog(self):
    #     """
    #     Pokazuje okno dialogowe do dodawania nadgodzin.
    #     POPRAWIONA WERSJA - bez duplikacji zdarzeń i z prawidłowym ustawianiem ikon.
    #     """
    #     # Pobierz bieżącą datę z tabeli grafiku
    #     current_data = self.date_combo.currentData()
    #     if not current_data:
    #         QMessageBox.warning(
    #             self,
    #             "Błąd",
    #             "Nie wybrano miesiąca. Nie można dodać nadgodzin.",
    #             QMessageBox.Ok
    #         )
    #         return
    #
    #     year, month = current_data
    #
    #     # Pobierz zaznaczone komórki z modelu
    #     selected_cells_data = self.table.get_data_for_selected_cells()
    #
    #     if not self._can_modify_cells(selected_cells_data):
    #         return
    #
    #     # Sprawdź liczbę zaznaczonych komórek
    #     if not selected_cells_data:
    #         QMessageBox.warning(
    #             self,
    #             "Brak zaznaczenia",
    #             "Nie zaznaczono żadnej komórki. Zaznacz dokładnie jedną komórkę, aby dodać nadgodziny.",
    #             QMessageBox.Ok
    #         )
    #         return
    #
    #     # Jeśli zaznaczono więcej niż jedną komórkę, wyświetl komunikat i zakończ
    #     if len(selected_cells_data) > 1:
    #         QMessageBox.warning(
    #             self,
    #             "Zbyt wiele zaznaczonych komórek",
    #             "Zaznaczono zbyt wiele komórek. Zaznacz dokładnie jedną komórkę, aby dodać nadgodziny.",
    #             QMessageBox.Ok
    #         )
    #         return
    #
    #     # Pobierz dane pierwszej (i jedynej) zaznaczonej komórki
    #     cell_data = selected_cells_data[0]
    #
    #     # Pobierz podstawowe informacje o komórce
    #     selected_user_id = cell_data.get('uzytkownik_id')
    #     selected_user_name = cell_data.get('uzytkownik_dane')
    #     day = cell_data.get('day')
    #     date_str = cell_data.get('date_str')
    #     nr_kadrowy = cell_data.get('nr_kadrowy')
    #     start_hour = cell_data.get('start_hour')
    #     current_symbol = cell_data.get('symbol', '')
    #
    #     # NOWE: Pobierz lokalizację domyślną z danych użytkownika
    #     lokalizacja_domyslna = cell_data.get('lokalizacja_domyslna', 'h')
    #
    #     if not selected_user_id or not day or not date_str:
    #         QMessageBox.warning(
    #             self,
    #             "Błąd",
    #             "Brak wymaganych danych w zaznaczonej komórce.",
    #             QMessageBox.Ok
    #         )
    #         return
    #
    #     # Utwórz datę QDate
    #     selected_date = QDate.fromString(date_str, "yyyy-MM-dd")
    #
    #     # Flaga określająca, czy to dzień wolny (brak danych lub pusty symbol)
    #     is_day_off = not current_symbol or current_symbol.strip() == ''
    #
    #     # Jeśli nr_kadrowy jest None, spróbuj znaleźć go w danych użytkownika
    #     if nr_kadrowy is None and selected_user_id in self.user_info_map:
    #         nr_kadrowy = self.user_info_map[selected_user_id].get('nr_kadrowy')
    #
    #     # Ustaw domyślną godzinę rozpoczęcia
    #     if start_hour is None:
    #         start_hour = 9 if is_day_off else 8
    #
    #     # POPRAWIONE: Pobierz lokalizację z symbolu lub użyj domyślnej
    #     current_location = lokalizacja_domyslna  # Domyślna z danych użytkownika
    #
    #     if current_symbol and ';' in current_symbol:
    #         from symbol_parser import parse_symbol
    #         parsed_symbol = parse_symbol(current_symbol)
    #         if parsed_symbol['location']:
    #             current_location = parsed_symbol['location']
    #
    #     # Utwórz okno dialogowe
    #     dialog = QDialog(self)
    #
    #     # Nazwy miesięcy po polsku
    #     polish_months = [
    #         "stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca",
    #         "lipca", "sierpnia", "września", "października", "listopada", "grudnia"
    #     ]
    #
    #     month_name = polish_months[selected_date.month() - 1]
    #     dialog.setWindowTitle(f"Dodaj nadgodziny w dniu {selected_date.day()} {month_name} {selected_date.year()}")
    #     dialog.setMinimumWidth(300)
    #
    #     layout = QVBoxLayout(dialog)
    #
    #     # Informacja o pracowniku
    #     user_info_label = QLabel(f"Pracownik: {selected_user_name}")
    #     user_info_label.setStyleSheet("font-weight: bold; margin-bottom: 10px;")
    #     layout.addWidget(user_info_label)
    #
    #     # Informacja o numerze kadrowym
    #     if nr_kadrowy:
    #         kadrowy_info_label = QLabel(f"Numer kadrowy: {nr_kadrowy}")
    #         kadrowy_info_label.setStyleSheet("margin-bottom: 10px;")
    #         layout.addWidget(kadrowy_info_label)
    #
    #     # Informacja o miesiącu rozliczenia
    #     settlement_month = month
    #     settlement_year = year
    #     settlement_info = QLabel(f"Miesiąc rozliczenia: {settlement_month:02d}.{settlement_year}")
    #     settlement_info.setStyleSheet("margin-bottom: 10px;")
    #     layout.addWidget(settlement_info)
    #
    #     # Informacja o dniu wolnym (jeśli to dzień wolny)
    #     if is_day_off:
    #         day_off_info = QLabel("Zaznaczony dzień jest dniem wolnym pracownika.")
    #         day_off_info.setStyleSheet("color: blue; font-weight: bold; margin-bottom: 10px;")
    #         layout.addWidget(day_off_info)
    #
    #     # Formularz wprowadzania
    #     form_frame = QFrame()
    #     form_frame.setFrameShape(QFrame.StyledPanel)
    #     form_frame.setFrameShadow(QFrame.Raised)
    #     form_layout = QGridLayout(form_frame)
    #
    #     # Etykiety
    #     od_label = QLabel("od kiedy")
    #     ile_label = QLabel("ile godzin")
    #     typ_label = QLabel("typ")
    #     ld_label = QLabel("LD")
    #     zalegle_label = QLabel("czy zaległe")
    #
    #     # Kontrolki wprowadzania
    #     time_combo = QComboBox()
    #     time_combo.setMinimumWidth(60)
    #
    #     # Ustal domyślny czas
    #     if is_day_off:
    #         default_time = "09:00"  # Dla dnia wolnego
    #     else:
    #         # Oblicz koniec zmiany (godzina rozpoczęcia + 8 godzin)
    #         end_hour = (start_hour + 8) % 24
    #         default_time = f"{end_hour:02d}:00"
    #
    #     # Dodaj opcje czasu
    #     for hour in range(0, 24):
    #         for minute in [0, 30]:
    #             time_combo.addItem(f"{hour:02d}:{minute:02d}", f"{hour:02d}:{minute:02d}")
    #
    #     # Ustaw domyślny czas
    #     index = time_combo.findText(default_time)
    #     if index != -1:
    #         time_combo.setCurrentIndex(index)
    #     else:
    #         time_combo.setCurrentText(default_time)
    #
    #     # Combo z liczbą godzin do 13.0
    #     hours_combo = QComboBox()
    #     hours_combo.setMinimumWidth(50)
    #     for hours in [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5,
    #                   10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0]:
    #         hours_combo.addItem(f"{hours:.1f}", hours)
    #     hours_combo.setCurrentIndex(1)  # Domyślnie 1.0
    #
    #     # Typ: wypłata, odbiór, odpracowanie
    #     type_combo = QComboBox()
    #     type_combo.addItem("wypłata", "wypłata")
    #     type_combo.addItem("odbiór", "odbiór")
    #     type_combo.addItem("odpracowanie", "odpracowanie")
    #
    #     # LD (lokalizacja): h, p, s
    #     ld_combo = QComboBox()
    #     ld_combo.addItem("h", "h")  # Hybrydowa
    #     ld_combo.addItem("p", "p")  # Praca zdalna
    #     ld_combo.addItem("s", "s")  # Stacjonarna
    #
    #     # POPRAWIONE: Ustaw domyślną lokalizację na podstawie symbolu lub domyślnej użytkownika
    #     if current_location == 'h':
    #         ld_combo.setCurrentIndex(0)
    #     elif current_location == 'p':
    #         ld_combo.setCurrentIndex(1)
    #     elif current_location == 's':
    #         ld_combo.setCurrentIndex(2)
    #     else:
    #         ld_combo.setCurrentIndex(0)  # Domyślnie 'h'
    #
    #     # Czy zaległe
    #     overdue_combo = QComboBox()
    #     overdue_combo.addItem("nie", 0)
    #     overdue_combo.addItem("tak", 1)
    #
    #     # Przycisk dodawania
    #     add_button = QPushButton("Dodaj")
    #     add_button.setStyleSheet("background-color: #333; color: white; font-weight: bold;")
    #
    #     # Dodaj kontrolki do layoutu
    #     form_layout.addWidget(od_label, 0, 0)
    #     form_layout.addWidget(time_combo, 0, 1)
    #     form_layout.addWidget(ile_label, 0, 2)
    #     form_layout.addWidget(hours_combo, 0, 3)
    #     form_layout.addWidget(typ_label, 0, 4)
    #     form_layout.addWidget(type_combo, 0, 5)
    #     form_layout.addWidget(ld_label, 0, 6)
    #     form_layout.addWidget(ld_combo, 0, 7)
    #     form_layout.addWidget(zalegle_label, 0, 8)
    #     form_layout.addWidget(overdue_combo, 0, 9)
    #     form_layout.addWidget(add_button, 0, 10)
    #
    #     # Dodaj formularz do głównego layoutu
    #     layout.addWidget(form_frame)
    #
    #     def add_overtime():
    #         try:
    #             result = self.call_add_overtime_procedure_fixed(
    #                 selected_user_id, selected_date.year(), selected_date.month(),
    #                 selected_date.toString("yyyy-MM-dd"), time_combo.currentText(),
    #                 float(hours_combo.currentData()), f"{year}-{month:02d}-01",
    #                 overdue_combo.currentIndex(), type_combo.currentText(),
    #                 ld_combo.currentText(), nr_kadrowy
    #             )
    #
    #             if result["success"]:
    #                 # ZMIANA: Usunięto okno z informacją o sukcesie
    #                 # QMessageBox.information(dialog, "Sukces", result["message"], QMessageBox.Ok)
    #                 self.statusBar().showMessage("Pomyślnie dodano nadgodziny.", 3000)
    #                 dialog.accept()
    #             else:
    #                 QMessageBox.warning(dialog, "Błąd", result["message"], QMessageBox.Ok)
    #
    #         except Exception as e:
    #             QMessageBox.critical(dialog, "Błąd", f"Wystąpił błąd: {str(e)}", QMessageBox.Ok)
    #
    #     # Podłącz funkcję do przycisku
    #     add_button.clicked.connect(add_overtime)
    #
    #     # Pokaż dialog
    #     dialog.exec()

    def _update_multiple_overtime_locations(self, location_changes):
        """
        Aktualizuje lokalizację dla wielu wpisów nadgodzin, każdy z inną wartością.
        WERSJA POPRAWIONA: Aktualizuje również nazwę zdarzenia w interfejsie.
        """
        if not location_changes:
            return True  # Brak zmian do wykonania to nie błąd

        location_map = {'h': 1, 's': 3, 'p': 2}

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            for event_id, new_location_code in location_changes:
                location_value = location_map.get(new_location_code)
                if location_value is None:
                    log_warning(
                        f"Pominięto aktualizację nadgodzin dla ID {event_id} z powodu nieznanego kodu lokalizacji: {new_location_code}")
                    continue

                query = f"UPDATE {SQL_OBJECTS['nadgodziny']} SET Lokalizacja = ? WHERE Id = ?"
                params = (location_value, event_id)
                debug_print(f"Aktualizuję lokalizację nadgodzin: ID={event_id}, nowa lokalizacja={location_value}")
                cursor.execute(query, params)

            conn.commit()
            conn.close()

            # --- NOWA LOGIKA: Aktualizacja nazwy w modelu danych po pomyślnym zapisie w bazie ---

            # Mapa kodów na pełne nazwy do wyświetlenia
            location_display_map = {'h': 'Home Office', 's': 'SBC', 'p': 'Przystanek'}

            # Stwórz słownik zmian dla szybszego wyszukiwania
            changes_map = dict(location_changes)

            # Zaktualizuj główną listę wszystkich zdarzeń
            for event in self.all_events_data:
                if event.get('id') in changes_map and event.get('type') == 'Nadgodziny':
                    new_loc_code = changes_map[event['id']]
                    new_loc_name = location_display_map.get(new_loc_code, 'N/A')
                    event['name'] = f"Nadgodziny {new_loc_name}"

            # Zaktualizuj listę zdarzeń aktualnie widoczną w tabeli
            for event in self.events_data:
                if event.get('id') in changes_map and event.get('type') == 'Nadgodziny':
                    new_loc_code = changes_map[event['id']]
                    new_loc_name = location_display_map.get(new_loc_code, 'N/A')
                    event['name'] = f"Nadgodziny {new_loc_name}"

            # Odśwież model tabeli zdarzeń, aby UI pokazał zmiany
            if hasattr(self, 'events_model'):
                self.events_model.update_data(self.events_data)

            debug_print(f"Zaktualizowano {len(location_changes)} wpisów nadgodzin w interfejsie.")
            # --- KONIEC NOWEJ LOGIKI ---

            return True

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji wielu lokalizacji nadgodzin: {e}", exception=e)
            QMessageBox.critical(self, "Błąd Bazy Danych", f"Nie udało się zaktualizować lokalizacji nadgodzin:\n{e}")
            return False

    def _update_overtime_icon_single(self, user_id, date_str, year, month):
        """
        NOWA METODA: Aktualizuje ikonę nadgodzin bez wpływania na cache innych danych.
        """
        try:
            # 1. Aktualizuj bezpośrednio w modelu grafiku
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonę nadgodzin w modelu dla ({user_id}, {date_str})")

            # 2. Wyczyść tylko cache ikon dla tej konkretnej komórki w DataProvider
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla komórki ({user_id}, {date_str})")

            # 3. Odśwież widok grafiku
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji ikony nadgodzin: {e}")

    def connect_model_signals(self):
        """Podłącz sygnały modelu - DODAJ TO DO METODY setup_ui lub __init__"""
        if hasattr(self, 'data_provider'):
            self.data_provider.data_changed.connect(self.on_data_changed)

            # NOWE: Podłącz sygnał odświeżania konkretnych ikon
            if hasattr(self.data_provider, 'data_changed'):
                self.data_provider.data_changed.connect(self._handle_specific_icons_refresh)

    def _handle_specific_icons_refresh(self, data_type, year, month):
        """NOWA METODA: Obsługuje sygnał odświeżenia konkretnych ikon"""
        if data_type == "icons" and hasattr(self, 'schedule_model') and self.schedule_model:
            # Model sam odświeży ikony przy następnym dostępie - nie rób nic więcej
            debug_print(f"Otrzymano sygnał odświeżenia ikon dla {year}-{month}")

    def call_add_overtime_procedure_fixed(self, user_id, year, month, date_str, start_time, hours,
                                          settlement_date, is_overdue, overtime_type, location,
                                          nr_kadrowy):
        """
        Dodaje nadgodziny i zapewnia natychmiastową, niezawodną aktualizację
        tabeli zdarzeń oraz ikony w grafiku.
        """
        try:
            # Krok 1: Dodanie rekordu do bazy danych
            location_map = {'h': 1, 'p': 2, 's': 3}
            location_value = location_map.get(location, 1)
            param_value = 1 if overtime_type == 'odpracowanie' else None
            odebrane_value = 1 if overtime_type == 'odbiór' else 0

            from datetime import datetime, timedelta
            start_datetime = datetime.strptime(f"{date_str} {start_time}", "%Y-%m-%d %H:%M")
            end_datetime = start_datetime + timedelta(hours=float(hours))
            end_time = end_datetime.strftime("%H:%M")

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            params = [
                nr_kadrowy, year, month, date_str, start_datetime, end_datetime,
                settlement_date, is_overdue, odebrane_value, location_value,
                param_value
            ]
            sql = f"{{CALL {SQL_OBJECTS['p_nadgodzinywstawienie']} ({', '.join(['?'] * len(params))})}}"
            cursor.execute(sql, params)
            conn.commit()
            conn.close()

            # Krok 2: Rejestracja własnej zmiany i unieważnienie cache
            self._update_modification_date()
            self.data_provider.invalidate_complete_cache_for_pairs([(user_id, date_str)])

            # --- NOWA, KLUCZOWA LOGIKA (skopiowana z `delete_event`) ---
            # Krok 3: Bezpośrednia aktualizacja ikony w modelu
            if hasattr(self, 'schedule_model'):
                # Sprawdzamy, jakie zdarzenia istnieją dla komórki PO dodaniu nowego
                remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)

                # Bezpośrednio aktualizujemy stan ikon w modelu
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_meetings, has_trainings, has_overtime
                )

            # Krok 4: Odświeżenie dolnej tabeli zdarzeń
            self.on_selection_changed()

            # Zwracamy sukces
            return {
                "success": True,
                "message": "Nadgodziny zostały pomyślnie dodane."
            }

        except Exception as e:
            log_error(f"Błąd podczas dodawania nadgodzin: {e}", exception=e)
            return {
                "success": False,
                "message": f"Wystąpił błąd podczas dodawania nadgodzin: {str(e)}"
            }

    def _refresh_data_after_overtime_addition(self, new_id, user_id, date_str, year, month):
        """
        NOWA METODA: Odświeża dane z bazy po dodaniu nadgodzin
        """
        try:
            debug_print(f"Odświeżam dane po dodaniu nadgodzin ID={new_id}")

            # Upewnij się, że column_mapper jest dostępny
            if not hasattr(self, 'column_mapper'):
                from column_mapper import ColumnMapper
                self.column_mapper = ColumnMapper()

            # 1. POBIERZ NOWE ZDARZENIE Z BAZY DANYCH
            new_event = self._fetch_specific_event_from_db(year, month, new_id, 'Nadgodziny')

            if not new_event:
                log_error(f"Nie znaleziono dodanych nadgodzin o ID {new_id} w bazie danych")
                return

            debug_print(f"Pobrano nowe zdarzenie z bazy: {new_event}")

            # 2. AKTUALIZUJ CACHE DATAPROVIDER
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]

                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data")

                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []

                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in
                           container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache")

                # Aktualizuj processed_data - ustaw ikonę nadgodzin
                try:
                    day = int(date_str.split('-')[2])
                    for key, user_data in container.processed_data.items():
                        if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonę nadgodzin w processed_data")
                            break
                except Exception as e:
                    log_error(f"Błąd aktualizacji processed_data: {e}")

            # 3. AKTUALIZUJ LOKALNE DANE
            # Konwertuj na lokalny format
            local_event = self._convert_dp_event_to_local(new_event)

            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(local_event)
                    debug_print(f"Dodano nadgodziny do all_events_data")

            # 4. AKTUALIZUJ events_data TYLKO JEŚLI KOMÓRKA JEST ZAZNACZONA
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )

                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(local_event)
                        debug_print(f"Dodano nadgodziny do events_data")

                        # Aktualizuj model zdarzeń
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # 5. AKTUALIZUJ MODEL GRAFIKU
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_overtime=True
                )
                debug_print(f"Zaktualizowano ikony w schedule_model")

            # 6. WYCZYŚĆ CACHE IKON
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon")

            # 7. ODŚWIEŻ WIDOKI
            if hasattr(self, 'table'):
                if hasattr(self.table, 'schedule_view'):
                    self.table.schedule_view.viewport().update()

            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

            debug_print(f"=== ODŚWIEŻENIE DANYCH ZAKOŃCZONE ===")

        except Exception as e:
            log_error(f"Błąd podczas odświeżania danych: {e}")
            import traceback
            traceback.print_exc()

    # def _fetch_specific_event_from_db(self, year, month, event_id, event_type):
    #     """
    #     NOWA METODA: Pobiera konkretne zdarzenie z bazy danych
    #     """
    #     try:
    #         # Zapytanie do pobrania konkretnego zdarzenia
    #         query = """
    #         SELECT * FROM {SQL_OBJECTS['fn_geteventsdata']}(?, ?) 
    #         WHERE EventType = ? AND ID = ?
    #         """
    # 
    #         conn = DatabaseConnector.get_connection()
    #         cursor = conn.cursor()
    #         cursor.execute(query, (year, month, event_type, event_id))
    #         result = cursor.fetchone()
    #         conn.close()
    # 
    #         if not result:
    #             return None
    # 
    #         # Konwertuj na format DataProvider używając column_mapper
    #         event_dict = self.column_mapper.map_events_row_to_dict(result)
    # 
    #         # Dodaj pola wymagane przez DataProvider
    #         if 'event_type' in event_dict:
    #             event_dict['type'] = event_dict['event_type']
    #         if 'event_id' in event_dict:
    #             event_dict['id'] = event_dict['event_id']
    # 
    #         # Formatuj daty
    #         raw_date = event_dict.get('date', '')
    #         if hasattr(raw_date, 'strftime'):
    #             event_dict['date_display'] = raw_date.strftime('%d.%m.%Y')
    #             event_dict['date_key'] = raw_date.strftime('%Y-%m-%d')
    #         elif isinstance(raw_date, str) and raw_date:
    #             event_dict['date_display'] = self.data_provider._format_date_display(raw_date)
    #             event_dict['date_key'] = self.data_provider._standardize_date(raw_date)
    # 
    #         # Formatuj czasy
    #         time_from = event_dict.get('time_from')
    #         time_to = event_dict.get('time_to')
    # 
    #         if hasattr(time_from, 'strftime'):
    #             event_dict['time_from'] = time_from.strftime('%H:%M')
    #         elif isinstance(time_from, str) and 'T' in time_from:
    #             event_dict['time_from'] = time_from.split(' ')[1][:5]
    # 
    #         if hasattr(time_to, 'strftime'):
    #             event_dict['time_to'] = time_to.strftime('%H:%M')
    #         elif isinstance(time_to, str) and 'T' in time_to:
    #             event_dict['time_to'] = time_to.split(' ')[1][:5]
    # 
    #         debug_print(f"Skonwertowano zdarzenie z bazy: {event_dict}")
    #         return event_dict
    # 
    #     except Exception as e:
    #         log_error(f"Błąd podczas pobierania zdarzenia z bazy: {e}")
    #         return None

    def _add_event_to_data_provider(self, new_id, user_id, user_name, date_str, start_time,
                                    end_time, overtime_type, is_overdue, year, month):
        """
        NOWA METODA: Dodaje zdarzenie bezpośrednio do DataProvider i wszystkich cache'y
        """
        try:
            # Utwórz obiekt zdarzenia w formacie DataProvider
            display_date = ".".join(reversed(date_str.split("-")))

            # Status na podstawie typu i flagi zaległości
            if overtime_type == 'wypłata':
                status = "Wypłata - zaległe" if is_overdue else "Wypłata"
            elif overtime_type == 'odbiór':
                status = "Odbiór"
            elif overtime_type == 'odpracowanie':
                status = "Odpracowanie"
            else:
                status = "Aktywne"

            # Utwórz zdarzenie w formacie zgodnym z DataProvider
            new_event_dp_format = {
                'event_type': 'Nadgodziny',
                'event_id': new_id,
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'date': date_str,  # DataProvider oczekuje YYYY-MM-DD
                'time_from': f"1900-01-01 {start_time}:00",  # Format z bazy
                'time_to': f"1900-01-01 {end_time}:00",
                'status': 'Wstawione',  # Status w formacie bazy
                'type': 'Nadgodziny',
                'id': new_id,
                'date_display': display_date,
                'date_key': date_str
            }

            # Utwórz zdarzenie w formacie lokalnym
            new_event_local_format = {
                'type': 'Nadgodziny',
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'user_name': user_name,
                'date': display_date,
                'date_key': date_str,
                'time_from': start_time,
                'time_to': end_time,
                'status': status,
                'id': new_id
            }

            # KLUCZOWA ZMIANA 1: Dodaj do cache DataProvider
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]

                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data (ID: {new_id})")

                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []

                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in
                           container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache (ID: {new_id})")

                # Aktualizuj processed_data - dodaj ikonę nadgodzin
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        try:
                            day = int(date_str.split('-')[2])
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonę nadgodzin w processed_data dla {user_id}, dzień {day}")
                            break
                        except:
                            pass

            # KLUCZOWA ZMIANA 2: Dodaj do lokalnych danych
            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(new_event_local_format)
                    debug_print(f"Dodano nadgodziny do all_events_data (ID: {new_id})")

            # KLUCZOWA ZMIANA 3: Dodaj do events_data tylko jeśli komórka jest zaznaczona
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )

                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(new_event_local_format)
                        debug_print(f"Dodano nadgodziny do events_data (ID: {new_id})")

                        # Aktualizuj model zdarzeń
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # KLUCZOWA ZMIANA 4: Aktualizuj ikonę w modelu
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonę nadgodzin w modelu dla ({user_id}, {date_str})")

            # KLUCZOWA ZMIANA 5: Wyczyść tylko cache ikon dla tej komórki (nie cały cache)
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla komórki ({user_id}, {date_str})")

            # Odśwież widok
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"Błąd podczas dodawania zdarzenia do DataProvider: {e}")

    def debug_check_event_in_index(self, event_id, event_type='Nadgodziny'):
        """
        Sprawdza, czy zdarzenie o podanym ID istnieje w indeksie zdarzeń
        i wyświetla informacje diagnostyczne.

        Args:
            event_id: ID zdarzenia
            event_type: Typ zdarzenia (domyślnie 'Nadgodziny')

        Returns:
            bool: True jeśli znaleziono zdarzenie, False w przeciwnym wypadku
        """
        debug_print(f"\n--- DIAGNOSTYKA INDEKSU ZDARZEŃ ---")
        debug_print(f"Szukam zdarzenia o ID {event_id} i typie {event_type}")

        # Sprawdź w indeksie zdarzeń DataProvider
        if hasattr(self.data_provider, 'events_index'):
            # Sprawdź bezpośrednio przez indeks ID
            event = self.data_provider.events_index.get_event_by_id(event_id)
            if event:
                debug_print(f"ZNALEZIONO w indeksie ID: {event}")
                return True

            # Alternatywnie, przeszukaj wszystkie zdarzenia
            found_in_all = False
            for e in self.data_provider.events_index.all_events:
                if e.get('id') == event_id and e.get('type') == event_type:
                    debug_print(f"ZNALEZIONO w all_events: {e}")
                    found_in_all = True

            # Przeszukaj indeks typów
            found_in_type_index = False
            type_events = self.data_provider.events_index.type_index.get(event_type, [])
            for e in type_events:
                if e.get('id') == event_id:
                    debug_print(f"ZNALEZIONO w type_index: {e}")
                    found_in_type_index = True

            if not found_in_all and not found_in_type_index:
                debug_print("NIE ZNALEZIONO w indeksie zdarzeń")
                return False

            return found_in_all or found_in_type_index
        else:
            debug_print("BRAK indeksu zdarzeń w data_provider")
            return False

    def update_cell_data(self, user_id, date_str, event_type=None, action="update"):
        """
        Aktualizuje dane komórki i ikony po różnych operacjach.
        Zoptymalizowana wersja wykorzystująca precyzyjne aktualizacje.

        Args:
            user_id: ID użytkownika
            date_str: Data w formacie 'YYYY-MM-DD'
            event_type: Typ zdarzenia (Spotkanie, Szkolenie, Nadgodziny lub None)
            action: Rodzaj operacji - "update", "add", "delete"

        Returns:
            bool: True jeśli operacja się powiodła, False w przeciwnym wypadku
        """
        if not user_id or not date_str:
            return False

        # Standardyzuj format daty
        date_str = self.data_provider._standardize_date(date_str)

        # Wyczyść cache dla miesiąca tej daty
        if date_str and date_str.count('-') == 2:
            year, month, _ = date_str.split('-')
            self.clear_events_cache(int(year), int(month))

        # Pobierz zdarzenia dla tej pary (użytkownik, data)
        events = self.data_provider.get_events_for_user_date(user_id, date_str)

        # Sprawdź typy zdarzeń
        has_meeting = any(
            e.get('type') == 'Spotkanie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_training = any(
            e.get('type') == 'Szkolenie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_overtime = any(e.get('type') == 'Nadgodziny' for e in events)

        # Aktualizuj wskaźniki w modelu - używając zoptymalizowanej metody
        if hasattr(self, 'schedule_model'):
            if event_type == 'Spotkanie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Szkolenie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Nadgodziny':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny',
                                                                  is_active=(action != "delete"))
            else:
                # Aktualizuj wszystkie wskaźniki
                result1 = self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', has_meeting)
                result2 = self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', has_training)
                result3 = self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', has_overtime)
                return result1 or result2 or result3

        return False

    def get_all_valid_symbols(self) -> set:
        """Zwraca zbiór wszystkich prawidłowych symboli specjalnych z załadowanej konfiguracji."""
        all_symbols = set()
        for category in app_settings.SYMBOL_CATEGORIES.values():
            all_symbols.update(category.keys())
        return all_symbols

    def apply_symbol_from_keyboard(self, special_symbol: str):
        """
        Aplikuje symbol z klawiatury, z obsugą błędów, usuwania zdarzeń
        oraz ujednoliconym, szczegółowym komunikatem potwierdzającym.
        """
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not selected_cells_data:
            self.statusBar().showMessage("Nie zaznaczono żadnych komórek do edycji.", 3000)
            return

        # Używamy pełnej listy, a nie tej przefiltrowanej po symbolach, do walidacji DTN
        if not self._can_modify_cells(selected_cells_data):
            return

        cells_to_modify = [cell for cell in selected_cells_data if
                           isinstance(cell, dict) and 'date_str' in cell and 'uzytkownik_id' in cell]

        if not cells_to_modify:
            self.statusBar().showMessage("Zaznaczone komórki są puste lub nie zawierają symboli do modyfikacji.", 3000)
            return

        # --- POCZĄTEK WERYFIKACJI DLA WYDZIAŁU DTN ---
        # Sprawdź, czy próba zapisu jest dozwolona dla DTN, zanim pokażesz jakiekolwiek okno
        cells_to_modify_final = []
        skipped_for_dtn = []
        for cell in cells_to_modify:
            target_dept = cell.get('wydzial', '').strip().lower()
            if self.current_user_role in ['Lider',
                                          'Lider OUT'] and target_dept == 'dtn' and special_symbol.upper() != 'CO':
                skipped_for_dtn.append(cell.get('uzytkownik_dane', 'Nieznany'))
            else:
                cells_to_modify_final.append(cell)

        if skipped_for_dtn:
            QMessageBox.warning(self, "Operacja zablokowana",
                                f"Dla wydziału DTN dozwolony jest tylko symbol 'CO'.\n"
                                f"Pominięto zmiany dla: {', '.join(set(skipped_for_dtn))}")

        if not cells_to_modify_final:
            return  # Zatrzymaj, jeśli po weryfikacji nie ma komórek do zmiany

        cells_to_modify = cells_to_modify_final
        # --- KONIEC WERYFIKACJI DLA WYDZIAŁU DTN ---

        events_to_cancel = []
        if special_symbol.upper() in app_settings.get_absence_symbols():
            user_date_pairs_for_events = {(c.get('uzytkownik_id'), c.get('date_str')) for c in cells_to_modify if
                                          c.get('uzytkownik_id') and c.get('date_str')}
            events_to_cancel = self._find_events_to_cancel(user_date_pairs_for_events)

        reply = QMessageBox.Yes
        if self._should_ask_for_confirmation():
            grouped_changes = self._group_cells_for_symbol_changes(cells_to_modify)
            changes_info = self._prepare_symbol_changes_description(grouped_changes, special_symbol)
            complete_info = f"Czy na pewno chcesz wprowadzić następujące zmiany?\n\n{changes_info}"
            if events_to_cancel:
                grouped_events = self._group_events_by_user_date(events_to_cancel)
                delegations_info = self._prepare_delegations_description(grouped_events)
                complete_info += f"\n{delegations_info}"
            reply = QMessageBox.question(self, "Potwierdzenie wstawienia symbolu", complete_info,
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

        if reply != QMessageBox.Yes:
            self.statusBar().showMessage("Operacja anulowana przez użytkownika.", 3000)
            return

        if events_to_cancel:
            self._cancel_delegations(events_to_cancel)

        updated_info, error_messages, skipped_employees = [], [], []

        for cell_data in cells_to_modify:
            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_edit_symbol']:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue

            new_symbol = self._predict_new_symbol(cell_data.get('symbol', ''), special_symbol, cell_data)
            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"Błąd: {cell_data.get('uzytkownik_dane')}: {result.get('message', 'Błąd zapisu.')}")
            except Exception as e:
                log_error(f"Błąd w apply_symbol_from_keyboard: {e}")
                error_messages.append(f"Błąd: {cell_data.get('uzytkownik_dane')}: Błąd aplikacji: {e}")

        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Zastosowano symbol '{special_symbol}' dla {len(updated_info)} komórek.",
                                         4000)
            self.schedule_model.layoutChanged.emit()

        # Zmieniono logikę wyświetlania wyników na bardziej spójną
        self._show_symbol_change_results(len(updated_info), len(error_messages), error_messages, events_to_cancel,
                                         skipped_employees)


    def apply_theme_settings(self, theme, font_family, font_size):
        """Stosuje wybrane ustawienia motywu z wykorzystaniem centralnych stylów"""
        # Zapamiętaj wybrane ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Zastosuj czcionkę do całej aplikacji
        font = QFont(font_family, font_size)
        QApplication.setFont(font)

        # Zastosuj główny styl dla całego okna aplikacji
        self.setStyleSheet(AppStyles.get_main_window_style(theme))

        # Definicje stylów
        button_style = AppStyles.get_button_style(theme)
        combo_style = AppStyles.get_combobox_style(theme)
        line_edit_style = AppStyles.get_line_edit_style(theme)
        list_style = AppStyles.get_list_style(theme)
        date_edit_style = AppStyles.get_date_edit_style(theme)
        checkbox_style = AppStyles.get_checkbox_style(theme)
        table_style = AppStyles.get_table_style(theme)
        left_panel_style = AppStyles.get_left_panel_style(theme)

        # Przyciski
        if hasattr(self, 'settings_button'): self.settings_button.setStyleSheet(button_style)
        if hasattr(self, 'refresh_button'): self.refresh_button.setStyleSheet(button_style)
        if hasattr(self, 'export_button'): self.export_button.setStyleSheet(button_style)
        if hasattr(self, 'toggle_menu_button'): self.toggle_menu_button.setStyleSheet(button_style)
        if hasattr(self, 'staffing_details_button'): self.staffing_details_button.setStyleSheet(button_style)
        if hasattr(self, 'show_audit_button'): self.show_audit_button.setStyleSheet(button_style)
        if hasattr(self, 'schedule_control_button'): self.schedule_control_button.setStyleSheet(button_style)
        if hasattr(self, 'clear_filters_button'): self.clear_filters_button.setStyleSheet(button_style)
        if hasattr(self, 'manage_columns_button'): self.manage_columns_button.setStyleSheet(button_style)
        if hasattr(self, 'toggle_events_panel_button'): self.toggle_events_panel_button.setStyleSheet(button_style)
        if hasattr(self, 'insert_change_button'): self.insert_change_button.setStyleSheet(button_style)
        if hasattr(self, 'insert_symbol_button'): self.insert_symbol_button.setStyleSheet(button_style)
        if hasattr(self, 'cancel_delegation_button'): self.cancel_delegation_button.setStyleSheet(button_style)
        if hasattr(self, 'add_overtime_button'): self.add_overtime_button.setStyleSheet(button_style)
        if hasattr(self, 'location_exception_button'): self.location_exception_button.setStyleSheet(button_style)

        # Pola wyboru (ComboBox)
        if hasattr(self, 'date_combo'): self.date_combo.setStyleSheet(combo_style)
        if hasattr(self, 'grupa_main_filter_combo'): self.grupa_main_filter_combo.setStyleSheet(combo_style)
        if hasattr(self, 'wydzial_combo'): self.wydzial_combo.setStyleSheet(combo_style)
        if hasattr(self, 'default_location_combo'): self.default_location_combo.setStyleSheet(combo_style)
        if hasattr(self, 'system_czasu_pracy_combo'): self.system_czasu_pracy_combo.setStyleSheet(combo_style)
        if hasattr(self, 'rola_combo'): self.rola_combo.setStyleSheet(combo_style)
        if hasattr(self, 'jezyk_combo'): self.jezyk_combo.setStyleSheet(combo_style)
        if hasattr(self, 'etat_combo'): self.etat_combo.setStyleSheet(combo_style)
        if hasattr(self, 'dtn_combo'): self.dtn_combo.setStyleSheet(combo_style)

        # Inne kontrolki
        if hasattr(self, '_left_panel'): self._left_panel.setStyleSheet(left_panel_style)
        if hasattr(self, 'przelozony_filter'): self.przelozony_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'topic_filter'): self.topic_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'name_filter'): self.name_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'przelozony_list'): self.przelozony_list.setStyleSheet(list_style)
        if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.setStyleSheet(list_style)
        if hasattr(self, 'date_from'): self.date_from.setStyleSheet(date_edit_style)
        if hasattr(self, 'date_to'): self.date_to.setStyleSheet(date_edit_style)
        if hasattr(self, 'meetings_checkbox'): self.meetings_checkbox.setStyleSheet(checkbox_style)
        if hasattr(self, 'trainings_checkbox'): self.trainings_checkbox.setStyleSheet(checkbox_style)
        if hasattr(self, 'overtime_checkbox'): self.overtime_checkbox.setStyleSheet(checkbox_style)
        # Zastosuj styl checkboxa do checkable QGroupBox oraz jego wewnętrznych kontrolek
        if hasattr(self, 'filter_by_presence_check'):
            self.filter_by_presence_check.setStyleSheet(checkbox_style)
        if hasattr(self, 'presence_date_edit'):
            self.presence_date_edit.setStyleSheet(date_edit_style)
        if hasattr(self, 'presence_location_combo'):
            self.presence_location_combo.setStyleSheet(combo_style)

            # Aktualizacja modeli i tabel
            if hasattr(self, '_left_panel'): self._left_panel.setStyleSheet(left_panel_style)
            if hasattr(self, 'schedule_model'): self.schedule_model.set_theme(self.is_dark_theme)
            if hasattr(self, 'events_model'): self.events_model.set_theme(self.is_dark_theme)
            if hasattr(self, 'table'):
                if hasattr(self.table, 'employees_view'): self.table.employees_view.setStyleSheet(table_style)
                if hasattr(self.table, 'schedule_view'): self.table.schedule_view.setStyleSheet(table_style)
            if hasattr(self, 'events_table'): self.events_table.setStyleSheet(table_style)

            if hasattr(self, '_left_panel'):
                title_style = AppStyles.get_label_style(theme, is_title=True)
                regular_label_style = AppStyles.get_label_style(theme, is_title=False)
                for label in self._left_panel.findChildren(QLabel):
                    if label.text() == "Filtry":
                        label.setStyleSheet(title_style)
                    else:
                        label.setStyleSheet(regular_label_style)

            if self.staffing_details_win and not self.staffing_details_win.isHidden():
                self.staffing_details_win.set_current_theme(self.is_dark_theme)

            if hasattr(self, 'table'):
                self._apply_dynamic_sizes()

    def save_user_settings_on_exit(self):
        """Zbiera i zapisuje wszystkie ustawienia użytkownika przy zamykaniu."""
        if not hasattr(self, 'user_settings'):
            return

        # Zbierz dynamiczne ustawienia z UI
        ui_settings = {
            'is_maximized': self.isMaximized(),
            'window_size': (self.size().width(), self.size().height()),
            'last_filters': self.get_current_filters_state(),
            'column_widths': self.table.get_column_widths(),
            'visible_columns': self.visible_columns  # Zapisz również aktualny układ kolumn
        }

        # Zaktualizuj główny słownik ustawień
        self.user_settings.update(ui_settings)

        # Zapisz cały słownik do bazy
        self.settings_db.save_settings(self.user_settings)
        debug_print("Zapisano ustawienia użytkownika przy zamknięciu.")

    def closeEvent(self, event):
        """Obsługuje zamknięcie aplikacji i zapisuje ustawienia."""
        try:
            # Wywołaj nową metodę zapisu
            self.save_user_settings_on_exit()

            debug_print("=== ZAMYKANIE APLIKACJI TEAMFLOW ===")
            self.cleanup_keyboard_filter()
            close_log_file()
        except Exception as e:
            log_error(f"Wystąpił błąd podczas zamykania aplikacji: {e}", exception=e)
        finally:
            event.accept()


if __name__ == "__main__":
    app = QApplication(sys.argv)

    # --- NOWA, BEZPIECZNA SEKWENCJA STARTOWA ---

    # Krok 1: Załaduj kluczowe ustawienia PRZED utworzeniem głównego okna
    if not load_all_app_settings():
        QMessageBox.critical(None, "Błąd Krytyczny",
                             "Nie udało się załadować konfiguracji aplikacji z serwera.\n"
                             "Sprawdź połączenie z bazą danych i plik config.ini.\n\n"
                             "Aplikacja nie może zostać uruchomiona.")
        sys.exit(1)

    # Krok 2: Sprawdź wersję aplikacji PRZED utworzeniem głównego okna
    if parse_version(APP_VERSION) != parse_version(app_settings.REQUIRED_VERSION):
        # Inicjalizujemy logowanie z pustymi ustawieniami, aby ewentualne błędy mogły być zapisane
        setup_logging()
        log_error(
            f"Wersja aplikacji jest przestarzała. Wymagana: {app_settings.REQUIRED_VERSION}, Obecna: {APP_VERSION}")

        # Używamy QDialog bezpośrednio, bo główne okno jeszcze nie istnieje
        dialog = UpdateRequiredDialog()
        dialog.exec()
        sys.exit(0)  # Zakończ normalnie po informacji dla użytkownika

    # Krok 3: Zainicjuj logowanie (teraz, gdy wiemy, że aplikacja może wystartować)
    try:
        current_windows_user = getpass.getuser().lower()
    except Exception:
        current_windows_user = "unknown_user"

    log_to_file = current_windows_user in app_settings.LOGGING_USERS_FILE
    log_to_console = current_windows_user in app_settings.LOGGING_USERS_CONSOLE
    setup_logging(log_to_file=log_to_file, log_to_console=log_to_console)

    # Krok 4: Jeśli wszystko jest w porządku, utwórz i pokaż główne okno
    window = WorkScheduleWindow()
    if window.user_settings.get('is_maximized'):
        window.showMaximized()
    else:
        window.show()
    sys.exit(app.exec())
