import sys
import sqlite3
import os
import time
from datetime import datetime, timedelta, date
from PySide6.QtWidgets import (QApplication, QMainWindow, QTableWidget, QTableWidgetItem,
                               QVBoxLayout, QHBoxLayout, QWidget, QLabel, QComboBox,
                               QPushButton, QHeaderView, QAbstractItemView, QListWidget,
                               QListWidgetItem, QLineEdit, QDialog, QCheckBox, QFrame, QDateEdit,
                               QFormLayout, QDialogButtonBox, QMessageBox, QSplitter, QStyledItemDelegate, QStyle,
                               QGridLayout, QSizePolicy, QTableWidgetSelectionRange)
from PySide6.QtCore import Qt, QThread, Signal, QDate, QTimer, QPoint, QModelIndex, QRect
from PySide6.QtGui import QFont, QColor, QIcon, QPixmap, QPainter, QPolygon, QBrush, QPen,  QLinearGradient, QRadialGradient

from config import DATABASE_CONFIG, ENVIRONMENT
from db_connector import DatabaseConnector, get_modifier_id
from theme_dialog import ThemeSettingsDialog, InsertSymbolDialog, ScheduleChangeDialog
from settings_db import SettingsDatabase
from data_provider import DataProvider




class DataFetcherThread(QThread):
    data_fetched = Signal(list)  # Sygnał z danymi grafiku i danymi zdarzeń

    def __init__(self, year, month, data_provider):
        super().__init__()
        self.year = year
        self.month = month
        self.data_provider = data_provider  # Dodaj referencję do DataProvider

    def run(self):
        try:
            # Pobierz dane używając DataProvider
            schedule_data = self.data_provider.get_schedule_data(self.year, self.month)
            # Upewnij się, że build_index=True jest przekazane
            events_data = self.data_provider.get_events_data(self.year, self.month, as_dict=False, build_index=True)
            users_data = self.data_provider.get_users_data(self.year, self.month)

            # Wyślij dane
            self.data_fetched.emit([schedule_data, events_data, users_data])

        except Exception as e:
            print(f"Błąd podczas pobierania danych: {e}")
            self.data_fetched.emit([])


class WeekendAwareHeaderView(QHeaderView):
    """Niestandardowy nagłówek tabeli, który koloruje weekendy"""

    def __init__(self, orientation, parent=None):
        super().__init__(orientation, parent)
        self.weekend_columns = set()
        self.dark_theme = False
        self.setSectionsClickable(True)  # Ważne, aby sekcje były klikalne

    def set_weekend_columns(self, weekend_cols, dark_theme=False):
        """Ustawia kolumny, które powinny być oznaczone jako weekendy"""
        self.weekend_columns = set(weekend_cols)
        self.dark_theme = dark_theme
        self.viewport().update()  # Wymusza odświeżenie widoku

    def paintSection(self, painter, rect, logicalIndex):
        """Nadpisuje metodę malowania sekcji nagłówka"""
        # Zapisz aktualny kolor i czcionkę
        old_pen = painter.pen()
        old_brush = painter.brush()
        old_font = painter.font()

        # Sprawdź, czy to weekend
        is_weekend = logicalIndex in self.weekend_columns

        # Najpierw rysujemy tło z odpowiednim kolorem
        if is_weekend:
            # Kolor tła dla weekendów
            if self.dark_theme:
                # Ciemniejszy czerwony dla trybu ciemnego
                painter.fillRect(rect, QColor(120, 40, 40))  # Ciemniejszy odcień czerwonego
            else:
                # Jaśniejszy czerwony dla trybu jasnego
                painter.fillRect(rect, QColor(255, 200, 200))  # Jasny odcień czerwonego
        else:
            # Standardowe tło dla dni powszednich
            if self.dark_theme:
                painter.fillRect(rect, QColor(44, 44, 44))  # Ciemny kolor tła
            else:
                painter.fillRect(rect, QColor(240, 240, 240))  # Jasny kolor tła

        # Ustawienia tekstu dla weekendów
        if is_weekend:
            # Ustawienie koloru tekstu dla weekendów
            if self.dark_theme:
                painter.setPen(QColor(255, 180, 180))  # Jaśniejszy czerwony dla ciemnego motywu
            else:
                painter.setPen(QColor(180, 0, 0))  # Ciemnoczerwony dla jasnego motywu

            # Pogrubiona czcionka dla weekendów
            font = painter.font()
            font.setBold(True)
            painter.setFont(font)
        else:
            # Standardowy kolor tekstu dla dni powszednich
            if self.dark_theme:
                painter.setPen(QColor(255, 255, 255))  # Biały tekst dla ciemnego motywu
            else:
                painter.setPen(QColor(0, 0, 0))  # Czarny tekst dla jasnego motywu

        # Pobierz tekst sekcji nagłówka - WAŻNA ZMIANA: Upewnij się, że text jest stringiem
        text = str(self.model().headerData(logicalIndex, self.orientation(), Qt.DisplayRole))

        # WAŻNA ZMIANA: Poprawnie wywołaj metodę drawText z flagą jako liczbą całkowitą
        # Używamy int(Qt.AlignCenter) aby przekonwertować flagę enumeracyjną na liczbę całkowitą
        painter.drawText(rect.adjusted(5, 5, -5, -5), int(Qt.AlignCenter), text)

        # Przywróć poprzednie ustawienia rysowania
        painter.setPen(old_pen)
        painter.setBrush(old_brush)
        painter.setFont(old_font)


class OvertimeItemDelegate(QStyledItemDelegate):
    """
    Niestandardowy delegat do rysowania komórek tabeli.
    Wyświetla subtelne znaczniki w prawym dolnym rogu:
    - Czerwony trójkąt dla nadgodzin
    - Białe kółko dla spotkań/szkoleń
    """

    def paint(self, painter, option, index):
        # Najpierw narysuj standardowy element
        super().paint(painter, option, index)

        # Sprawdź czy komórka ma oznaczenie nadgodzin (dane z UserRole)
        has_overtime = index.data(Qt.UserRole)
        # Sprawdź czy komórka ma spotkanie lub szkolenie (dane z UserRole+1)
        has_meeting_or_training = index.data(Qt.UserRole + 1)

        # Jeśli element ma jakiekolwiek oznaczenia
        if has_overtime or has_meeting_or_training:
            painter.save()
            # Włącz antyaliasing dla gładkich krawędzi
            painter.setRenderHint(QPainter.Antialiasing)

            # Określ szerokość i pozycję znaczników
            marker_width = 8  # Zwiększony rozmiar
            marker_height = 8  # Zwiększony rozmiar

            # Rysuj znacznik spotkań/szkoleń (białe kółko) w górnym prawym rogu
            if has_meeting_or_training:
                # Oblicz pozycję w górnym prawym rogu
                top_right_x = option.rect.right() - marker_width - 2  # -2 to margines
                top_right_y = option.rect.top() + 2  # +2 to margines

                # Rysujemy kółko z białym wypełnieniem i czarną obwódką
                painter.setBrush(QBrush(QColor(255, 255, 255, 240)))  # Białe wypełnienie
                painter.setPen(QPen(QColor(0, 0, 0, 220), 1.0))  # Czarna obwódka
                painter.drawEllipse(
                    top_right_x,
                    top_right_y,
                    marker_width,
                    marker_height
                )

            # Rysuj znacznik nadgodzin (czerwony trójkąt) w dolnym prawym rogu
            if has_overtime:
                # Oblicz pozycję w dolnym prawym rogu
                bottom_right_x = option.rect.right() - marker_width - 2  # -2 to margines
                bottom_right_y = option.rect.bottom() - marker_height - 2  # -2 to margines

                # Czerwony trójkąt z czarną obwódką
                painter.setBrush(QBrush(QColor(220, 0, 0, 220)))  # Czerwone wypełnienie
                painter.setPen(QPen(Qt.black, 1.0))  # Czarna obwódka

                triangle = QPolygon()
                triangle.append(QPoint(bottom_right_x, bottom_right_y + marker_height))
                triangle.append(QPoint(bottom_right_x + marker_width, bottom_right_y + marker_height))
                triangle.append(QPoint(bottom_right_x + marker_width, bottom_right_y))
                painter.drawPolygon(triangle)

            painter.restore()

class WorkScheduleWindow(QMainWindow):
    def __init__(self):
        super().__init__()

        # Inicjalizacja bazy danych ustawień
        self.settings_db = SettingsDatabase()

        # Inicjalizacja DataProvider
        self.data_provider = DataProvider()

        # Podłącz sygnał zmiany danych
        self.data_provider.data_changed.connect(self.on_data_changed)

        self.setWindowTitle("TeamFlowApp")
        self.setGeometry(100, 100, 1200, 800)

        # Zmienna do śledzenia ostatniej modyfikacji dokonanej przez bieżącą sesję
        self.last_self_modification_date = None



        # Inicjalizacja bazy danych ustawień
        self.settings_db = SettingsDatabase()

        # Załaduj ustawienia użytkownika
        user_settings = self.settings_db.load_settings()

        # Zapisz ustawienia motywu z bazy danych
        self.is_dark_theme = user_settings['theme'] == 'dark'
        self.current_font = user_settings['font_family']
        self.current_font_size = user_settings['font_size']

        # Zastosuj czcionkę globalnie dla całej aplikacji
        font = QFont(self.current_font, self.current_font_size)
        QApplication.setFont(font)

        # Zastosuj bazowy styl dla motywu ciemnego/jasnego przed utworzeniem UI
        if self.is_dark_theme:
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #1e1e1e;
                    color: white;
                }
                QPushButton {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QComboBox {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QMessageBox {
                    background-color: #1e1e1e;
                    color: white;
                }
                QMessageBox QPushButton {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        else:
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #f5f5f5;
                    color: black;
                }
                QPushButton {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QComboBox {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QMessageBox {
                    background-color: #f5f5f5;
                    color: black;
                }
                QMessageBox QPushButton {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)

        # Dane
        self.raw_data = []
        self.processed_data = {}
        self.visible_rows = []
        self.last_modification_date = None
        self.all_events_data = []  # Bufor na wszystkie zdarzenia
        self.user_info_map = {}  # Mapowanie użytkowników na ich dane (wydział, przełożony, nazwa)

        # Utworzenie interfejsu
        self.setup_ui()

        # Zastosuj pełny zestaw stylów dla całej aplikacji
        self.apply_theme_settings(
            'dark' if self.is_dark_theme else 'light',
            self.current_font,
            self.current_font_size
        )

        # Sprawdź uprawnienia użytkownika - jeśli zwróci False, aplikacja się zamknie
        if not self.check_user_permissions():
            return

        # Pobieranie początkowych danych
        self.current_date = QDate.currentDate()
        self.update_data(self.current_date.year(), self.current_date.month())

        # Ładowanie ikon
        self.load_icons()

        # Ustaw daty filtrowania po inicjalizacji danych
        self.update_filter_dates()

    def on_data_changed(self, data_type, year, month):
        """Obsługuje powiadomienie o zmianie danych"""
        current_data = self.date_combo.currentData()
        if current_data and current_data == (year, month):
            if data_type == "schedule":
                self.update_table_content()
            elif data_type == "events":
                self.filter_events_table()

    def log_time(self, label, start_time):
        """Pomocnicza funkcja do logowania czasu"""
        end_time = time.time()
        elapsed = end_time - start_time
        print(f"[CZAS] {label}: {elapsed:.3f} sekundy")
        return end_time

    def setup_ui(self):
        # Główny widget i layout
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)

        # ------------ CZĘŚĆ 1: GÓRNY PASEK ------------
        top_bar_frame = QFrame()
        top_bar_frame.setFrameShape(QFrame.StyledPanel)
        top_bar_frame.setFrameShadow(QFrame.Raised)
        top_bar_layout = QHBoxLayout(top_bar_frame)
        top_bar_layout.setContentsMargins(5, 5, 5, 5)

        # Dodaj przycisk menu (burger)
        self.toggle_menu_button = QPushButton()
        self.toggle_menu_button.setFixedSize(32, 32)
        # Używamy znaku Unicode dla "burger menu"
        self.toggle_menu_button.setText("☰")
        self.toggle_menu_button.setToolTip("Pokaż/ukryj panel filtrów")

        # Ustaw styl przycisku
        if self.is_dark_theme:
            self.toggle_menu_button.setStyleSheet("""
                    QPushButton {
                        background-color: #2c2c2c;
                        color: white;
                        border: 1px solid #3a3a3a;
                        border-radius: 4px;
                        font-size: 18px;
                        font-weight: bold;
                    }
                    QPushButton:hover {
                        background-color: #3a3a3a;
                    }
                """)
        else:
            self.toggle_menu_button.setStyleSheet("""
                    QPushButton {
                        background-color: #e0e0e0;
                        color: black;
                        border: 1px solid #cccccc;
                        border-radius: 4px;
                        font-size: 18px;
                        font-weight: bold;
                    }
                    QPushButton:hover {
                        background-color: #d0d0d0;
                    }
                """)

        # Podłącz funkcję do przycisku
        self.toggle_menu_button.clicked.connect(self.toggle_left_panel)

        # Dodaj przycisk menu na początku górnego paska
        top_bar_layout.addWidget(self.toggle_menu_button)

        # Przycisk zmiany motywu
        self.theme_button = QPushButton("Zmień motyw")
        self.theme_button.clicked.connect(self.show_theme_settings)
        # Zastosuj bazowy styl zgodny z motywem
        if self.is_dark_theme:
            self.theme_button.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            self.theme_button.setStyleSheet("""
                background-color: #e0e0e0;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)

        # Etykieta i combobox na rok-miesiąc
        date_label = QLabel("Miesiąc:")
        self.date_combo = QComboBox()

        # Zastosuj styl zgodny z motywem dla comboboxa
        if self.is_dark_theme:
            self.date_combo.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            self.date_combo.setStyleSheet("""
                background-color: white;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)

            # Dodanie opcji dla 3 miesięcy wstecz i 1 miesiąca do przodu od bieżącego
            current_date = datetime.now()
            months_to_show = []

            # Zacznij od 3 miesięcy wstecz
            year = current_date.year
            month = current_date.month

            # Generowanie 3 miesięcy wstecz
            for i in range(3, 0, -1):
                # Oblicz rok i miesiąc dla i miesięcy wstecz
                prev_month = month - i
                prev_year = year

                # Dostosuj rok, jeśli trzeba
                while prev_month <= 0:
                    prev_month += 12
                    prev_year -= 1

                months_to_show.append((prev_year, prev_month))

            # Dodaj bieżący miesiąc
            months_to_show.append((year, month))

            # Dodaj 1 miesiąc do przodu
            next_month = month + 1
            next_year = year
            if next_month > 12:
                next_month = 1
                next_year += 1
            months_to_show.append((next_year, next_month))

            # Dodanie miesięcy do comboboxa w formacie YYYY-MM
            self.date_combo.clear()  # Wyczyść poprzednie pozycje
            for year, month in months_to_show:
                self.date_combo.addItem(f"{year}-{month:02d}", (year, month))

            # Ustawienie bieżącego miesiąca (czwarty element, indeks 3)
            self.date_combo.setCurrentIndex(3)

        # Podłącz sygnał zmiany comboboxa daty
        self.date_combo.currentIndexChanged.connect(self.on_date_combo_changed)

        # Przycisk odświeżania
        self.refresh_button = QPushButton("Odśwież dane")
        self.refresh_button.clicked.connect(self.refresh_data)
        # Zastosuj bazowy styl zgodny z motywem
        if self.is_dark_theme:
            self.refresh_button.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            self.refresh_button.setStyleSheet("""
                background-color: #e0e0e0;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)

        # Dodanie widgetów do layoutu górnego paska
        top_bar_layout.addWidget(self.theme_button)
        top_bar_layout.addWidget(date_label)
        top_bar_layout.addWidget(self.date_combo)
        top_bar_layout.addWidget(self.refresh_button)
        top_bar_layout.addStretch()

        # Dodaj górny pasek do głównego layoutu
        main_layout.addWidget(top_bar_frame)

        # ------------ CZĘŚĆ 2 i 3: ŚRODKOWA CZĘŚĆ ------------
        # Główny kontener na środkową część (filtry po lewej, tabela po prawej)
        main_splitter = QSplitter(Qt.Horizontal)
        middle_container = QWidget()
        middle_layout = QHBoxLayout(middle_container)
        middle_layout.setContentsMargins(0, 0, 0, 0)
        middle_layout.setSpacing(10)

        # ------------ CZĘŚĆ 2: LEWY PANEL FILTRÓW ------------
        self._left_panel = QWidget()

        if self.is_dark_theme:
            self._left_panel.setStyleSheet("background-color: #1e1e1e; color: white;")
        else:
            self._left_panel.setStyleSheet("background-color: #f0f0f0; color: black;")

        filters_layout = QVBoxLayout(self._left_panel)
        filters_layout.setContentsMargins(10, 10, 10, 10)

        # Tytuł filtrów
        filters_title = QLabel("Filtry")
        if self.is_dark_theme:
            filters_title.setStyleSheet("font-size: 16px; font-weight: bold; color: white;")
        else:
            filters_title.setStyleSheet("font-size: 16px; font-weight: bold; color: black;")
        filters_layout.addWidget(filters_title)

        # Filtr wydziału
        wydzial_label = QLabel("Wydział:")
        if self.is_dark_theme:
            wydzial_label.setStyleSheet("color: #3498db;")
        else:
            wydzial_label.setStyleSheet("color: #2980b9;")
        filters_layout.addWidget(wydzial_label)

        # Lista wydziałów
        self.wydzial_list = QListWidget()
        self.wydzial_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        if self.is_dark_theme:
            self.wydzial_list.setStyleSheet("""
                QListWidget {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                }
            """)
        else:
            self.wydzial_list.setStyleSheet("""
                QListWidget {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
            """)
        self.wydzial_list.setFixedHeight(120)

        # Dodaj pole wyszukiwania dla wydziałów
        self.wydzial_filter = QLineEdit()
        self.wydzial_filter.setPlaceholderText("Filtruj wydział...")
        if self.is_dark_theme:
            self.wydzial_filter.setStyleSheet("""
                QLineEdit {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        else:
            self.wydzial_filter.setStyleSheet("""
                QLineEdit {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        self.wydzial_filter.textChanged.connect(self.filter_wydzial_list)

        filters_layout.addWidget(self.wydzial_filter)
        filters_layout.addWidget(self.wydzial_list)

        # Filtr przełożonego
        przelozony_label = QLabel("Przełożony:")
        if self.is_dark_theme:
            przelozony_label.setStyleSheet("color: #3498db;")
        else:
            przelozony_label.setStyleSheet("color: #2980b9;")
        filters_layout.addWidget(przelozony_label)

        # Lista przełożonych
        self.przelozony_list = QListWidget()
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        if self.is_dark_theme:
            self.przelozony_list.setStyleSheet("""
                QListWidget {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                }
            """)
        else:
            self.przelozony_list.setStyleSheet("""
                QListWidget {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
            """)
        self.przelozony_list.setFixedHeight(150)

        # Dodaj pole wyszukiwania dla przełożonych
        self.przelozony_filter = QLineEdit()
        self.przelozony_filter.setPlaceholderText("Filtruj przełożonych...")
        if self.is_dark_theme:
            self.przelozony_filter.setStyleSheet("""
                QLineEdit {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        else:
            self.przelozony_filter.setStyleSheet("""
                QLineEdit {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)

        filters_layout.addWidget(self.przelozony_filter)
        filters_layout.addWidget(self.przelozony_list)

        # Filtr użytkownika
        uzytkownik_label = QLabel("Użytkownik:")
        if self.is_dark_theme:
            uzytkownik_label.setStyleSheet("color: #3498db;")
        else:
            uzytkownik_label.setStyleSheet("color: #2980b9;")
        filters_layout.addWidget(uzytkownik_label)

        # Lista użytkowników
        self.uzytkownik_list = QListWidget()
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        if self.is_dark_theme:
            self.uzytkownik_list.setStyleSheet("""
                QListWidget {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                }
            """)
        else:
            self.uzytkownik_list.setStyleSheet("""
                QListWidget {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
            """)
        self.uzytkownik_list.setFixedHeight(180)

        # Dodaj pole wyszukiwania dla użytkowników
        self.uzytkownik_filter = QLineEdit()
        self.uzytkownik_filter.setPlaceholderText("Filtruj użytkowników...")
        if self.is_dark_theme:
            self.uzytkownik_filter.setStyleSheet("""
                QLineEdit {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        else:
            self.uzytkownik_filter.setStyleSheet("""
                QLineEdit {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
            """)
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)

        filters_layout.addWidget(self.uzytkownik_filter)
        filters_layout.addWidget(self.uzytkownik_list)

        # Przycisk wyczyść filtry
        clear_filters_button = QPushButton("Wyczyść filtry")
        # Zastosuj bazowy styl zgodny z motywem (taki sam jak inne przyciski)
        if self.is_dark_theme:
            clear_filters_button.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            clear_filters_button.setStyleSheet("""
                background-color: #e0e0e0;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)
        clear_filters_button.clicked.connect(self.clear_filters)
        filters_layout.addStretch()
        filters_layout.addWidget(clear_filters_button)

        # Zapamiętaj standardową szerokość lewego panelu
        self._left_panel.setMinimumWidth(150)
        self._left_panel.setMaximumWidth(250)
        self.left_panel_visible = True  # Dodaj zmienną do śledzenia stanu widoczności
        self.left_panel_width = 200  # Zapamiętaj szerokość panelu

        # Zapisz referencję do przycisku "Wyczyść filtry", aby móc go stylizować w apply_theme_settings
        self.clear_filters_button = clear_filters_button

        # Podłączenie sygnałów zmiany filtrów
        self.wydzial_list.itemSelectionChanged.connect(self.filter_data)
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)

        # ------------ CZĘŚĆ 3: PRAWY PANEL Z TABELAMI ------------
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)

        # Splitter pionowy dla prawego panelu (grafik | zdarzenia)
        right_splitter = QSplitter(Qt.Vertical)

        # ------------ Tabela z grafikiem (Górna część prawego panelu) ------------
        schedule_frame = QFrame()
        schedule_frame.setFrameShape(QFrame.StyledPanel)
        schedule_frame.setFrameShadow(QFrame.Raised)
        schedule_layout = QVBoxLayout(schedule_frame)
        schedule_layout.setContentsMargins(5, 5, 5, 5)

        # Tabela z grafikiem
        self.table = QTableWidget()
        self.table.setSelectionMode(QAbstractItemView.ExtendedSelection)  # Umożliwia zaznaczanie wielu komórek
        self.table.setSelectionBehavior(QAbstractItemView.SelectItems)  # Zaznaczanie pojedynczych komórek
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.itemSelectionChanged.connect(self.on_selection_changed)


        # Zastąp standardowy nagłówek poziomy niestandardowym
        self.table.setHorizontalHeader(WeekendAwareHeaderView(Qt.Horizontal, self.table))

        # Dodaj tabelę do layoutu
        schedule_layout.addWidget(self.table)

        # Ustaw domyślną wysokość wierszy
        self.table.verticalHeader().setDefaultSectionSize(15)

        # Wyłącz automatyczne dostosowywanie wysokości wierszy
        self.table.verticalHeader().setSectionResizeMode(QHeaderView.Fixed)

        # Dodaj przyciski "Wstaw nieobecność" i "Odwołaj delegacje" po prawej stronie
        symbol_button_frame = QFrame()
        symbol_button_layout = QHBoxLayout(symbol_button_frame)
        symbol_button_layout.setContentsMargins(0, 0, 0, 0)

        # Dodaj elastyczny odstęp po lewej stronie, aby przyciski były po prawej
        symbol_button_layout.addStretch()

        # Dodaj przycisk "Wstaw zmianę" obok istniejących przycisków
        self.insert_change_button = QPushButton("Wstaw zmianę")
        self.insert_change_button.setShortcut("Ctrl+Z")  # Skrót klawiszowy
        self.insert_change_button.setToolTip("Wstaw zmianę grafiku (Ctrl+Z)")

        # Zastosuj styl zgodny z motywem
        if self.is_dark_theme:
            self.insert_change_button.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            self.insert_change_button.setStyleSheet("""
                background-color: #e0e0e0;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)
        self.insert_change_button.clicked.connect(self.show_insert_change_dialog)

        # Dodaj przycisk do układu (symbol_button_layout)
        symbol_button_layout.addWidget(self.insert_change_button)

        # Przycisk "Wstaw nieobecność" (dawny "Wstaw symbol")
        self.insert_symbol_button = QPushButton("Wstaw nieobecność")
        self.insert_symbol_button.setShortcut("Ctrl+I")  # Skrót klawiszowy Ctrl+I
        self.insert_symbol_button.setToolTip("Wstaw nieobecność (Ctrl+I)")  # Podpowiedź z informacją o skrócie

        # Zastosuj bazowy styl zgodny z motywem
        if self.is_dark_theme:
            self.insert_symbol_button.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            self.insert_symbol_button.setStyleSheet("""
                background-color: #e0e0e0;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)
        self.insert_symbol_button.clicked.connect(self.show_insert_symbol_dialog)

        # Przycisk "Odwołaj delegacje"
        self.cancel_delegation_button = QPushButton("Odwołaj delegacje")
        self.cancel_delegation_button.setShortcut("Ctrl+D")  # Skrót klawiszowy Ctrl+D
        self.cancel_delegation_button.setToolTip("Odwołaj delegacje dla zaznaczonych komórek (Ctrl+D)")

        # Zastosuj bazowy styl zgodny z motywem
        if self.is_dark_theme:
            self.cancel_delegation_button.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            self.cancel_delegation_button.setStyleSheet("""
                background-color: #e0e0e0;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)
        self.cancel_delegation_button.clicked.connect(self.cancel_delegations)

        # Przycisk "Dodaj nadgodziny"
        self.add_overtime_button = QPushButton("Dodaj nadgodziny")
        self.add_overtime_button.setShortcut("Ctrl+N")  # Skrót klawiszowy Ctrl+N
        self.add_overtime_button.setToolTip("Dodaj nadgodziny dla zaznaczonych komórek (Ctrl+N)")

        # Zastosuj bazowy styl zgodny z motywem
        if self.is_dark_theme:
            self.add_overtime_button.setStyleSheet("""
                background-color: #2c2c2c;
                color: white;
                border: 1px solid #3a3a3a;
                padding: 5px;
                border-radius: 3px;
            """)
        else:
            self.add_overtime_button.setStyleSheet("""
                background-color: #e0e0e0;
                color: black;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            """)
        self.add_overtime_button.clicked.connect(self.show_add_overtime_dialog)

        # Pokaż przycisk tylko dla roli "Pracownik WPR"
        if hasattr(self, 'current_user_role') and self.current_user_role == "Pracownik WPR":
            symbol_button_layout.addWidget(self.add_overtime_button)

        # Dodaj przyciski do layoutu
        symbol_button_layout.addWidget(self.insert_symbol_button)
        symbol_button_layout.addWidget(self.cancel_delegation_button)
        symbol_button_layout.addWidget(self.add_overtime_button)

        schedule_layout.addWidget(symbol_button_frame)

        # Dodaj panel grafiku do prawego panelu
        right_layout.addWidget(schedule_frame)

        separator_top = QFrame()
        separator_top.setFrameShape(QFrame.HLine)
        separator_top.setFrameShadow(QFrame.Sunken)
        separator_top.setStyleSheet("background-color: transparent;")  # Ukryj górny separator
        self.separator_top = separator_top
        right_layout.addWidget(separator_top)

        # ------------ CZĘŚĆ 4: PANEL ZDARZEŃ ------------
        events_frame = QFrame()
        events_frame.setFrameShape(QFrame.StyledPanel)
        events_frame.setFrameShadow(QFrame.Raised)
        events_layout = QVBoxLayout(events_frame)
        events_layout.setContentsMargins(5, 5, 5, 5)

        # Tworzenie kontrolek filtrów dla tabeli zdarzeń
        events_filter_frame = QFrame()
        events_filter_layout = QHBoxLayout(events_filter_frame)
        events_filter_layout.setContentsMargins(0, 0, 0, 0)

        # Filtry daty od-do
        date_from_label = QLabel("Data od:")
        self.date_from = QDateEdit()
        self.date_from.setDisplayFormat("dd.MM.yyyy")
        self.date_from.setDate(QDate.currentDate().addDays(-30))
        self.date_from.setCalendarPopup(True)

        date_to_label = QLabel("Data do:")
        self.date_to = QDateEdit()
        self.date_to.setDisplayFormat("dd.MM.yyyy")
        self.date_to.setDate(QDate.currentDate())
        self.date_to.setCalendarPopup(True)

        # Filtr tematu
        topic_label = QLabel("Temat:")
        self.topic_filter = QLineEdit()
        self.topic_filter.setPlaceholderText("Filtruj po temacie...")

        # Filtr nazwy
        name_label = QLabel("Nazwa:")
        self.name_filter = QLineEdit()
        self.name_filter.setPlaceholderText("Filtruj po nazwie...")

        # Checkbox do filtrowania spotkań
        self.meetings_checkbox = QCheckBox("Spotkania")
        self.meetings_checkbox.setChecked(True)
        self.meetings_checkbox.stateChanged.connect(self.filter_events_table)

        # Checkbox do filtrowania szkoleń
        self.trainings_checkbox = QCheckBox("Szkolenia")
        self.trainings_checkbox.setChecked(True)
        self.trainings_checkbox.stateChanged.connect(self.filter_events_table)

        # Checkbox do filtrowania nadgodzin
        self.overtime_checkbox = QCheckBox("Nadgodziny")
        self.overtime_checkbox.setChecked(True)
        self.overtime_checkbox.stateChanged.connect(self.filter_events_table)

        # podłącz sygnały zmiany daty bezpośrednio do filtrowania
        self.date_from.dateChanged.connect(self.filter_events_table)
        self.date_to.dateChanged.connect(self.filter_events_table)

        # Dodaj kontrolki do layoutu filtrów zdarzeń
        events_filter_layout.addWidget(date_from_label)
        events_filter_layout.addWidget(self.date_from)
        events_filter_layout.addWidget(date_to_label)
        events_filter_layout.addWidget(self.date_to)
        events_filter_layout.addWidget(topic_label)
        events_filter_layout.addWidget(self.topic_filter)
        events_filter_layout.addWidget(name_label)
        events_filter_layout.addWidget(self.name_filter)
        events_filter_layout.addWidget(self.meetings_checkbox)
        events_filter_layout.addWidget(self.trainings_checkbox)
        events_filter_layout.addWidget(self.overtime_checkbox)
        events_filter_layout.addStretch()

        # Dodaj panel filtrów zdarzeń do layoutu panelu zdarzeń
        events_layout.addWidget(events_filter_frame)

        # Tworzenie tabeli zdarzeń
        self.events_table = QTableWidget()
        self.events_table.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.events_table.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.events_table.setEditTriggers(QAbstractItemView.NoEditTriggers)

        # Ustawienie kolumn dla tabeli zdarzeń
        self.events_table.setColumnCount(10)
        self.events_table.setHorizontalHeaderLabels([
            "Id", "Typ", "Temat", "Nazwa", "Użytkownik", "Data", "Od", "Do", "Status", "Akcje"
        ])

        # Ustaw szerokość kolumn
        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Użytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

        # Aplikuj styl do tabeli zdarzeń
        if self.is_dark_theme:
            self.events_table.setStyleSheet("""
                QTableWidget {
                    background-color: #2c2c2c;
                    color: white;
                    gridline-color: #3a3a3a;
                    border: 1px solid #3a3a3a;
                }
                QTableWidget::item {
                    color: white;
                }
                QTableWidget::item:selected {
                    background-color: #3498db;
                }
            """)
        else:
            self.events_table.setStyleSheet("""
                QTableWidget {
                    background-color: white;
                    color: black;
                    gridline-color: #cccccc;
                    border: 1px solid #cccccc;
                }
                QTableWidget::item {

                }
                QTableWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
            """)

        # Dodaj tabelę zdarzeń do panelu zdarzeń
        events_layout.addWidget(self.events_table)

        # Dodaj panel zdarzeń do prawego panelu
        right_layout.addWidget(events_frame)

        # Inicjalizacja danych w tabeli zdarzeń
        self.events_data = []  # Lista słowników z danymi o zdarzeniach

        # Podłącz sygnały do filtrów
        self.topic_filter.textChanged.connect(self.filter_events_table)
        self.name_filter.textChanged.connect(self.filter_events_table)

        # Dodaj lewy i prawy panel do środkowego kontenera
        middle_layout.addWidget(self._left_panel)
        middle_layout.addWidget(right_panel, 1)  # Dodaj wagę, aby prawy panel zajmował więcej miejsca

        # Możesz ustawić minimalną szerokość, aby panel nie znikał
        self._left_panel.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
        self._left_panel.setMinimumWidth(150)  # Ustaw minimalną szerokość
        self._left_panel.setMaximumWidth(250)  # Ustaw maksymalną szerokość (taka sama jak minimalna)

        # Dodaj środkowy kontener do głównego layoutu
        main_layout.addWidget(middle_container, 0)  # Dodaj wagę, aby środkowy kontener rozciągał się

        # Dodaj panele do pionowego splittera
        right_splitter.addWidget(schedule_frame)
        right_splitter.addWidget(events_frame)

        # Ustaw początkowe proporcje dla pionowego splittera (np. 60% grafik, 40% zdarzenia)
        right_splitter.setSizes([600, 400])

        # Dodaj pionowy splitter do layoutu prawego panelu
        right_layout.addWidget(right_splitter)

        # Dodaj panele do głównego splittera
        main_splitter.addWidget(self._left_panel)
        main_splitter.addWidget(right_panel)

        # Ustaw początkowe proporcje dla głównego splittera (np. 25% lewy panel, 75% prawy panel)
        main_splitter.setSizes([250, 950])

        # Dodaj główny splitter do głównego layoutu
        main_layout.addWidget(main_splitter, 1)  # Waga 1 zapewnia rozciąganie

        # Zapisz referencję do splittera
        self.main_splitter = main_splitter

        # Dodaj główny splitter do głównego layoutu
        main_layout.addWidget(main_splitter, 1)  # Waga 1 zapewnia rozciąganie

        # Ustawienie głównego widgetu
        self.setCentralWidget(central_widget)

        # Ukryj nagłówek pionowy (numery wierszy)
        self.table.verticalHeader().setVisible(True)
        self.events_table.verticalHeader().setVisible(True)

        self.table.setSortingEnabled(True)
        self.events_table.setSortingEnabled(True)

        # Domyślnie sortuj po pierwszej kolumnie (Wydział)
        self.table.sortByColumn(0, Qt.AscendingOrder)
        self.events_table.sortByColumn(0, Qt.AscendingOrder)

        # Możemy także zachować informację o ostatnim sortowaniu
        self.last_sort_column = 0
        self.last_sort_order = Qt.AscendingOrder

        # Podłącz sygnał sortowania (opcjonalnie, jeśli chcesz wykonać dodatkowe działania przy sortowaniu)
        self.table.horizontalHeader().sortIndicatorChanged.connect(self.on_sort_changed)
        self.events_table.horizontalHeader().sortIndicatorChanged.connect(self.on_events_sort_changed)

    def toggle_left_panel(self):
        """Przełącza widoczność lewego panelu filtrów"""
        if self.left_panel_visible:
            # Ukryj panel
            self.left_panel_width = self._left_panel.width()  # Zapamiętaj bieżącą szerokość
            self._left_panel.setFixedWidth(0)
            self.left_panel_visible = False
            self.toggle_menu_button.setText("☲")  # Zmień ikonę na "pokaż menu"
            self.toggle_menu_button.setToolTip("Pokaż panel filtrów")
        else:
            # Pokaż panel
            self._left_panel.setMinimumWidth(150)
            self._left_panel.setMaximumWidth(250)
            main_splitter_sizes = self.main_splitter.sizes()
            # Przywróć zapamiętaną szerokość
            self.main_splitter.setSizes([self.left_panel_width, main_splitter_sizes[1]])
            self.left_panel_visible = True
            self.toggle_menu_button.setText("☰")  # Przywróć ikonę "burger menu"
            self.toggle_menu_button.setToolTip("Ukryj panel filtrów")

        # Dostosuj widoczność głównego splittera
        self.main_splitter.refresh()

    def on_sort_changed(self, logical_index, order):
        """Obsługuje zmianę sortowania w tabeli grafiku"""
        self.last_sort_column = logical_index
        self.last_sort_order = order
        print(
            f"Tabela grafiku: Sortowanie po kolumnie {logical_index}, kolejność: {'rosnąco' if order == Qt.AscendingOrder else 'malejąco'}")



    def on_events_sort_changed(self, logical_index, order):
        """Obsługuje zmianę sortowania w tabeli zdarzeń"""
        print(
            f"Tabela zdarzeń: Sortowanie po kolumnie {logical_index}, kolejność: {'rosnąco' if order == Qt.AscendingOrder else 'malejąco'}")

        # Po sortowaniu, upewnij się, że przyciski Usuń wciąż są prawidłowo powiązane z danymi
        for row in range(self.events_table.rowCount()):
            # Pobierz ID zdarzenia z pierwszej kolumny (ID)
            id_item = self.events_table.item(row, 0)
            if id_item:
                event_id = id_item.data(Qt.UserRole)

                # Znajdź typ zdarzenia
                type_item = self.events_table.item(row, 1)
                event_type = type_item.text() if type_item else "Nieznany"

                # Utwórz nowy przycisk usuwania
                delete_button = QPushButton("Usuń")
                delete_button.setStyleSheet("""
                    background-color: #e74c3c;
                    color: white;
                    border-radius: 3px;
                    padding: 3px;
                    font-weight: bold;
                """)

                # Utwórz closure dla obsługi zdarzenia kliknięcia
                def create_click_handler(eid, etype):
                    return lambda: self.delete_event(eid, etype)

                # Podłącz funkcję z aktualnymi wartościami
                delete_button.clicked.connect(create_click_handler(event_id, event_type))

                # Zaktualizuj przycisk w komórce
                self.events_table.setCellWidget(row, 9, delete_button)

    def check_user_permissions(self):
        """Sprawdza, czy użytkownik ma odpowiednie uprawnienia do korzystania z aplikacji"""
        # Pobierz dane użytkownika
        user_id, user_app_id, user_app_role = get_modifier_id()

        # Zapisz ID użytkownika do wykorzystania w zapytaniach SQL
        self.current_user_id = user_id
        self.current_user_app_id = user_app_id
        self.current_user_role = user_app_role

        # Lista dozwolonych ról
        allowed_roles = ["Pracownik WPR", "Lider", "Menadżer"]

        # Sprawdź, czy rola użytkownika jest na liście dozwolonych
        if user_app_role not in allowed_roles:
            # Pokaż komunikat o braku uprawnień
            QMessageBox.critical(
                self,
                "Brak uprawnień",
                f"Nie masz uprawnień do korzystania z tej aplikacji.\n\n"
                f"Wymagana rola: Pracownik WPR, Lider lub Menadżer\n"
                f"Twoja rola: {user_app_role}",
                QMessageBox.Ok
            )
            # Zamknij aplikację
            self.close()
            return False

        print(f"Zalogowano jako: {user_app_id} ({user_app_role})")
        return True

    def load_icons(self):
        """Ładuje ikonę PNG do oznaczania spotkań i szkoleń"""
        try:
            # Ścieżka do folderu z ikonami
            icons_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'icons')



            # Szukamy ikony dla spotkań/szkoleń - spróbuj kilka możliwych nazw plików
            event_icon_paths = [
                os.path.join(icons_path, 'time.png'),
                os.path.join(icons_path, 'meeting.png'),
                os.path.join(icons_path, 'calender.png')
            ]

            # Załaduj pierwszą znalezioną ikonę
            self.icons = {}
            icon_loaded = False

            for icon_path in event_icon_paths:
                if os.path.exists(icon_path):
                    # Utwórz ikonę i ustaw jej rozmiar
                    icon = QIcon(icon_path)
                    # Upewnij się, że ikona jest skalowana do określonego rozmiaru
                    pixmap = icon.pixmap(12, 12)  # Mniejszy rozmiar: 12x12 pikseli
                    self.icons['event'] = QIcon(pixmap)

                    if not self.icons['event'].isNull():
                        icon_loaded = True
                        print(f"Załadowano ikonę: {icon_path}")
                        break


            return icon_loaded



        except Exception as e:
            print(f"Błąd podczas ładowania ikon: {e}")
            # Tworzymy pixmapy awaryjne
            self.icons = {}

            meeting_pixmap = QPixmap(16, 16)
            meeting_pixmap.fill(QColor(100, 149, 237))
            self.icons['meeting'] = QIcon(meeting_pixmap)

            training_pixmap = QPixmap(16, 16)
            training_pixmap.fill(QColor(144, 238, 144))
            self.icons['training'] = QIcon(training_pixmap)

            overtime_pixmap = QPixmap(16, 16)
            overtime_pixmap.fill(QColor(255, 165, 0))
            self.icons['overtime'] = QIcon(overtime_pixmap)

            return False


    def show_insert_symbol_dialog(self):
        """Pokazuje okno dialogowe do wstawiania symbolu"""
        dialog = InsertSymbolDialog(self)
        if dialog.exec():
            symbol = dialog.get_selected_symbol()

            # Pobierz zaznaczone komórki
            selected_ranges = self.table.selectedRanges()
            current_data = self.date_combo.currentData()

            if not current_data:
                QMessageBox.warning(
                    self,
                    "Brak danych",
                    "Nie wybrano miesiąca lub brak dostępnych danych do wyświetlenia.",
                    QMessageBox.Ok
                )
                return

            if not selected_ranges:
                QMessageBox.warning(
                    self,
                    "Brak zaznaczenia",
                    "Nie zaznaczono żadnych komórek do aktualizacji.",
                    QMessageBox.Ok
                )
                return

            year, month_idx = current_data

            # Oblicz liczbę dni w miesiącu
            if month_idx in [4, 6, 9, 11]:
                days_in_month = 30
            elif month_idx == 2:
                if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                    days_in_month = 29
                else:
                    days_in_month = 28
            else:
                days_in_month = 31

            processed_keys = list(self.processed_data.keys())
            selected_cells = []
            user_date_pairs = set()  # Dla odwoływania delegacji

            for range_item in selected_ranges:
                top_row = max(0, range_item.topRow())
                bottom_row = min(range_item.bottomRow(), len(self.visible_rows) - 1)
                left_col = max(3, range_item.leftColumn())
                right_col = min(range_item.rightColumn(), 2 + days_in_month)

                for table_row in range(top_row, bottom_row + 1):
                    data_row = self.visible_rows[table_row]
                    if data_row >= len(processed_keys):
                        continue

                    key = processed_keys[data_row]
                    wydzial, przelozony, uzytkownik_dane, uzytkownik = key

                    for col in range(left_col, right_col + 1):
                        day = col - 2
                        day_data = self.processed_data[key]['days'].get(day)
                        if day_data:
                            date_str = f"{year}-{month_idx:02d}-{day:02d}"
                            selected_cells.append({
                                'wydzial': wydzial,
                                'przelozony': przelozony,
                                'uzytkownik_dane': uzytkownik_dane,
                                'uzytkownik_id': uzytkownik,
                                'day': day,
                                'symbol': day_data.get('symbol'),
                                'hours': day_data.get('hours'),
                                'id': day_data.get('id')
                            })
                            # Dodaj parę (użytkownik, data) do odwołania delegacji
                            user_date_pairs.add((uzytkownik, date_str))

            if not selected_cells:
                QMessageBox.information(
                    self,
                    "Brak danych",
                    "Nie znaleziono danych dla zaznaczonych komórek.",
                    QMessageBox.Ok
                )
                return

            # Sprawdź, czy istnieją delegacje do odwołania
            events_to_cancel = []

            # Użyj indeksu zdarzeń do szybkiego znalezienia delegacji
            for user_id, date_str in user_date_pairs:
                # Pobierz zdarzenia dla tej pary użytkownik-data z indeksu
                user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                # Filtruj tylko spotkania i szkolenia
                for event in user_events:
                    event_type = event.get('type', '')
                    event_id = event.get('id')
                    if event_type in ['Spotkanie', 'Szkolenie'] and event_id:
                        events_to_cancel.append({
                            'id': event_id,
                            'type': event_type,
                            'user_id': user_id,
                            'date': date_str,
                            'date_key': event.get('date_key', date_str),
                            'name': event.get('name', ''),
                        })

            # Jeśli znaleziono delegacje, zapytaj użytkownika czy chce je odwołać
            if events_to_cancel:
                # Przygotuj podsumowanie delegacji do odwołania
                events_summary = ""
                for i, event in enumerate(events_to_cancel[:5]):  # Pokaż maksymalnie 5 przykładów
                    events_summary += f"{i + 1}. {event['type']}: {event['name']} ({event['date']})\n"

                if len(events_to_cancel) > 5:
                    events_summary += f"...oraz {len(events_to_cancel) - 5} więcej\n"

                # Zapytaj użytkownika
                cancel_reply = QMessageBox.question(
                    self,
                    "Odwołać delegacje?",
                    f"Znaleziono {len(events_to_cancel)} delegacje (spotkania/szkolenia) w zaznaczonych dniach.\n\n"
                    f"Przykłady:\n{events_summary}\n"
                    f"Czy chcesz automatycznie odwołać te delegacje przed wstawieniem nieobecności?",
                    QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel,
                    QMessageBox.Yes
                )

                if cancel_reply == QMessageBox.Cancel:
                    return  # Anuluj całą operację

                # Jeśli użytkownik potwierdził, odwołaj delegacje
                if cancel_reply == QMessageBox.Yes:
                    # Pobierz identyfikator użytkownika
                    _, user_app_id, _ = get_modifier_id()

                    try:
                        conn = DatabaseConnector.get_connection()
                        cursor = conn.cursor()
                        canceled_count = 0

                        # Dla każdego zdarzenia do odwołania
                        for event in events_to_cancel:
                            event_id = event['id']
                            event_type = event['type']
                            user_id = event['user_id']
                            date_key = event.get('date_key')

                            # Określ odpowiednią tabelę
                            table_name = "p_t_zz_Spotkania" if event_type == "Spotkanie" else "p_t_zz_Szkolenia"

                            # Aktualizuj status zdarzenia
                            update_query = f"""
                            UPDATE {table_name} 
                            SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? 
                            WHERE Id = ?
                            """
                            cursor.execute(update_query, (user_app_id, event_id))
                            canceled_count += 1

                            # Usuń zdarzenie z indeksu zdarzeń
                            self.data_provider.delete_event_from_index(event_id, event_type)

                            # Aktualizuj ikony
                            self.update_table_icons_after_event_deletion(user_id, date_key, event_type)

                        conn.commit()
                        conn.close()

                        # Pokaż informację o odwołanych delegacjach
                        QMessageBox.information(
                            self,
                            "Sukces",
                            f"Pomyślnie odwołano {canceled_count} delegacji.",
                            QMessageBox.Ok
                        )

                        # Wymuś odświeżenie tabeli
                        self.table.viewport().update()

                    except Exception as e:
                        print(f"Błąd podczas odwoływania delegacji: {e}")
                        import traceback
                        traceback.print_exc()
                        QMessageBox.critical(
                            self,
                            "Błąd",
                            f"Wystąpił błąd podczas odwoływania delegacji: {str(e)}",
                            QMessageBox.Ok
                        )

            # Wywołaj update_selected_cells z symbolem i zaznaczonymi komórkami
            self.update_selected_cells(symbol=symbol, selected_cells=selected_cells)

    def update_filter_dates(self):
        """Aktualizuje daty filtrowania do pierwszego i ostatniego dnia wybranego miesiąca"""
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # Pierwszy dzień miesiąca
        first_day = QDate(year, month, 1)
        self.date_from.setDate(first_day)

        # Ostatni dzień miesiąca (przejdź do następnego miesiąca i cofnij o 1 dzień)
        if month == 12:
            next_month = QDate(year + 1, 1, 1)
        else:
            next_month = QDate(year, month + 1, 1)

        last_day = next_month.addDays(-1)
        self.date_to.setDate(last_day)

        # DODANE: Odśwież filtry po aktualizacji dat
        self.filter_events_table()

    # Aktualizacja metody on_date_combo_changed aby odświeżać indeks zdarzeń przy zmianie miesiąca
    def on_date_combo_changed(self):
        """Obsługuje zmianę wybranego miesiąca"""
        # Pobierz rok i miesiąc
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data
            # Aktualizuj dane
            self.update_data(year, month)
            # Aktualizuj daty filtrowania
            self.update_filter_dates()

    def get_selected_schedule_cells(self):
        """Zwraca listę zaznaczonych komórek z siatki grafiku"""
        selected_cells = []
        selected_ranges = self.table.selectedRanges()

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            return selected_cells
        year, month_idx = current_data

        for range_item in selected_ranges:
            for table_row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawdź czy to komórka z grafikiem
                    if col >= 3:
                        if table_row < len(self.visible_rows):
                            data_row = self.visible_rows[table_row]
                            if data_row < len(self.processed_data):
                                key = list(self.processed_data.keys())[data_row]
                                wydzial, przelozony, uzytkownik_dane, uzytkownik = key
                                day = col - 2
                                day_data = self.processed_data[key]['days'].get(day)

                                if day_data:
                                    # Format daty jako YYYY-MM-DD
                                    date_str = f"{year}-{month_idx:02d}-{day:02d}"

                                    # Ważne: pobieramy nr_kadrowy z day_data
                                    nr_kadrowy = day_data.get('nr_kadrowy')

                                    selected_cells.append({
                                        'user_id': uzytkownik,
                                        'day': day,
                                        'date': date_str,
                                        'id': day_data.get('id'),
                                        'current_symbol': day_data.get('symbol', ''),
                                        'start_hour': day_data.get('start_hour'),
                                        'nr_kadrowy': nr_kadrowy  # Dodajemy nr_kadrowy do danych komórki
                                    })
        return selected_cells

    def update_selected_cells(self, symbol=None, selected_cells=None):
        """Aktualizuje listę zaznaczonych komórek i ładuje zdarzenia, opcjonalnie wstawia symbol"""
        # Jeśli nie podano symbolu, wyjdź z funkcji
        if symbol is None:
            print("Ostrzeżenie: Wywołano update_selected_cells bez podania symbolu")
            return

        # Sprawdź, czy selected_cells nie jest puste
        if selected_cells is None:
            print("Ostrzeżenie: Wywołano update_selected_cells bez podania komórek")

        # Jeśli selected_cells nie jest przekazane, pobierz je z tabeli
        if selected_cells is None:
            selected_ranges = self.table.selectedRanges()
            current_data = self.date_combo.currentData()

            if not current_data:
                QMessageBox.warning(
                    self,
                    "Brak danych",
                    "Nie wybrano miesiąca lub brak dostępnych danych do wyświetlenia.",
                    QMessageBox.Ok
                )
                return

            if not selected_ranges:
                year, month = current_data
                self.load_all_events_for_month(year, month)
                return

            # Pobierz rok i miesiąc tylko raz
            year, month_idx = current_data

            # Oblicz liczbę dni w miesiącu tylko raz
            if month_idx in [4, 6, 9, 11]:
                days_in_month = 30
            elif month_idx == 2:
                if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                    days_in_month = 29
                else:
                    days_in_month = 28
            else:
                days_in_month = 31

            # Przygotuj listę kluczy z self.processed_data raz
            processed_keys = list(self.processed_data.keys())

            selected_cells = []
            for range_item in selected_ranges:
                # Ogranicz zakres wierszy do widocznych
                top_row = max(0, range_item.topRow())
                bottom_row = min(range_item.bottomRow(), len(self.visible_rows) - 1)
                # Ogranicz zakres kolumn do dni miesiąca
                left_col = max(3, range_item.leftColumn())
                right_col = min(range_item.rightColumn(), 2 + days_in_month)

                for table_row in range(top_row, bottom_row + 1):
                    data_row = self.visible_rows[table_row]
                    if data_row >= len(processed_keys):
                        continue

                    key = processed_keys[data_row]
                    wydzial, przelozony, uzytkownik_dane, uzytkownik = key

                    for col in range(left_col, right_col + 1):
                        day = col - 2
                        day_data = self.processed_data[key]['days'].get(day)
                        if day_data:
                            # Dodaj date_str do słownika komórki - to rozwiąże błąd
                            date_str = f"{year}-{month_idx:02d}-{day:02d}"
                            selected_cells.append({
                                'wydzial': wydzial,
                                'przelozony': przelozony,
                                'uzytkownik_dane': uzytkownik_dane,
                                'uzytkownik_id': uzytkownik,
                                'day': day,
                                'date_str': date_str,  # Dodane pole date_str
                                'symbol': day_data.get('symbol'),
                                'hours': day_data.get('hours'),
                                'id': day_data.get('id')
                            })

            if not selected_cells:
                QMessageBox.information(
                    self,
                    "Brak danych",
                    "Nie znaleziono danych dla zaznaczonych komórek.",
                    QMessageBox.Ok
                )
                return

        # Jeśli podano symbol, zaktualizuj grafik
        if symbol and selected_cells:
            # Przygotuj tekstową informację o zmianach
            changes_info = ""
            for i, cell in enumerate(selected_cells[:10]):  # Pokaż max 10 przykładów
                changes_info += f"{i + 1}. Użytkownik: {cell['uzytkownik_dane']}, Dzień: {cell['day']}, "
                current_symbol = cell['symbol'] or "brak"
                changes_info += f"Symbol: {current_symbol} -> {symbol}\n"

            if len(selected_cells) > 10:
                changes_info += f"... i {len(selected_cells) - 10} więcej\n"

            # Wyświetl komunikat potwierdzenia
            reply = QMessageBox.question(
                self,
                "Potwierdzenie zmiany symbolu",
                f"Czy na pewno chcesz wprowadzić następujące zmiany?\n\n{changes_info}\n"
                f"Łącznie: {len(selected_cells)} komórek",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )

            if reply == QMessageBox.Yes:
                try:
                    conn = DatabaseConnector.get_connection()
                    cursor = conn.cursor()

                    current_data = self.date_combo.currentData()
                    if not current_data:
                        QMessageBox.warning(
                            self,
                            "Brak danych",
                            "Nie wybrano miesiąca do aktualizacji grafiku.",
                            QMessageBox.Ok
                        )
                        return

                    # Pobierz identyfikator użytkownika modyfikującego rekord
                    _, user_app_id, _ = get_modifier_id()

                    year, month = current_data
                    successful_updates = 0

                    for cell in selected_cells:
                        user_id = cell['uzytkownik_id']
                        day = cell['day']
                        date = QDate(year, month, day).toString('yyyy-MM-dd')



                        # Sprawdź, czy rekord już istnieje
                        existing_id = cell.get('id')
                        if existing_id:
                            # Zmodyfikowane zapytanie do aktualizacji symbolu - używa CASE do obsługi różnych formatów
                            query = f'''
                            DECLARE @NewSymbol VARCHAR(3) = '{symbol}';
                            DECLARE @Modyfikujacy VARCHAR(50) = '{user_app_id}';
                            UPDATE p_T_ZZ_GrafikiPracy
                            SET Symbol = 
                                CASE 
                                -- Obsługa usuwania lokalizacji (h;, s;, p;)
                                WHEN Symbol LIKE 'h;%' OR Symbol LIKE 's;%' OR Symbol LIKE 'p;%' THEN
                                    CASE
                                        -- Jeśli po lokalizacji jest jeszcze jakiś średnik, zachowaj do ostatniego średnika i dodaj nowy symbol
                                        WHEN 
                                            (SUBSTRING(Symbol, 3, LEN(Symbol)) LIKE '%' + ';') THEN 
                                            SUBSTRING(Symbol, 3, LEN(Symbol) - 2) + @NewSymbol
                                        -- Jeśli po lokalizacji są jakieś średniki w środku
                                        WHEN 
                                            (SUBSTRING(Symbol, 3, LEN(Symbol)) LIKE '%' + ';' + '%') THEN
                                            SUBSTRING(Symbol, 3, LEN(SUBSTRING(Symbol, 3, LEN(Symbol))) - CHARINDEX(';', REVERSE(SUBSTRING(Symbol, 3, LEN(Symbol))))) + ';' + @NewSymbol
                                        -- Jeśli po lokalizacji nie ma już średników
                                        ELSE
                                            SUBSTRING(Symbol, 3, LEN(Symbol)) + ';' + @NewSymbol
                                    END

                                -- Dla zwykłych przypadków bez lokalizacji
                                WHEN Symbol LIKE '%' + ';' THEN Symbol + @NewSymbol
                                WHEN Symbol LIKE '%' + ';' + '%' THEN
                                    SUBSTRING(Symbol, 1, LEN(Symbol) - CHARINDEX(';', REVERSE(Symbol))) + ';' + @NewSymbol
                                ELSE Symbol + ';' + @NewSymbol
                            END,
                                DataModyfikacji = GETDATE(),
                                Modyfikujacy = @Modyfikujacy
                            WHERE Id = {existing_id} ;
                            '''
                            cursor.execute(query)
                            successful_updates += 1
                        else:
                            pass


                    conn.commit()
                    conn.close()

                    # Po pomyślnej aktualizacji danych w bazie danych:
                    try:
                        # Pobierz najnowszą datę modyfikacji po wykonaniu zmian
                        query = """
                                SELECT MAX(DataModyfikacji) as DataModyfikacji FROM p_v_zz_GrafikiPracy
                            """
                        conn = DatabaseConnector.get_connection()
                        cursor = conn.cursor()
                        cursor.execute(query)
                        result = cursor.fetchone()
                        conn.close()

                        if result and result[0]:
                            # Zapisz tę datę jako własną modyfikację
                            self.last_self_modification_date = result[0]
                            self.last_modification_date = result[0]  # Aktualizuj również ostatnią znaną modyfikację
                            print(f"Zarejestrowano własną modyfikację z datą: {self.last_self_modification_date}")
                    except Exception as e:
                        print(f"Błąd podczas rejestrowania własnej modyfikacji: {e}")

                    # Zamiast odświeżać całe dane, aktualizuj tylko zaznaczone komórki
                    if successful_updates > 0:
                        print(f"Aktualizacja {successful_updates} komórek po wstawieniu symbolu {symbol}")

                        # Zapisz zaznaczenie przed modyfikacją
                        selected_ranges = self.table.selectedRanges()
                        selected_ranges_data = []
                        for range_item in selected_ranges:
                            selected_ranges_data.append((
                                range_item.topRow(),
                                range_item.leftColumn(),
                                range_item.bottomRow(),
                                range_item.rightColumn()
                            ))

                        # Aktualizuj tylko zaznaczone komórki
                        for cell in selected_cells:
                            user_id = cell['uzytkownik_id']
                            day = cell['day']

                            # Znajdź odpowiednią komórkę w tabeli
                            for row in range(self.table.rowCount()):
                                # Pobierz element z kolumny "Pracownik"
                                pracownik_item = self.table.item(row, 2)
                                if not pracownik_item:
                                    continue

                                # Sprawdź, czy to odpowiedni wiersz
                                found_row = False
                                for key in self.processed_data.keys():
                                    _, _, user_name, uid = key
                                    if user_name == pracownik_item.text() and str(uid) == str(user_id):
                                        found_row = True
                                        break

                                if found_row:
                                    # Znaleźliśmy właściwy wiersz, aktualizuj komórkę
                                    col = 2 + day  # Kolumna odpowiadająca dniowi

                                    # Sprawdź czy komórka istnieje
                                    item = self.table.item(row, col)
                                    if item:
                                        # Aktualizuj symbol w komórce - tu zachowujemy format
                                        current_text = item.text()

                                        # 1. Usuwanie prefiksów (h;, s;, p;) na początku
                                        prefixes = ['h;', 's;', 'p;']
                                        for prefix in prefixes:
                                            if current_text.startswith(prefix):
                                                current_text = current_text[len(prefix):]
                                                break

                                        # 2. Usuwanie części przed ostatnim średnikiem (jeśli istnieje)
                                        if ';' in current_text:
                                            parts = current_text.split(';')
                                            # Zachowaj tylko ostatnią część po średniku, jeśli taka istnieje
                                            if len(parts) == 3:  # Jeśli jest już symbol
                                                prefix = ';'.join(parts[:-1]) + ';'
                                                new_text = prefix + symbol
                                            elif len(parts) == 2:  # Jeśli brak symbolu
                                                prefix = ';'.join(parts) + ';'
                                                new_text = prefix + symbol
                                        print(f"Oryginalny symbol: {item.text()}, Po przetworzeniu: {new_text}")


                                        item.setText(new_text)

                                        # Aktualizuj wygląd komórki
                                        if symbol and ("OS" in symbol or "U" in symbol):
                                            item.setBackground(QColor(255, 180, 0))  # Pomarańczowy dla OS/U
                                            item.setForeground(QColor(0, 0, 0))  # Czarny tekst

                                        # Aktualizuj również dane w pamięci
                                        key = list(self.processed_data.keys())[self.visible_rows[row]]
                                        if day in self.processed_data[key]['days']:
                                            self.processed_data[key]['days'][day]['symbol'] = symbol

                        # Wymuś odświeżenie tabeli
                        self.table.viewport().update()

                        # Przywróć zaznaczenie
                        for top_row, left_col, bottom_row, right_col in selected_ranges_data:
                            selection_range = QTableWidgetSelectionRange(
                                top_row, left_col, bottom_row, right_col
                            )
                            self.table.setRangeSelected(selection_range, True)

                        # Poinformuj o zakończeniu
                        QMessageBox.information(
                            self,
                            "Sukces",
                            f"Grafik został pomyślnie zaktualizowany. Liczba aktualizacji: {successful_updates}",
                            QMessageBox.Ok
                        )

                except Exception as e:
                    QMessageBox.critical(
                        self,
                        "Błąd",
                        f"Wystąpił błąd podczas aktualizacji grafiku: {str(e)}",
                        QMessageBox.Ok
                    )
                    import traceback
                    traceback.print_exc()
                    return

            # Ładuj zdarzenia dla wybranych komórek
            self.load_events_for_selection(selected_cells)



    # Metoda do aktualizacji danych
    def update_data(self, year, month):
        """Aktualizuje dane dla wybranego roku i miesiąca"""
        self.year = year
        self.month = month

        print(f"Pobieranie danych dla {year}-{month}")

        # Wyczyść istniejące dane
        self.raw_data = []
        self.processed_data = {}
        self.all_events_data = []
        self.user_info_map = {}

        # Pokaż informację o ładowaniu
        self.table.clear()
        self.table.setRowCount(1)
        self.table.setColumnCount(1)

        loading_item = QTableWidgetItem("Ładowanie danych...")
        loading_item.setTextAlignment(Qt.AlignCenter)
        loading_font = QFont()
        loading_font.setBold(True)
        loading_font.setPointSize(10)
        loading_item.setFont(loading_font)

        self.table.setItem(0, 0, loading_item)
        self.table.horizontalHeader().setVisible(True)
        self.table.verticalHeader().setVisible(True)

        # Wyczyść tabelę zdarzeń
        self.events_table.setRowCount(0)

        # Użyj wątku do pobrania danych bez blokowania interfejsu
        self.data_thread = DataFetcherThread(year, month, self.data_provider)  # Przekaż data_provider
        self.data_thread.data_fetched.connect(self.on_data_fetched)
        self.data_thread.start()

        # Rozpocznij sprawdzanie nowych danych co 1 minutę
        self.setup_check_timer()

    def setup_check_timer(self):
        """Konfiguruje timer do sprawdzania nowych danych"""
        # Zatrzymaj istniejący timer jeśli działa
        if hasattr(self, 'check_timer') and self.check_timer.isActive():
            self.check_timer.stop()

        # Utwórz nowy timer
        self.check_timer = QTimer()
        self.check_timer.timeout.connect(self.check_for_new_data)
        self.check_timer.start(60000)  # 60 sekund = 1 minuta

    def refresh_data(self):
        """Odświeża dane i resetuje stan przycisku odświeżania"""
        # Resetuj stan przycisku
        self.refresh_button.setText("Odśwież dane")

        # Przywróć domyślny styl przycisku
        button_style = """
            background-color: #2c2c2c;
            color: white;
            border: 1px solid #3a3a3a;
            padding: 5px;
            border-radius: 3px;
        """ if self.is_dark_theme else """
            background-color: #e0e0e0;
            color: black;
            border: 1px solid #cccccc;
            padding: 5px;
            border-radius: 3px;
        """
        self.refresh_button.setStyleSheet(button_style)

        # Pobierz rok i miesiąc
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            print(f"Odświeżam dane dla {year}-{month}")

            # Odśwież dane w DataProvider
            self.data_provider.refresh_data(year, month)

            # Pobierz dane na nowo
            self.update_data(year, month)

    def check_for_new_data(self):
        """Sprawdza czy są nowe dane w bazie danych, ignorując własne modyfikacje"""
        try:
            # Pobierz najnowszą datę modyfikacji z bazy danych
            query = """
                SELECT MAX(DataModyfikacji) as DataModyfikacji FROM p_v_zz_GrafikiPracy
            """
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(query)
            result = cursor.fetchone()
            conn.close()

            if result and result[0]:
                latest_modification = result[0]
                print(f"Ostatnia modyfikacja w bazie: {latest_modification}")

                # Jeśli to pierwszy raz, zapamiętaj datę i wyjdź
                if not hasattr(self, 'last_modification_date') or not self.last_modification_date:
                    self.last_modification_date = latest_modification
                    print("Zapamiętano początkową datę modyfikacji")
                    return False

                # Sprawdź czy najnowsza modyfikacja jest własną modyfikacją
                if hasattr(self, 'last_self_modification_date') and self.last_self_modification_date:
                    # Porównaj daty jako string dla pewności
                    latest_str = str(latest_modification)
                    self_mod_str = str(self.last_self_modification_date)

                    # Jeśli najnowsza modyfikacja to nasza własna, ignoruj ją
                    if latest_str == self_mod_str:
                        print(f"Ignoruję własną modyfikację z datą: {latest_str}")
                        return False

                # Sprawdź czy są nowsze dane niż ostatnio zapamiętane (które nie są naszymi własnymi)
                latest_str = str(latest_modification)
                last_str = str(self.last_modification_date)

                # Jeśli znajdziesz nowe dane, odśwież cache w DataProvider
                if latest_str > last_str:
                    # Aktualizuj ostatnią datę modyfikacji
                    self.last_modification_date = latest_modification

                    # Oznacz przycisk odświeżania
                    self.refresh_button.setText("Nowe dane!")

                    # Wyraźny styl przycisku z nowymi danymi
                    new_data_style = """
                        background-color: #f39c12; 
                        color: white;
                        font-weight: bold;
                        border: 2px solid #e67e22;
                        padding: 5px;
                        border-radius: 3px;
                    """
                    self.refresh_button.setStyleSheet(new_data_style)

                    # Zatrzymaj timer - nie musimy już sprawdzać, czekamy na akcję użytkownika
                    self.check_timer.stop()

                    return True
                else:
                    print("Brak nowych danych")

            return False

        except Exception as e:
            print(f"Błąd podczas sprawdzania nowych danych: {e}")
            return False

    def filter_data(self):
        start_time = time.time()

        # Pobierz wybrane filtry
        selected_wydzialy = self.get_selected_items(self.wydzial_list)
        selected_przelozeni = self.get_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_selected_items(self.uzytkownik_list)

        # Pobierz bieżący rok i miesiąc
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            # Użyj data_provider do filtrowania danych
            filtered_data = self.data_provider.filter_data(
                year, month,
                wydzialy=selected_wydzialy if selected_wydzialy else None,
                przelozeni=selected_przelozeni if selected_przelozeni else None,
                uzytkownicy=selected_uzytkownicy if selected_uzytkownicy else None
            )

            # Przetwórz dane używając istniejącej metody process_data
            self.raw_data = filtered_data
            self.process_data(filtered_data)

        # Aplikuj filtry do wyświetlanych danych tabeli grafiku
        self.update_filtered_table()

        # Wyczyść tabelę zdarzeń, gdy zmieniają się filtry
        self.events_data = []
        self.events_table.setRowCount(0)

        self.log_time("Filtrowanie danych", start_time)

    def clear_filters(self):
        # Wyczyść wszystkie filtry
        self.wydzial_list.clearSelection()
        self.przelozony_list.clearSelection()
        self.uzytkownik_list.clearSelection()

        # Wyczyść pola wyszukiwania
        self.wydzial_filter.clear()
        self.przelozony_filter.clear()
        self.uzytkownik_filter.clear()

        # Pokaż wszystkie elementy list
        for i in range(self.wydzial_list.count()):
            self.wydzial_list.item(i).setHidden(False)

        for i in range(self.przelozony_list.count()):
            self.przelozony_list.item(i).setHidden(False)

        for i in range(self.uzytkownik_list.count()):
            self.uzytkownik_list.item(i).setHidden(False)

        self.update_filtered_table()

    # Metody do filtrowania list
    def filter_wydzial_list(self, text):
        """Filtruje listę wydziałów na podstawie wpisanego tekstu"""
        text = text.lower()
        for i in range(self.wydzial_list.count()):
            item = self.wydzial_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_przelozony_list(self, text):
        """Filtruje listę przełożonych na podstawie wpisanego tekstu"""
        text = text.lower()
        for i in range(self.przelozony_list.count()):
            item = self.przelozony_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_uzytkownik_list(self, text):
        """Filtruje listę użytkowników na podstawie wpisanego tekstu"""
        text = text.lower()
        for i in range(self.uzytkownik_list.count()):
            item = self.uzytkownik_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def update_filtered_table(self):
        # Filtrowanie danych na podstawie wybranych filtrów
        selected_wydzialy = self.get_selected_items(self.wydzial_list)
        selected_przelozeni = self.get_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_selected_items(self.uzytkownik_list)

        # Określenie widocznych wierszy
        self.visible_rows = []
        for i, key in enumerate(self.processed_data.keys()):
            wydzial, przelozony, uzytkownik_dane, uzytkownik = key
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni) and \
                    (not selected_uzytkownicy or str(uzytkownik_dane) in selected_uzytkownicy):
                self.visible_rows.append(i)

        # Aktualizacja tabeli z uwzględnieniem filtrów
        self.update_table_content()

    # Metoda do obsługi danych zwróconych przez wątek
    def on_data_fetched(self, data):
        try:
            if not data or len(data) < 3:
                QMessageBox.critical(
                    self,
                    "Błąd",
                    "Nie udało się pobrać danych. Proszę spróbować ponownie.",
                    QMessageBox.StandardButton.Ok
                )
                return

            schedule_data, events_data, users_data = data

            # Przywróć tylko nagłówek poziomy
            self.table.horizontalHeader().setVisible(True)

            # Ukryj nagłówek pionowy (numery wierszy)
            self.table.verticalHeader().setVisible(True)

            # Przetwarzanie danych grafiku
            process_start = time.time()
            try:
                self.raw_data = schedule_data
                self.process_data(schedule_data)
                process_end = self.log_time("Przetwarzanie grafiku", process_start)
            except Exception as e:
                print(f"Błąd podczas przetwarzania grafiku: {str(e)}")
                process_end = time.time()
                # Kontynuuj mimo błędu

            # Przetwarzanie danych użytkowników
            users_start = time.time()
            try:
                self.user_info_map = {}
                for user_data in users_data:
                    if len(user_data) >= 4:  # Sprawdź czy dane są kompletne
                        user_id, wydzial, przelozony, uzytkownik_dane = user_data
                        self.user_info_map[user_id] = {
                            'wydzial': wydzial or 'Nieznany',
                            'przelozony': przelozony or 'Nieznany',
                            'uzytkownik_dane': uzytkownik_dane or f"{user_id}"
                        }
                users_end = self.log_time("Przetwarzanie użytkowników", users_start)
            except Exception as e:
                print(f"Błąd podczas przetwarzania użytkowników: {str(e)}")
                users_end = time.time()
                # Kontynuuj mimo błędu

            # Przetwarzanie zdarzeń - ta część może powodować problemy
            events_start = time.time()
            try:
                self.all_events_data = []
                if events_data:
                    for event_data in events_data:
                        try:
                            if len(event_data) >= 9:  # Sprawdź czy dane są kompletne
                                event_type, topic, name, event_user_id, event_date, time_from, time_to, status, event_id = event_data

                                # Pobierz dane użytkownika - bezpiecznie
                                user_info = self.user_info_map.get(event_user_id, {
                                    'wydzial': 'Nieznany',
                                    'przelozony': 'Nieznany',
                                    'uzytkownik_dane': f"{event_user_id}"
                                })
                                user_name = user_info.get('uzytkownik_dane', f"{event_user_id}")

                                # Bezpieczne formatowanie dat
                                date_obj = "01.01.2025"  # Wartość domyślna
                                date_key = event_date  # Zachowaj oryginalną datę

                                if event_date:
                                    try:
                                        if isinstance(event_date, str):
                                            date_parts = event_date.split(' ')[0].split('-')
                                            if len(date_parts) >= 3:
                                                date_obj = f"{date_parts[2]}.{date_parts[1]}.{date_parts[0]}"
                                        else:
                                            date_obj = event_date.strftime('%d.%m.%Y')
                                    except:
                                        # W przypadku problemu z formatowaniem daty
                                        pass

                                # Bezpieczne formatowanie czasu
                                time_from_obj = "00:00"
                                time_to_obj = "00:00"

                                try:
                                    if time_from:
                                        time_from_obj = time_from.strftime('%H:%M')
                                except:
                                    pass

                                try:
                                    if time_to:
                                        time_to_obj = time_to.strftime('%H:%M')
                                except:
                                    pass

                                self.all_events_data.append({
                                    'type': event_type or 'Nieznany',
                                    'topic': topic or '',
                                    'name': name or '',
                                    'user_id': event_user_id,
                                    'user_name': user_name,
                                    'date': date_obj,
                                    'date_key': date_key,
                                    'time_from': time_from_obj,
                                    'time_to': time_to_obj,
                                    'status': status or 'Nieznany',
                                    'id': event_id
                                })
                        except Exception as event_error:
                            print(f"Błąd podczas przetwarzania zdarzenia: {str(event_error)}")
                            continue  # Przejdź do następnego zdarzenia



                events_end = self.log_time(f"Przetwarzanie {len(self.all_events_data)} zdarzeń", events_start)
            except Exception as e:
                print(f"Błąd podczas przetwarzania zdarzeń: {str(e)}")
                events_end = time.time()
                # Kontynuuj mimo błędu - już mamy grafik

            # Aktualizacja interfejsu - każda operacja zabezpieczona oddzielnie
            ui_start = time.time()

            # Aktualizacja filtrów
            filters_start = time.time()
            try:
                self.update_filters()
                filters_end = self.log_time("Aktualizacja filtrów", filters_start)
            except Exception as e:
                print(f"Błąd podczas aktualizacji filtrów: {str(e)}")
                filters_end = time.time()

            # Aktualizacja tabeli
            table_start = time.time()
            try:
                self.update_filtered_table()
                table_end = self.log_time("Aktualizacja tabeli grafiku", table_start)
            except Exception as e:
                print(f"Błąd podczas aktualizacji tabeli: {str(e)}")
                table_end = time.time()

            # Aktualizacja dat
            dates_start = time.time()
            try:
                self.update_filter_dates()
                dates_end = self.log_time("Aktualizacja dat", dates_start)
            except Exception as e:
                print(f"Błąd podczas aktualizacji dat: {str(e)}")
                dates_end = time.time()

            # Aktualizacja zdarzeń
            selection_start = time.time()
            try:
                # To może być problematyczne - obsługujemy tylko jeśli zainicjalizowano zdarzenia
                if hasattr(self, 'all_events_data') and self.all_events_data:
                    self.on_selection_changed()
                selection_end = self.log_time("Aktualizacja zdarzeń", selection_start)
            except Exception as e:
                print(f"Błąd podczas aktualizacji zaznaczenia: {str(e)}")
                selection_end = time.time()

            self.log_time("Całkowity czas aktualizacji UI", ui_start)

            # Na końcu metody również upewnij się, że nagłówek pionowy jest ukryty
            self.table.verticalHeader().setVisible(True)

        except Exception as e:

            print(f"Błąd podczas przetwarzania danych: {str(e)}")

            QMessageBox.critical(

                self,

                "Błąd",

                f"Wystąpił błąd podczas przetwarzania danych: {str(e)}",

                QMessageBox.StandardButton.Ok

            )


    def get_selected_items(self, list_widget):
        """Zwraca teksty zaznaczonych elementów z listy"""
        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item.isSelected():
                selected.append(item.text())
        return selected

    def update_filters(self):
        # Aktualizacja filtrów na podstawie pobranych danych
        # Zapamiętaj bieżące zaznaczenia
        selected_wydzialy = self.get_selected_items(self.wydzial_list)
        selected_przelozeni = self.get_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_selected_items(self.uzytkownik_list)

        # Wydziały
        self.wydzial_list.clear()
        wydzialy = set()
        for key in self.processed_data.keys():
            wydzial = key[0]
            wydzialy.add(wydzial)

        for wydzial in sorted(wydzialy):
            item = QListWidgetItem(wydzial)
            self.wydzial_list.addItem(item)
            # Przywróć zaznaczenie jeśli było
            if wydzial in selected_wydzialy:
                item.setSelected(True)

        # Aktualizacja przełożonych
        self.update_przelozony_filter(selected_przelozeni)

        # Aktualizacja użytkowników
        self.update_uzytkownik_filter(selected_uzytkownicy)

    def update_przelozony_filter(self, selected_przelozeni=None):
        # Aktualizacja listy przełożonych na podstawie wybranych wydziałów
        if selected_przelozeni is None:
            selected_przelozeni = []

        self.przelozony_list.clear()

        selected_wydzialy = self.get_selected_items(self.wydzial_list)

        przelozeni = set()
        for key in self.processed_data.keys():
            wydzial, przelozony, _, _ = key
            if not selected_wydzialy or wydzial in selected_wydzialy:
                przelozeni.add(przelozony)

        for przelozony in sorted(przelozeni):
            item = QListWidgetItem(przelozony)
            self.przelozony_list.addItem(item)
            # Przywróć zaznaczenie jeśli było
            if przelozony in selected_przelozeni:
                item.setSelected(True)

    def update_uzytkownik_filter(self, selected_uzytkownicy=None):
        # Aktualizacja listy użytkowników na podstawie wybranych wydziałów i przełożonych
        if selected_uzytkownicy is None:
            selected_uzytkownicy = []

        self.uzytkownik_list.clear()

        selected_wydzialy = self.get_selected_items(self.wydzial_list)
        selected_przelozeni = self.get_selected_items(self.przelozony_list)

        uzytkownicy_data = []
        for key in self.processed_data.keys():
            wydzial, przelozony, uzytkownik_dane, uzytkownik = key
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni):
                uzytkownicy_data.append(uzytkownik_dane)

        for uzytkownik in sorted(uzytkownicy_data):
            item = QListWidgetItem(str(uzytkownik))
            self.uzytkownik_list.addItem(item)
            # Przywróć zaznaczenie jeśli było
            if str(uzytkownik) in selected_uzytkownicy:
                item.setSelected(True)

    def process_data(self, data):
        # Przetwarzamy dane do struktury:

        self.processed_data = {}

        for row in data:
            try:
                # Stała liczba kolumn z nr_kadrowy i start_hour
                wydzial, przelozony, uzytkownik_dane, uzytkownik, data_str, symbol, godziny_pracy, id_wpisu, spotkania, szkolenia, nadgodziny, start_hour, nr_kadrowy = row

                # Klucz dla grupy (wydział, przełożony, użytkownik)
                key = (wydzial, przelozony, uzytkownik_dane, uzytkownik)

                # Jeśli nie ma jeszcze wpisu dla tego klucza, utwórz go
                if key not in self.processed_data:
                    self.processed_data[key] = {'days': {}, 'total_hours': 0}

                # Jeśli data_str nie jest None, dodaj symbol i godziny dla odpowiedniego dnia
                if data_str:
                    day = int(data_str.split('-')[2])  # Pobierz dzień z daty w formacie 'YYYY-MM-DD'
                    self.processed_data[key]['days'][day] = {
                        'symbol': symbol,
                        'hours': godziny_pracy if godziny_pracy is not None else 0,
                        'id': id_wpisu,
                        'spotkania': spotkania if spotkania is not None else 0,
                        'szkolenia': szkolenia if szkolenia is not None else 0,
                        'nadgodziny': nadgodziny if nadgodziny is not None else 0,
                        'start_hour': start_hour,  # Dodaj godzinę rozpoczęcia
                        'nr_kadrowy': nr_kadrowy  # Dodaj numer kadrowy
                    }

                    # Sumuj godziny pracy
                    if godziny_pracy is not None:
                        self.processed_data[key]['total_hours'] += godziny_pracy
            except Exception as e:
                print(f"Błąd podczas przetwarzania wiersza danych: {e}, liczba kolumn: {len(row)}")
                print(f"Dane wiersza: {row}")
                continue  # Kontynuuj z następnym wierszem w przypadku błędu

    def update_table_content(self):
        start_time = time.time()

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month_idx = current_data

        # Określ liczbę dni w miesiącu
        if month_idx in [4, 6, 9, 11]:
            days_in_month = 30
        elif month_idx == 2:  # Luty
            if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):  # Rok przestępny
                days_in_month = 29
            else:
                days_in_month = 28
        else:
            days_in_month = 31

        # Konfiguracja tabeli
        self.table.clear()

        # Ustawienie liczby kolumn (Wydział, Przełożony, Pracownik, dni miesiąca, Suma RBH)
        self.table.setColumnCount(3 + days_in_month + 1)

        # Ustawienie nagłówków kolumn
        headers = ["Wydział", "Przełożony", "Pracownik"]
        for day in range(1, days_in_month + 1):
            # Ustal dzień tygodnia
            date = QDate(year, month_idx, day)
            day_of_week = date.dayOfWeek()  # 1=Pon, 2=Wt, ..., 7=Nie

            # Ustal etykietę dnia tygodnia
            day_labels = ["Pon", "Wt", "Śr", "Czw", "Pt", "Sob", "Nie"]
            day_label = day_labels[day_of_week - 1]

            headers.append(f"{day}\n{day_label}")

        # Dodaj nagłówek suma RBH
        headers.append("Suma RBH")

        self.table.setHorizontalHeaderLabels(headers)

        # Znajdź kolumny z weekendami i ustaw je w niestandardowym nagłówku
        weekend_columns = []
        for col in range(3, 3 + days_in_month):
            day = col - 2
            date = QDate(year, month_idx, day)
            day_of_week = date.dayOfWeek()

            # Jeśli to weekend (sobota=6, niedziela=7)
            if day_of_week >= 6:
                weekend_columns.append(col)
        # Ustaw kolumny weekendowe w niestandardowym nagłówku
        header = self.table.horizontalHeader()
        if isinstance(header, WeekendAwareHeaderView):
            header.set_weekend_columns(weekend_columns, self.is_dark_theme)
            # Ważne - wymuś odświeżenie nagłówka
            header.viewport().update()

        # Ustaw szerokość kolumn
        self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Wydział
        self.table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Przełożony
        self.table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)  # Pracownik

        # Dla dni miesiąca - stała szerokość
        for i in range(3, 3 + days_in_month):
            self.table.horizontalHeader().setSectionResizeMode(i, QHeaderView.Interactive)
            self.table.setColumnWidth(i, 70)  # Szerokość kolumn z dniami

        # Kolumna z sumą RBH
        suma_rbh_col = 3 + days_in_month
        self.table.horizontalHeader().setSectionResizeMode(suma_rbh_col, QHeaderView.ResizeToContents)

        # Wypełnianie tabeli tylko widocznymi wierszami
        self.table.setRowCount(len(self.visible_rows))

        # Dodaj delegata do tabeli aby obsługiwał niestandardowe rysowanie
        self.table.setItemDelegate(OvertimeItemDelegate())

        for row_idx, orig_idx in enumerate(self.visible_rows):
            key = list(self.processed_data.keys())[orig_idx]
            data = self.processed_data[key]
            wydzial, przelozony, uzytkownik_dane, uzytkownik = key
            day_data = data['days']
            total_hours = data['total_hours']

            # Podstawowe informacje
            self.table.setItem(row_idx, 0, QTableWidgetItem(wydzial))
            self.table.setItem(row_idx, 1, QTableWidgetItem(przelozony))
            self.table.setItem(row_idx, 2, QTableWidgetItem(uzytkownik_dane))

            # Symbole grafiku dla poszczególnych dni
            for day in range(1, days_in_month + 1):
                if day in day_data:
                    # Komórka z danymi
                    try:
                        symbol = day_data[day]['symbol']
                        start_hour = day_data[day].get('start_hour')  # Pobierz godzinę rozpoczęcia

                        # Sprawdź różne typy zdarzeń
                        has_meeting = day_data[day].get('spotkania', 0)
                        has_training = day_data[day].get('szkolenia', 0)
                        has_overtime = day_data[day].get('nadgodziny', 0)

                        # Utwórz nowy element tabeli
                        item = QTableWidgetItem(symbol)

                        # Ustaw dane o nadgodzinach w UserRole
                        item.setData(Qt.UserRole, bool(has_overtime))

                        # Dodaj ikonę dla spotkań i szkoleń
                        if (has_meeting or has_training):
                            item.setData(Qt.UserRole + 1, True)

                        # Ustaw kolor tła na podstawie godziny rozpoczęcia
                        if start_hour is not None:
                            background_color = self.get_cell_color_by_time(start_hour)
                            item.setBackground(background_color)

                            # Określ jasność tła i dostosuj kolor tekstu
                            brightness = (
                                                     background_color.red() * 299 + background_color.green() * 587 + background_color.blue() * 114) / 1000
                            if brightness > 128:
                                item.setForeground(QColor(0, 0, 0))  # Czarny tekst dla jasnego tła
                            else:
                                item.setForeground(QColor(255, 255, 255))  # Biały tekst dla ciemnego tła

                        # Kolorowanie specjalnych symboli
                        if symbol and "OS" in symbol:
                            item.setBackground(QColor(255, 180, 0))  # Pomarańczowy dla OS
                            item.setForeground(QColor(0, 0, 0))  # Czarny tekst dla jasnego tła
                        elif symbol and "U" in symbol:
                            item.setBackground(QColor(255, 180, 0))  # Pomarańczowy dla U
                            item.setForeground(QColor(0, 0, 0))  # Czarny tekst dla jasnego tła

                    except Exception as e:
                        print(f"Błąd podczas tworzenia komórki: {e}")
                        # W przypadku błędu, użyj standardowej komórki
                        item = QTableWidgetItem(day_data[day].get('symbol', ''))

                    # Dodaj element do tabeli
                    self.table.setItem(row_idx, 2 + day, item)
                else:
                    # Pusta komórka bez danych w grafiku
                    item = QTableWidgetItem("")

                    # Sprawdzamy czy mamy zbuforowane dane o zdarzeniach
                    if hasattr(self, 'events_index'):
                        try:
                            # Tworzymy nową datę dla tego dnia w formacie string
                            date_str = f"{year}-{month_idx:02d}-{day:02d}"  # Format YYYY-MM-DD

                            # Przygotuj identyfikator użytkownika jako string dla porównania
                            user_id_str = str(uzytkownik)

                            # Użyj indeksu zdarzeń do sprawdzenia, czy istnieją zdarzenia dla tej pary (użytkownik, data)
                            events_for_cell = self.data_provider.get_events_for_user_date(user_id_str, date_str)

                            # Flagi na zdarzenia
                            has_meeting = False
                            has_training = False
                            has_overtime = False

                            # Sprawdź typy zdarzeń
                            for event in events_for_cell:
                                event_type = event.get('type', '')
                                if event_type == 'Spotkanie':
                                    has_meeting = True
                                elif event_type == 'Szkolenie':
                                    has_training = True
                                elif event_type == 'Nadgodziny':
                                    has_overtime = True

                                # Optymalizacja - jeśli mamy już wszystkie typy zdarzeń, przerywamy pętlę
                                if has_meeting and has_training and has_overtime:
                                    break

                            # Ustaw dane o nadgodzinach
                            item.setData(Qt.UserRole, has_overtime)

                            # Jeśli element ma spotkanie lub szkolenie, zapisz ikonę w DecorationRole
                            if (has_meeting or has_training):
                                item.setData(Qt.UserRole + 1, True)

                        except Exception as e:
                            print(
                                f"Błąd podczas sprawdzania zdarzeń dla pustej komórki ({day}.{month_idx}.{year}, {uzytkownik}): {e}")
                    # Dodaj pustą komórkę do tabeli
                    self.table.setItem(row_idx, 2 + day, item)

            # Suma RBH
            self.table.setItem(row_idx, suma_rbh_col, QTableWidgetItem(str(total_hours)))

        # Dopasuj wysokość wierszy
        self.table.resizeRowsToContents()

        self.log_time("Aktualizacja zawartości tabeli grafiku", start_time)

        # Numer wiersza
        self.table.verticalHeader().setVisible(True)

    def get_cell_color_by_time(self, hour):
        """
        Zwraca kolor tła komórki na podstawie godziny rozpoczęcia.
        Godziny są mapowane na kolory w bardziej czytelnej palecie.

        Args:
            hour (int): Godzina rozpoczęcia zmiany (0-23)

        Returns:
            QColor: Kolor tła komórki
        """
        # Domyślny kolor (przezroczysty) gdy godzina nie jest zdefiniowana
        if hour is None or hour < 0 or hour > 23:
            return QColor(255, 255, 255, 0)  # Przezroczysty

        # Mapowanie godzin na kolory - zharmonizowana paleta
        if hour == 5:
            return QColor(204, 255, 255)  # Jasny błękit (bardzo jasny cyjan)
        elif hour == 6:
            return QColor(204, 255, 255)  # Jasny błękit (bardzo jasny cyjan)
        elif hour == 7:
            return QColor(0, 255, 255)  # Cyjan (akwamaryna)
        elif hour == 8:
            return QColor(0, 204, 255)  # Jasny błękit (niebieskozielony)
        elif hour == 9:
            return QColor(0, 255, 0)  # Limonkowy (czysty zielony)
        elif hour == 10:
            return QColor(153, 204, 0)  # Oliwkowy (żółtozielony)
        elif hour == 11:
            return QColor(204, 255, 204)  # Bardzo jasny zielony (miętowy)
        elif hour == 12:
            return QColor(255, 255, 153)  # Bardzo jasny żółty (kremowy)
        elif hour == 13:
            return QColor(255, 204, 153)  # Jasny łososiowy (brzoskwiniowy)
        elif hour == 14:
            return QColor(255, 153, 0)  # Ciemny pomarańczowy
        elif hour == 15:
            return QColor(255, 0, 255)  # Magenta (fuksja)
        elif hour == 16:
            return QColor(204, 0, 0)  # Ciemnoczerwony
        elif hour == 17:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 18:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 19:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 20:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 21:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 22:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 23:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 0:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour in [1, 2, 3, 4]:
            return QColor(51, 51, 51)  # Ciemny szary

        # Domyślny kolor dla innych wartości
        return QColor(255, 255, 255, 0)  # Przezroczysty

    def update_table(self):
        # Inicjalizacja widocznych wierszy - wszystkie wiersze są widoczne
        self.visible_rows = list(range(len(self.processed_data)))
        self.update_table_content()

    def on_selection_changed(self):
        """Obsługuje zmianę zaznaczenia w tabeli grafiku"""
        start_time = time.time()
        selected_ranges = self.table.selectedRanges()

        # Jeśli nie ma zaznaczenia, wyczyść tabelę zdarzeń
        if not selected_ranges:
            print("Brak zaznaczenia - czyszczę tabelę zdarzeń")
            self.events_data = []
            self.events_table.setRowCount(0)
            return

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month_idx = current_data

        # Zbierz informacje o zaznaczonych komórkach
        selected_cells = []
        processed_keys = list(self.processed_data.keys())
        processed_cells = set()

        for range_item in selected_ranges:
            # Iteruj po zaznaczonych komórkach
            for table_row in range(range_item.topRow(), range_item.bottomRow() + 1):
                # Sprawdź czy wiersz istnieje
                if table_row >= len(self.visible_rows):
                    continue

                data_row = self.visible_rows[table_row]
                # Sprawdź czy wiersz danych istnieje
                if data_row >= len(processed_keys):
                    continue

                # Pobierz klucz dla tego wiersza
                key = processed_keys[data_row]
                wydzial, przelozony, uzytkownik_dane, uzytkownik = key

                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawdź czy to komórka z dniem miesiąca
                    if col < 3:
                        continue

                    # Pomijamy już przetworzone komórki
                    cell_key = (table_row, col)
                    if cell_key in processed_cells:
                        continue
                    processed_cells.add(cell_key)

                    # Pobierz dzień z kolumny
                    day = col - 2

                    # Upewnij się, że dzień jest prawidłowy
                    if day < 1:
                        continue

                    # Przygotuj dane komórki
                    date_str = f"{year}-{month_idx:02d}-{day:02d}"  # Format YYYY-MM-DD

                    # Pobierz dane dla tego dnia, jeśli istnieją
                    day_data = self.processed_data[key]['days'].get(day)

                    # Zbierz dane o komórce
                    selected_cells.append({
                        'wydzial': wydzial,
                        'przelozony': przelozony,
                        'uzytkownik_dane': uzytkownik_dane,
                        'uzytkownik_id': uzytkownik,
                        'day': day,
                        'date_str': date_str,
                        'symbol': day_data.get('symbol') if day_data else None,
                        'hours': day_data.get('hours') if day_data else None,
                        'id': day_data.get('id') if day_data else None
                    })

        print(f"Zaznaczono {len(selected_cells)} komórek grafiku")

        # Ładuj zdarzenia dla zaznaczonych komórek
        if selected_cells:
            self.load_events_for_selection(selected_cells)

        self.log_time("Obsługa zmiany zaznaczenia", start_time)



    def load_all_events_for_month(self, year, month):
        """Ładuje wszystkie zdarzenia dla wybranego miesiąca"""
        start_time = time.time()

        # Pobierz wybrane filtry
        selected_wydzialy = self.get_selected_items(self.wydzial_list)
        selected_przelozeni = self.get_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_selected_items(self.uzytkownik_list)

        print(
            f"Filtry: Wydziały({len(selected_wydzialy)}), Przełożeni({len(selected_przelozeni)}), Użytkownicy({len(selected_uzytkownicy)})")

        # Pobierz zdarzenia używając DataProvider
        events = self.data_provider.get_events_data(year, month, as_dict=True)

        # Zastosuj dodatkowe filtry wydziałów, przełożonych, użytkowników
        if selected_wydzialy or selected_przelozeni or selected_uzytkownicy:
            filtered_events = []
            for event in events:
                event_user_id = event.get('user_id')
                user_info = self.user_info_map.get(event_user_id, {})

                # Sprawdź filtry
                if selected_wydzialy and user_info.get('wydzial') not in selected_wydzialy:
                    continue
                if selected_przelozeni and user_info.get('przelozony') not in selected_przelozeni:
                    continue
                if selected_uzytkownicy and str(event_user_id) not in selected_uzytkownicy:
                    continue

                filtered_events.append(event)

            events = filtered_events

        # Aktualizuj dane zdarzeń
        self.events_data = events

        print(f"Znaleziono {len(self.events_data)} zdarzeń dla miesiąca {month}/{year} z zastosowaniem filtrów")

        # Aktualizuj tabelę zdarzeń
        self.filter_events_table()

        self.log_time(f"Ładowanie wszystkich zdarzeń dla miesiąca {month}/{year}", start_time)

    def load_events_for_selection(self, selected_cells):
        """Ładuje zdarzenia dla wybranych komórek w grafiku"""
        start_time = time.time()

        # Jeśli nie ma zaznaczonych komórek, wyczyść tabelę zdarzeń
        if not selected_cells:
            print("Brak zaznaczonych komórek - czyszczę tabelę zdarzeń")
            self.events_data = []
            self.events_table.setRowCount(0)
            return

        # Czyść poprzednie dane
        self.events_data = []

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if current_data:
            year, month_idx = current_data

        # Pobierz zdarzenia dla każdej zaznaczonej komórki
        for cell in selected_cells:
            user_id = cell['uzytkownik_id']

            # Sprawdź, czy mamy już date_str, jeśli nie, utwórz ją
            if 'date_str' in cell:
                date_str = cell['date_str']
            else:
                # Jeśli brak date_str, utwórz na podstawie dnia, roku i miesiąca
                day = cell['day']
                date_str = f"{year}-{month_idx:02d}-{day:02d}"  # Format YYYY-MM-DD

            print(f"Szukam zdarzeń dla użytkownika {user_id} i daty {date_str}")

            # Pobierz zdarzenia dla tej pary użytkownik-data
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

            print(f"Znaleziono {len(user_events)} zdarzeń dla komórki")

            # Dodaj znalezione zdarzenia do listy events_data (bez duplikatów)
            for event in user_events:
                event_id = event.get('id')
                if not any(e.get('id') == event_id for e in self.events_data):
                    self.events_data.append(event)

        print(f"Łącznie znaleziono {len(self.events_data)} zdarzeń dla {len(selected_cells)} komórek")

        # Aktualizuj tabelę zdarzeń
        self.filter_events_table()

        self.log_time(f"Ładowanie zdarzeń dla {len(selected_cells)} komórek", start_time)

    def filter_events_table(self):
        """Filtruje tabelę zdarzeń na podstawie zaznaczonych filtrów i zakresów dat"""
        try:
            start_time = time.time()
            # Wyświetl informacje o aktualnych danych zdarzeń
            print(
                f"filter_events_table: liczba wszystkich zdarzeń: {len(self.events_data) if hasattr(self, 'events_data') and isinstance(self.events_data, list) else 'brak'}")

            # Szybkie sprawdzenie czy jest co filtrować
            if not hasattr(self, 'events_data') or not isinstance(self.events_data, list) or not self.events_data:
                print("Brak danych zdarzeń do filtrowania")
                self.events_table.setRowCount(0)  # Wyczyść tabelę
                return

            # Pobierz zaznaczone typy zdarzeń
            allowed_types = []
            if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
                allowed_types.append('Spotkanie')
            if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
                allowed_types.append('Szkolenie')
            if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
                allowed_types.append('Nadgodziny')

            print(f"Dozwolone typy zdarzeń: {allowed_types}")

            # DODANE: Pobierz daty z kontrolek i przekształć na format YYYY-MM-DD
            date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
            date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

            # Przygotuj parametry filtrowania
            filter_params = {}

            # Dodaj filtr typów zdarzeń
            if allowed_types:
                filter_params['allowed_types'] = allowed_types

            # Dodaj filtry tematu i nazwy
            topic_filter = self.topic_filter.text().lower() if hasattr(self,
                                                                       'topic_filter') and self.topic_filter.text() else None
            name_filter = self.name_filter.text().lower() if hasattr(self,
                                                                     'name_filter') and self.name_filter.text() else None

            if topic_filter:
                filter_params['topic'] = topic_filter
            if name_filter:
                filter_params['name'] = name_filter

            # DODANE: Dodaj filtry zakresu dat
            if date_from_str:
                filter_params['date_from'] = date_from_str
            if date_to_str:
                filter_params['date_to'] = date_to_str

            print(f"Parametry filtrowania: {filter_params}")

            # Zoptymalizowane filtrowanie - tylko jeden przebieg przez dane
            filtered_data = []

            # OPTYMALIZACJA: Używamy list comprehension zamiast pętli for dla szybszego filtrowania
            events_to_filter = self.events_data.copy()

            # Filtruj po typie (jeśli podano)
            if 'allowed_types' in filter_params:
                events_to_filter = [e for e in events_to_filter if e.get('type', '') in filter_params['allowed_types']]

            # Filtruj po temacie (jeśli podano)
            if 'topic' in filter_params:
                events_to_filter = [e for e in events_to_filter if
                                    filter_params['topic'] in str(e.get('topic', '')).lower()]

            # Filtruj po nazwie (jeśli podano)
            if 'name' in filter_params:
                events_to_filter = [e for e in events_to_filter if
                                    filter_params['name'] in str(e.get('name', '')).lower()]

            # Filtruj po dacie od (jeśli podano)
            if 'date_from' in filter_params:
                events_to_filter = [e for e in events_to_filter if
                                    self.standardize_date(e.get('date_key', '')) >= filter_params['date_from']]

            # Filtruj po dacie do (jeśli podano)
            if 'date_to' in filter_params:
                events_to_filter = [e for e in events_to_filter if
                                    self.standardize_date(e.get('date_key', '')) <= filter_params['date_to']]

            filtered_data = events_to_filter

            print(f"Po filtrowaniu pozostało {len(filtered_data)} zdarzeń")
            filtering_time = self.log_time("Filtrowanie zdarzeń", start_time)

            # Aktualizuj tabelę używając zoptymalizowanej metody
            self.update_events_table(filtered_data)

        except Exception as e:
            print(f"Błąd podczas filtrowania zdarzeń: {str(e)}")
            import traceback
            traceback.print_exc()
            # Wyczyść tabelę w przypadku błędu
            self.events_table.setRowCount(0)

    def standardize_date(self, date_obj):
        """
        Standaryzuje format daty do 'YYYY-MM-DD' dla porównań

        Args:
            date_obj: Data w dowolnym formacie (string, datetime, itp.)

        Returns:
            str: Data w formacie 'YYYY-MM-DD'
        """
        if not date_obj:
            return ''

        # Jeśli to już string, wyciągnij tylko datę
        if isinstance(date_obj, str):
            # Obsługa różnych formatów
            if 'T' in date_obj:  # Format ISO 'YYYY-MM-DDThh:mm:ss'
                return date_obj.split('T')[0]
            elif ' ' in date_obj:  # Format 'YYYY-MM-DD hh:mm:ss'
                return date_obj.split(' ')[0]
            elif len(date_obj) == 10 and date_obj.count('-') == 2:  # Format 'YYYY-MM-DD'
                return date_obj
            # Jeśli nie dopasowano do żadnego formatu, zwróć oryginalny string
            return date_obj

        # Jeśli to obiekt datetime, skonwertuj na string
        if hasattr(date_obj, 'strftime'):
            return date_obj.strftime('%Y-%m-%d')

        # W przypadku nieznanego typu, zwróć pusty string
        return ''

    def update_events_table(self, filtered_data):
        """
        Aktualizuje tabelę zdarzeń w zoptymalizowany sposób - przygotowuje wszystkie
        dane przed ich umieszczeniem w tabeli i wiąże przyciski bezpośrednio z danymi zdarzenia.
        """
        start_time = time.time()

        # Ustawienie rozmiaru tabeli - tylko raz!
        self.events_table.setRowCount(len(filtered_data))

        # Zapobiegaj wywołaniu sygnałów sortowania podczas wypełniania tabeli
        self.events_table.setSortingEnabled(False)

        # Listy do przechowywania obiektów do umieszczenia w tabeli
        table_items = []

        # Przygotuj wszystkie elementy tabeli w pamięci
        for row, event in enumerate(filtered_data):
            # Id zdarzenia - nowa kolumna
            event_id = event.get('id', '')
            id_item = QTableWidgetItem(str(event_id))
            # Zapisz ID zdarzenia jako dane użytkownika (ważne dla sortowania)
            id_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 0, id_item))

            # Typ
            event_type = event.get('type', '')
            type_item = QTableWidgetItem(event_type)
            type_item.setData(Qt.UserRole, event_id)  # Zapisz ID zdarzenia
            if event_type == 'Spotkanie':
                type_item.setBackground(QColor(100, 149, 237))  # Cornflower Blue
            elif event_type == 'Szkolenie':
                type_item.setBackground(QColor(144, 238, 144))  # Light Green
            elif event_type == 'Nadgodziny':
                type_item.setBackground(QColor(255, 165, 0))  # Orange
            table_items.append((row, 1, type_item))

            # Pozostałe kolumny - tekstowe, wszystkie z zapisanym ID zdarzenia
            topic_item = QTableWidgetItem(str(event.get('topic', '')))
            topic_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 2, topic_item))

            name_item = QTableWidgetItem(str(event.get('name', '')))
            name_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 3, name_item))

            # WAŻNA ZMIANA: Użyj user_name (pełnej nazwy użytkownika) zamiast samego ID
            user_name = event.get('user_name', '')
            if not user_name:
                # Jeśli nie ma user_name, pokaż ID i spróbuj pobrać dane z user_info_map
                user_id = event.get('user_id', '')
                user_info = self.user_info_map.get(user_id, {})
                user_name = user_info.get('uzytkownik_dane', str(user_id))

            user_item = QTableWidgetItem(str(user_name))
            user_item.setData(Qt.UserRole, event_id)
            # Zapisz również ID użytkownika jako dodatkowe dane (dla filtrowania)
            user_item.setData(Qt.UserRole + 1, event.get('user_id', ''))
            table_items.append((row, 4, user_item))

            date_item = QTableWidgetItem(str(event.get('date', '')))
            date_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 5, date_item))

            time_from_item = QTableWidgetItem(str(event.get('time_from', '')))
            time_from_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 6, time_from_item))

            time_to_item = QTableWidgetItem(str(event.get('time_to', '')))
            time_to_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 7, time_to_item))

            status_item = QTableWidgetItem(str(event.get('status', '')))
            status_item.setData(Qt.UserRole, event_id)
            table_items.append((row, 8, status_item))

        # Umieść wszystkie przygotowane elementy w tabeli - szybsza operacja
        for row, col, item in table_items:
            self.events_table.setItem(row, col, item)

        # Teraz utwórz i dodaj przyciski
        for row, event in enumerate(filtered_data):
            event_id = event.get('id', '')
            event_type = event.get('type', '')

            # Utwórz przycisk usuwania
            delete_button = QPushButton("Usuń")
            delete_button.setStyleSheet("""
                background-color: #e74c3c;
                color: white;
                border-radius: 3px;
                padding: 3px;
                font-weight: bold;
            """)

            # Ważne: użyj closure, aby zachować aktualną wartość event_id i event_type
            def create_click_handler(event_id, event_type):
                return lambda: self.delete_event(event_id, event_type)

            # Podłącz funkcję do przycisku z konkretnymi wartościami event_id i event_type
            delete_button.clicked.connect(create_click_handler(event_id, event_type))

            # Dodaj przycisk do komórki
            self.events_table.setCellWidget(row, 9, delete_button)  # Kolumna 9 dla Akcji

        # Dopasuj wysokość wierszy tylko raz na końcu
        self.events_table.resizeRowsToContents()

        # Włącz ponownie sortowanie
        self.events_table.setSortingEnabled(True)

        self.log_time(f"Aktualizacja tabeli zdarzeń ({len(filtered_data)} wierszy)", start_time)

    def cancel_delegations(self):
        """
        Odwołuje delegacje (spotkania i szkolenia) dla zaznaczonych komórek w grafiku.
        Wykorzystuje indeks zdarzeń do szybkiego znalezienia delegacji do odwołania.
        """
        # Pobierz zaznaczone komórki
        selected_ranges = self.table.selectedRanges()
        current_data = self.date_combo.currentData()

        if not current_data:
            QMessageBox.warning(
                self,
                "Brak danych",
                "Nie wybrano miesiąca lub brak dostępnych danych do wyświetlenia.",
                QMessageBox.Ok
            )
            return

        if not selected_ranges:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono żadnych komórek do odwołania delegacji.",
                QMessageBox.Ok
            )
            return

        # Pobierz rok i miesiąc tylko raz
        year, month_idx = current_data

        # Oblicz liczbę dni w miesiącu tylko raz
        if month_idx in [4, 6, 9, 11]:
            days_in_month = 30
        elif month_idx == 2:
            if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                days_in_month = 29
            else:
                days_in_month = 28
        else:
            days_in_month = 31

        # Przygotuj listę kluczy z self.processed_data raz
        processed_keys = list(self.processed_data.keys())

        # Zbierz informacje o zaznaczonych komórkach
        user_date_pairs = set()
        for range_item in selected_ranges:
            # Ogranicz zakres wierszy do widocznych
            top_row = max(0, range_item.topRow())
            bottom_row = min(range_item.bottomRow(), len(self.visible_rows) - 1)
            # Ogranicz zakres kolumn do dni miesiąca
            left_col = max(3, range_item.leftColumn())
            right_col = min(range_item.rightColumn(), 2 + days_in_month)

            for table_row in range(top_row, bottom_row + 1):
                # Zamiast używać visible_rows, pobierz dane bezpośrednio z tabeli
                pracownik_item = self.table.item(table_row, 2)  # Kolumna "Pracownik"
                if not pracownik_item:
                    continue

                # Znajdź użytkownika na podstawie nazwy
                user_id = None
                for key in processed_keys:
                    _, _, name, id_user = key
                    if name == pracownik_item.text():
                        user_id = id_user
                        break

                if not user_id:
                    continue

                for col in range(left_col, right_col + 1):
                    day = col - 2
                    date_str = f"{year}-{month_idx:02d}-{day:02d}"

                    # Dodaj parę (użytkownik, data) do zbioru
                    user_date_pairs.add((user_id, date_str))

        # Jeśli nie znaleziono par użytkownik-data, pokaż komunikat
        if not user_date_pairs:
            QMessageBox.information(
                self,
                "Brak danych",
                "Nie znaleziono danych dla zaznaczonych komórek.",
                QMessageBox.Ok
            )
            return

        # Przygotuj listę zdarzeń do odwołania
        events_to_cancel = []

        # Użyj indeksu zdarzeń do szybkiego znalezienia delegacji
        for user_id, date_str in user_date_pairs:
            # Pobierz zdarzenia dla tej pary użytkownik-data z indeksu
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

            # Filtruj tylko spotkania i szkolenia
            for event in user_events:
                event_type = event.get('type', '')
                event_id = event.get('id')
                if event_type in ['Spotkanie', 'Szkolenie'] and event_id:
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                    })

        # Jeśli nie znaleziono delegacji do odwołania, pokaż komunikat
        if not events_to_cancel:
            QMessageBox.information(
                self,
                "Brak delegacji",
                "Nie znaleziono delegacji do odwołania dla zaznaczonych komórek.",
                QMessageBox.Ok
            )
            return

        # Pokaż komunikat potwierdzenia
        reply = QMessageBox.question(
            self,
            "Potwierdzenie",
            f"Czy na pewno chcesz odwołać {len(events_to_cancel)} delegacji (spotkania i szkolenia) "
            f"dla {len(user_date_pairs)} zaznaczonych komórek?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )

        if reply != QMessageBox.Yes:
            return

        # Pobierz identyfikator użytkownika
        _, user_app_id, _ = get_modifier_id()

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            canceled_count = 0

            # Lista identyfikatorów zdarzeń, które zostały anulowane
            canceled_event_ids = []

            # Dla każdego zdarzenia do odwołania
            for event in events_to_cancel:
                event_id = event['id']
                event_type = event['type']
                user_id = event['user_id']
                date_key = event.get('date_key')

                # Określ odpowiednią tabelę
                table_name = "p_t_zz_Spotkania" if event_type == "Spotkanie" else "p_t_zz_Szkolenia"

                # Aktualizuj status zdarzenia
                update_query = f"""
                UPDATE {table_name} 
                SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? 
                WHERE Id = ?
                """
                cursor.execute(update_query, (user_app_id, event_id))
                canceled_count += 1

                # Dodaj ID zdarzenia do listy anulowanych
                canceled_event_ids.append(event_id)

                # Usuń zdarzenie z indeksu zdarzeń
                self.data_provider.delete_event_from_index(event_id, event_type)

                # Aktualizuj ikony
                self.update_table_icons_after_event_deletion(user_id, date_key, event_type)

            conn.commit()
            conn.close()

            try:
                # Pobierz najnowszą datę modyfikacji po wykonaniu zmian
                query = """
                        SELECT MAX(DataModyfikacji) as DataModyfikacji FROM p_v_zz_GrafikiPracy
                    """
                conn = DatabaseConnector.get_connection()
                cursor = conn.cursor()
                cursor.execute(query)
                result = cursor.fetchone()
                conn.close()

                if result and result[0]:
                    # Zapisz tę datę jako własną modyfikację
                    self.last_self_modification_date = result[0]
                    self.last_modification_date = result[0]  # Aktualizuj również ostatnią znaną modyfikację
                    print(f"Zarejestrowano własną modyfikację z datą: {self.last_self_modification_date}")
            except Exception as e:
                print(f"Błąd podczas rejestrowania własnej modyfikacji: {e}")

            # Zapamiętaj bieżące zaznaczenie przed odświeżeniem
            current_selection = []
            for range_item in selected_ranges:
                current_selection.append((
                    range_item.topRow(),
                    range_item.leftColumn(),
                    range_item.bottomRow(),
                    range_item.rightColumn()
                ))

            # WAŻNA ZMIANA: Usuń anulowane zdarzenia z listy zdarzeń w pamięci
            if canceled_event_ids:
                self.events_data = [event for event in self.events_data
                                    if event.get('id') not in canceled_event_ids]
                print(
                    f"Usunięto {len(canceled_event_ids)} zdarzeń z listy events_data. Pozostało {len(self.events_data)} zdarzeń.")

            # Wymuś pełne odświeżenie całej tabeli
            self.table.viewport().update()

            # Wymuś odświeżenie tabeli zdarzeń
            self.filter_events_table()

            # Przywróć zaznaczenie
            for top, left, bottom, right in current_selection:
                try:
                    selection_range = QTableWidgetSelectionRange(top, left, bottom, right)
                    self.table.setRangeSelected(selection_range, True)
                except Exception as e:
                    print(f"Błąd podczas przywracania zaznaczenia: {e}")

            # Pokaż informację o odwołanych delegacjach
            QMessageBox.information(
                self,
                "Sukces",
                f"Odwołano {canceled_count} delegacji z {len(events_to_cancel)} znalezionych.",
                QMessageBox.Ok
            )

        except Exception as e:
            print(f"Błąd podczas odwoływania delegacji: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.critical(
                self,
                "Błąd",
                f"Wystąpił błąd podczas odwoływania delegacji: {str(e)}",
                QMessageBox.Ok
            )

    def delete_event(self, event_id, event_type):
        """Usuwa zdarzenie z bazy danych i z indeksu zdarzeń, a następnie aktualizuje ikonki w komórkach grafiku"""
        # Pokaż komunikat potwierdzenia
        reply = QMessageBox.question(
            self,
            "Potwierdzenie",
            f"Czy na pewno chcesz usunąć {event_type.lower()} o ID {event_id}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No
        )

        if reply != QMessageBox.StandardButton.Yes:
            return

        # Określenie tabeli i typu operacji w zależności od typu zdarzenia
        table_name = ""
        operation_type = ""

        if event_type == "Spotkanie":
            table_name = "p_t_zz_Spotkania"
            operation_type = "Usunięcie spotkania"
        elif event_type == "Szkolenie":
            table_name = "p_t_zz_Szkolenia"
            operation_type = "Usunięcie szkolenia"
        elif event_type == "Nadgodziny":
            table_name = "p_t_zz_Nadgodziny"
            operation_type = "Usunięcie nadgodzin"

        if not table_name:
            QMessageBox.warning(
                self,
                "Błąd",
                "Nieprawidłowy typ zdarzenia.",
                QMessageBox.StandardButton.Ok
            )
            return

        try:
            # Zapamiętaj bieżące zaznaczenie w tabeli grafiku
            current_selection = self.table.selectedRanges()
            current_selection_data = []
            for range_item in current_selection:
                current_selection_data.append((
                    range_item.topRow(),
                    range_item.leftColumn(),
                    range_item.bottomRow(),
                    range_item.rightColumn()
                ))

            # Znajdź właściwe dane zdarzenia z listy events_data
            user_id = None
            date_key = None
            event_to_remove = None

            # Szukaj w bieżących wydarzeniach (które są wyświetlane w tabeli)
            for event in self.events_data:
                if event.get('id') == event_id and event.get('type') == event_type:
                    user_id = event.get('user_id')
                    date_key = event.get('date_key')
                    event_to_remove = event
                    break

            # Jeśli nie znaleziono w events_data, spróbuj w indeksie (jako zapasowe)
            if not user_id or not date_key:
                event = self.data_provider.get_event_by_id(event_id)
                if event and event.get('type') == event_type:
                    user_id = event.get('user_id')
                    date_key = event.get('date_key')

            if not user_id or not date_key:
                QMessageBox.warning(
                    self,
                    "Błąd",
                    f"Nie znaleziono zdarzenia o ID {event_id} i typie {event_type}.",
                    QMessageBox.StandardButton.Ok
                )
                return

            print(f'ID: {event_id} , Typ: {event_type} , Uzytkownik: {user_id}, Data: {date_key}')

            # Pobierz identyfikator użytkownika
            _, user_app_id, _ = get_modifier_id()

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # Usuń rekord z bazy danych - używamy identyfikatora użytkownika
            if event_type in ["Spotkanie", "Szkolenie"]:
                # Dla spotkań i szkoleń zmieniamy status zamiast usuwać
                # Dodatkowo resetujemy DataDo na NULL i ustawiamy DataOd na wartość z pola Data
                query = f"""UPDATE {table_name} 
                         SET Status = 0, 
                            DataDo = NULL, 
                            DataOd = Data, 
                            Modyfikujacy = ? 
                        WHERE Id = ?
                        """
                cursor.execute(query, (user_app_id, event_id))
            else:
                # Dla nadgodzin usuwamy rekord
                query = f"DELETE FROM {table_name} WHERE Id = ?"
                cursor.execute(query, (event_id,))

            conn.commit()
            conn.close()

            # Usuń zdarzenie z indeksu w DataProvider
            success_index_removal = False
            if hasattr(self.data_provider, 'delete_event_from_index'):
                success_index_removal = self.data_provider.delete_event_from_index(event_id, event_type)
                if success_index_removal:
                    print(f"Usunięto zdarzenie o ID {event_id} i typie {event_type} z indeksu")

            # WAŻNE: Usuń zdarzenie z bieżącej listy zdarzeń - to naprawia problem z aktualizacją tabeli
            if event_to_remove:
                self.events_data.remove(event_to_remove)
                print(f"Usunięto zdarzenie z listy events_data. Pozostało {len(self.events_data)} zdarzeń.")
            else:
                # Alternatywnie, jeśli nie znaleziono konkretnego obiektu
                self.events_data = [event for event in self.events_data if
                                    not (event.get('id') == event_id and event.get('type') == event_type)]
                print(f"Przefiltrowano events_data. Pozostało {len(self.events_data)} zdarzeń.")

            # Aktualizuj ikonki w komórce grafiku
            self.update_table_icons_after_event_deletion(user_id, date_key, event_type)

            # Wymuś odświeżenie całej tabeli grafiku
            self.table.viewport().update()

            # Wymuś odświeżenie tabeli zdarzeń
            self.filter_events_table()

            # Przywróć zaznaczenie tabeli
            for top_row, left_col, bottom_row, right_col in current_selection_data:
                selection_range = QTableWidgetSelectionRange(top_row, left_col, bottom_row, right_col)
                self.table.setRangeSelected(selection_range, True)

            # Ponowne załadowanie zdarzeń dla aktualnego zaznaczenia NIE JEST KONIECZNE
            # ponieważ już usunęliśmy zdarzenie z events_data i odświeżyliśmy tabelę zdarzeń
            # self.on_selection_changed()

            # Pokaż komunikat sukcesu
            QMessageBox.information(
                self,
                "Sukces",
                f"{event_type} o ID {event_id} zostało pomyślnie usunięte.",
                QMessageBox.StandardButton.Ok
            )

        except Exception as e:
            QMessageBox.critical(
                self,
                "Błąd",
                f"Wystąpił błąd podczas usuwania zdarzenia: {str(e)}",
                QMessageBox.StandardButton.Ok
            )
            import traceback
            traceback.print_exc()

    def show_insert_change_dialog(self):
        """Pokazuje okno dialogowe do wstawiania zmian w grafiku"""
        # Pobierz aktualną datę z tabeli grafiku
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Błąd",
                "Nie wybrano miesiąca. Nie można dodać zmiany grafiku.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone komórki, aby ustalić dzień i użytkownika
        selected_cells = self.get_selected_schedule_cells()

        if not selected_cells:
            QMessageBox.warning(
                self,
                "Brak zaznaczenia",
                "Nie zaznaczono żadnych komórek do edycji.",
                QMessageBox.Ok
            )
            return

        # Grupuj komórki według użytkownika i dnia dla łatwiejszej edycji
        grouped_cells = self.group_cells_by_user_and_day(selected_cells)

        # Utwórz dialog
        dialog = ScheduleChangeDialog(self, grouped_cells, year, month)
        dialog.exec()

    def get_selected_schedule_cells(self):
        """Zwraca listę zaznaczonych komórek z siatki grafiku"""
        selected_cells = []
        selected_ranges = self.table.selectedRanges()

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            return selected_cells
        year, month_idx = current_data

        for range_item in selected_ranges:
            for table_row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawdź czy to komórka z grafikiem
                    if col >= 3:
                        if table_row < len(self.visible_rows):
                            data_row = self.visible_rows[table_row]
                            if data_row < len(self.processed_data):
                                key = list(self.processed_data.keys())[data_row]
                                wydzial, przelozony, uzytkownik_dane, uzytkownik = key
                                day = col - 2
                                day_data = self.processed_data[key]['days'].get(day)

                                if day_data:
                                    # Format daty jako YYYY-MM-DD
                                    date_str = f"{year}-{month_idx:02d}-{day:02d}"

                                    # Pobierz nr_kadrowy bezpośrednio z danych dnia (zgodnie z Twoim komentarzem)
                                    nr_kadrowy = day_data.get('nr_kadrowy')

                                    selected_cells.append({
                                        'user_id': uzytkownik,
                                        'user_name': uzytkownik_dane,
                                        'day': day,
                                        'date': date_str,
                                        'id': day_data.get('id'),
                                        'current_symbol': day_data.get('symbol', ''),
                                        'start_hour': day_data.get('start_hour'),
                                        'nr_kadrowy': nr_kadrowy  # Dodajemy nr_kadrowy z kolumny grafiku
                                    })
        return selected_cells

    def group_cells_by_user_and_day(self, cells):
        """Grupuje komórki według użytkownika i dnia dla łatwiejszej edycji"""
        grouped = {}
        for cell in cells:
            user_id = cell['user_id']
            date = cell['date']

            if user_id not in grouped:
                grouped[user_id] = {}

            if date not in grouped[user_id]:
                grouped[user_id][date] = []

            grouped[user_id][date].append(cell)

        return grouped

    def update_table_icons_after_event_deletion(self, user_id, date_str, deleted_event_type=None):
        """
        Aktualizuje ikonki w komórkach grafiku po usunięciu zdarzenia

        Args:
            user_id: ID użytkownika
            date_str: Data w formacie 'YYYY-MM-DD'
            deleted_event_type: Typ usuniętego zdarzenia
        """
        try:
            print(f"Aktualizacja ikon dla użytkownika {user_id}, data {date_str}, typ {deleted_event_type}")

            # Standardyzuj format daty (użyj metody z DataProvider)
            date_str = date_str.split(' ')[0] if ' ' in date_str else date_str  # Usuń czas

            # Upewnij się, że mamy datę w formacie YYYY-MM-DD
            if not date_str or date_str.count('-') != 2:
                print(f"Nieprawidłowy format daty: {date_str}")
                return

            year, month, day = date_str.split('-')
            day = int(day)
            month = int(month)
            year = int(year)

            # Sprawdź, jakie zdarzenia pozostały dla tej pary (użytkownik, data)
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str)
            print(f"Znaleziono {len(user_events)} zdarzeń dla użytkownika {user_id} na dzień {date_str}")

            # Sprawdź typy zdarzeń
            has_meeting = any(e.get('type') == 'Spotkanie' for e in user_events)
            has_training = any(e.get('type') == 'Szkolenie' for e in user_events)
            has_overtime = any(e.get('type') == 'Nadgodziny' for e in user_events)

            print(f"Status ikon: spotkania={has_meeting}, szkolenia={has_training}, nadgodziny={has_overtime}")

            # Znajdź odpowiednią komórkę w tabeli
            found = False
            for row in range(self.table.rowCount()):
                # Znajdź kolumnę z odpowiednim dniem
                col = 2 + day  # Pierwsza kolumna dnia ma indeks 3 (0-bazowany) = 2 + 1

                # Pobierz dane użytkownika z kolumny "Pracownik" (indeks 2)
                pracownik_item = self.table.item(row, 2)
                if not pracownik_item:
                    continue

                # Znajdź odpowiednią komórkę
                cell_item = self.table.item(row, col)
                if not cell_item:
                    continue

                # Znajdź klucz pasujący do użytkownika
                for key in self.processed_data.keys():
                    _, _, user_name, uid = key
                    if user_name == pracownik_item.text() and str(uid) == str(user_id):
                        # Znaleźliśmy właściwą komórkę
                        print(f"Znaleziono komórkę ({row}, {col}) dla użytkownika {user_id}")

                        # Zaktualizuj dane komórki
                        cell_item.setData(Qt.UserRole, has_overtime)  # Informacja o nadgodzinach
                        cell_item.setData(Qt.UserRole + 1,
                                          has_meeting or has_training)  # Informacja o spotkaniach/szkoleniach


                        found = True
                        break

                if found:
                    break

            if not found:
                print(f"Nie znaleziono komórki dla użytkownika {user_id} i dnia {day}")

        except Exception as e:
            print(f"Błąd podczas aktualizacji ikonek w komórkach grafiku: {str(e)}")
            import traceback
            traceback.print_exc()

    def show_add_overtime_dialog(self):
        """Pokazuje okno dialogowe do dodawania nadgodzin z niestandardowymi opcjami"""
        # Pobierz bieżącą datę z tabeli grafiku
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(
                self,
                "Błąd",
                "Nie wybrano miesiąca. Nie można dodać nadgodzin.",
                QMessageBox.Ok
            )
            return

        year, month = current_data

        # Pobierz zaznaczone komórki, aby ustalić dzień i użytkownika
        selected_ranges = self.table.selectedRanges()
        selected_user_id = None
        selected_user_name = None
        nr_kadrowy = None
        selected_date = None
        start_hour = 8  # Domyślna godzina rozpoczęcia
        hours_worked = 8  # Domyślna liczba godzin pracy

        if selected_ranges:
            # Pobierz dane z zaznaczonych komórek
            selected_cells = self.get_selected_schedule_cells()

            if selected_cells:
                # Bierzemy dane z pierwszej zaznaczonej komórki
                first_cell = selected_cells[0]
                selected_user_id = first_cell.get('user_id')

                # Szukamy nazwy użytkownika w danych
                for key in self.processed_data.keys():
                    _, _, user_name, user_id = key
                    if str(user_id) == str(selected_user_id):
                        selected_user_name = user_name
                        break

                # Pobieramy nr_kadrowy bezpośrednio z danych komórki
                nr_kadrowy = first_cell.get('nr_kadrowy')

                # Ustawiamy datę
                date_str = first_cell.get('date')
                if date_str:
                    try:
                        year_part, month_part, day_part = date_str.split('-')
                        selected_date = QDate(int(year_part), int(month_part), int(day_part))
                    except:
                        pass

                # Pobierz godzinę rozpoczęcia i liczbę godzin pracy z danych komórki
                day_data = first_cell.get('day_data', {})
                start_hour = first_cell.get('start_hour')
                if start_hour is None:
                    start_hour = 8  # Domyślna godzina, jeśli nie znaleziono

                # Oblicz koniec zmiany na podstawie godziny rozpoczęcia i liczby godzin
                day = first_cell.get('day')
                key = None
                for k in self.processed_data.keys():
                    _, _, _, uid = k
                    if str(uid) == str(selected_user_id):
                        key = k
                        break

                if key and day:
                    day_data = self.processed_data[key]['days'].get(day, {})
                    symbol = day_data.get('symbol', '')

                    # Próba wyciągnięcia liczby godzin z symbolu
                    if symbol and ';' in symbol:
                        parts = symbol.split(';')
                        if len(parts) >= 3 and parts[2].isdigit():
                            hours_worked = int(parts[2])

                    # Jeśli nie udało się wyciągnąć z symbolu, sprawdź czy mamy godziny pracy w danych dnia
                    if hours_worked == 8 and 'hours' in day_data:
                        hours_worked = day_data.get('hours', 8)

        # Jeśli nie ma zaznaczenia, użyj dzisiejszej daty i bieżącego użytkownika
        if selected_date is None:
            selected_date = QDate.currentDate()
            # Pobierz domyślny numer kadrowy bieżącego użytkownika tylko jeśli nie mamy nr_kadrowy
            if nr_kadrowy is None:
                nr_kadrowy, user_app_id, _ = get_modifier_id()
                selected_user_name = user_app_id  # Domyślnie używamy ID aplikacji jako nazwy
                print(f"Używam domyślnego numeru kadrowego bieżącego użytkownika: {nr_kadrowy}")

        # Utwórz okno dialogowe
        dialog = QDialog(self)

        # Nazwy miesięcy po polsku
        polish_months = [
            "stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca",
            "lipca", "sierpnia", "września", "października", "listopada", "grudnia"
        ]

        month_name = polish_months[selected_date.month() - 1]
        dialog.setWindowTitle(f"Dodaj nadgodziny w dniu {selected_date.day()} {month_name} {selected_date.year()}")
        dialog.setMinimumWidth(600)

        layout = QVBoxLayout(dialog)

        # Informacja o pracowniku
        if selected_user_name:
            user_info_label = QLabel(f"Pracownik: {selected_user_name}")
            user_info_label.setStyleSheet("font-weight: bold; margin-bottom: 10px;")
            layout.addWidget(user_info_label)

        # Informacja o numerze kadrowym
        if nr_kadrowy:
            kadrowy_info_label = QLabel(f"Numer kadrowy: {nr_kadrowy}")
            kadrowy_info_label.setStyleSheet("margin-bottom: 10px;")
            layout.addWidget(kadrowy_info_label)

        # Informacja o miesiącu rozliczenia
        settlement_month = month
        settlement_year = year
        settlement_info = QLabel(f"Miesiąc rozliczenia: {settlement_month:02d}.{settlement_year}")
        settlement_info.setStyleSheet("margin-bottom: 10px;")
        layout.addWidget(settlement_info)

        # Formularz wprowadzania
        form_frame = QFrame()
        form_frame.setFrameShape(QFrame.StyledPanel)
        form_frame.setFrameShadow(QFrame.Raised)
        form_layout = QGridLayout(form_frame)

        # Etykiety
        od_label = QLabel("od kiedy")
        ile_label = QLabel("ile godzin")
        typ_label = QLabel("typ")
        ld_label = QLabel("LD")
        zalegle_label = QLabel("czy zaległe")

        # Kontrolki wprowadzania
        # Combo z czasem co 30 minut - ze zwiększoną szerokością
        time_combo = QComboBox()
        time_combo.setMinimumWidth(60)  # Zwiększona szerokość

        # Oblicz koniec zmiany (godzina rozpoczęcia + liczba godzin pracy)
        end_hour = (start_hour + hours_worked) % 24

        for hour in range(0, 24):
            for minute in [0, 30]:
                time_combo.addItem(f"{hour:02d}:{minute:02d}", f"{hour:02d}:{minute:02d}")

        # Ustaw czas rozpoczęcia nadgodzin na koniec zmiany (czyli godzinę rozpoczęcia + liczba godzin)
        default_time = f"{end_hour:02d}:00"
        index = time_combo.findText(default_time)
        if index != -1:
            time_combo.setCurrentIndex(index)
        else:
            time_combo.setCurrentText(default_time)

        # Combo z liczbą godzin do 13.0
        hours_combo = QComboBox()
        hours_combo.setMinimumWidth(50)  # Zwiększona szerokość
        for hours in [0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 6.0, 6.5, 7.0, 7.5, 8.0, 8.5, 9.0, 9.5,
                      10.0, 10.5, 11.0, 11.5, 12.0, 12.5, 13.0]:
            hours_combo.addItem(f"{hours:.1f}", hours)
        hours_combo.setCurrentIndex(1)  # Domyślnie 1.0

        # Typ: wypłata, odbiór, odpracowanie
        type_combo = QComboBox()
        type_combo.addItem("wypłata", "wypłata")
        type_combo.addItem("odbiór", "odbiór")
        type_combo.addItem("odpracowanie", "odpracowanie")

        # LD (lokalizacja): h, p, s
        ld_combo = QComboBox()
        ld_combo.addItem("h", "h")  # Hybrydowa
        ld_combo.addItem("p", "p")  # Praca zdalna
        ld_combo.addItem("s", "s")  # Stacjonarna

        # Czy zaległe
        overdue_combo = QComboBox()
        overdue_combo.addItem("nie", 0)
        overdue_combo.addItem("tak", 1)

        # Przycisk dodawania
        add_button = QPushButton("Dodaj")
        add_button.setStyleSheet("background-color: #333; color: white; font-weight: bold;")

        # Dodaj kontrolki do layoutu
        form_layout.addWidget(od_label, 0, 0)
        form_layout.addWidget(time_combo, 0, 1)
        form_layout.addWidget(ile_label, 0, 2)
        form_layout.addWidget(hours_combo, 0, 3)
        form_layout.addWidget(typ_label, 0, 4)
        form_layout.addWidget(type_combo, 0, 5)
        form_layout.addWidget(ld_label, 0, 6)
        form_layout.addWidget(ld_combo, 0, 7)
        form_layout.addWidget(zalegle_label, 0, 8)
        form_layout.addWidget(overdue_combo, 0, 9)
        form_layout.addWidget(add_button, 0, 10)

        # Dodaj formularz do głównego layoutu
        layout.addWidget(form_frame)

        # Funkcja dodawania nadgodzin
        def add_overtime():
            try:
                # Pobierz dane z formularza
                start_time = time_combo.currentText()
                hours = float(hours_combo.currentData())
                overtime_type = type_combo.currentData()
                location = ld_combo.currentData()  # Lokalizacja: h, p, s
                is_overdue = overdue_combo.currentData()

                # Data rozliczenia to pierwszy dzień bieżącego miesiąca
                settlement_date_str = f"{settlement_year}-{settlement_month:02d}-01"

                # Wywołaj procedurę składowaną z poprawnie zmapowanymi parametrami
                # Używamy nr_kadrowy z danych komórki zamiast domyślnej wartości
                result = self.call_add_overtime_procedure(
                    selected_user_id,
                    selected_date.year(),
                    selected_date.month(),
                    selected_date.toString("yyyy-MM-dd"),
                    start_time,
                    hours,
                    settlement_date_str,
                    is_overdue,
                    overtime_type,
                    location,
                    nr_kadrowy  # Przekazujemy nr_kadrowy do procedury
                )

                # Obsłuż wynik
                if result["success"]:
                    QMessageBox.information(dialog, "Sukces", result["message"], QMessageBox.Ok)
                    dialog.accept()  # Zamknij dialog po sukcesie

                    # Odśwież DataProvider dla bieżącego miesiąca
                    current_data = self.date_combo.currentData()
                    if current_data:
                        year, month = current_data
                        self.data_provider.refresh_data(year, month)
                else:
                    QMessageBox.warning(dialog, "Błąd", result["message"], QMessageBox.Ok)

            except Exception as e:
                QMessageBox.critical(dialog, "Błąd", f"Wystąpił błąd: {str(e)}", QMessageBox.Ok)

        # Podłącz funkcję do przycisku
        add_button.clicked.connect(add_overtime)

        # Pokaż dialog
        dialog.exec()

def call_add_overtime_procedure(self, user_id, year, month, date_str, start_time, hours, settlement_date,
                                is_overdue, overtime_type, location, nr_kadrowy):
    """
    Wywołuje procedurę składowaną p_P_ZZ_NadgodzinyWstawienie_v3 z poprawnym mapowaniem parametrów

    Args:
        user_id (str): ID użytkownika
        year (int): Rok
        month (int): Miesiąc
        date_str (str): Data w formacie 'YYYY-MM-DD'
        start_time (str): Czas rozpoczęcia w formacie 'HH:MM'
        hours (float): Liczba godzin
        settlement_date (str): Data rozliczenia w formacie 'YYYY-MM-DD'
        is_overdue (int): Czy zaległe (0/1)
        overtime_type (str): Typ nadgodzin (wypłata/odbiór/odpracowanie)
        location (str): Lokalizacja (h, p, s)
        nr_kadrowy (str, optional): Numer kadrowy użytkownika

    Returns:
        dict: Wynik operacji z kluczami 'success' i 'message'
    """
    try:

        # Mapowanie lokalizacji na wartości liczbowe:
        # h - 1, p - 2, s - 3
        location_map = {'h': 1, 'p': 2, 's': 3}
        location_value = location_map.get(location, 1)  # Domyślnie 1 (h)

        # Mapowanie typu nadgodzin:
        # wypłata i odbiór - NULL (nie przekazujemy), odpracowanie - 1
        param_value = None
        if overtime_type == 'odpracowanie':
            param_value = 1

        # Określenie wartości @odebrane:
        # 1 dla typu "odbiór", 0 dla pozostałych
        odebrane_value = 1 if overtime_type == 'odbiór' else 0

        # Oblicz datę i czas zakończenia
        start_datetime = datetime.strptime(f"{date_str} {start_time}", "%Y-%m-%d %H:%M")
        end_datetime = start_datetime + timedelta(hours=hours)
        end_time = end_datetime.strftime("%H:%M")

        # Utwórz połączenie do bazy danych
        conn = DatabaseConnector.get_connection()
        cursor = conn.cursor()

        # Przygotuj parametry dla procedury składowanej
        params = [
            nr_kadrowy,  # @Nr_Kadrowy - używamy pobranego numeru kadrowego
            year,  # @Rok
            month,  # @Miesiac
            date_str,  # @Data
            start_time,  # @DataOd
            end_time,  # @DataDo
            settlement_date,  # @MiesiacRozliczenia
            is_overdue,  # @Zalegle
            odebrane_value,  # @Odebrane - 1 dla odbioru, 0 dla innych
            location_value,  # @lokalizacja - zmapowana wartość (1, 2, 3)
        ]

        # Dodaj parametr @Parametr tylko dla odpracowania, w przeciwnym razie użyj NULL
        if param_value is not None:
            params.append(param_value)  # @Parametr - tylko dla odpracowania (wartość 1)
        else:
            params.append(None)  # Dla wypłaty i odbioru - NULL

        # Przygotuj wywołanie procedury składowanej z odpowiednią liczbą parametrów
        placeholders = ", ".join(["?"] * len(params))
        sql = f"{{CALL [dbo].[p_P_ZZ_NadgodzinyWstawienie_v3] ({placeholders})}}"

        # Wywołaj procedurę składowaną
        cursor.execute(sql, params)

        # Pobierz wyniki z instrukcji SELECT zwróconej przez procedurę
        result_sets = []

        # Procedura może zwrócić więcej niż jeden zestaw wyników (jeśli ma wiele SELECT)
        while True:
            try:
                rows = cursor.fetchall()
                if rows:
                    result_sets.append(rows)

                # Sprawdź, czy są kolejne zestawy wyników
                if not cursor.nextset():
                    break
            except:
                break

        # Domyślny komunikat, jeśli nie otrzymamy żadnego
        success = False
        message = "Nieznany wynik operacji."

        # ID nowo dodanego rekordu, jeśli dostępne
        new_id = None

        # Sprawdź wyniki - zwykle pierwszy zestaw wyników (jeśli jest)
        # zawiera informację o sukcesie/porażce i komunikat
        if result_sets and result_sets[0]:
            first_result = result_sets[0][0]  # Pobierz pierwszy wiersz z pierwszego zestawu wyników

            # Pobierz komunikat z wyników
            message = str(first_result[0]) if first_result and len(first_result) > 0 else "Operacja zakończona."

            # ZMIANA: Procedura zwraca "0" lub pusty string jako sukces
            if message == "0" or message == "":
                success = True
                message = "Nadgodziny zostały pomyślnie dodane."
            else:
                # Niepusty komunikat różny od "0" oznacza błąd
                success = False

            # Sprawdź, czy mamy ID nowego rekordu (może być zwrócone w drugim zestawie wyników)
            if len(result_sets) > 1 and result_sets[1]:
                try:
                    new_id = result_sets[1][0][0]  # Pierwszy wiersz, pierwsza kolumna drugiego zestawu wyników
                except:
                    pass

        # Zatwierdź transakcję i zamknij połączenie
        conn.commit()
        conn.close()

        if success:
            try:
                # Pobierz najnowszą datę modyfikacji po wykonaniu zmian
                query = """
                        SELECT MAX(DataModyfikacji) as DataModyfikacji FROM p_v_zz_GrafikiPracy
                    """
                conn = DatabaseConnector.get_connection()
                cursor = conn.cursor()
                cursor.execute(query)
                result = cursor.fetchone()
                conn.close()

                if result and result[0]:
                    # Zapisz tę datę jako własną modyfikację
                    self.last_self_modification_date = result[0]
                    self.last_modification_date = result[0]  # Aktualizuj również ostatnią znaną modyfikację
                    print(f"Zarejestrowano własną modyfikację z datą: {self.last_self_modification_date}")
            except Exception as e:
                print(f"Błąd podczas rejestrowania własnej modyfikacji: {e}")

            # Jeśli dodanie się powiodło i znamy ID, pobierz dodane nadgodziny i dodaj do indeksu
            if success and new_id:
                self.update_overtime_in_index(new_id, user_id, date_str, start_time, end_time)
                
                # DODANE: Odśwież tabelę zdarzeń po dodaniu nadgodzin
                current_data = self.date_combo.currentData()
                if current_data:
                    year, month = current_data
                    # Odśwież dane w DataProvider
                    self.data_provider.refresh_data(year, month)
                    
                    # Aktualizuj ikony w komórce grafiku po dodaniu nadgodzin
                    self.update_table_icons_after_event_addition(user_id, date_str, "Nadgodziny")
                    
                    # Wymuś odświeżenie tabeli grafiku
                    self.table.viewport().update()
                    
                    # Odśwież tabelę zdarzeń, ale zachowaj zaznaczenie
                    selected_ranges = self.table.selectedRanges()
                    self.on_selection_changed()  # To odświeży tabelę zdarzeń
                    
                    # Przywróć zaznaczenie
                    for range_item in selected_ranges:
                        self.table.setRangeSelected(range_item, True)

            return {
                "success": success,
                "message": message,
                "new_id": new_id
            }

        except Exception as e:
            print(f"Błąd podczas dodawania nadgodzin: {e}")
            return {
                "success": False,
                "message": f"Wystąpił błąd: {str(e)}"
            }

    # Nowa metoda do aktualizacji indeksu zdarzeń po dodaniu nadgodzin
    def update_overtime_in_index(self, overtime_id, user_id, date_str, start_time, end_time):
        try:
            # Pobierz informacje o użytkowniku
            user_info = self.user_info_map.get(user_id, {
                'wydzial': 'Nieznany',
                'przelozony': 'Nieznany',
                'uzytkownik_dane': f"{user_id}"
            })
            user_name = user_info.get('uzytkownik_dane', f"{user_id}")

            # Formatuj datę do wyświetlenia (zamień YYYY-MM-DD na DD.MM.YYYY)
            display_date = ".".join(reversed(date_str.split("-")))

            # Utwórz obiekt zdarzenia
            new_overtime = {
                'type': 'Nadgodziny',
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'user_name': user_name,
                'date': display_date,
                'date_key': date_str,
                'time_from': start_time,
                'time_to': end_time,
                'status': 'Wstawione',
                'id': overtime_id
            }

            # Poprawne wywołanie - używamy events_index zamiast bezpośrednio data_provider
            if hasattr(self.data_provider, 'events_index'):
                self.data_provider.events_index.add_event(new_overtime)

            # Dodaj również do listy wszystkich zdarzeń
            if hasattr(self, 'all_events_data'):
                self.all_events_data.append(new_overtime)

            print(f"Dodano nadgodziny (ID: {overtime_id}) do indeksu zdarzeń")

        except Exception as e:
            print(f"Błąd podczas aktualizacji indeksu zdarzeń po dodaniu nadgodzin: {str(e)}")

    def show_theme_settings(self):
        """Pokazuje okno dialogowe z ustawieniami motywu"""
        theme = "dark" if self.is_dark_theme else "light"
        dialog = ThemeSettingsDialog(self, theme, self.current_font, self.current_font_size)
        dialog.settings_changed.connect(self.apply_theme_settings)

        # Uruchom dialog
        if dialog.exec() == QDialog.Accepted:
            # Pobierz ustawienia bezpośrednio z dialogu
            theme = dialog.get_current_theme()
            font = dialog.font_combo.currentFont().family()
            font_size = dialog.font_size_spin.value()

            # Sprawdź, czy użytkownik chce zapisać ustawienia
            save_settings = dialog.save_settings_checkbox.isChecked()

            # Zapisz ustawienia
            self.save_theme_settings(theme, font, font_size, save_settings)



    def save_theme_settings(self, theme, font_family, font_size, save_to_db):
        """Zapisuje ustawienia motywu trwale"""
        # Zaktualizuj lokalne ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Jeśli zaznaczono opcję zapamiętania, zapisz w bazie
        if save_to_db:
            try:
                self.settings_db.save_settings(theme, font_family, font_size)
                print(f"Ustawienia zostały zapisane do bazy danych: {theme}, {font_family}, {font_size}")
            except Exception as e:
                print(f"Błąd podczas zapisywania ustawień: {e}")

        # Zastosuj ustawienia nawet jeśli nie zapisujemy do bazy
        self.apply_theme_settings(theme, font_family, font_size)

    def apply_theme_settings(self, theme, font_family, font_size):
        """Stosuje wybrane ustawienia motywu"""
        # Zapamiętaj wybrane ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Zastosuj czcionkę do całej aplikacji
        font = QFont(font_family, font_size)
        QApplication.setFont(font)

        # Zastosuj motyw
        if self.is_dark_theme:
            # Ciemny motyw
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #1e1e1e;
                    color: white;
                }
                QHeaderView {
                    background-color: #2c2c2c;
                    color: white;
                }
                QHeaderView::section {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                }
                QTableWidget {
                    background-color: #2c2c2c;

                    gridline-color: #3a3a3a;
                    border: 1px solid #3a3a3a;
                }
                QTableWidget::item {

                }
                QTableWidget::item:selected {
                    background-color: #3498db;
                }
                QPushButton {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
                QComboBox {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QComboBox::drop-down {
                    border: 0px;
                }
                QComboBox QAbstractItemView {
                    background-color: #2c2c2c;
                    color: white;
                    selection-background-color: #3498db;
                    border: 1px solid #3a3a3a;
                }
                QLabel {
                    color: white;
                }
                QDateEdit {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QDateEdit::drop-down {
                    border: 0px;
                    width: 20px;
                }
                QDateEdit QAbstractItemView {
                    background-color: #2c2c2c;
                    color: white;
                    selection-background-color: #3498db;
                }
                QTabWidget::pane {
                    border: 1px solid #3a3a3a;
                    background-color: #1e1e1e;
                }
                QTabBar::tab {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px 10px;
                    border-top-left-radius: 4px;
                    border-top-right-radius: 4px;
                    margin-right: 2px;
                }
                QTabBar::tab:selected {
                    background-color: #3498db;
                }
                QTabBar::tab:!selected {
                    margin-top: 2px;
                }
            """)

            # Style dla komponentów filtrów
            left_panel_style = "background-color: #1e1e1e; color: white;"
            list_style = """
                QListWidget {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                }
            """
            line_edit_style = """
                QLineEdit {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
            """
            date_edit_style = """
                QDateEdit {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QDateEdit::drop-down {
                    border: 0px;
                    width: 20px;
                }
                QDateEdit QAbstractItemView {
                    background-color: #2c2c2c;
                    color: white;
                    selection-background-color: #3498db;
                }
            """
            label_style = "color: #3498db;"
            title_style = "font-size: 16px; font-weight: bold; color: white;"

            # Styl dla przycisków
            button_style = """
                QPushButton {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """

        else:
            # Jasny motyw
            self.setStyleSheet("""
                QMainWindow, QWidget {
                    background-color: #f5f5f5;
                    color: black;
                }
                QHeaderView {
                    background-color: #e0e0e0;
                    color: black;
                }
                QHeaderView::section {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                }
                QTableWidget {
                    background-color: white;
                    color: black;
                    gridline-color: #cccccc;
                    border: 1px solid #cccccc;
                }
                QTableWidget::item {

                }
                QTableWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
                QPushButton {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #d0d0d0;
                }
                QComboBox {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QComboBox::drop-down {
                    border: 0px;
                }
                QComboBox QAbstractItemView {
                    background-color: white;
                    color: black;
                    selection-background-color: #3498db;
                    selection-color: white;
                    border: 1px solid #cccccc;
                }
                QLabel {
                    color: black;
                }
                QDateEdit {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QDateEdit::drop-down {
                    border: 0px;
                    width: 20px;
                }
                QDateEdit QAbstractItemView {
                    background-color: white;
                    color: black;
                    selection-background-color: #3498db;
                    selection-color: white;
                }
                QTabWidget::pane {
                    border: 1px solid #cccccc;
                    background-color: #f5f5f5;
                }
                QTabBar::tab {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px 10px;
                    border-top-left-radius: 4px;
                    border-top-right-radius: 4px;
                    margin-right: 2px;
                }
                QTabBar::tab:selected {
                    background-color: #3498db;
                    color: white;
                }
                QTabBar::tab:!selected {
                    margin-top: 2px;
                }
            """)

            # Style dla komponentów filtrów
            left_panel_style = "background-color: #f0f0f0; color: black;"
            list_style = """
                QListWidget {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    border-radius: 3px;
                }
                QListWidget::item {
                    padding: 3px;
                }
                QListWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
            """
            line_edit_style = """
                QLineEdit {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
            """
            date_edit_style = """
                QDateEdit {
                    background-color: white;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QDateEdit::drop-down {
                    border: 0px;
                    width: 20px;
                }
                QDateEdit QAbstractItemView {
                    background-color: white;
                    color: black;
                    selection-background-color: #3498db;
                    selection-color: white;
                }
            """
            label_style = "color: #2980b9;"
            title_style = "font-size: 16px; font-weight: bold; color: black;"

            # Styl dla przycisków
            button_style = """
                QPushButton {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: #d0d0d0;
                }
            """

        # Stylizacja comboboxa miesiąca
        if self.is_dark_theme:
            self.date_combo.setStyleSheet("""
                   QComboBox {
                       background-color: #2c2c2c;
                       color: white;
                       border: 1px solid #3a3a3a;
                       padding: 5px;
                       border-radius: 3px;
                   }
                   QComboBox::drop-down {
                       border: 0px;
                       width: 20px;
                   }
                   QComboBox QAbstractItemView {
                       background-color: #2c2c2c;
                       color: white;
                       selection-background-color: #3498db;
                       border: 1px solid #3a3a3a;
                   }
               """)
        else:
            self.date_combo.setStyleSheet("""
                   QComboBox {
                       background-color: white;
                       color: black;
                       border: 1px solid #cccccc;
                       padding: 5px;
                       border-radius: 3px;
                   }
                   QComboBox::drop-down {
                       border: 0px;
                       width: 20px;
                   }
                   QComboBox QAbstractItemView {
                       background-color: white;
                       color: black;
                       selection-background-color: #3498db;
                       selection-color: white;
                       border: 1px solid #cccccc;
                   }
               """)
        # Aktualizuj styl przycisku Zmiany grafiku
        if hasattr(self, 'insert_change_button'):
            if self.is_dark_theme:
                self.insert_change_button.setStyleSheet("""
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 5px;
                    border-radius: 3px;
                """)
            else:
                self.insert_change_button.setStyleSheet("""
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 5px;
                    border-radius: 3px;
                """)

        # Aktualizuj styl przycisku menu
        if self.is_dark_theme:
            self.toggle_menu_button.setStyleSheet("""
                QPushButton {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    border-radius: 4px;
                    font-size: 18px;
                    font-weight: bold;
                }
                QPushButton:hover {
                    background-color: #3a3a3a;
                }
            """)
        else:
            self.toggle_menu_button.setStyleSheet("""
                QPushButton {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    border-radius: 4px;
                    font-size: 18px;
                    font-weight: bold;
                }
                QPushButton:hover {
                    background-color: #d0d0d0;
                }
            """)

        # Stylizacja numerów wierszy
        if self.is_dark_theme:
            self.table.verticalHeader().setStyleSheet("""
                QHeaderView::section {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 3px;
                }
            """)
            self.events_table.verticalHeader().setStyleSheet("""
                QHeaderView::section {
                    background-color: #2c2c2c;
                    color: white;
                    border: 1px solid #3a3a3a;
                    padding: 3px;
                }
            """)
        else:
            self.table.verticalHeader().setStyleSheet("""
                QHeaderView::section {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 3px;
                }
            """)
            self.events_table.verticalHeader().setStyleSheet("""
                QHeaderView::section {
                    background-color: #e0e0e0;
                    color: black;
                    border: 1px solid #cccccc;
                    padding: 3px;
                }
            """)

        # Zastosowanie stylów do wszystkich komponentów
        self._left_panel.setStyleSheet(left_panel_style)

        # Aktualizacja stylów dla list i pól wyszukiwania
        self.wydzial_list.setStyleSheet(list_style)
        self.przelozony_list.setStyleSheet(list_style)
        self.uzytkownik_list.setStyleSheet(list_style)

        self.wydzial_filter.setStyleSheet(line_edit_style)
        self.przelozony_filter.setStyleSheet(line_edit_style)
        self.uzytkownik_filter.setStyleSheet(line_edit_style)

        # Zastosuj styl do przycisków
        self.theme_button.setStyleSheet(button_style)
        self.refresh_button.setStyleSheet(button_style)
        self.clear_filters_button.setStyleSheet(button_style)
        self.insert_symbol_button.setStyleSheet(button_style)
        self.cancel_delegation_button.setStyleSheet(button_style)
        self.add_overtime_button.setStyleSheet(button_style)

        # Zastosuj styl do filtrów zdarzeń
        if hasattr(self, 'date_from'):
            self.date_from.setStyleSheet(date_edit_style)
            self.date_to.setStyleSheet(date_edit_style)
            self.topic_filter.setStyleSheet(line_edit_style)
            self.name_filter.setStyleSheet(line_edit_style)


        # # Aktualizacja stylu separatora
        # if hasattr(self, 'separator_top'):
        #     self.separator_top.setStyleSheet(
        #         "background-color: #3a3a3a;" if self.is_dark_theme else "background-color: #cccccc;")

        # Zastosuj czcionkę i rozmiar do etykiet
        for widget in self.findChildren(QLabel):
            widget.setFont(font)

        # Etykiety w panelu filtrów
        for label in self.findChildren(QLabel):
            if label.text() in ["Wydział:", "Przełożony:", "Użytkownik:"]:
                label.setStyleSheet(label_style)
            elif label.text() == "Filtry":
                label.setStyleSheet(title_style)

        # Aktualizacja czcionki w tabeli
        self.table.setFont(font)
        self.date_combo.setFont(font)

        # Aktualizacja czcionki w nagłówkach tabeli
        header_font = QFont(font_family, font_size)
        self.table.horizontalHeader().setFont(header_font)
        self.table.verticalHeader().setFont(header_font)

        # Dodatkowo aktualizuj styl dla tabeli zdarzeń
        if hasattr(self, 'events_table'):
            self.events_table.setStyleSheet(
                """
                QTableWidget {
                    background-color: #2c2c2c;
                    color: white;
                    gridline-color: #3a3a3a;
                    border: 1px solid #3a3a3a;
                }
                QTableWidget::item {

                }
                QTableWidget::item:selected {
                    background-color: #3498db;
                }
                """
                if self.is_dark_theme else
                """
                QTableWidget {
                    background-color: white;
                    color: black;
                    gridline-color: #cccccc;
                    border: 1px solid #cccccc;
                }
                QTableWidget::item {

                }
                QTableWidget::item:selected {
                    background-color: #3498db;
                    color: white;
                }
                """
            )

            # Aktualizacja czcionki w tabeli zdarzeń
            self.events_table.setFont(font)
            self.events_table.horizontalHeader().setFont(header_font)

        # Aktualizacja kolorów weekendów w nagłówku
        header = self.table.horizontalHeader()
        if isinstance(header, WeekendAwareHeaderView):
            header.dark_theme = self.is_dark_theme

            # Pobierz aktualny rok i miesiąc
            current_data = self.date_combo.currentData()
            if current_data:
                year, month_idx = current_data

                # Określ liczbę dni w miesiącu i znajdź weekendy
                days_in_month = 31  # domyślna wartość
                if month_idx in [4, 6, 9, 11]:
                    days_in_month = 30
                elif month_idx == 2:
                    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                        days_in_month = 29
                    else:
                        days_in_month = 28

                weekend_columns = []
                # Aktualizuj kolory weekendów
                for col in range(3, 3 + days_in_month):
                    day = col - 2
                    date = QDate(year, month_idx, day)
                    day_of_week = date.dayOfWeek()

                    if day_of_week >= 6:  # weekend
                        weekend_columns.append(col)
                        header_item = self.table.horizontalHeaderItem(col)
                        if header_item:
                            if self.is_dark_theme:
                                header_item.setForeground(QColor(255, 99, 71))  # Tomato red dla ciemnego motywu
                            else:
                                header_item.setForeground(QColor(220, 20, 60))  # Crimson dla jasnego motywu

                # Aktualizuj kolumny weekendowe
                header.set_weekend_columns(weekend_columns, self.is_dark_theme)

            # Wymuś odświeżenie widoku nagłówka
            header.viewport().update()

        # Wymuś pełne odświeżenie tabeli grafiku
        current_data = self.date_combo.currentData()
        if current_data:
            # Zapisz bieżące zaznaczenie
            selected_ranges = self.table.selectedRanges()

            # Całkowicie wyczyść i przebuduj tabelę
            self.table.clear()
            self.table.setRowCount(0)
            self.table.setColumnCount(0)

            # Odtwórz zawartość tabeli
            self.update_table_content()

            # Przywróć zaznaczenie (opcjonalnie)
            for range_item in selected_ranges:
                self.table.setRangeSelected(
                    range_item,
                    True
                )


if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = WorkScheduleWindow()
    window.show()
    sys.exit(app.exec())
