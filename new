To typowy niuans biblioteki Qt. Przycisk "Zamknij" w Twoim kodzie był podłączony do metody self.accept (standardowe zachowanie dla dialogów), która zamyka okno, ale nie zawsze wyzwala zdarzenie closeEvent (gdzie umieściliśmy logikę zapisu), zwłaszcza jeśli okno nie jest modalne.
Aby to naprawić, musimy zmienić akcję przycisku "Zamknij" tak, aby wywoływał metodę self.close(). To zadziała tak samo jak kliknięcie "X" w rogu okna i zagwarantuje uruchomienie logiki zapisu.
Oto poprawka w pliku staffing_details_window.py.
Plik: staffing_details_window.py
Znajdź metodę setup_ui i popraw linię łączącą przycisk close_button.
    def setup_ui(self):
        main_layout = QVBoxLayout(self)
        self.info_label = QLabel(f"Analiza obsady i zdarzeń dla miesiąca: {self._month:02}.{self._year}")
        main_layout.addWidget(self.info_label)
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)

        self._create_hourly_staffing_tab()
        self._create_daily_staffing_tab()
        self._create_forecast_tab()
        self._create_overtime_tab()
        self._create_symbols_tab()
        self._create_absence_analysis_tab()
        self._create_flexibility_analysis_tab()

        buttons_layout = QHBoxLayout()
        buttons_layout.addStretch()
        self.refresh_button = QPushButton("Odśwież")
        self.refresh_button.clicked.connect(self.load_and_display_data)
        
        self.close_button = QPushButton("Zamknij")
        
        # --- POPRAWKA: Zmiana z self.accept na self.close ---
        # self.close() wymusza wywołanie closeEvent, gdzie jest logika zapisu.
        self.close_button.clicked.connect(self.close)
        # ----------------------------------------------------
        
        buttons_layout.addWidget(self.refresh_button)
        buttons_layout.addWidget(self.close_button)
        main_layout.addLayout(buttons_layout)

Dla pewności upewnij się, że metoda closeEvent (którą podałem w poprzedniej odpowiedzi) jest nadal w klasie StaffingDetailsWindow:
    def closeEvent(self, event):
        """Zapisuje aktualne wymiary okna do ustawień i wymusza zapis do bazy."""
        if self.parent_widget and hasattr(self.parent_widget, 'user_app_settings'):
            # 1. Zapisz wymiary do słownika ustawień w pamięci głównego okna
            current_size = (self.width(), self.height())
            self.parent_widget.user_app_settings['staffing_window_size'] = current_size
            
            # 2. Wymuś natychmiastowy zapis do bazy danych SQL
            if hasattr(self.parent_widget, 'settings_db'):
                self.parent_widget.settings_db.save_settings(
                    self.parent_widget.user_app_settings
                )
            
        event.accept()

Teraz zarówno krzyżyk ("X"), jak i przycisk "Zamknij" wywołają ten sam kod i zapiszą rozmiar okna.


Rozumiem. Problem wynika z tego, że obecna logika w _predict_new_symbol automatycznie zakłada, że jeśli wstawiamy absencję w dzień wolny (pusty), to system powinien pobrać etat i wstawić np. "8;U" (szczególnie w systemie równoważnym).
Dla roli Lider musimy zablokować to zachowanie na etapie filtrowania komórek, zanim trafią one do przetwarzania.
Należy zmodyfikować metodę _apply_special_symbol_to_selection w pliku main.py.
Plik: main.py
Zastąp metodę _apply_special_symbol_to_selection poniższą wersją. Dodałem w niej nową listę skipped_day_off oraz warunek sprawdzający, czy komórka jest pusta.
    def _apply_special_symbol_to_selection(self, special_symbol: str):
        """
        Aplikuje symbol specjalny do zaznaczonych komórek z uwzględnieniem logiki Lidera:
        1. Blokada wstawiania U/OS nie-Liderom.
        2. Blokada wstawiania absencji w dni wolne (puste).
        """
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not selected_cells_data:
            self.statusBar().showMessage("Nie zaznaczono żadnych komórek do edycji.", 3000)
            return

        if not self._can_modify_cells(selected_cells_data):
            return

        special_symbol_upper = special_symbol.upper()
        user_role = self.current_user_app_role
        
        # Czy to jest symbol absencji? (np. U, L4, ale nie HO, DYS)
        is_absence = special_symbol_upper in app_settings.get_absence_symbols()

        show_vacation_plan_warning = False
        cells_to_process = []
        
        # Listy pominiętych
        skipped_restricted_symbol = [] 
        skipped_day_off = [] # <--- NOWA LISTA

        for cell_data in selected_cells_data:
            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_edit_symbol']:
                continue

            target_role = cell_data.get('rola_nazwa', '')
            current_symbol_str = cell_data.get('symbol', '')
            parsed_current = parse_symbol(current_symbol_str)
            current_special = (parsed_current.get('special_symbol') or '').upper()
            
            # Sprawdź czy dzień jest wolny (brak godzin pracy)
            is_day_off = parsed_current.get('work_hours') is None

            # --- NOWA LOGIKA: LIDER + DZIEŃ WOLNY + ABSENCJA ---
            if user_role == 'Lider' and is_day_off and is_absence:
                skipped_day_off.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue
            # ---------------------------------------------------

            # Logika: Lider może wstawić "U" lub "OS" TYLKO osobie w roli Lider.
            if user_role == 'Lider':
                if special_symbol_upper in ['U', 'OS']:
                    if target_role != 'Lider':
                        skipped_restricted_symbol.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                        continue
            
            # Ostrzeżenie przy zmianie 'U' na co innego
            if current_special in ['U', 'UZ'] and special_symbol_upper not in ['U', 'UZ'] and special_symbol_upper:
                show_vacation_plan_warning = True

            cells_to_process.append(cell_data)

        # --- KOMUNIKATY O POMINIĘCIACH ---
        
        if skipped_restricted_symbol:
            QMessageBox.warning(self, "Ograniczenia uprawnień",
                                f"Symbol '{special_symbol_upper}' może być wstawiony przez Lidera TYLKO innemu Liderowi.<br>"
                                f"Pominięto zmiany dla:<br>- {', '.join(set(skipped_restricted_symbol))}")

        # Nowy komunikat dla dni wolnych
        if skipped_day_off:
             # Opcjonalnie: pokaż komunikat, lub po prostu statusbar, żeby nie spamować oknami
             # Tutaj wersja z Info, bo to ważna reguła biznesowa
             if len(skipped_day_off) > 5:
                 msg_users = f"{len(skipped_day_off)} komórek"
             else:
                 msg_users = "<br>- ".join(set(skipped_day_off))
                 
             self.statusBar().showMessage(f"Pominięto wstawianie absencji w dni wolne dla: {msg_users}", 5000)
             # Jeśli wolisz okno dialogowe, odkomentuj poniższe:
             # QMessageBox.information(self, "Pominięto dni wolne", 
             #                        f"Jako Lider nie możesz wstawiać absencji w dni wolne od pracy.<br>"
             #                        f"Pominięto: {msg_users}")

        if not cells_to_process:
            return

        # --- RESZTA BEZ ZMIAN ---
        
        events_to_cancel = []
        if is_absence:
            user_date_pairs = {(c.get('uzytkownik_id'), c.get('date_str')) for c in cells_to_process}
            events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        reply = QMessageBox.Yes
        if self._should_ask_for_confirmation():
            grouped_changes = self._group_cells_for_symbol_changes(cells_to_process)
            changes_info = self._prepare_symbol_changes_description(grouped_changes, special_symbol)
            complete_info = f"Czy na pewno chcesz wprowadzić następujące zmiany?{changes_info}"
            
            if show_vacation_plan_warning:
                complete_info += "<br><br><b><font color='orange'>UWAGA:</font> Zmieniasz 'U' na inny symbol. Pamiętaj o usunięciu urlopu z planów urlopowych!</b>"

            if events_to_cancel:
                grouped_events = self._group_events_by_user_date(events_to_cancel)
                delegations_info = self._prepare_delegations_description(grouped_events)
                complete_info += f"<br>{delegations_info}"
            
            reply = show_confirmation_dialog(self, "Potwierdzenie wstawienia symbolu", complete_info)

        if reply != QMessageBox.Yes:
            return

        if events_to_cancel:
            self.cancel_delegations(ask_for_confirmation=False)

        change_requests = []
        for cell_data in cells_to_process:
            new_symbol = self._predict_new_symbol(cell_data.get('symbol', ''), special_symbol, cell_data)
            change_requests.append((ChangeType.APPLY_SPECIAL_SYMBOL, cell_data, special_symbol))

        if change_requests:
            self.schedule_change_processor.start_changes(change_requests)
            if show_vacation_plan_warning and not self._should_ask_for_confirmation():
                 QMessageBox.information(self, "Przypomnienie", "Zmieniono symbol urlopu. Pamiętaj o usunięciu go z planów urlopowych.")

Co się zmieniło?
 * Definicja Dnia Wolnego: Dodano is_day_off = parsed_current.get('work_hours') is None.
 * Nowy Warunek: W pętli dodano blok:
   if user_role == 'Lider' and is_day_off and is_absence:
    # pomiń

   Dzięki temu, jeśli Lider wybierze pustą komórkę i spróbuje wstawić "U" lub "L4" (lub cokolwiek ze zbioru absencji), kod po prostu pominie tę komórkę, nie próbując jej wypełniać domyślnymi godzinami.
 * Kompatybilność: To działa zarówno przy wyborze z klawiatury (wpisanie "U"), jak i przez okno dialogowe (wybranie przycisku "U"), ponieważ obie metody korzystają z tej samej funkcji _apply_special_symbol_to_selection.



Problem wynika z tego, że metoda _predict_new_symbol domyślnie pobiera godziny i lokalizację z istniejącego symbolu. W przypadku dnia wolnego (pustego), tych danych nie ma (None), a logika "Lidera OUT" była zaimplementowana wcześniej w pętli, a nie w samym predyktorze.
Przeniesiemy logikę "wypełniania pustego dnia" dla Lidera OUT bezpośrednio do metody obliczającej nowy symbol.
Oto poprawiona metoda _predict_new_symbol. Wklej ją do pliku main.py.
Plik: main.py
Zastąp istniejącą metodę _predict_new_symbol tą wersją:
    def _predict_new_symbol(self, current_symbol: str, special_symbol: str, cell_data: dict) -> str:
        """
        Przewiduje nowy symbol.
        Dla Lidera OUT w dzień wolny automatycznie ustawia start na 9:00 i godziny z etatu.
        """
        parsed_current = parse_symbol(current_symbol)

        final_start_hour = parsed_current.get('start_hour')
        final_work_hours = parsed_current.get('work_hours')
        
        # Sprawdź czy to dzień wolny (brak godzin pracy)
        is_day_off = final_work_hours is None

        # --- NOWA LOGIKA DLA LIDERA OUT W DZIEŃ WOLNY ---
        if self.current_user_app_role == 'Lider OUT' and is_day_off:
            # 1. Sztywna godzina rozpoczęcia
            final_start_hour = 9
            
            # 2. Pobranie godzin z etatu
            try:
                etat_val = float(cell_data.get('etat', 0) or 0)
                # Jeśli etat jest zapisany jako ułamek (np. 1.0, 0.5) -> przelicz na godziny standardowe (x8)
                # Jeśli etat jest zapisany w godzinach (np. 7, 8) -> użyj wprost
                if 0 < etat_val <= 1.0:
                    final_work_hours = int(etat_val * 8)
                elif etat_val > 1.0:
                    final_work_hours = int(etat_val)
                else:
                    final_work_hours = 8 # Fallback
            except (ValueError, TypeError):
                final_work_hours = 8
            
            # 3. Wstępne ustawienie lokalizacji domyślnej w "sparsowanym" obiekcie, 
            # aby logika poniżej mogła z niej skorzystać
            parsed_current['location'] = cell_data.get('lokalizacja_domyslna')
        # ------------------------------------------------

        # Logika dla systemu równoważnego i absencji (zachowana z poprzedniej wersji)
        system_pracy = cell_data.get('system_czasu_pracy', '').strip().lower()
        is_equivalent_system = (system_pracy == 'równoważny')
        is_absence_symbol = special_symbol and special_symbol.upper() in app_settings.get_absence_symbols()

        if is_equivalent_system and is_absence_symbol and final_work_hours is None:
             # Jeśli system równoważny i brak godzin (a nie wpadło w logikę Lider OUT), spróbuj pobrać etat
             try:
                 etat_val = float(cell_data.get('etat', 0) or 0)
                 final_work_hours = int(etat_val) if etat_val > 1 else 8
             except:
                 final_work_hours = 8

        # --- USTALANIE LOKALIZACJI ---
        final_location = None
        
        # Lokalizację dodajemy TYLKO gdy:
        # 1. Symbol jest "pracujący" (np. HO, DYS, T, PR)
        # 2. LUB brak symbolu specjalnego (zwykła zmiana)
        is_work_like = (special_symbol and special_symbol.upper() in app_settings.WORK_LIKE_SYMBOLS)
        
        if is_work_like or not special_symbol:
            # Priorytet: 1. Lokalizacja z obecnego symbolu, 2. Domyślna lokalizacja pracownika (lub ta ustawiona dla Lidera OUT wyżej)
            current_loc = parsed_current.get('location')
            
            # Jeśli Lider OUT wstawia w dzień wolny, parsed_current['location'] został ustawiony w bloku wyżej
            # Jeśli to edycja istniejącego dnia, bierzemy to co było.
            if current_loc:
                final_location = current_loc
            else:
                # Fallback do funkcji SQL (determine_correct_location)
                final_location = self.determine_correct_location(cell_data)
        
        # Budowanie symbolu
        new_symbol = build_symbol(
            location=final_location,
            start_hour=final_start_hour,
            work_hours=final_work_hours,
            special_symbol=special_symbol
        )

        if not new_symbol.strip() and special_symbol and special_symbol.strip():
            return special_symbol.strip()

        return new_symbol.strip() if new_symbol else ""

Co naprawiono?
 * Start 9:00: Dodano blok if Lider OUT and day_off, który na sztywno ustawia final_start_hour = 9.
 * Godziny z etatu: Dodano przeliczanie etatu. Jeśli etat to 1.0, system wstawi 8 godzin. Jeśli 0.5, wstawi 4 godziny.
 * Lokalizacja:
   * Jeśli wstawiany symbol to np. HO (pracujący) -> system wstawi lokalizację domyślną (np. h) i powstanie h;9;8;HO.
   * Jeśli wstawiany symbol to U (absencja) -> system wstawi godziny, ale pominie lokalizację, tworząc 9;8;U (zgodnie z tym, że absencje zazwyczaj nie mają lokalizacji, ale Lider OUT chce mieć godziny).



Masz absolutną rację. Problem polega na tym, że chociaż _predict_new_symbol w main.py poprawnie wylicza nowy symbol (np. h;9;8;HO), to do procesora zmian (ScheduleChangeProcessor) przekazujemy typ APPLY_SPECIAL_SYMBOL i surowy symbol (np. "HO").
Wątek w tle (schedule_change_processor.py) przelicza to na nowo, używając swojej wewnętrznej metody _prepare_new_symbol_legacy, która nie zna specyficznej logiki dla "Lidera OUT" (ustawiania startu na 9:00).
Rozwiązaniem jest przekazanie do procesora już gotowego, obliczonego symbolu jako typ APPLY_BUILT_SYMBOL.
Oto poprawiona końcówka metody _apply_special_symbol_to_selection w pliku main.py.
Plik: main.py
Znajdź w metodzie _apply_special_symbol_to_selection (na samym dole tej metody) pętlę tworzącą change_requests i podmień ją na poniższą wersję:
        # ... (wcześniejszy kod metody bez zmian) ...

        change_requests = []
        for cell_data in cells_to_process:
            # 1. Obliczamy pełny symbol lokalnie (korzystając z naprawionej logiki _predict_new_symbol)
            new_symbol = self._predict_new_symbol(cell_data.get('symbol', ''), special_symbol, cell_data)
            
            # 2. ZMIANA: Przekazujemy gotowy symbol (APPLY_BUILT_SYMBOL) zamiast surowego (APPLY_SPECIAL_SYMBOL).
            # Dzięki temu wątek w tle nie będzie próbował przeliczać go na nowo i nie zgubi godziny 9:00.
            change_requests.append((ChangeType.APPLY_BUILT_SYMBOL, cell_data, new_symbol))

        if change_requests:
            self.schedule_change_processor.start_changes(change_requests)
            if show_vacation_plan_warning and not self._should_ask_for_confirmation():
                 QMessageBox.information(self, "Przypomnienie", "Zmieniono symbol urlopu. Pamiętaj o usunięciu go z planów urlopowych.")

Dlaczego to zadziała?
W pliku schedule_change_processor.py obsługa APPLY_BUILT_SYMBOL wygląda tak:
if change_type == ChangeType.APPLY_BUILT_SYMBOL:
    new_symbol = str(value)

Oznacza to, że baza danych otrzyma dokładnie ten ciąg znaków, który wygenerowała Twoja poprawiona metoda _predict_new_symbol (czyli np. h;9;8;HO), zamiast próbować zgadywać go od zera.



Problem polega na tym, że choć aplikacja nasłuchuje zmian szerokości kolumn na bieżąco (_on_column_resized), to w momencie kliknięcia "Importuj teraz" następuje sekwencja zdarzeń (zamknięcie dialogu -> aplikowanie motywu -> odświeżenie danych), która może korzystać z nieaktualnego stanu w user_app_settings, jeśli ostatnia zmiana nie została poprawnie zrzutowana.
Najbezpieczniejszym rozwiązaniem jest wymuszenie zapisu bieżących szerokości kolumn z widoku do pamięci ustawień tuż przed otwarciem okna ustawień. Dzięki temu, niezależnie od tego co zrobisz w oknie (zmienisz motyw, klikniesz importuj), aplikacja zawsze przywróci te szerokości, które widziałeś sekundę temu.
Wprowadź jedną, kluczową zmianę w pliku main.py.
Plik: main.py
Znajdź metodę show_settings_dialog w klasie WorkScheduleWindow i dodaj linię zapisu na samym początku.
    def show_settings_dialog(self):
        """Pokazuje okno dialogowe ustawień aplikacji."""
        
        # --- POPRAWKA: Zapisz aktualne szerokości kolumn przed otwarciem okna ---
        # Zapobiega to resetowaniu widoku przy zmianie motywu lub imporcie.
        if hasattr(self, 'table'):
             self.user_app_settings['column_widths'] = self.table.get_column_widths()
        # ------------------------------------------------------------------------

        from settings_dialog import AppSettingsDialog

        # Przekazujemy current_user_app_role
        dialog = AppSettingsDialog(self, settings=self.user_app_settings, user_role=self.current_user_app_role)

        dialog.live_theme_changed.connect(self.apply_theme_settings)
        dialog.import_requested.connect(self.on_import_requested)
        dialog.save_global_settings_requested.connect(self._save_global_app_settings)

        if dialog.exec() == QDialog.Accepted:
            # ... (reszta metody bez zmian) ...

Dlaczego to działa?
Kiedy klikasz "Importuj teraz":
 * Dialog emituje sygnał import_requested.
 * Uruchamia się refresh_data (który czyści widok i ładuje dane).
 * Dialog zamyka się, wywołując apply_theme_settings w oknie głównym.
 * apply_theme_settings wywołuje _apply_dynamic_sizes.
 * _apply_dynamic_sizes pobiera szerokości z self.user_app_settings['column_widths'].
Dzięki dodanej linijce mamy 100% pewności, że w punkcie 5 aplikacja użyje dokładnie tych szerokości, które miałeś ustawione przed chwilą na ekranie.



Diagnoza jest trafna. Problem polega na tym, że reset modelu (wywoływany przez self.schedule_model.update_data(...)) powoduje zresetowanie widoku tabeli, co z kolei wyzwala sygnały sectionResized z domyślnymi wartościami szerokości. Ponieważ Twój slot _on_column_resized nasłuchuje tych zmian, nieświadomie nadpisuje on poprawne ustawienia użytkownika wartościami domyślnymi (śmieciami), zanim _apply_dynamic_sizes zdąży je przywrócić.
Rozwiązaniem jest objęcie całej operacji ładowania danych (_apply_loaded_data) blokadą flagi _is_updating_layout. Dzięki temu wszelkie sygnały zmiany rozmiaru wygenerowane podczas przebudowy tabeli zostaną zignorowane.
Oto poprawiona metoda _apply_loaded_data. Wklej ją do pliku main.py, zastępując istniejącą wersję.
Plik: main.py
    def _apply_loaded_data(self, data, filters_to_restore=None):
        """Aplikuje nowo załadowane dane do modeli i UI."""
        if data is None:
            log_error("Błąd: _apply_loaded_data otrzymało puste dane (None).")
            return

        # --- FIX: BLOKADA PRZED RESETEM MODELU ---
        # Ustawiamy flagę na True PRZED jakąkolwiek ingerencją w model.
        # To sprawi, że metoda _on_column_resized zignoruje wszystkie sygnały
        # generowane podczas resetowania i wypełniania tabeli.
        self._is_updating_layout = True
        # -----------------------------------------

        try:
            schedule_data = data.get('schedule_data', [])
            events_data = data.get('events_data', [])
            processed_data = data.get('processed_data', {})
            year = data.get('year')
            month = data.get('month')

            if processed_data is None or year is None or month is None:
                log_error(f"Niekompletne dane przekazane do _apply_loaded_data: rok={year}, miesiac={month}")
                return

            self.raw_data = schedule_data
            self.all_events_data = events_data
            self.processed_data = processed_data

            is_initial_load = self.schedule_model.rowCount() == 0
            
            # KRYTYCZNY MOMENT: To wywołanie resetuje model.
            # Bez blokady, widok zresetowałby kolumny do domyślnych szerokości,
            # a _on_column_resized nadpisałby ustawienia użytkownika.
            # Dzięki fladze _is_updating_layout=True, ustawienia są bezpieczne.
            self.schedule_model.update_data(self.processed_data, year, month)

            if 'custom_columns' in self.user_app_settings:
                self.schedule_model.set_custom_columns(self.user_app_settings['custom_columns'])

            self.events_data = []
            if 'row_colors' in self.user_app_settings:
                self.schedule_model.set_row_colors(self.user_app_settings['row_colors'])
            
            if hasattr(self, 'events_model'):
                self.events_model.update_data([])
            self.all_events_data = data.get('events_data', [])

            if hasattr(self, 'status_filter_combo'):
                all_statuses = sorted(list(set(e.get('status', '') for e in self.all_events_data if e.get('status'))))
                self.status_filter_combo.add_items(all_statuses)
                self.status_filter_combo.select_items(all_statuses)

            if filters_to_restore:
                self.restore_filters_state(filters_to_restore)
            else:
                last_filters = self.user_app_settings.get('last_filters')
                if last_filters:
                    self.restore_filters_state(last_filters)
                else:
                    self.update_filters()
                    self.filter_data()

            if is_initial_load:
                self.apply_custom_sort()

            # Na końcu aplikujemy poprawne szerokości z nienaruszonej pamięci ustawień.
            # Metoda _apply_dynamic_sizes zarządza własną blokadą (wewnątrz), 
            # ale ponieważ jesteśmy w bloku try...finally, jest to bezpieczne.
            self._apply_dynamic_sizes()
            self.setup_events_table_columns()
            
        finally:
            # --- ZDEJMOWANIE BLOKADY ---
            # Zawsze zdejmujemy blokadę na końcu, aby przywrócić 
            # możliwość ręcznego zmieniania rozmiaru przez użytkownika.
            self._is_updating_layout = False
            # ---------------------------

Jak to działa?
 * Użytkownik klika "Importuj teraz".
 * Wcześniej dodana linijka w show_settings_dialog zapisała bieżące szerokości do self.user_app_settings.
 * Aplikacja pobiera dane i wywołuje _apply_loaded_data.
 * Włączamy blokadę: self._is_updating_layout = True.
 * Wywołujemy update_data. Tabela się czyści, kolumny wracają do 100px. Qt wysyła sygnał sectionResized.
 * Slot _on_column_resized odbiera sygnał, ale widzi self._is_updating_layout == True, więc nic nie robi (nie psuje ustawień).
 * Wywołujemy _apply_dynamic_sizes. Metoda ta bierze poprawne, niezepsute szerokości z self.user_app_settings i aplikuje je do tabeli.
 * Zdejmujemy blokadę (False).
 * Widok jest poprawny.
