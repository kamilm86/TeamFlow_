# schedule_edit_dialogs.py
from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel,
                               QPushButton, QComboBox, QGroupBox, QRadioButton,
                               QFontComboBox, QSpinBox, QColorDialog, QCheckBox, QWidget, QTextEdit,
                               QFrame, QButtonGroup, QTabWidget, QGridLayout, QMessageBox, QLineEdit,
                               QApplication, QSpacerItem, QSizePolicy,
                               QTableWidget, QTableWidgetItem, QHeaderView)
from PySide6.QtCore import Qt, Signal, QTimer
from PySide6.QtGui import QFont, QColor
from styles import AppStyles  # Dodano import AppStyles
from debug_utils import debug_print, log_error


class ThemeSettingsDialog(QDialog):
    """
    Dialog do wyboru ustawie≈Ñ motywu aplikacji.
    """
    settings_changed = Signal(str, str, int)

    def __init__(self, parent=None, current_theme="dark", current_font="", current_font_size=9):
        super().__init__(parent)
        self.parent_widget = parent  # Zapisz rodzica

        self.setWindowTitle("Ustawienia motywu")
        self.setMinimumWidth(300)

        self.current_theme = current_theme
        self.current_font = current_font
        self.current_font_size = current_font_size

        self.setup_ui()  # Najpierw UI
        self.apply_dialog_theme()  # Potem styl zgodny z przekazanym/rodzica

        # Pod≈ÇƒÖczenie sygna≈Ç√≥w do natychmiastowej zmiany - PO setup_ui i apply_dialog_theme
        self.dark_theme_radio.toggled.connect(self.apply_immediate_changes)
        # Unikamy podw√≥jnego wywo≈Çania przy prze≈ÇƒÖczaniu radio, wystarczy jeden sygna≈Ç
        # self.light_theme_radio.toggled.connect(self.apply_immediate_changes)
        self.font_combo.currentFontChanged.connect(self.apply_immediate_changes)
        self.font_size_spin.valueChanged.connect(self.apply_immediate_changes)

    def apply_dialog_theme(self):  # Ta metoda stylizuje dialog na podstawie motywu rodzica lub current_theme
        """Stosuje motyw dla samego okna dialogowego."""
        theme_to_apply = self.current_theme  # Domy≈õlnie u≈ºyj przekazanego motywu

        # Je≈õli dialog ma rodzica i rodzic ma informacjƒô o motywie, u≈ºyj jej
        # To jest na wypadek, gdyby current_theme nie by≈Ço zsynchronizowane
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            theme_to_apply = "dark" if self.parent_widget.is_dark_theme else "light"

        # Je≈õli aktualnie wybrane radio buttony wskazujƒÖ inny motyw, u≈ºyj go
        # To jest kluczowe dla od≈õwie≈ºania "na ≈ºywo"
        if hasattr(self, 'dark_theme_radio') and self.dark_theme_radio.isChecked():
            theme_to_apply = "dark"
        elif hasattr(self, 'light_theme_radio') and self.light_theme_radio.isChecked():
            theme_to_apply = "light"

        self.setStyleSheet(AppStyles.get_dialog_style(theme_to_apply))

        # Od≈õwie≈º style przycisk√≥w w dialogu, bo get_dialog_style ich nie obejmuje
        button_style = AppStyles.get_button_style(theme_to_apply)
        if hasattr(self, 'ok_button'): self.ok_button.setStyleSheet(button_style)
        if hasattr(self, 'cancel_button'): self.cancel_button.setStyleSheet(button_style)

    def setup_ui(self):  # Tutaj tylko tworzymy widgety
        main_layout = QVBoxLayout(self)

        theme_group = QGroupBox("Motyw")
        theme_layout = QVBoxLayout()
        self.dark_theme_radio = QRadioButton("Ciemny")
        self.light_theme_radio = QRadioButton("Jasny")

        if self.current_theme == "dark":
            self.dark_theme_radio.setChecked(True)
        else:  # Domy≈õlnie lub je≈õli light
            self.light_theme_radio.setChecked(True)

        theme_layout.addWidget(self.dark_theme_radio)
        theme_layout.addWidget(self.light_theme_radio)
        theme_group.setLayout(theme_layout)

        font_group = QGroupBox("Czcionka")
        font_layout = QVBoxLayout()
        font_type_layout = QHBoxLayout()
        font_type_label = QLabel("Typ czcionki:")
        self.font_combo = QFontComboBox()
        if self.current_font:
            self.font_combo.setCurrentFont(QFont(self.current_font))
        font_type_layout.addWidget(font_type_label)
        font_type_layout.addWidget(self.font_combo)

        font_size_layout = QHBoxLayout()
        font_size_label = QLabel("Rozmiar czcionki:")
        self.font_size_spin = QSpinBox()
        self.font_size_spin.setRange(6, 24)
        self.font_size_spin.setValue(self.current_font_size)
        font_size_layout.addWidget(font_size_label)
        font_size_layout.addWidget(self.font_size_spin)

        font_layout.addLayout(font_type_layout)
        font_layout.addLayout(font_size_layout)
        font_group.setLayout(font_layout)

        self.save_settings_checkbox = QCheckBox("Zapamiƒôtaj ustawienia")
        self.save_settings_checkbox.setChecked(True)

        buttons_layout = QHBoxLayout()
        self.ok_button = QPushButton("OK")
        self.cancel_button = QPushButton("Anuluj")

        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

        buttons_layout.addStretch()
        buttons_layout.addWidget(self.ok_button)
        buttons_layout.addWidget(self.cancel_button)

        main_layout.addWidget(theme_group)
        main_layout.addWidget(font_group)
        main_layout.addWidget(self.save_settings_checkbox)
        main_layout.addLayout(buttons_layout)

    def apply_immediate_changes(self):
        """Aplikuje zmiany natychmiastowo podczas wybierania opcji W TYM SAMYM DIALOGU"""
        if not hasattr(self, 'font_combo') or not hasattr(self, 'font_size_spin') or not hasattr(self,
                                                                                                 'dark_theme_radio'):
            return

        selected_theme = "dark" if self.dark_theme_radio.isChecked() else "light"
        font_family = self.font_combo.currentFont().family()
        font_size = self.font_size_spin.value()

        # Emituj sygna≈Ç dla g≈Ç√≥wnego okna, aby ono zaktualizowa≈Ço swoje style
        self.settings_changed.emit(selected_theme, font_family, font_size)

        # Zaktualizuj styl samego dialogu ThemeSettingsDialog "na ≈ºywo"
        # Musimy przekazaƒá wybrany motyw, a niekoniecznie ten z rodzica
        # (bo w≈Ça≈õnie go zmieniamy)
        current_dialog_theme_choice = self.get_current_theme_choice()  # U≈ºyj wyboru z radio button√≥w

        # Zastosuj pe≈Çny styl dialogu na nowo
        self.setStyleSheet(AppStyles.get_dialog_style(current_dialog_theme_choice))

        # Zastosuj style dla przycisk√≥w, kt√≥re nie sƒÖ objƒôte get_dialog_style
        button_style = AppStyles.get_button_style(current_dialog_theme_choice)
        if hasattr(self, 'ok_button'): self.ok_button.setStyleSheet(button_style)
        if hasattr(self, 'cancel_button'): self.cancel_button.setStyleSheet(button_style)

        # Mo≈ºe byƒá konieczne od≈õwie≈ºenie styl√≥w dla kontrolek wewnƒÖtrz groupbox√≥w,
        # je≈õli dziedziczenie nie zadzia≈Ça idealnie po zmianie g≈Ç√≥wnego stylu dialogu.
        # Na przyk≈Çad:
        # self.font_combo.setStyleSheet(AppStyles.get_combobox_style(current_dialog_theme_choice))
        # self.font_size_spin.setStyleSheet(AppStyles.get_line_edit_style(current_dialog_theme_choice)) # SpinBox czƒôsto dziedziczy styl LineEdit
        # self.dark_theme_radio.setStyleSheet(AppStyles.get_checkbox_style(current_dialog_theme_choice)) # RadioButton czƒôsto jak CheckBox
        # self.light_theme_radio.setStyleSheet(AppStyles.get_checkbox_style(current_dialog_theme_choice))
        # To jest bardziej granularne i mo≈ºe byƒá potrzebne, je≈õli prosty self.setStyleSheet() nie wystarczy.

        # Dla pewno≈õci mo≈ºna wymusiƒá od≈õwie≈ºenie wyglƒÖdu, choƒá zmiana stylesheetu powinna to zrobiƒá.
        self.update()

    def get_current_theme_choice(self):  # Zmieniono nazwƒô, aby odr√≥≈ºniƒá od current_theme przy inicjalizacji
        """Zwraca nazwƒô aktualnie wybranego motywu w tym dialogu."""
        if hasattr(self, 'dark_theme_radio') and self.dark_theme_radio.isChecked():
            return "dark"
        elif hasattr(self, 'light_theme_radio') and self.light_theme_radio.isChecked():
            return "light"
        # Fallback na current_theme, je≈õli radio buttony nie sƒÖ jeszcze dostƒôpne
        return self.current_theme


class InsertSymbolDialog(QDialog):
    """
    Dialog do wyboru symbolu urlopu lub nieobecno≈õci z zak≈Çadkami.
    Zmniejszony, z podpowiedziami zamiast legendy i ulepszonƒÖ obs≈ÇugƒÖ.
    """
    symbol_selected = Signal(str)  # Sygna≈Ç z wybranym symbolem

    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent_widget = parent  # Ensure this is assigned early

        self.setWindowTitle("Wstaw symbol")
        self.setMinimumWidth(300)
        self.setMinimumHeight(250)

        self.selected_symbol = ""
        self.user_role = ""
        self.valid_symbols = set()

        # Access parent_widget after it has been assigned
        if self.parent_widget and hasattr(self.parent_widget, 'current_user_role'):
            self.user_role = self.parent_widget.current_user_role

        self.parent_font = QApplication.font()
        if self.parent_widget:
            self.parent_font = self.parent_widget.font()

        self.setObjectName("InsertSymbolDialogInstance")

        self.setup_ui()
        self.apply_dialog_theme()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu InsertSymbolDialog."""
        actual_theme = "dark"
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            actual_theme = "dark" if self.parent_widget.is_dark_theme else "light"

        # debug_print(f"InsertSymbolDialog ('{self.windowTitle()}'): Stosujƒô motyw '{actual_theme}'")

        # Ustaw og√≥lny styl dialogu (powinien zawieraƒá QDialog#InsertSymbolDialogInstance)
        self.setStyleSheet(AppStyles.get_dialog_style(actual_theme))

        # Styl dla przycisk√≥w i innych kontrolek w tym dialogu
        button_style_qss = AppStyles.get_button_style(actual_theme)
        line_edit_style_qss = AppStyles.get_line_edit_style(actual_theme)
        tab_widget_style_qss = self._get_tab_widget_style(actual_theme)  # Dedykowana metoda dla QTabWidget

        if hasattr(self, 'symbol_input'):
            self.symbol_input.setStyleSheet(line_edit_style_qss)

        if hasattr(self, 'tabs'):
            self.tabs.setStyleSheet(tab_widget_style_qss)
            # Mo≈ºna dodatkowo ostylowaƒá przyciski wewnƒÖtrz zak≈Çadek, je≈õli to konieczne
            # i je≈õli nie dziedziczƒÖ poprawnie stylu z button_style_qss
            for i in range(self.tabs.count()):
                tab_content_widget = self.tabs.widget(i)
                if tab_content_widget:
                    buttons_in_tab = tab_content_widget.findChildren(QPushButton)
                    for btn in buttons_in_tab:
                        btn.setStyleSheet(button_style_qss)  # U≈ºyj g≈Ç√≥wnego stylu przycisk√≥w
                        # lub dedykowanego mniejszego stylu

        if hasattr(self, 'cancel_button'):
            self.cancel_button.setStyleSheet(button_style_qss)

        # Styl dla etykiet, je≈õli potrzeba specyficznego
        label_style_qss = AppStyles.get_label_style(actual_theme)
        if hasattr(self, 'instruction_label'): self.instruction_label.setStyleSheet(label_style_qss)
        if hasattr(self, 'input_label'): self.input_label.setStyleSheet(label_style_qss)
        if hasattr(self, 'validation_label'): self.validation_label.setStyleSheet(label_style_qss)

        self.style().unpolish(self)
        self.style().polish(self)
        self.update()

    def _get_tab_widget_style(self, theme):
        """Zwraca styl dla QTabWidget i QTabBar zgodny z motywem."""
        # Pobierz kolory z AppStyles
        main_bg = AppStyles.DARK_BACKGROUND_MAIN if theme == "dark" else AppStyles.LIGHT_BACKGROUND_MAIN
        control_bg = AppStyles.DARK_BACKGROUND_CONTROLS if theme == "dark" else AppStyles.LIGHT_BACKGROUND_CONTROLS
        text_color = AppStyles.DARK_TEXT_PRIMARY if theme == "dark" else AppStyles.LIGHT_TEXT_PRIMARY
        border_color = AppStyles.DARK_BORDER_SECONDARY if theme == "dark" else AppStyles.LIGHT_BORDER_PRIMARY
        accent_color = AppStyles.ACCENT_COLOR_DARK if theme == "dark" else AppStyles.ACCENT_COLOR_LIGHT

        # Dla jasnego motywu zak≈Çadki mogƒÖ mieƒá nieco inne t≈Ço ni≈º sam dialog
        tab_bar_bg = control_bg if theme == "dark" else AppStyles.LIGHT_BACKGROUND_HOVER
        tab_pane_bg = control_bg  # T≈Ço zawarto≈õci zak≈Çadki

        return f"""
            QTabWidget::pane {{
                border: 1px solid {border_color};
                border-top: none; /* ≈ÅƒÖczy siƒô z QTabBar */
                background-color: {tab_pane_bg};
                border-bottom-left-radius: {AppStyles.BORDER_RADIUS};
                border-bottom-right-radius: {AppStyles.BORDER_RADIUS};
            }}
            QTabBar::tab {{
                background-color: {tab_bar_bg};
                color: {text_color};
                border: 1px solid {border_color};
                border-bottom: none; 
                padding: 5px 10px;
                margin-right: 1px;
                border-top-left-radius: {AppStyles.BORDER_RADIUS};
                border-top-right-radius: {AppStyles.BORDER_RADIUS};
            }}
            QTabBar::tab:selected {{
                background-color: {accent_color};
                color: {'white' if theme == "dark" else AppStyles.LIGHT_BACKGROUND_CONTROLS}; /* Poprawiony kolor tekstu dla jasnego motywu */
                /* border-bottom: 1px solid {accent_color}; */ /* Usuwamy, bo pane ma border-top */
            }}
            QTabBar::tab:!selected {{
                background-color: {main_bg if theme == "dark" else AppStyles.LIGHT_BACKGROUND_MAIN};
                 /* margin-top: 2px; */ /* Mo≈ºna usunƒÖƒá dla p≈Çaskiego wyglƒÖdu */
            }}
            QTabBar::tab:hover:!selected {{
                background-color: {AppStyles.DARK_BACKGROUND_HOVER if theme == "dark" else AppStyles.LIGHT_BACKGROUND_HOVER};
            }}
        """

    def setup_ui(self):
        main_layout = QVBoxLayout(self)

        self.instruction_label = QLabel("Wpisz symbol lub wybierz z poni≈ºszych zak≈Çadek")
        self.instruction_label.setStyleSheet(
            "color: gray; font-style: italic;")  # Ten styl mo≈ºe byƒá nadpisany przez apply_dialog_theme
        self.instruction_label.setFont(self.parent_font)
        main_layout.addWidget(self.instruction_label)

        input_layout = QHBoxLayout()
        self.input_label = QLabel("Symbol:")  # Zapisz referencjƒô
        self.input_label.setFont(self.parent_font)

        self.symbol_input = QLineEdit()
        self.symbol_input.setMaxLength(5)
        font = QFont(self.parent_font)
        font.setBold(True)
        font.setPointSize(font.pointSize() + 2)
        self.symbol_input.setFont(font)
        self.symbol_input.textChanged.connect(self.on_symbol_input_changed)
        self.symbol_input.returnPressed.connect(self.check_and_accept)
        input_layout.addWidget(self.input_label)
        input_layout.addWidget(self.symbol_input)
        main_layout.addLayout(input_layout)

        self.tabs = QTabWidget()
        self.tabs.setFont(self.parent_font)

        # Definicje symboli w kategoriach
        popularne_symbole = [
            ("UZ", "Urlop na ≈ºƒÖdanie"),
            ("CO", "Zwolnienie lekarskie"),
            ("CR", "Zwolnienie lekarskie na innƒÖ osobƒô we wsp√≥lnym gospodarstwie")
        ]
        urlopy_symbole = [
            ("U", "Urlop wypoczynkowy"),
            ("UB", "Urlop bezp≈Çatny"),
            ("UD", "Urlop dodatkowy z tytu≈Çu niepe≈Çnosprawno≈õci"),
            ("UM", "Urlop macierzy≈Ñski (20 tyg., Dodatkowy 6 tyg., Rodzicielski 26 tyg.)"),
            ("UO", "Urlop okoliczno≈õciowy"),
            ("UOD", "Opieka nad dzieckiem do lat 14"),
            ("US", "Urlop szkolny"),
            ("UT", "Urlop ojcowski"),
            ("UW", "Urlop wychowawczy"),
            ("UZ", "Urlop na ≈ºƒÖdanie"),
            ("UOP", "5 dni opieki na dziecko lub cz≈Çonka rodziny - urlop opieku≈Ñczy")
        ]
        zwolnienia_symbole = [
            ("CO", "Zwolnienie lekarskie"),
            ("CR", "Zwolnienie lekarskie na innƒÖ osobƒô we wsp√≥lnym gospodarstwie"),
            ("CRW", "Zwolnienie lekarskie na opiekƒô (sytuacja wyjƒÖtkowa)"),
            ("CSR", "≈öwiadczenie rehabilitacyjne"),
            ("ZO", "Zwolnienie z obowiƒÖzku ≈õwiadczenia pracy"),
            ("ZS", "Zwolnienie z obowiƒÖzku ≈õwiadczenia pracy (sytuacja wyjƒÖtkowa)")
        ]
        delegacje_symbole = [
            ("DK", "Podr√≥≈º s≈Çu≈ºbowa krajowa"),
            ("DZ", "Podr√≥≈º s≈Çu≈ºbowa zagraniczna"),
            ("HO", "Home Office"),
            ("P", "Czasowe oddelegowanie"),
            ("PD", "Prace dodatkowe")
        ]
        inne_symbole = [
            ("BC", "Doradca w backup"),
            ("BK", "Badanie kontrolne"),
            ("BO", "Badanie okresowe"),
            ("CW", "ƒÜwiczenia wojskowe"),
            ("DYS", "Realizacja dyspozycji"),
            ("MW", "mWolne"),
            ("NN", "Nieobecno≈õƒá nieusprawiedliwiona"),
            ("NU", "Nieobecno≈õƒá usprawiedliwiona"),
            ("NW", "Nieobecno≈õƒá do wyja≈õnienia"),
            ("O", "Nieobecno≈õƒá usprawiedliwiona z tytu≈Çu odbioru godzin"),
            ("OS", "Odbi√≥r dnia wolnego za ≈õwiƒôto przypadajƒÖce w sobotƒô"),
            ("S", "Szkolenie po programie adaptacyjnym"),
            ("T", "Testy"),
            ("USW", "2 dni wolne na zwolnienie od pracy z powodu si≈Çy wy≈ºszej"),
            ("Z", "RozwiƒÖzanie umowy")
        ]

        # Zbierz wszystkie dostƒôpne symbole
        # all_symbol_lists = [popularne_symbole, urlopy_symbole, zwolnienia_symbole, delegacje_symbole, inne_symbole]
        # for symbol_list in all_symbol_lists:
        #     for symbol, _ in symbol_list:
        #         self.valid_symbols.add(symbol)
        #
        # # Dodanie zak≈Çadek w zale≈ºno≈õci od roli
        # if self.user_role == "Lider":
        #     # Lider widzi tylko Zwolnienia i Popularne symbole
        #     # self.add_tab_with_symbols(popularne_symbole, "Popularne symbole")
        #     self.add_tab_with_symbols(zwolnienia_symbole, "Zwolnienia")
        # elif self.user_role == "Pracownik WPR":
        #     # Menad≈ºer widzi wszystko
        #     # self.add_tab_with_symbols(popularne_symbole, "Popularne symbole")
        #     # self.add_tab_with_symbols(urlopy_symbole, "Urlopy")
        #     self.add_tab_with_symbols(zwolnienia_symbole, "Zwolnienia")
        #     # self.add_tab_with_symbols(delegacje_symbole, "Delegacje i praca zdalna")
        #     # self.add_tab_with_symbols(inne_symbole, "Inne")
        # else:
        #     pass
        #     # # Domy≈õlnie - u≈ºytkownik standardowy widzi wszystkie zak≈Çadki
        #     # self.add_tab_with_symbols(popularne_symbole, "Popularne symbole")
        #     # self.add_tab_with_symbols(urlopy_symbole, "Urlopy")
        #     # self.add_tab_with_symbols(zwolnienia_symbole, "Zwolnienia")
        #     # self.add_tab_with_symbols(delegacje_symbole, "Delegacje i praca zdalna")
        #     # self.add_tab_with_symbols(inne_symbole, "Inne")
        all_symbol_lists = {"Popularne": popularne_symbole, "Urlopy": urlopy_symbole,
                            "Zwolnienia": zwolnienia_symbole}  # Skr√≥cono dla przyk≈Çadu

        self.valid_symbols.clear()  # Wyczy≈õƒá przed ponownym wype≈Çnieniem
        for cat_name, symbol_list in all_symbol_lists.items():
            # Logika widoczno≈õci zak≈Çadek na podstawie roli
            if (self.user_role == "Lider" and cat_name not in ["Popularne", "Zwolnienia"]) or \
                    (self.user_role == "Pracownik WPR" and cat_name not in ["Zwolnienia"]):  # Przyk≈Çad ogranicze≈Ñ
                if self.user_role == "Lider" and cat_name == "Zwolnienia":  # Lider widzi zwolnienia
                    pass  # Dodaj zak≈Çadkƒô
                elif self.user_role == "Pracownik WPR" and cat_name == "Zwolnienia":  # WPR widzi zwolnienia
                    pass
                else:
                    continue  # Pomi≈Ñ dodawanie tej zak≈Çadki dla danej roli

            self.add_tab_with_symbols(symbol_list, cat_name)  # Dodaj zak≈Çadkƒô
            for symbol, _ in symbol_list:
                self.valid_symbols.add(symbol)

        buttons_layout = QHBoxLayout()
        self.cancel_button = QPushButton("Anuluj")  # Zapisz referencjƒô
        self.cancel_button.setFont(self.parent_font)
        self.cancel_button.clicked.connect(self.reject)

        self.validation_label = QLabel("")  # Zapisz referencjƒô
        self.validation_label.setFont(self.parent_font)

        buttons_layout.addWidget(self.validation_label)
        buttons_layout.addStretch()
        buttons_layout.addWidget(self.cancel_button)

        main_layout.addWidget(self.tabs)
        main_layout.addLayout(buttons_layout)
        self.symbol_input.setFocus()

    def add_tab_with_symbols(self, symbols, tab_name):
        """Dodaje zak≈Çadkƒô z symbolami do tabwidget"""
        tab = QWidget()
        tab_layout = QGridLayout(tab)
        tab_layout.setSpacing(5)

        for idx, (symbol, desc) in enumerate(symbols):
            button = QPushButton(symbol)
            button.setFont(self.parent_font)
            button.setToolTip(desc)
            button.setProperty("symbol", symbol)
            button.setFocusPolicy(Qt.NoFocus)  # Wy≈ÇƒÖcz fokus dla przycisku
            button.clicked.connect(self.on_symbol_button_clicked)
            row = idx // 4
            col = idx % 4
            tab_layout.addWidget(button, row, col)

        tab_layout.addItem(QSpacerItem(10, 10, QSizePolicy.Expanding, QSizePolicy.Expanding),
                           (len(symbols) // 4) + 1, 0, 1, 4)
        self.tabs.addTab(tab, tab_name)

    def on_symbol_button_clicked(self):
        """Obs≈Çuguje klikniƒôcie przycisku z symbolem"""
        button = self.sender()  # Pobierz obiekt, kt√≥ry wys≈Ça≈Ç sygna≈Ç
        if button:
            symbol = button.property("symbol")
            if symbol:
                self.accept_symbol(symbol)

    def on_symbol_input_changed(self, text):
        """Obs≈Çuguje zmianƒô symbolu wpisanego z klawiatury"""
        # Konwersja do du≈ºych liter
        uppercase_text = text.upper()
        if text != uppercase_text:
            # Blokuj sygna≈Ç, aby uniknƒÖƒá niesko≈Ñczonej pƒôtli
            self.symbol_input.blockSignals(True)
            self.symbol_input.setText(uppercase_text)
            self.symbol_input.blockSignals(False)

        self.selected_symbol = uppercase_text.strip()

        # Sprawd≈∫, czy symbol jest na li≈õcie dostƒôpnych
        if self.selected_symbol:
            if self.selected_symbol in self.valid_symbols:
                self.validation_label.setText("Symbol prawid≈Çowy")
                self.validation_label.setStyleSheet("color: green;")
            else:
                self.validation_label.setText("Symbol niedostƒôpny!")
                self.validation_label.setStyleSheet("color: red;")
        else:
            self.validation_label.setText("")

    def accept_symbol(self, symbol):
        """Akceptuje symbol i zamyka dialog"""
        self.selected_symbol = symbol

        # Blokuj sygna≈Ç, aby uniknƒÖƒá wywo≈Çania on_symbol_input_changed
        self.symbol_input.blockSignals(True)
        self.symbol_input.setText(symbol)
        self.symbol_input.blockSignals(False)

        # Aktualizuj etykietƒô walidacji
        self.validation_label.setText("Symbol prawid≈Çowy")
        self.validation_label.setStyleSheet("color: green;")

        # Wywo≈Çaj metodƒô sprawdzajƒÖcƒÖ
        self.check_and_accept()

    def check_and_accept(self):
        if self.selected_symbol and self.selected_symbol in self.valid_symbols:
            super().accept()
        elif self.selected_symbol:
            QMessageBox.warning(
                self,
                "Nieprawid≈Çowy symbol",
                f"Symbol '{self.selected_symbol}' nie znajduje siƒô na li≈õcie dostƒôpnych symboli.",
                QMessageBox.Ok
            )
            self.selected_symbol = ""
            self.symbol_input.setText("")
            self.symbol_input.setFocus()
        else:
            QMessageBox.warning(
                self,
                "Brak symbolu",
                "Proszƒô wpisaƒá lub wybraƒá symbol.",
                QMessageBox.Ok
            )
            self.selected_symbol = ""
            self.symbol_input.setText("")
            self.symbol_input.setFocus()

    def get_selected_symbol(self):
        """Zwraca wybrany symbol"""
        return self.selected_symbol


class ScheduleChangeDialog(QDialog):
    """Dialog do edycji zmian w grafiku"""

    def __init__(self, parent=None, grouped_cells=None, year=None, month=None):
        super().__init__(parent)
        self.parent_widget = parent
        self.determined_theme = "dark"
        if self.parent_widget and hasattr(self.parent_widget, 'is_dark_theme'):
            self.determined_theme = "dark" if self.parent_widget.is_dark_theme else "light"

        self.setWindowTitle("Wstaw zmianƒô grafiku")
        self.setMinimumWidth(900)
        self.setMinimumHeight(500)

        self.grouped_cells = grouped_cells
        self.year = year
        self.month = month
        self.flattened_cells = self.flatten_grouped_cells(grouped_cells)

        self.user_role = "U≈ºytkownik"
        if self.parent_widget and hasattr(self.parent_widget, 'current_user_role'):
            self.user_role = self.parent_widget.current_user_role

        self.default_button_style = AppStyles.get_button_style(self.determined_theme)

        self.setup_ui()
        self.apply_dialog_theme()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu ScheduleChangeDialog."""
        actual_theme = self.determined_theme  # U≈ºyj zapamiƒôtanego motywu

        from styles import AppStyles
        self.setStyleSheet(AppStyles.get_dialog_style(actual_theme))

        button_style = AppStyles.get_button_style(actual_theme)
        if hasattr(self, 'close_button'):
            self.close_button.setStyleSheet(button_style)

        if hasattr(self, 'cells_table'):
            self.cells_table.setStyleSheet(AppStyles.get_tablewidget_style(actual_theme))  #
            for row in range(self.cells_table.rowCount()):
                location_combo = self.cells_table.cellWidget(row, 3)
                if location_combo and isinstance(location_combo, QComboBox):
                    location_combo.setStyleSheet(AppStyles.get_combobox_style(actual_theme))

                time_button = self.cells_table.cellWidget(row, 4)
                if time_button and isinstance(time_button, QPushButton):
                    time_button.setStyleSheet(button_style)

                hours_button = self.cells_table.cellWidget(row, 5)
                if hours_button and isinstance(hours_button, QPushButton):
                    hours_button.setStyleSheet(button_style)

                apply_button = self.cells_table.cellWidget(row, 6)
                if apply_button and isinstance(apply_button, QPushButton):
                    apply_button.setStyleSheet(button_style)  # U≈ºyj domy≈õlnego stylu

    def flatten_grouped_cells(self, grouped_cells):
        """Sp≈Çaszcza pogrupowane kom√≥rki do jednej listy"""
        flattened = []
        if not grouped_cells:
            return flattened

        for user_id, dates in grouped_cells.items():
            for date, cells in dates.items():
                for cell in cells:
                    flattened.append(cell)
        return flattened

    def setup_ui(self):
        main_layout = QVBoxLayout(self)
        header_label = QLabel("Edycja zmian w grafiku")
        main_layout.addWidget(header_label)
        self.cells_table = QTableWidget()
        self.cells_table.setColumnCount(8)  # ZMIANA: 7 -> 8
        self.cells_table.setHorizontalHeaderLabels(
            ["Data", "U≈ºytkownik", "Symbol", "Lokalizacja", "Godzina rozp.", "Liczba godzin", "Akcje",
             "Status"])  # ZMIANA: Dodano "Status"
        self.cells_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.cells_table.horizontalHeader().setStretchLastSection(True)
        self.cells_table.setRowCount(len(self.flattened_cells))
        user_can_edit_time_hours = self.user_role in ["Pracownik WPR", "Lider OUT"]

        for row, cell in enumerate(self.flattened_cells):
            date_str = cell.get('date_str', '')
            date_item = QTableWidgetItem(self.format_date(date_str))
            date_item.setFlags(date_item.flags() & ~Qt.ItemIsEditable)
            self.cells_table.setItem(row, 0, date_item)

            user_name = cell.get('uzytkownik_dane', 'Nieznany')
            user_item = QTableWidgetItem(user_name)
            user_item.setFlags(user_item.flags() & ~Qt.ItemIsEditable)
            self.cells_table.setItem(row, 1, user_item)

            symbol = cell.get('symbol', '')
            symbol_item = QTableWidgetItem(symbol)
            symbol_item.setFlags(symbol_item.flags() & ~Qt.ItemIsEditable)
            self.cells_table.setItem(row, 2, symbol_item)

            from symbol_parser import parse_symbol
            parsed_symbol = parse_symbol(cell.get('symbol', ''))

            location_code = parsed_symbol.get('location') or cell.get('lokalizacja_domyslna', 'h')
            start_hour = parsed_symbol.get('start_hour', 8)
            work_hours = parsed_symbol.get('work_hours')
            if work_hours is None:
                work_hours = cell.get('etat', 8.0)

            try:
                work_hours = int(float(work_hours))
            except (ValueError, TypeError):
                work_hours = 8

            location_combo = QComboBox()
            location_combo.addItem("SBC (s)", "s");
            location_combo.addItem("mPrzystanek (p)", "p");
            location_combo.addItem("HomeOffice (h)", "h")
            location_index = {'s': 0, 'p': 1, 'h': 2}.get(location_code, 2)
            location_combo.setCurrentIndex(location_index)
            self.cells_table.setCellWidget(row, 3, location_combo)

            time_button = QPushButton(str(start_hour))
            time_button.setProperty("cell_index", row);
            time_button.setProperty("field_type", "hour")
            time_button.clicked.connect(self.show_digit_selection)
            time_button.setMinimumWidth(50);
            time_button.setEnabled(user_can_edit_time_hours)
            self.cells_table.setCellWidget(row, 4, time_button)

            hours_button = QPushButton(str(work_hours))
            hours_button.setProperty("cell_index", row);
            hours_button.setProperty("field_type", "hours")
            hours_button.clicked.connect(self.show_digit_selection)
            hours_button.setMinimumWidth(50);
            hours_button.setEnabled(user_can_edit_time_hours)
            self.cells_table.setCellWidget(row, 5, hours_button)

            can_edit_this_row_controls = user_can_edit_time_hours or (symbol != "")
            apply_button = QPushButton("Zastosuj")
            apply_button.setProperty("cell_index", row)
            apply_button.clicked.connect(self.apply_change_by_index)
            apply_button.setEnabled(can_edit_this_row_controls)
            self.cells_table.setCellWidget(row, 6, apply_button)

            # ZMIANA: Dodanie pustego itemu dla statusu
            status_item = QTableWidgetItem("")
            status_item.setFlags(status_item.flags() & ~Qt.ItemIsEditable)
            status_item.setTextAlignment(Qt.AlignCenter)
            self.cells_table.setItem(row, 7, status_item)

        main_layout.addWidget(self.cells_table)
        button_layout = QHBoxLayout()
        self.close_button = QPushButton("Zamknij")
        self.close_button.clicked.connect(self.close)
        button_layout.addStretch();
        button_layout.addWidget(self.close_button)
        main_layout.addLayout(button_layout)
        self.apply_dialog_theme()

    def show_digit_selection(self):
        button = self.sender()
        if not button:
            return

        field_type = button.property("field_type")
        cell_index = button.property("cell_index")

        if field_type == "hour":
            values = list(range(24))
            title = "Wybierz godzinƒô rozpoczƒôcia"
        elif field_type == "hours":
            values = list(range(1, 14))
            title = "Wybierz liczbƒô godzin"
        else:
            return

        dialog = DigitSelectionDialog(self, title, values, current_theme=self.determined_theme)
        if dialog.exec() == QDialog.Accepted:
            selected_value = dialog.get_selected_value()
            if selected_value is not None:
                button.setText(str(selected_value))
                button.setProperty("selected_value", selected_value)

    def _reset_button_state(self, button):
        """Przywraca przycisk do stanu poczƒÖtkowego."""
        button.setText("Zastosuj")
        button.setStyleSheet(self.default_button_style)
        button.setEnabled(True)

    def apply_change_by_index(self):
        """
        Stosuje zmianƒô, dajƒÖc wizualnƒÖ informacjƒô zwrotnƒÖ i zapobiegajƒÖc
        wielokrotnemu klikaniu.
        """
        button = self.sender()
        if not button: return

        button.setEnabled(False)
        button.setText("Przetwarzanie...")
        QApplication.processEvents()

        cell_index = button.property("cell_index")
        if cell_index is None or cell_index >= len(self.flattened_cells):
            self._reset_button_state(button)
            return

        # ZMIANA: Pobranie kom√≥rki statusu
        status_item = self.cells_table.item(cell_index, 7)

        cell = self.flattened_cells[cell_index]
        location_combo = self.cells_table.cellWidget(cell_index, 3)
        time_button = self.cells_table.cellWidget(cell_index, 4)
        hours_button = self.cells_table.cellWidget(cell_index, 5)

        try:
            start_hour = int(float(time_button.text()))
            work_hours = int(float(hours_button.text()))
            location = location_combo.currentData()
            user_id = cell.get('uzytkownik_id')
            date_str = cell.get('date_str')
            nr_kadrowy = cell.get('nr_kadrowy')
            user_name = cell.get('uzytkownik_dane', 'Nieznany')

            original_symbol_text = cell.get('symbol', '')
            from symbol_parser import parse_symbol, build_symbol
            original_parsed_symbol = parse_symbol(original_symbol_text)

            if original_parsed_symbol.get('location') != location:
                all_events = self.parent_widget.data_provider.get_events_for_user_date(user_id, date_str)
                overtime_events = [e for e in all_events if e.get('type') == 'Nadgodziny']
                if overtime_events:
                    ot_dialog = OvertimeLocationDialog(self, overtime_events, location, self.determined_theme)
                    if ot_dialog.exec() == QDialog.Accepted:
                        location_changes = ot_dialog.get_selected_locations()
                        if location_changes:
                            self.parent_widget._update_multiple_overtime_locations(location_changes)
                    else:
                        self._reset_button_state(button)
                        return

            new_symbol = build_symbol(
                location=location, start_hour=start_hour, work_hours=work_hours,
                special_symbol=original_parsed_symbol.get('special_symbol')
            )

            if self.parent_widget and hasattr(self.parent_widget, '_call_import_changes_procedure'):
                result = self.parent_widget._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=self.year, miesiac=self.month, data=date_str, symbol=new_symbol
                )
            else:
                raise RuntimeError("Brak dostƒôpu do funkcji zapisu zmian.")

            # ZMIANA: Aktualizacja statusu w tabeli zamiast przycisku
            if result.get("success", False):
                status_item.setText("Sukces ‚úÖ")
                status_item.setForeground(QColor("green"))

                returned_symbol = result.get('returned_symbol', new_symbol)
                symbol_item = self.cells_table.item(cell_index, 2)
                if symbol_item: symbol_item.setText(returned_symbol)

                if self.parent_widget and hasattr(self.parent_widget, '_update_cells_with_new_symbols'):
                    self.parent_widget._update_cells_with_new_symbols([(user_id, date_str, returned_symbol)])
                    self.parent_widget.schedule_model.layoutChanged.emit()
            else:
                status_item.setText("Pora≈ºka ‚ùå")
                status_item.setForeground(QColor("red"))

                error_message_from_db = result.get("message", "Nieznany b≈ÇƒÖd podczas zapisu zmian.")
                formatted_error = f"üë§ {user_name} ({self.format_date(date_str)}):\n{error_message_from_db}"
                QMessageBox.warning(self, "B≈ÇƒÖd zapisu", formatted_error, QMessageBox.Ok)

        except Exception as e:
            status_item.setText("Pora≈ºka ‚ùå")
            status_item.setForeground(QColor("red"))
            log_error(f"B≈ÇƒÖd w ScheduleChangeDialog.apply_change_by_index: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd krytyczny", f"WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd: {str(e)}", QMessageBox.Ok)
        finally:
            QTimer.singleShot(2000, lambda: self._reset_button_state(button))

    def format_date(self, date_str):
        """Formatuje ciƒÖg daty z YYYY-MM-DD do DD.MM.YYYY"""
        try:
            year, month, day = date_str.split('-')
            return f"{day}.{month}.{year}"
        except:
            return date_str


class DigitSelectionDialog(QDialog):
    """
    Dialog do wyboru cyfry z siatki przycisk√≥w.
    """

    def __init__(self, parent=None, title="Wybierz warto≈õƒá", values=None, current_theme="dark"):  # Dodano current_theme
        super().__init__(parent)
        self.parent_widget = parent
        self.current_theme = current_theme  # U≈ºyj przekazanego motywu
        self.setWindowTitle(title)
        self.setModal(True)
        self.selected_value = None

        if values is None:
            values = list(range(10))

        self.values = values
        self.setFixedSize(230, 160)

        self.setObjectName("DigitSelectionDialogInstance")

        self.setup_ui()
        self.apply_dialog_theme()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu DigitSelectionDialog."""
        actual_theme = self.current_theme  # U≈ºyj motywu przekazanego w konstruktorze

        # debug_print(f"DigitSelectionDialog ('{self.windowTitle()}'): Stosujƒô motyw '{actual_theme}'")

        self.setStyleSheet(AppStyles.get_dialog_style(actual_theme))  #

        button_style_qss = AppStyles.get_button_style(actual_theme)

        if hasattr(self, 'grid_layout'):
            for i in range(self.grid_layout.count()):
                widget = self.grid_layout.itemAt(i).widget()
                if isinstance(widget, QPushButton):
                    widget.setStyleSheet(button_style_qss)
                    widget.style().unpolish(widget)
                    widget.style().polish(widget)

        if hasattr(self, 'cancel_button'):
            self.cancel_button.setStyleSheet(button_style_qss)
            self.cancel_button.style().unpolish(self.cancel_button)
            self.cancel_button.style().polish(self.cancel_button)

        self.style().unpolish(self)
        self.style().polish(self)
        self.update()

    def setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)

        self.grid_layout = QGridLayout()
        self.grid_layout.setSpacing(5)

        cols = min(6, len(self.values))
        if cols == 0: cols = 1  # Zapobieganie dzieleniu przez zero

        for i, value in enumerate(self.values):
            row = i // cols
            col = i % cols

            button = QPushButton(str(value))
            button.setFixedSize(30, 30)  # Zwiƒôkszono rozmiar przycisk√≥w
            button.setProperty("value", value)
            button.clicked.connect(self.on_value_selected)
            # Styl przycisk√≥w zostanie ustawiony w apply_dialog_theme
            self.grid_layout.addWidget(button, row, col)

        main_layout.addLayout(self.grid_layout)

        self.cancel_button = QPushButton("Anuluj")
        self.cancel_button.clicked.connect(self.reject)
        # Styl przycisku zostanie ustawiony w apply_dialog_theme

        button_layout = QHBoxLayout()
        button_layout.addStretch()
        button_layout.addWidget(self.cancel_button)
        main_layout.addLayout(button_layout)

        # Zastosuj motyw po utworzeniu UI
        self.apply_dialog_theme()

    def on_value_selected(self):
        """Obs≈Çuguje wyb√≥r warto≈õci"""
        button = self.sender()
        if button:
            self.selected_value = button.property("value")
            self.accept()

    def get_selected_value(self):
        """Zwraca wybranƒÖ warto≈õƒá"""
        return self.selected_value


class OvertimeLocationDialog(QDialog):
    """Dialog do indywidualnej edycji lokalizacji dla wykrytych nadgodzin."""

    def __init__(self, parent, overtime_events, current_shift_location, current_theme="dark"):
        super().__init__(parent)
        self.setWindowTitle("Zmiana lokalizacji a nadgodziny")
        self.setMinimumWidth(450)  # Zwiƒôkszamy szeroko≈õƒá
        self.theme = current_theme
        self.events = overtime_events
        self.location_combos = []  # Bƒôdziemy przechowywaƒá tu referencje do ComboBox√≥w

        self.setup_ui(current_shift_location)
        self.apply_styles()

    def setup_ui(self, current_shift_location):
        layout = QVBoxLayout(self)

        info_text = (f"Wykryto {len(self.events)} wpis(y) nadgodzin w tym dniu. "
                     f"Lokalizacja w grafiku zosta≈Ça zmieniona na <b>'{current_shift_location.upper()}'</b>.<br><br>"
                     "Dla ka≈ºdego wpisu nadgodzin mo≈ºesz ustawiƒá innƒÖ lokalizacjƒô.")
        layout.addWidget(QLabel(info_text))

        # U≈ºywamy QGridLayout dla lepszego u≈Ço≈ºenia kontrolek
        grid_layout = QGridLayout()
        grid_layout.setSpacing(10)

        # Nag≈Ç√≥wki
        grid_layout.addWidget(QLabel("<b>Godziny nadliczbowe</b>"), 0, 0)
        grid_layout.addWidget(QLabel("<b>Obecna lokalizacja</b>"), 0, 1)
        grid_layout.addWidget(QLabel("<b>Nowa lokalizacja</b>"), 0, 2)

        # Dane dla ka≈ºdego wpisu nadgodzin
        for i, event in enumerate(self.events):
            row = i + 1
            # Informacje o godzinach
            event_label = QLabel(f"{event.get('time_from', '?')} - {event.get('time_to', '?')}")

            # Aktualna lokalizacja nadgodzin (zak≈Çadamy, ≈ºe jest w danych zdarzenia)
            current_ot_location_code = event.get('location', 'b/d')  # 'b/d' - brak danych
            location_map = {'h': 'Home Office', 's': 'SBC', 'p': 'mPrzystanek'}
            current_ot_location_label = QLabel(location_map.get(current_ot_location_code, "Nieznana"))

            # Menu wyboru nowej lokalizacji
            location_combo = QComboBox()
            location_combo.addItem("Bez zmian", "skip")
            location_combo.addItem(f"Jak w grafiku ({current_shift_location.upper()})", current_shift_location)
            location_combo.addItem("Home Office (h)", "h")
            location_combo.addItem("SBC (s)", "s")
            location_combo.addItem("mPrzystanek (p)", "p")

            # Ustaw domy≈õlnie "Bez zmian"
            location_combo.setCurrentIndex(0)

            self.location_combos.append(location_combo)  # Zapisz referencjƒô

            grid_layout.addWidget(event_label, row, 0)
            grid_layout.addWidget(current_ot_location_label, row, 1)
            grid_layout.addWidget(location_combo, row, 2)

        layout.addLayout(grid_layout)

        button_box = QHBoxLayout()
        self.ok_button = QPushButton("Zatwierd≈∫ zmiany")
        self.cancel_button = QPushButton("Anuluj")
        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)
        button_box.addStretch()
        button_box.addWidget(self.cancel_button)
        button_box.addWidget(self.ok_button)
        layout.addLayout(button_box)

    def apply_styles(self):
        self.setStyleSheet(AppStyles.get_dialog_style(self.theme))
        for button in self.findChildren(QPushButton):
            button.setStyleSheet(AppStyles.get_button_style(self.theme))
        for combo in self.findChildren(QComboBox):
            combo.setStyleSheet(AppStyles.get_combobox_style(self.theme))
        for box in self.findChildren(QGroupBox):
            box.setStyleSheet(f"""
                QGroupBox {{
                    border: 1px solid {'#495057' if self.theme == 'dark' else '#ced4da'};
                    border-radius: 4px;
                    margin-top: 10px;
                }}
                QGroupBox::title {{
                    subcontrol-origin: margin;
                    subcontrol-position: top left;
                    padding: 0 3px;
                    left: 10px;
                }}
            """)

    def get_selected_locations(self):
        """Zwraca listƒô zmian w formacie [(event_id, nowa_lokalizacja), ...]."""
        changes = []
        for i, combo in enumerate(self.location_combos):
            selected_loc = combo.currentData()
            if selected_loc != "skip":  # Zapisujemy tylko te, kt√≥re faktycznie majƒÖ byƒá zmienione
                event_id = self.events[i]['id']
                changes.append((event_id, selected_loc))
        return changes
