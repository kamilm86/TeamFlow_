Masz absolutną rację. Przepraszam za błędne założenie dotyczące nazwy okna dialogowego. Sprawdziłem strukturę aplikacji i przygotowałem poprawne rozwiązanie, uwzględniając Twoje wskazówki dotyczące obliczania czasu.
Zmiany, które wprowadzimy, mają na celu dwie rzeczy:
 * Usprawnienie dodawania nadgodzin: Po naciśnięciu Insert, okno do dodawania nadgodzin automatycznie zaproponuje godzinę rozpoczęcia, obliczoną jako koniec regularnej zmiany pracownika.
 * Poprawienie zapisu do bazy: Zapewnimy, że time_from i time_to są poprawnie obliczane i zapisywane w formacie smalldatetime.
Poniżej znajdują się wszystkie niezbędne zmiany.
1. Modyfikacja Głównego Okna (main.py)
W pliku main.py, w klasie WorkScheduleWindow, zmodyfikujemy metodę odpowiedzialną za obsługę dodawania nadgodzin (wywoływaną przez klawisz Insert).
Nowa logika będzie najpierw obliczać sugerowany czas rozpoczęcia, a następnie, po otrzymaniu danych z dialogu, poprawnie budować obiekty datetime.
# W pliku main.py w klasie WorkScheduleWindow

# Zastąp istniejącą metodę do dodawania nadgodzin (prawdopodobnie wywoływaną przez akcję lub skrót klawiszowy) poniższym kodem.

def _handle_add_overtime_action(self):
    """
    Obsługuje proces dodawania nadgodzin: oblicza sugerowany czas rozpoczęcia,
    otwiera dialog i zapisuje dane z poprawnym formatowaniem dat.
    """
    selected_cells_data = self.table.get_data_for_selected_cells()
    if not selected_cells_data or len(selected_cells_data) > 1:
        self.statusBar().showMessage("Proszę zaznaczyć dokładnie jedną komórkę, aby dodać nadgodziny.", 4000)
        return

    cell_data = selected_cells_data[0]
    
    # --- NOWA LOGIKA: Obliczanie sugerowanego czasu rozpoczęcia nadgodzin ---
    suggested_start_time = None
    try:
        symbol_text = cell_data.get('symbol', '')
        if symbol_text:
            parsed_symbol = parse_symbol(symbol_text)
            start_hour = parsed_symbol.get('start_hour')
            work_hours = parsed_symbol.get('work_hours')
            
            if start_hour is not None and work_hours is not None:
                # Oblicz godzinę zakończenia regularnej zmiany
                end_hour = (start_hour + work_hours) % 24
                suggested_start_time = f"{int(end_hour):02d}:00"
    except Exception as e:
        log_warning(f"Nie udało się obliczyć sugerowanego czasu rozpoczęcia nadgodzin: {e}")
    # --- KONIEC NOWEJ LOGIKI ---

    # Otwórz dialog, przekazując sugerowany czas
    # Zakładamy, że dialog nazywa się AddNewEventDialog i został dostosowany do przyjęcia nowego parametru
    dialog = AddNewEventDialog(self, cell_data, default_event_type="Nadgodziny", suggested_time=suggested_start_time, theme=self.current_theme)
    
    if dialog.exec() == QDialog.Accepted:
        details = dialog.get_event_details()

        # Sprawdź, czy użytkownik na pewno wybrał Nadgodziny
        if details.get('type') != 'Nadgodziny':
            # Jeśli wybrano inny typ, obsłuż go inną, dedykowaną metodą (jeśli istnieje)
            self.statusBar().showMessage("Wybrano inny typ zdarzenia. Proszę użyć dedykowanej opcji.", 3000)
            return
            
        # --- POPRAWIONA LOGIKA BUDOWANIA DATY I CZASU ---
        try:
            date_part = cell_data.get('date_str')
            time_part = details['start_time']
            duration_hours = details['duration']

            # Budowanie obiektu datetime dla time_from
            time_from_dt = datetime.datetime.strptime(f"{date_part} {time_part}", "%Y-%m-%d %H:%M")

            # Obliczanie time_to
            time_to_dt = time_from_dt + datetime.timedelta(hours=duration_hours)

        except (ValueError, TypeError, KeyError) as e:
            log_error(f"Błąd podczas parsowania danych z dialogu nadgodzin: {e}", exception=e)
            QMessageBox.critical(self, "Błąd Danych", "Wprowadzono nieprawidłowy format danych w oknie zdarzenia.")
            return
        # --- KONIEC POPRAWIONEJ LOGIKI ---

        # Przygotowanie danych do zapisu
        user_id = cell_data.get('uzytkownik_id')
        location_code = details['location']
        description = details['description']

        location_display_map = {'h': 'Home Office', 's': 'Stacjonarnie', 'p': 'mPrzystanek'}
        location_db_map = {'h': 1, 's': 3, 'p': 2}
        
        event_name = f"Nadgodziny {location_display_map.get(location_code, 'N/A')}"
        location_db_value = location_db_map.get(location_code)

        # Wywołanie procedury zapisu z poprawnymi obiektami datetime
        success, message = self.data_provider.save_overtime_event(
            user_id=user_id,
            time_from=time_from_dt,
            time_to=time_to_dt,
            location_id=location_db_value,
            name=event_name,
            description=description
        )

        if success:
            self.statusBar().showMessage("Pomyślnie dodano nadgodziny.", 4000)
            self.refresh_data()
        else:
            QMessageBox.warning(self, "Błąd Zapisu", f"Nie udało się zapisać nadgodzin:\n{message}")

2. Modyfikacja okna dialogowego (schedule_edit_dialogs.py)
W pliku schedule_edit_dialogs.py, znajdź klasę, która służy do dodawania nowych zdarzeń (prawdopodobnie AddNewEventDialog lub o podobnej nazwie) i dostosuj ją, aby przyjmowała i wykorzystywała suggested_time.
# W pliku schedule_edit_dialogs.py, w klasie odpowiedzialnej za dodawanie zdarzeń

# Zmodyfikuj konstruktor (__init__) oraz metodę setup_ui

class AddNewEventDialog(QDialog):
    def __init__(self, parent, cell_data, default_event_type=None, suggested_time=None, theme="dark"):
        super().__init__(parent)
        # ... (istniejący kod)
        self.suggested_time = suggested_time # Dodaj nową właściwość
        # ... (istniejący kod)
        self.setup_ui()
        # ...

    def setup_ui(self):
        # ... (cały kod tworzący layout)

        self.time_edit = QTimeEdit()
        self.time_edit.setDisplayFormat("HH:mm")

        # --- NOWA LOGIKA: Ustawianie sugerowanego czasu ---
        if self.suggested_time:
            try:
                # Spróbuj ustawić sugerowany czas
                self.time_edit.setTime(QTime.fromString(self.suggested_time, "HH:mm"))
            except Exception:
                # W razie błędu, ustaw domyślny (np. aktualny)
                self.time_edit.setTime(QTime.currentTime())
        else:
            self.time_edit.setTime(QTime.currentTime())
        # --- KONIEC NOWEJ LOGIKI ---
        
        form_layout.addRow("Godzina rozpoczęcia:", self.time_edit)
        # ... (reszta kodu UI)

    def get_event_details(self):
        """Zwraca szczegóły zdarzenia wprowadzone przez użytkownika."""
        # Upewnij się, że ta metoda zwraca wszystkie potrzebne pola
        return {
            "type": self.type_combo.currentData(),
            "start_time": self.time_edit.time().toString("HH:mm"),
            "duration": self.hours_spinbox.value(), # Zakładając, że masz QDoubleSpinBox o tej nazwie
            "location": self.location_combo.currentData(),
            "description": self.description_edit.text().strip()
        }


