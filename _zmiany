To, że okno zamyka się natychmiast, oznacza zazwyczaj błąd składni w pliku .bat. Wiersz poleceń (CMD) napotyka znak, którego nie rozumie (np. źle zamknięty nawias w bloku kodu), i "wywala się" zanim zdąży wykonać polecenie pause.
W poprzednim kodzie użyłem bloku ( echo ... ), który jest elegancki, ale bardzo wrażliwy na błędy.
Przygotowałem wersję "Pancerną". Zmieniłem sposób zapisywania pliku PowerShell – teraz robimy to linijka po linijce. To jest mniej ładne w kodzie, ale niezawodne i nie powoduje natychmiastowego zamknięcia okna.
Co musisz zrobić:
Skopiuj poniższy kod i wklej go do swojego pliku .bat.
@echo off
setlocal

:: --- 1. KONFIGURACJA ---
:: Mapujemy dysk, zeby uniknac bledu UNC
pushd "%~dp0"

set "APP_NAME=TeamFlowApp.exe"
:: Ustawiamy sciezke do folderu glownego na serwerze (tam gdzie jest ten skrypt)
set "NET_ROOT=%~dp0"
:: Usuwamy ewentualny ukosnik na koncu
if "%NET_ROOT:~-1%"=="\" set "NET_ROOT=%NET_ROOT:~0,-1%"

:: Sciezki lokalne
set "LOCAL_DIR=%TEMP%\TeamFlowApp"
set "LOCAL_EXE=%LOCAL_DIR%\%APP_NAME%"
set "LOCAL_VER_FILE=%LOCAL_DIR%\installed_version.txt"
set "PS_SCRIPT=%TEMP%\updater_safe.ps1"

:: --- 2. TWORZENIE SKRYPTU POWERSHELL (METODA BEZPIECZNA) ---
:: Kasujemy stary plik, zeby dopisywac do czystego
if exist "%PS_SCRIPT%" del "%PS_SCRIPT%"

:: Zapisujemy kod linijka po linijce (to zapobiega bledom skladni BAT)
echo $ErrorActionPreference = 'Stop' >> "%PS_SCRIPT%"
echo $netRoot = $env:NET_ROOT >> "%PS_SCRIPT%"
echo $localDir = $env:LOCAL_DIR >> "%PS_SCRIPT%"
echo $localExe = $env:LOCAL_EXE >> "%PS_SCRIPT%"
echo $localVerFile = $env:LOCAL_VER_FILE >> "%PS_SCRIPT%"
echo $appName = $env:APP_NAME >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo try { >> "%PS_SCRIPT%"
echo     Write-Host "Szukam wersji w: $netRoot" >> "%PS_SCRIPT%"
echo     $latestFolder = Get-ChildItem -Path $netRoot -Directory ^| Where-Object { $_.Name -match '^\d+\.\d+\.\d+$' } ^| Sort-Object { [version]$_.Name } -Descending ^| Select-Object -First 1 >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo     if (-not $latestFolder) { >> "%PS_SCRIPT%"
echo         Write-Host "[BLAD] Nie znaleziono folderow z wersjami (np. 1.0.17) w lokalizacji skryptu!" -ForegroundColor Red >> "%PS_SCRIPT%"
echo         exit 1 >> "%PS_SCRIPT%"
echo     } >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo     $latestVersion = $latestFolder.Name >> "%PS_SCRIPT%"
echo     $sourceExe = Join-Path $latestFolder.FullName $appName >> "%PS_SCRIPT%"
echo     Write-Host "Najnowsza wersja na serwerze: $latestVersion" >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo     $currentVersion = "0.0.0" >> "%PS_SCRIPT%"
echo     if (Test-Path $localVerFile) { $currentVersion = (Get-Content $localVerFile).Trim() } >> "%PS_SCRIPT%"
echo     Write-Host "Zainstalowana wersja:     $currentVersion" >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo     $needsUpdate = $false >> "%PS_SCRIPT%"
echo     if ([version]$latestVersion -gt [version]$currentVersion) { $needsUpdate = $true } >> "%PS_SCRIPT%"
echo     elseif (-not (Test-Path $localExe)) { $needsUpdate = $true } >> "%PS_SCRIPT%"
echo. >> "%PS_SCRIPT%"
echo     if ($needsUpdate) { >> "%PS_SCRIPT%"
echo         Write-Host "--- Aktualizacja do $latestVersion ---" -ForegroundColor Cyan >> "%PS_SCRIPT%"
echo         if (-not (Test-Path $sourceExe)) { throw "Brak pliku $appName w folderze $latestVersion" } >> "%PS_SCRIPT%"
echo         Stop-Process -Name "TeamFlowApp" -ErrorAction SilentlyContinue >> "%PS_SCRIPT%"
echo         Start-Sleep -Seconds 2 >> "%PS_SCRIPT%"
echo         if (-not (Test-Path $localDir)) { New-Item -ItemType Directory -Path $localDir ^| Out-Null } >> "%PS_SCRIPT%"
echo         Copy-Item -LiteralPath $sourceExe -Destination $localExe -Force >> "%PS_SCRIPT%"
echo         Set-Content -Path $localVerFile -Value $latestVersion >> "%PS_SCRIPT%"
echo         Unblock-File -Path $localExe >> "%PS_SCRIPT%"
echo         Write-Host "Gotowe." -ForegroundColor Green >> "%PS_SCRIPT%"
echo     } else { >> "%PS_SCRIPT%"
echo         Write-Host "Aplikacja aktualna." -ForegroundColor Green >> "%PS_SCRIPT%"
echo     } >> "%PS_SCRIPT%"
echo } catch { >> "%PS_SCRIPT%"
echo     Write-Host "[BLAD KRYTYCZNY] $($_.Exception.Message)" -ForegroundColor Red >> "%PS_SCRIPT%"
echo     exit 1 >> "%PS_SCRIPT%"
echo } >> "%PS_SCRIPT%"

:: --- 3. URUCHOMIENIE ---
powershell -NoProfile -ExecutionPolicy Bypass -File "%PS_SCRIPT%"

:: Jesli byl blad, nie zamykaj okna
if %errorlevel% NEQ 0 (
    echo.
    echo [ERROR] Skrypt napotkal problem.
    pause
)

:: Sprzatanie
del "%PS_SCRIPT%" >nul 2>&1

:: Start aplikacji
echo.
if exist "%LOCAL_EXE%" (
    echo [INFO] Uruchamianie aplikacji...
    start "" "%LOCAL_EXE%"
) else (
    echo [BLAD] Nie udalo sie uruchomic aplikacji.
    pause
)

popd

Dlaczego to zadziała?
 * Usunąłem blokadę ( ... ): Zamiast grupować komendy, każda linijka jest oddzielnie dopisywana (>>) do pliku. Dzięki temu jeden błąd nie "wysadza" całego skryptu.
 * Debugowanie: Kod jest tak skonstruowany, że jeśli PowerShell zwróci błąd (exit 1), skrypt .bat to wykryje (if %errorlevel% NEQ 0) i zrobi pause, więc zobaczysz czerwony komunikat zamiast znikającego okna.
Pamiętaj o strukturze folderów:
Skrypt .bat musi leżeć w tym samym folderze co podfoldery z wersjami (1.0.17, 1.0.18 itd.).
