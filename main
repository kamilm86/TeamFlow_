import sys
import time
import getpass
from datetime import datetime, timedelta
from typing import List, Dict
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill
from openpyxl.utils import get_column_letter
import functools
# --- GŁÓWNE IMPORTY (NIEZBĘDNE PRZY STARCIE) ---
from PySide6.QtWidgets import (QApplication, QMainWindow, QTableView,
                               QVBoxLayout, QHBoxLayout, QWidget, QLabel, QComboBox,
                               QPushButton, QHeaderView, QAbstractItemView, QListWidget,
                               QListWidgetItem, QLineEdit, QDialog, QCheckBox, QFrame, QDateEdit,
                               QMessageBox, QSplitter, QStyledItemDelegate, QFileDialog,
                               QGridLayout, QSizePolicy, QScrollArea, QGroupBox, QStyle)
from PySide6.QtCore import Qt, Signal, QDate, QTimer, QEvent, QObject, QItemSelection, QItemSelectionModel
from packaging.version import parse as parse_version
from PySide6.QtGui import QShortcut, QKeySequence, QFont, QColor, QStandardItem, QStandardItemModel, QPixmap, QPainter, QPen, QIcon

from data_provider import DataProvider
from db_connector import DatabaseConnector, get_modifier_id, load_all_app_settings
from config import APP_VERSION, SQL_OBJECTS
from app_settings import app_settings
from settings_db import SettingsDatabase
from styles import AppStyles
from column_definitions import ColumnDefinitions
from schedule_model import ScheduleTableModel, ROLE_DATA
from events_model import EventsTableModel
from split_table_view import SplitTableView
from schedule_delegates import OvertimeItemDelegate
from schedule_edit_dialogs import ScheduleChangeDialog, ReasonDialog, OvertimeLocationDialog
from events_delegates import ButtonDelegate
from debug_utils import debug_print, log_warning, log_error, setup_logging, close_log_file
from symbol_parser import parse_symbol, build_symbol, get_symbol_description
from email_dialog import EmailDialog
from outlook_connector import create_outlook_email, create_email_from_template


class ScheduleKeyboardFilter(QObject):
    """
    Dedykowany filtr zdarzeń klawiatury dla tabeli grafiku z obsługa:
    - dwucyfrowych godzin i wieloznakowych symboli (z buforowaniem)
    - modyfikacji liczby godzin (+/-/=) z poprawnym odświeżaniem bilansu.
    """

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self._digit_buffer = ""
        self._buffer_timer = QTimer()
        self._buffer_timer.setSingleShot(True)
        self._buffer_timer.timeout.connect(self._process_digit_buffer_on_timeout)
        self._buffer_timeout = 1200
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1200

        # Bufor i timer dla wieloznakowych symboli
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1200

    def eventFilter(self, obj, event):
        """Główna metoda filtrująca zdarzenia klawiatury."""
        if not (hasattr(self.main_window, 'table') and
                hasattr(self.main_window.table, 'schedule_view') and
                obj == self.main_window.table.schedule_view and
                event.type() == QEvent.KeyPress):
            return False

        key = event.key()
        role = self.main_window.current_user_role

        if key in (Qt.Key_Plus, Qt.Key_Equal, Qt.Key_Minus):
            self._clear_digit_buffer()
            self._clear_char_buffer()
            # ZMIANA: Odwołanie do app_settings
            if app_settings.has_permission(role, 'schedule_keyboard_edit'):
                self._handle_hour_modification(key)
            return True

        # ZMIANA: Odwołanie do app_settings
        can_edit_hours_symbols = app_settings.has_permission(role, 'schedule_keyboard_edit')

        is_digit_key = (Qt.Key_0 <= key <= Qt.Key_9)
        is_char_key = (Qt.Key_A <= key <= Qt.Key_Z)
        is_delete_key = key in [Qt.Key_Delete, Qt.Key_Backspace]
        is_escape_key = key == Qt.Key_Escape

        if not can_edit_hours_symbols and (is_digit_key or is_char_key or is_delete_key):
            return True

        if is_digit_key or is_char_key or is_delete_key:
            if not self._validate_selected_cells():
                return True

        if is_digit_key:
            self._handle_digit_input(key - Qt.Key_0)
            return True

        if is_char_key:
            self._handle_char_input(event.text())
            return True

        if is_delete_key:
            # ZMIANA: Odwołanie do app_settings
            if app_settings.has_permission(role, 'action_delete_symbol'):
                self.main_window.clear_selected_cells()
            self._clear_digit_buffer()
            self._clear_char_buffer()
            return True

        if is_escape_key:
            self._clear_digit_buffer()
            self._clear_char_buffer()
            self.main_window.table.schedule_view.clearSelection()
            return True

        if key in [Qt.Key_Space, Qt.Key_Enter, Qt.Key_Return, Qt.Key_Tab]:
            return True

        return False

    def _handle_hour_modification(self, key):
        """Obsługuje zwiększanie/zmniejszanie liczby godzin (+/-/=) z uwzględnieniem uprawnień."""
        selected_cells_data = self.main_window.table.get_data_for_selected_cells()
        if not selected_cells_data: return

        updated_info = []
        error_messages = []
        skipped_count = 0
        permission_denied_count = 0
        current_user_role = self.main_window.current_user_role  # Pobierz rolę bieżącego użytkownika

        for cell_data in selected_cells_data:
            permissions = self.main_window._get_permission_for_cell(cell_data)
            if not permissions['can_edit_hours']:
                permission_denied_count += 1
                continue

            system_pracy = cell_data.get('system_czasu_pracy', '')

            # --- POCZĄTEK ZMIANY ---
            # Sprawdź system pracy, ale zezwól na edycję dla roli 'Pracownik WPR'
            is_equivalent_system = system_pracy.strip().lower() == 'równoważny'
            if not is_equivalent_system and current_user_role != 'Pracownik WPR':
                skipped_count += 1
                continue
            # --- KONIEC ZMIANY ---

            current_symbol = cell_data.get('symbol', '')
            if not current_symbol: continue

            try:
                parsed = parse_symbol(current_symbol)
                if parsed.get('work_hours') is None: continue

                current_hours = int(parsed['work_hours'])
                new_hours = min(12, current_hours + 1) if key in (Qt.Key_Plus, Qt.Key_Equal) else max(1,
                                                                                                      current_hours - 1)
                if new_hours == current_hours: continue

                new_symbol = build_symbol(
                    location=parsed.get('location'), start_hour=parsed.get('start_hour'),
                    work_hours=new_hours, special_symbol=parsed.get('special_symbol')
                )

                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self.main_window._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )

                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"⑭ {cell_data.get('uzytkownik_dane')}: {result.get('message', 'Błąd zapisu.')}")
            except (ValueError, TypeError) as e:
                log_warning(f"Błąd modyfikacji godzin dla symbolu '{current_symbol}': {e}")
                error_messages.append(f"⑭ {cell_data.get('uzytkownik_dane')}: Błąd aplikacji: {e}")

        if permission_denied_count > 0:
            self.main_window.statusBar().showMessage(
                f"Pominięto {permission_denied_count} komórek z powodu braku uprawnień do zmiany godzin.", 4000)

        if updated_info:
            self.main_window._update_cells_with_new_symbols(updated_info)
            self.main_window.statusBar().showMessage(f"Zmieniono liczbę godzin dla {len(updated_info)} komórek.", 4000)

        if error_messages:
            QMessageBox.warning(self.main_window, "Błędy podczas zapisu",
                                "Wystąpiły następujące błędy:\\n\\n" + "\\n".join(error_messages))
        elif not updated_info and skipped_count > 0 and skipped_count == len(selected_cells_data):
            self.main_window.statusBar().showMessage("Operacja dozwolona tylko dla Równoważnego Systemu Czasu Pracy.",
                                                     5000)

    def _handle_char_input(self, char: str):
        self._clear_digit_buffer()
        self._char_buffer += char.upper()
        self.main_window.statusBar().showMessage(f"Wpisywanie symbolu: {self._char_buffer}", self._char_buffer_timeout)
        if len(self._char_buffer) >= 3:
            self._char_buffer_timer.stop()
            self._process_char_buffer()
        else:
            self._char_buffer_timer.start(self._char_buffer_timeout)

    def _process_char_buffer(self):
        symbol = self._char_buffer
        self._clear_char_buffer()
        if not symbol: return

        # Krok 1: Sprawdź, czy symbol jest w ogóle poprawny
        if symbol in self.main_window.get_all_valid_symbols():

            # --- POCZĄTEK POPRAWKI ---
            # Krok 2: Sprawdź, czy bieżąca rola ma uprawnienia do tego symbolu
            current_role = self.main_window.current_user_role
            if app_settings.has_symbol_permission(current_role, symbol):
                self.main_window.apply_symbol_from_keyboard(symbol)
            else:
                # Symbol jest poprawny, ale użytkownik nie ma uprawnień
                self.main_window.statusBar().showMessage(
                    f"Brak uprawnień do użycia symbolu '{symbol}' dla Twojej roli.", 4000)
            # --- KONIEC POPRAWKI ---

        else:
            # Symbol jest nieprawidłowy
            self.main_window.statusBar().showMessage(f"Błąd: Symbol '{symbol}' jest nieprawidłowy!", 4000)

    def _handle_digit_input(self, digit: int):
        self._clear_char_buffer()
        self._digit_buffer += str(digit)
        self.main_window.statusBar().showMessage(f"Wpisywanie godziny: {self._digit_buffer}", self._buffer_timeout)

        if len(self._digit_buffer) == 1:
            if int(self._digit_buffer) >= 3:
                self.main_window.quick_edit_selected_cells(int(self._digit_buffer))
                self._clear_digit_buffer()
            else:
                self._buffer_timer.start(self._buffer_timeout)
        elif len(self._digit_buffer) == 2:
            self._buffer_timer.stop()
            potential_hour = int(self._digit_buffer)
            hour = potential_hour if 0 <= potential_hour <= 23 else int(self._digit_buffer[0])
            self.main_window.quick_edit_selected_cells(hour)
            self._clear_digit_buffer()
        else:
            self._buffer_timer.stop()
            self.main_window.quick_edit_selected_cells(digit)
            self._clear_digit_buffer()

    def _process_digit_buffer_on_timeout(self):
        if self._digit_buffer:
            self.main_window.quick_edit_selected_cells(int(self._digit_buffer))
            self._clear_digit_buffer()

    def _clear_digit_buffer(self):
        self._digit_buffer = ""
        if self._buffer_timer.isActive(): self._buffer_timer.stop()
        if self.main_window.statusBar().currentMessage().startswith("Wpisywanie godziny:"):
            self.main_window.statusBar().clearMessage()

    def _clear_char_buffer(self):
        self._char_buffer = ""
        if self._char_buffer_timer.isActive(): self._char_buffer_timer.stop()
        if self.main_window.statusBar().currentMessage().startswith("Wpisywanie symbolu:"):
            self.main_window.statusBar().clearMessage()

    def _validate_selected_cells(self) -> bool:
        selected_cells_data = self.main_window.table.get_data_for_selected_cells()
        if not selected_cells_data: return False
        return self.main_window._can_modify_cells(selected_cells_data)


class CustomMultiComboBox(QComboBox):
    """Niestandardowy ComboBox z obsługa wielokrotnego wyboru (wersja poprawiona)."""
    selection_changed = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)

        self._selected_items = set()
        self._select_all_text = "-Wszystkie-"

        # Konfiguracja modelu
        self.setModel(QStandardItemModel(self))

        # Konfiguracja wyglądu
        self.setEditable(True)
        self.lineEdit().setReadOnly(True)
        self.setEditText("-Wszystkie-")
        self.setSizeAdjustPolicy(QComboBox.AdjustToContents)

        # Używamy filtra zdarzeń do przechwytywania kliknięć, co zapobiega zamykaniu listy
        self.view().viewport().installEventFilter(self)
        self.lineEdit().installEventFilter(self)

        # Delegat jest potrzebny do poprawnego renderowania
        self.setItemDelegate(QStyledItemDelegate(self))

    def eventFilter(self, obj, event):
        # Przechwytujemy kliknięcie myszą w polu tekstowym, aby pokazać listę
        if obj == self.lineEdit() and event.type() == QEvent.MouseButtonPress:
            self.showPopup()
            return True

        # Przechwytujemy zwolnienie przycisku myszy na liście (widoku)
        if obj == self.view().viewport() and event.type() == QEvent.MouseButtonRelease:
            index = self.view().indexAt(event.position().toPoint())  # Użyj .position().toPoint() zamiast .pos()
            if index.isValid():
                self.handle_item_pressed(index)
            return True

        return False

    def handle_item_pressed(self, index):
        """Logika zaznaczania/odznaczania elementu."""
        item = self.model().itemFromIndex(index)
        if not item:
            return

        if item.text() == self._select_all_text:
            # Logika dla przycisku "Zaznacz wszystkie"
            is_checked = (item.checkState() == Qt.Checked)
            new_state = Qt.Unchecked if is_checked else Qt.Checked
            for i in range(1, self.model().rowCount()):
                self.model().item(i).setCheckState(new_state)
        else:
            # Logika dla zwykłego elementu
            current_state = item.checkState()
            item.setCheckState(Qt.Checked if current_state == Qt.Unchecked else Qt.Unchecked)

        self._rebuild_selected_items()
        self.update_display_text()

        self.selection_changed.emit()

    def _rebuild_selected_items(self):
        """Przebudowuje zbiór zaznaczonych elementów na podstawie stanu modelu."""
        self._selected_items.clear()
        all_selected = True
        # Pętla od 1, aby pominąć element "Zaznacz wszystkie"
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.checkState() == Qt.Checked:
                self._selected_items.add(item.text())
            else:
                all_selected = False

        # Aktualizuj stan checkboxa "Zaznacz wszystkie"
        if self.model().rowCount() > 0:
            select_all_item = self.model().item(0)
            select_all_item.setCheckState(Qt.Checked if all_selected else Qt.Unchecked)

    def hidePopup(self):
        """Aktualizuje tekst po zamknięciu listy."""
        self.update_display_text()
        super().hidePopup()

    def add_items(self, items):
        """Dodaje elementy do ComboBoxa."""
        self.clear()

        select_all_item = QStandardItem(self._select_all_text)
        select_all_item.setCheckable(True)
        self.model().appendRow(select_all_item)

        for item_text in sorted(items):
            item = QStandardItem(item_text)
            item.setCheckable(True)
            self.model().appendRow(item)

        self.update_display_text()

    def showPopup(self):
        """Pokaż menu rozwijane z dostosowaną szerokością."""
        super().showPopup()

        width = self.view().sizeHintForColumn(0) + 20
        width = min(width, 450)
        self.view().setMinimumWidth(width)

    def clear(self):
        """Czyści listę elementów."""
        self.model().clear()
        self._selected_items.clear()
        self.setEditText("-Wszystkie-")

    def clear_selection(self):
        """Czyści zaznaczenie wszystkich elementów i emituje sygnał o zmianie."""
        for i in range(self.model().rowCount()):
            self.model().item(i).setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()
        # ZMIANA: Dodano emisję sygnału, aby odświeżyć filtrowanie
        self.selection_changed.emit()

    def get_selected_items(self):
        """Zwraca listę zaznaczonych elementów."""
        return list(self._selected_items)

    def select_items(self, items_to_select):
        """Zaznacza programowo określone elementy na liście."""
        lookup = set(items_to_select)
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.text() in lookup:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()

    def update_display_text(self):
        """Aktualizuje tekst wyświetlany w comboboxie."""
        if not self._selected_items or len(self._selected_items) == (self.model().rowCount() - 1):
            self.setEditText("-Wszystkie-")
        else:
            self.setEditText(f"Wybrano {len(self._selected_items)} z {self.model().rowCount() - 1}")

class UpdateRequiredDialog(QDialog):
    """Modalne okno informujące o konieczności aktualizacji i wymuszające zamknięcie."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Wymagana aktualizacja")
        self.setModal(True)
        self.setWindowFlags(Qt.Dialog | Qt.CustomizeWindowHint | Qt.WindowTitleHint)

        self.countdown = 15

        layout = QVBoxLayout(self)
        info_label = QLabel(
            "<b>Dostępna jest nowa wersja aplikacji.</b><br><br>"
            "Aby zapewnić spójność danych i dostęp do nowych funkcji, dalsza praca na tej wersji nie jest możliwa.<br>"

        )
        info_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(info_label)

        self.countdown_label = QLabel(f"Aplikacja zostanie zamknięta za {self.countdown} sekund...")
        self.countdown_label.setAlignment(Qt.AlignCenter)
        self.countdown_label.setStyleSheet("font-weight: bold; color: #e74c3c;")
        layout.addWidget(self.countdown_label)

        self.timer = QTimer(self)
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.update_countdown)
        self.timer.start()

    def update_countdown(self):
        self.countdown -= 1
        self.countdown_label.setText(f"Aplikacja zostanie zamknięta za {self.countdown} sekund...")
        if self.countdown <= 0:
            self.timer.stop()
            self.accept()


class WorkScheduleWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self._state_to_restore = None

        self.settings_db = SettingsDatabase()
        try:
            current_windows_user = getpass.getuser().lower()
        except Exception:
            current_windows_user = "unknown_user"

        self.user_settings = self.settings_db.load_settings(login_windows=current_windows_user)
        debug_print(f"ZAŁADOWANE USTAWIENIA UŻYTKOWNIKA: {self.user_settings}")

        self.clear_icon_dark = self._create_clear_icon(QColor("#d0d0d0"))
        self.clear_icon_light = self._create_clear_icon(QColor("#505050"))
        self.is_dark_theme = self.user_settings.get('theme') == 'dark'
        self.current_font = self.user_settings.get('font_family', 'Segoe UI')
        self.current_font_size = self.user_settings.get('font_size', 9)
        self.import_grupa = self.user_settings.get('import_grupa', 3)
        self.import_funkcja = self.user_settings.get('import_funkcja', 1)
        self.column_definitions = ColumnDefinitions()
        self.default_visible_columns = self.column_definitions.DEFAULT_VISIBLE_COLUMNS
        saved_columns = self.user_settings.get('visible_columns')
        self.visible_columns = saved_columns if saved_columns else self.default_visible_columns.copy()
        self.user_sort_preferences = self.user_settings.get('sort_preferences', [])
        self.show_comment_column = self.user_settings.get('show_schedule_comment', False)

        self.staffing_details_win = None
        self.current_user_role = None
        self.data_provider = DataProvider()
        self.data_provider.data_changed.connect(self._handle_specific_icons_refresh)
        self.employee_columns = self.column_definitions.get_ui_display_columns()

        self.setWindowTitle("TeamFlowApp")

        self._selection_timer = QTimer()
        self._selection_timer.setSingleShot(True)
        self._selection_timer.timeout.connect(self._handle_selection_change)
        self._selection_debounce_delay = 50

        font = QFont(self.current_font, self.current_font_size)
        QApplication.setFont(font)

        self.schedule_model = ScheduleTableModel(self)
        self.schedule_model.set_visible_columns(self.visible_columns)
        self.events_model = EventsTableModel(self)

        self._create_central_widget()

        self.table.set_model(self.schedule_model)
        self.events_table.setModel(self.events_model)
        self.manage_columns_button.clicked.connect(self.show_column_select_dialog)

        if self.table.employees_view.selectionModel():
            self.table.employees_view.selectionModel().selectionChanged.connect(self.on_selection_changed)
        if self.table.schedule_view.selectionModel():
            self.table.schedule_view.selectionModel().selectionChanged.connect(self.on_selection_changed)

        self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font, self.current_font_size)

        self.shortcut_f1 = QShortcut(QKeySequence(Qt.Key_F1), self)
        self.shortcut_f1.activated.connect(self.toggle_left_panel)

        self.shortcut_f2 = QShortcut(QKeySequence(Qt.Key_F2), self)
        self.shortcut_f2.activated.connect(self.toggle_events_panel)

        self.shortcut_f3 = QShortcut(QKeySequence(Qt.Key_F3), self)
        self.shortcut_f3.activated.connect(self.show_insert_change_dialog)

        self.shortcut_f4 = QShortcut(QKeySequence(Qt.Key_F4), self)
        self.shortcut_f4.activated.connect(self.show_insert_symbol_dialog)

        self.shortcut_insert = QShortcut(QKeySequence(Qt.Key_Insert), self)
        self.shortcut_insert.activated.connect(self.show_add_overtime_dialog)

        self.shortcut_f12 = QShortcut(QKeySequence(Qt.Key_F12), self)
        self.shortcut_f12.activated.connect(self.clear_special_symbol_from_selected_cells)

        self.copy_shortcut = QShortcut(QKeySequence.Copy, self)
        self.copy_shortcut.activated.connect(self.copy_selection_to_clipboard)

        self.start_full_initialization()

        # PRZENIESIONY BLOK: Ustawienie rozmiaru i pokazanie okna na samym końcu
        if self.user_settings.get('is_maximized'):
            self.showMaximized()
        else:
            width, height = self.user_settings.get('window_size', (1600, 800))
            self.setGeometry(100, 100, width, height)

        debug_print("=== APLIKACJA URUCHOMIONA W TRYBIE AUTOMATYCZNYM ===")

    def manage_ui_state(self, enabled: bool):
        """Włącza lub wyłącza kluczowe elementy interfejsu użytkownika."""
        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(enabled)

        action_buttons = [
            self.settings_button, self.refresh_button, self.show_audit_button,
            self.staffing_details_button, self.schedule_control_button,
            self.manage_columns_button, self.toggle_events_panel_button,
            self.insert_change_button, self.insert_symbol_button,
            self.cancel_delegation_button, self.add_overtime_button
        ]
        for button in action_buttons:
            if hasattr(self, button.objectName()):
                button.setEnabled(enabled)

        if hasattr(self, 'date_combo'):
            self.date_combo.setEnabled(enabled)

    def start_full_initialization(self):
        """Uruchamia pełną inicjalizację po sprawdzeniu wersji i uprawnień."""
        self.load_data_button.setText("Sprawdzanie uprawnień...")
        self.load_data_button.setEnabled(False)
        QApplication.processEvents()

        if not self.check_user_permissions():
            QTimer.singleShot(10, self.close)
            return

        self.manage_ui_state(enabled=True)
        self.load_data_button.setVisible(False)
        self.refresh_button.setVisible(True)

        self.setup_table_properties()
        self.setup_keyboard_editing()

        self.setup_date_combo()
        self.load_initial_data()

        self.check_timer = QTimer(self)
        self.check_timer.timeout.connect(self.check_for_new_data)
        self.check_timer.start(60000)

    def check_if_update_is_required(self) -> bool:
        """Sprawdza wersję aplikacji na podstawie załadowanych ustawień."""
        # Porównujemy wersje. Funkcja zwraca tylko wynik, nie zamyka już aplikacji.
        return parse_version(APP_VERSION) != parse_version(app_settings.REQUIRED_VERSION)

    def show_staffing_details_window(self):
        from staffing_details_window import StaffingDetailsWindow
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Brak danych", "Proszę wybrać miesiąc, aby wyświetlić szczegóły obsady.",
                                QMessageBox.Ok)
            return
        year, month = current_data
        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            self.staffing_details_win.activateWindow()
            self.staffing_details_win.raise_()
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.update_for_new_month_or_filters(year, month)
        else:
            self.staffing_details_win = StaffingDetailsWindow(
                self, self.data_provider, year, month, self.import_grupa, self.import_funkcja
            )
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.show()

    def setup_keyboard_editing(self):
        """Konfiguruje edycję klawiatury dla komórek grafiku"""
        if not app_settings.has_permission(self.current_user_role, 'schedule_keyboard_edit'):
            debug_print(f"Edycja klawiatury wyłączona - rola '{self.current_user_role}' nie ma uprawnień.")
            return

        self.keyboard_filter = ScheduleKeyboardFilter(self)
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            self.table.schedule_view.installEventFilter(self.keyboard_filter)
            debug_print(f"Włączono edycję klawiatury dla roli: {self.current_user_role}")

    def cleanup_keyboard_filter(self):
        """Czyści filtr klawiatury przy zamykaniu aplikacji"""
        if hasattr(self, 'keyboard_filter'):
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.removeEventFilter(self.keyboard_filter)
            del self.keyboard_filter
            debug_print("Wyczyszczono filtr klawiatury")

    def _should_ask_for_confirmation(self) -> bool:
        """
        Sprawdza, czy należy wyświetlić okno dialogowe z prośbą o potwierdzenie.
        Zwraca False, jeśli grafik nie jest opublikowany (praca "na brudno"), True w przeciwnym wypadku.
        """
        current_data = self.date_combo.currentData()
        if not current_data:
            return True  # W razie wątpliwości, dla bezpieczeństwa pytaj

        year, month = current_data
        is_published = self.data_provider.is_schedule_published(year, month)

        # Pytamy o potwierdzenie tylko wtedy, gdy grafik JEST opublikowany.
        return is_published

    def _get_permission_for_cell(self, cell_data: dict) -> dict:
        permissions = {'can_edit_hours': False, 'can_edit_symbol': False, 'can_edit_location': False,
                       'can_delete': False}
        if not cell_data: return permissions

        user_role, user_dept = self.current_user_role, self.current_user_department
        target_role, target_dept = cell_data.get('rola_nazwa'), cell_data.get('wydzial')

        # --- POCZĄTEK NOWEJ LOGIKI ---
        # Specjalna reguła: Lider i Lider OUT mogą wstawić symbol 'CO' osobom z wydziału DTN.
        # Przyznajemy im tylko uprawnienie do edycji symbolu w tym konkretnym przypadku.
        if user_role in ['Lider', 'Lider OUT'] and target_dept and target_dept.strip().lower() == 'dtn':
            return {'can_edit_hours': False, 'can_edit_symbol': True, 'can_edit_location': False, 'can_delete': False}
        # --- KONIEC NOWEJ LOGIKI ---

        if user_role == 'Pracownik WPR':
            return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}

        is_in_same_department = False
        if user_dept and target_dept:
            if target_dept.strip().lower().startswith(user_dept.strip().lower()):
                is_in_same_department = True

        if not is_in_same_department: return permissions

        if user_role == 'Lider OUT':
            return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}

        if user_role == 'Lider':
            if target_role == 'Lider':
                return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}
            else:
                return {'can_edit_hours': False, 'can_edit_symbol': True, 'can_edit_location': True,
                        'can_delete': False}

        return permissions

    def quick_edit_selected_cells(self, start_hour):
        """Szybka edycja zaznaczonych komórek z klawiatury"""
        try:
            if not app_settings.has_permission(self.current_user_role, 'schedule_keyboard_edit'):
                return

            selected_cells_data = self.table.get_data_for_selected_cells()
            if not self._can_modify_cells(selected_cells_data) or not selected_cells_data:
                return

            schedule_cells = [cell for cell in selected_cells_data if isinstance(cell, dict) and 'date_str' in cell and 'uzytkownik_id' in cell]
            if not schedule_cells:
                return

            grouped_changes = {}
            for cell_data in schedule_cells:
                user_id, user_name, date_str = cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane', ''), cell_data.get('date_str')
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str
                user_key = (user_id, user_name)
                if user_key not in grouped_changes:
                    grouped_changes[user_key] = []
                grouped_changes[user_key].append(formatted_date)

            changes_info = f"Zmiana godziny rozpoczęcia na {start_hour}:00 dla:\n\n"
            for (user_id, user_name), dates in grouped_changes.items():
                changes_info += f"🧑 {user_name}:\n"
                dates_str = ", ".join(sorted(dates))
                changes_info += f"   📅 {dates_str}\n\n"
            changes_info += f"Łącznie: {len(schedule_cells)} komórek"

            reply = QMessageBox.Yes  # Domyślnie zakładamy, że użytkownik się zgadza
            if self._should_ask_for_confirmation():
                reply = QMessageBox.question(self, "Potwierdzenie szybkiej edycji", changes_info, QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
            if reply == QMessageBox.Yes:
                self._apply_quick_changes(schedule_cells, start_hour)
        except Exception as e:
            log_error(f"Błąd podczas szybkiej edycji: {e}")
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas edycji: {str(e)}", QMessageBox.Ok)

    def _apply_quick_changes(self, schedule_cells, start_hour):
        """Stosuje szybką zmianę godziny z indywidualnym sprawdzaniem uprawnień."""
        updated_info, error_messages, skipped_employees = [], [], []

        for cell_data in schedule_cells:
            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_edit_hours']:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue

            current_symbol = cell_data.get('symbol', '')
            parsed = parse_symbol(current_symbol)
            try:
                work_hours = int(float(cell_data.get('etat', 8.0)))
            except (ValueError, TypeError):
                work_hours = 8

            location_for_build = parsed.get('location') or self.determine_correct_location(cell_data)

            new_symbol = build_symbol(
                location=location_for_build,
                start_hour=start_hour,
                work_hours=parsed.get('work_hours') or work_hours,
                special_symbol=parsed.get('special_symbol')
            )
            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"🗣️ {cell_data.get('uzytkownik_dane')}: {result.get('message', 'Błąd zapisu.')}")
            except Exception as e:
                log_error(f"Błąd krytyczny w _apply_quick_changes: {e}")
                error_messages.append(f"🗣️ {cell_data.get('uzytkownik_dane')}: Błąd aplikacji: {e}")

        if updated_info:
            self._update_cells_with_new_symbols(updated_info)

        success_msg = f"Zmieniono godzinę rozpoczęcia dla {len(updated_info)} komórek."
        if skipped_employees:
            QMessageBox.information(self, "Częściowy sukces",
                                    f"{success_msg}\\n\\nPominięto {len(skipped_employees)} komórek z powodu braku uprawnień dla:\\n"
                                    f"- {', '.join(set(skipped_employees))}")
        elif updated_info:
            self.statusBar().showMessage(success_msg, 4000)

        if error_messages:
            QMessageBox.warning(self, "Błędy podczas zapisu",
                                "Wystąpiły następujące błędy:\\n\\n" + "\\n".join(error_messages))

    def _show_keyboard_edit_results(self, successful_updates, failed_updates, error_messages, start_hour):
        """Pokazuje wyniki edycji klawiatury - uproszczone komunikaty"""
        if successful_updates > 0:
            message = f"Pomyślnie zaktualizowano {successful_updates} komórek (cyfra: {start_hour})"
            if failed_updates > 0:
                message += f"\n\n⚠️ {failed_updates} aktualizacji nie powiodło się"
                if error_messages:
                    message += ":\n" + "\n".join(error_messages[:3])
                    if len(error_messages) > 3:
                        message += f"\n... i {len(error_messages) - 3} więcej błędów"
            QMessageBox.information(self, "Edycja klawiatury", message, QMessageBox.Ok)
        else:
            message = f"Nie udało się zaktualizować żadnej komórki (cyfra: {start_hour})"
            if error_messages:
                message += f"\n\nBłędy:\n" + "\n".join(error_messages[:5])
            QMessageBox.warning(self, "Błąd edycji klawiatury", message, QMessageBox.Ok)

    def _prepare_deletion_summary_message(self, schedule_cells: list) -> str:
        """
        Przygotowuje sformatowaną wiadomość podsumowującą, które symbole zostaną usunięte,
        grupując je według użytkownika i dat.
        """
        if not schedule_cells:
            return "Nie wybrano żadnych komórek z symbolami do usunięcia."
        grouped_deletions = {}
        for cell_data in schedule_cells:
            user_name = cell_data.get('uzytkownik_dane', 'Nieznany Użytkownik')
            date_str = cell_data.get('date_str', 'Nieznana Data')
            symbol = cell_data.get('symbol', '??')
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except ValueError:
                formatted_date = date_str
            if user_name not in grouped_deletions:
                grouped_deletions[user_name] = []
            grouped_deletions[user_name].append(f"{formatted_date} (symbol: {symbol})")

        summary_lines = ["Czy na pewno chcesz usunąć symbole dla następujących pozycji?\n"]
        for user_name, date_symbol_list in grouped_deletions.items():
            summary_lines.append(f"🧑 {user_name}:")
            for date_with_symbol in sorted(date_symbol_list):
                summary_lines.append(f"   • {date_with_symbol}")
            summary_lines.append("")
        summary_lines.append(f"Łącznie zostanie wyczyszczonych: {len(schedule_cells)} komórek.")
        return "\n".join(summary_lines)

    def clear_selected_cells(self):
        try:
            if hasattr(self, 'keyboard_filter') and hasattr(self.keyboard_filter, '_buffer_timer'):
                self.keyboard_filter._buffer_timer.stop()
                self.keyboard_filter._digit_buffer = ""

            selected_cells_data = self.table.get_data_for_selected_cells()
            if not selected_cells_data:
                return

            schedule_cells = [cell for cell in selected_cells_data if cell.get('symbol', '').strip()]
            if not schedule_cells:
                QMessageBox.information(self, "Brak symboli do usunięcia", "Zaznaczone komórki są już puste.", QMessageBox.Ok)
                return

            # Wstępne sprawdzenie (można pominąć, bo i tak sprawdzamy w pętli, ale zostawiamy dla szybkiego feedbacku)
            if not any(self._get_permission_for_cell(c)['can_delete'] for c in schedule_cells):
                 QMessageBox.warning(self, "Brak uprawnień", "Nie posiadasz uprawnień do usunięcia symboli dla żadnej z zaznaczonych osób.")
                 return

            user_date_pairs = {(cell.get('uzytkownik_id'), cell.get('date_str')) for cell in schedule_cells}
            events_to_cancel = self._find_events_to_cancel(user_date_pairs)

            reply = QMessageBox.Yes
            if self._should_ask_for_confirmation():
                confirmation_message = self._prepare_deletion_summary_message(schedule_cells)
                if events_to_cancel:
                    grouped_events = self._group_events_by_user_date(events_to_cancel)
                    delegations_info = self._prepare_delegations_description(grouped_events)
                    confirmation_message += f"\n\n{delegations_info}"
                reply = QMessageBox.question(self, "Potwierdzenie usunięcia", confirmation_message, QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

            if reply == QMessageBox.Yes:
                if events_to_cancel: self._cancel_delegations(events_to_cancel)
                self._clear_cells_symbols(schedule_cells)
        except Exception as e:
            log_error(f"Błąd podczas czyszczenia komórek: {e}", exception=e)
            QMessageBox.critical(self, "Błąd krytyczny", f"Wystąpił nieoczekiwany błąd: {str(e)}")


    def _clear_cells_symbols(self, schedule_cells: list):
        """Usuwa symbole z indywidualnym sprawdzaniem uprawnień."""
        successful_updates, failed_updates = 0, 0
        error_messages, affected_pairs, skipped_employees = [], [], []

        for cell_data in schedule_cells:
            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_delete']:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue

            user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get('date_str'), cell_data.get('nr_kadrowy')

            if not all([user_id, date_str, nr_kadrowy]):
                failed_updates += 1
                error_messages.append(f"Niekompletne dane dla komórki: user_id={user_id}, data={date_str}, nr_kadrowy={nr_kadrowy}.")
                continue

            try:
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol="")
                if result.get('success', False):
                    successful_updates += 1
                    affected_pairs.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    failed_updates += 1
                    error_msg = result.get('message', 'Nieznany błąd.')
                    error_messages.append(f"Pracownik {nr_kadrowy} (dnia {date_str}): {error_msg}")
            except Exception as e:
                failed_updates += 1
                error_messages.append(f"{nr_kadrowy} ({date_str}): Błąd krytyczny - {str(e)}")
                log_error(f"Krytyczny błąd podczas usuwania symbolu dla {user_id}, {date_str}: {e}", exception=e)

        if successful_updates > 0:
            self._update_cells_with_new_symbols(affected_pairs)

        self._show_clear_symbols_results(successful_updates, failed_updates, error_messages, skipped_employees)

    def _show_clear_symbols_results(self, successful_updates: int, failed_updates: int, error_messages: list,
                                    skipped_employees: list):
        """
        Wyświetla użytkownikowi podsumowanie operacji usuwania symboli,
        uwzględniając komórki pominięte z powodu braku uprawnień.
        """
        title = ""
        full_message = ""

        # Komunikat o sukcesach
        if successful_updates > 0:
            full_message += f"Pomyślnie usunięto symbole z {successful_updates} komórek.\\n"

        # Komunikat o pominiętych pracownikach z powodu braku uprawnień
        if skipped_employees:
            # Używamy set(), aby uniknąć duplikatów nazwisk w komunikacie
            unique_skipped = set(skipped_employees)
            full_message += (f"\\nPominięto {len(skipped_employees)} komórek z powodu braku uprawnień dla:\\n"
                             f"- {', '.join(unique_skipped)}\\n")

        # Komunikat o błędach
        if failed_updates > 0:
            title = "Częściowy sukces" if successful_updates > 0 or skipped_employees else "Błąd usuwania"
            error_list_str = "\\n - " + "\\n - ".join(error_messages[:10])
            full_message += f"\\nNie udało się usunąć {failed_updates} symboli z powodu błędów:{error_list_str}"
            if len(error_messages) > 10:
                full_message += f"\\n... i {len(error_messages) - 10} więcej błędów."

        elif successful_updates > 0 or skipped_employees:
            title = "Zakończono operację"

        # Wyświetl komunikat tylko, jeśli cokolwiek się wydarzyło
        if full_message:
            # Jeśli nie było błędów ani pominięć, pokaż tylko informację na pasku statusu
            if successful_updates > 0 and failed_updates == 0 and not skipped_employees:
                self.statusBar().showMessage(full_message.strip(), 4000)
            else:
                # W przeciwnym razie, pokaż pełne okno dialogowe z podsumowaniem
                QMessageBox.information(self, title, full_message.strip())

    def set_cell_data(self, row, col, data_dict):
        """Ustawia dane w komórce modelu."""
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return False

        if not isinstance(data_dict, dict):
            log_error(f"Błąd: data_dict nie jest słownikiem: {type(data_dict)}")
            return False

        # Utwórz indeks modelu dla podanej pozycji
        index = self.schedule_model.index(row, col)
        if not index.isValid():
            return False

        # Ustaw dane w modelu
        return self.schedule_model.setData(index, data_dict, Qt.UserRole)

    def on_data_changed(self, data_type, year, month):
        """Obsługuje powiadomienie o zmianie danych z DataProvider."""
        current_data = self.date_combo.currentData()
        if not (current_data and current_data == (year, month)):
            return

        if data_type == "schedule":
            self.update_table_content()
        elif data_type == "events":
            # Po prostu odświeżamy tabelę zdarzeń, jeśli coś się w nich zmieniło
            self.on_selection_changed()

    def log_time(self, label, start_time):
        """Pomocnicza funkcja do logowania czasu"""
        end_time = time.time()
        elapsed = end_time - start_time
        debug_print(f"[CZAS] {label}: {elapsed:.3f} sekundy")
        return end_time

    def _create_central_widget(self):
        """Tworzy i ustawia główny widget aplikacji."""
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(10, 0, 10, 0)
        main_layout.setSpacing(0)

        top_bar = self.setup_top_bar(main_layout)
        main_layout.addWidget(top_bar)

        middle_splitter = self.setup_middle_section(main_layout)
        main_layout.addWidget(middle_splitter, 1)

        self.setCentralWidget(central_widget)
        
    def setup_top_bar(self, main_layout):
        top_bar_frame = QFrame()
        top_bar_frame.setFrameShape(QFrame.StyledPanel)
        top_bar_frame.setFrameShadow(QFrame.Raised)
        top_bar_frame.setFixedHeight(50)
        top_bar_layout = QHBoxLayout(top_bar_frame)
        top_bar_layout.setContentsMargins(5, 5, 5, 5)
        top_bar_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        self.toggle_menu_button = QPushButton("☰")
        self.toggle_menu_button.setFixedSize(32, 32)
        self.toggle_menu_button.setToolTip("Pokaż/ukryj panel filtrów (F1)")
        self.toggle_menu_button.clicked.connect(self.toggle_left_panel)
        top_bar_layout.addWidget(self.toggle_menu_button)

        self.settings_button = QPushButton("Ustawienia")
        self.settings_button.clicked.connect(self.show_settings_dialog)
        top_bar_layout.addWidget(self.settings_button)

        top_bar_layout.addWidget(self.create_separator())

        top_bar_layout.addWidget(QLabel("Miesiąc:"))
        self.date_combo = QComboBox()
        self.date_combo.setMinimumWidth(120)
        # --- POCZĄTEK POPRAWKI: Pozostawiono tylko jedno, poprawne podłączenie ---
        self.date_combo.currentIndexChanged.connect(self.refresh_data)
        # --- KONIEC POPRAWKI ---
        top_bar_layout.addWidget(self.date_combo)

        self.load_data_button = QPushButton("🚀 Pobierz Dane")
        self.load_data_button.setToolTip("Kliknij, aby połączyć się z bazą i załadować dane.")
        top_bar_layout.addWidget(self.load_data_button)
        self.load_data_button.setVisible(True)

        self.refresh_button = QPushButton("Odśwież")
        self.refresh_button.setToolTip("Odśwież dane dla bieżących filtrów")
        self.refresh_button.clicked.connect(self.refresh_data)
        top_bar_layout.addWidget(self.refresh_button)
        self.refresh_button.setVisible(False)

        self.export_button = QPushButton("Eksportuj do Excel")
        self.export_button.setToolTip("Zapisz aktualny widok grafiku do pliku Excel (.xlsx)")
        self.export_button.clicked.connect(self.export_schedule_to_excel)
        top_bar_layout.addWidget(self.export_button)

        self.show_audit_button = QPushButton("Historia Zmian")
        self.show_audit_button.clicked.connect(self.show_audit_log_window)
        top_bar_layout.addWidget(self.show_audit_button)

        self.staffing_details_button = QPushButton("Obsada")
        self.staffing_details_button.clicked.connect(self.show_staffing_details_window)
        top_bar_layout.addWidget(self.staffing_details_button)

        self.schedule_control_button = QPushButton("Zarządzaj Grafikiem")
        self.schedule_control_button.clicked.connect(self.show_schedule_control_dialog)
        top_bar_layout.addWidget(self.schedule_control_button)

        self.send_email_button = QPushButton("Wyślij e-mail")
        self.send_email_button.setToolTip("Wyślij wiadomość e-mail do zaznaczonych pracowników")
        self.send_email_button.clicked.connect(self.show_email_dialog)
        self.send_email_button.setEnabled(False)  # Domyślnie wyłączony
        top_bar_layout.addWidget(self.send_email_button)

        top_bar_layout.addStretch()

        return top_bar_frame

    def create_separator(self):
        separator = QFrame()
        separator.setFrameShape(QFrame.VLine)
        separator.setFrameShadow(QFrame.Sunken)
        return separator

    def setup_date_combo(self):
        """Konfiguruje combobox z datami, uwzględniając uprawnienia."""
        self.date_combo.blockSignals(True)
        current_date = datetime.now()
        months_to_show = []
        year, month = current_date.year, current_date.month

        for i in range(3, 0, -1):
            prev_month, prev_year = (month - i, year)
            while prev_month <= 0:
                prev_month += 12
                prev_year -= 1
            months_to_show.append((prev_year, prev_month))

        months_to_show.append((year, month))

        if self.can_see_next_month:
            next_month, next_year = (month + 1, year)
            if next_month > 12:
                next_month = 1
                next_year += 1
            months_to_show.append((next_year, next_month))

        current_index = self.date_combo.currentIndex()
        if current_index == -1:
            current_index = 3

        self.date_combo.clear()
        for y, m in months_to_show:
            self.date_combo.addItem(f"{y}-{m:02d}", (y, m))

        self.date_combo.setCurrentIndex(min(current_index, self.date_combo.count() - 1))
        self.date_combo.blockSignals(False)

    def setup_middle_section(self, main_layout):
        """Tworzy środkową sekcję z filtrem i tabelami"""
        main_splitter = QSplitter(Qt.Horizontal)
        main_splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.setup_left_panel()
        right_panel = self.setup_right_panel()
        main_splitter.addWidget(self._left_panel)
        main_splitter.addWidget(right_panel)

        # Ustawienie rozmiarów początkowych
        main_splitter.setSizes([260, 1200])
        self.main_splitter = main_splitter

        self.main_splitter.setStretchFactor(0, 0)
        self.main_splitter.setStretchFactor(1, 1)

        return main_splitter

    def setup_left_panel(self):
        """Tworzy lewy panel z filtrami, w tym z rozbudowanym filtrem obecności."""
        self._left_panel = QWidget()
        self._left_panel.setMinimumSize(0, 0)
        panel_main_layout = QVBoxLayout(self._left_panel)
        panel_main_layout.setContentsMargins(0, 0, 0, 0)

        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.NoFrame)

        filter_container = QWidget()
        filters_layout = QVBoxLayout(filter_container)
        filters_layout.setContentsMargins(10, 10, 10, 10)
        filters_layout.setSpacing(6)
        filter_container.setMinimumWidth(240)

        # --- ZMIANA: Rozbudowa panelu "Obecni w pracy w dniu" ---
        presence_group = QGroupBox("Obecni w pracy w dniu:")
        presence_group.setCheckable(True)
        presence_group.setChecked(False)
        self.filter_by_presence_check = presence_group

        presence_layout = QGridLayout(presence_group)
        presence_layout.setContentsMargins(5, 10, 5, 5)

        self.presence_date_edit = QDateEdit(QDate.currentDate())
        self.presence_date_edit.setCalendarPopup(True)
        self.presence_date_edit.setDisplayFormat("dd.MM.yyyy")

        self.presence_location_combo = CustomMultiComboBox()
        location_items = ["Home Office (h)", "SBC (s)", "Przystanek (p)", "Bez lokalizacji"]
        self.presence_location_combo.add_items(location_items)

        # ZMIANA: Zamiana QComboBox na CustomMultiComboBox
        self.presence_hour_combo = CustomMultiComboBox()
        self.presence_hour_combo.add_items([f"{h:02d}:00" for h in range(24)])

        presence_layout.addWidget(QLabel("Data:"), 0, 0)
        presence_layout.addWidget(self.presence_date_edit, 0, 1)
        presence_layout.addWidget(QLabel("Lokalizacja:"), 1, 0)
        presence_layout.addWidget(self.presence_location_combo, 1, 1)
        presence_layout.addWidget(QLabel("Godzina:"), 2, 0)
        presence_layout.addWidget(self.presence_hour_combo, 2, 1)

        # ZMIANA: Podłączenie sygnału `selection_changed`
        self.filter_by_presence_check.toggled.connect(self.filter_data)
        self.presence_date_edit.dateChanged.connect(self.filter_data)
        self.presence_location_combo.selection_changed.connect(self.filter_data)
        self.presence_hour_combo.selection_changed.connect(self.filter_data)

        filters_layout.addWidget(presence_group)

        # 2. Zmiana podłączanych sygnałów
        self.filter_by_presence_check.toggled.connect(self.filter_data)
        self.presence_date_edit.dateChanged.connect(self.filter_data)
        self.presence_location_combo.selection_changed.connect(self.filter_data)

        # --- KONIEC ZMIAN ---

        separator = QFrame()
        separator.setFrameShape(QFrame.HLine)
        separator.setFrameShadow(QFrame.Sunken)
        filters_layout.addWidget(separator)

        self.add_horizontal_filter("Grupa:", "grupa_main_filter_combo", filters_layout)
        self.add_horizontal_filter("Wydział:", "wydzial_combo", filters_layout)
        # ZMIANA: Przekazanie referencji do list do metody tworzącej filtr
        self.przelozony_list = QListWidget()
        self.add_horizontal_search_filter("Przełożony:", "przelozony_filter", filters_layout,
                                          list_widget_to_clear=self.przelozony_list)
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.przelozony_list)

        self.uzytkownik_list = QListWidget()
        self.add_horizontal_search_filter("Użytkownik:", "uzytkownik_filter", filters_layout,
                                          list_widget_to_clear=self.uzytkownik_list)
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.uzytkownik_list)

        self.add_horizontal_filter("LD:", "default_location_combo", filters_layout)
        self.add_horizontal_filter("System Pracy:", "system_czasu_pracy_combo", filters_layout)
        self.add_horizontal_filter("Rola:", "rola_combo", filters_layout)
        self.add_horizontal_filter("Język:", "jezyk_combo", filters_layout)
        self.add_horizontal_filter("Etat:", "etat_combo", filters_layout)
        self.add_horizontal_filter("DTN:", "dtn_combo", filters_layout)

        self.clear_filters_button = QPushButton("Wyczyść filtry")
        self.clear_filters_button.clicked.connect(self.clear_filters)
        filters_layout.addStretch()
        filters_layout.addWidget(self.clear_filters_button)

        scroll_area.setWidget(filter_container)
        panel_main_layout.addWidget(scroll_area)

    def _create_clear_icon(self, color: QColor) -> QIcon:
        """Tworzy ikonę 'X' o zadanym kolorze."""
        pixmap = QPixmap(16, 16)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        pen = QPen(color, 2)
        painter.setPen(pen)
        painter.drawLine(4, 4, 12, 12)
        painter.drawLine(4, 12, 12, 4)
        painter.end()
        return QIcon(pixmap)

    def add_horizontal_filter(self, label_text, combo_name, parent_layout):
        """Dodaje filtr w układzie poziomym z poprawnie działającym rozmiarem."""
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)
        filter_layout.setSpacing(4)

        filter_label = QLabel(label_text)
        filter_label.setFixedWidth(65)
        filter_layout.addWidget(filter_label)

        combo = CustomMultiComboBox()
        combo.setFixedHeight(24)
        combo.view().setMaximumWidth(240)
        combo.selection_changed.connect(self.filter_data)
        setattr(self, combo_name, combo)

        # ZMIANA: Dodajemy kontrolkę z priorytetem rozciągania (stretch=1)
        filter_layout.addWidget(combo, 1)

        clear_button = QPushButton()
        icon = self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light
        clear_button.setIcon(icon)
        clear_button.setObjectName("FilterClearButton")
        clear_button.setFixedSize(22, 22)
        clear_button.setToolTip(f"Wyczyść filtr '{label_text}'")
        clear_button.setFlat(True)
        clear_button.clicked.connect(lambda: combo.clear_selection())

        # ZMIANA: Dodajemy przycisk bez priorytetu rozciągania (stretch=0)
        filter_layout.addWidget(clear_button, 0)

        parent_layout.addLayout(filter_layout)

    def add_horizontal_search_filter(self, label_text, filter_name, parent_layout, list_widget_to_clear=None):
        """Dodaje filtr wyszukiwania z poprawnie działającym rozmiarem."""
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)
        filter_layout.setSpacing(4)

        filter_label = QLabel(label_text)
        filter_label.setFixedWidth(65)
        filter_layout.addWidget(filter_label)

        text_edit = QLineEdit()
        text_edit.setPlaceholderText(f"Filtruj {label_text.lower()[:-1]}...")
        text_edit.setFixedHeight(24)
        setattr(self, filter_name, text_edit)

        # ZMIANA: Dodajemy kontrolkę z priorytetem rozciągania (stretch=1)
        filter_layout.addWidget(text_edit, 1)

        clear_button = QPushButton()
        icon = self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light
        clear_button.setIcon(icon)
        clear_button.setObjectName("FilterClearButton")
        clear_button.setFixedSize(22, 22)
        clear_button.setToolTip(f"Wyczyść filtr '{label_text}'")
        clear_button.setFlat(True)

        def clear_action():
            text_edit.blockSignals(True)
            if list_widget_to_clear: list_widget_to_clear.blockSignals(True)
            text_edit.clear()
            if list_widget_to_clear: list_widget_to_clear.clearSelection()
            text_edit.blockSignals(False)
            if list_widget_to_clear: list_widget_to_clear.blockSignals(False)
            self.filter_data()

        clear_button.clicked.connect(clear_action)

        # ZMIANA: Dodajemy przycisk bez priorytetu rozciągania (stretch=0)
        filter_layout.addWidget(clear_button, 0)

        parent_layout.addLayout(filter_layout)

    def load_initial_data(self):
        """Uruchamia proces ładowania danych i jednorazowo aplikuje zapisane sortowanie."""
        debug_print("Uruchamianie leniwego ładowania danych początkowych...")
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            # Tworzymy jednorazową funkcję obsługi, aby zastosować sortowanie po załadowaniu danych
            def initial_load_handler(data):
                # Najpierw standardowo zastosuj dane
                self._on_async_data_loaded(data)
                # A następnie, tylko ten jeden raz, zastosuj zapisane sortowanie
                self.apply_custom_sort()
                # Odłącz ten handler, aby nie został ponownie wywołany
                if hasattr(self, 'loading_dialog') and self.loading_dialog:
                    try:
                        self.loading_dialog.loading_completed.disconnect(initial_load_handler)
                    except (TypeError, RuntimeError):
                        pass  # Ignoruj błąd, jeśli sygnał był już odłączony

            # Rozpocznij asynchroniczne ładowanie
            self.update_data(year, month, self.import_grupa, self.import_funkcja, use_async=True)

            # Podłącz nasz jednorazowy handler do sygnału zakończenia ładowania
            if hasattr(self, 'loading_dialog') and self.loading_dialog:
                self.loading_dialog.loading_completed.connect(initial_load_handler)

            self.update_filter_dates()

    def setup_right_panel(self):
        """Tworzy prawy panel z tabelami"""
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)
        right_splitter = QSplitter(Qt.Vertical)
        schedule_frame = self.setup_schedule_section()
        events_frame = self.setup_events_section()
        right_splitter.addWidget(schedule_frame)
        right_splitter.addWidget(events_frame)
        right_splitter.setSizes([650, 350])
        right_layout.addWidget(right_splitter)
        return right_panel

    def setup_schedule_section(self):
        """Tworzy sekcję grafiku (górna część prawego panelu) używając SplitTableView."""
        schedule_frame = QFrame()
        schedule_layout = QVBoxLayout(schedule_frame)
        schedule_layout.setContentsMargins(5, 5, 5, 5)

        self.table = SplitTableView()
        schedule_layout.addWidget(self.table)

        # Tworzymy przycisk i kontener na pozostałe przyciski
        self.manage_columns_button = QPushButton("Dostosuj widok")
        button_frame = self.setup_schedule_buttons()
        button_layout = button_frame.layout()

        # Wstawiamy przycisk zarządzania kolumnami na początek layoutu z przyciskami
        if isinstance(button_layout, QHBoxLayout):
            button_layout.insertWidget(0, self.manage_columns_button)

        # --- POCZĄTEK POPRAWKI ---
        # Dodajemy kontener z WSZYSTKIMI przyciskami do layoutu sekcji grafiku - TYLKO RAZ.
        # Usunięto zduplikowaną linię, która powodowała błąd.
        schedule_layout.addWidget(button_frame)
        # --- KONIEC POPRAWKI ---

        return schedule_frame

    def setup_schedule_buttons(self):
        """Tworzy przyciski akcji dla sekcji grafiku"""
        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setContentsMargins(0, 0, 0, 0)
        button_frame.setFixedHeight(40)
        button_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.toggle_events_panel_button = QPushButton("Ukryj zdarzenia↓")
        self.toggle_events_panel_button.setToolTip("Ukryj panel zdarzeń (dla większego widoku grafiku) (F2)")
        self.toggle_events_panel_button.clicked.connect(self.toggle_events_panel)
        self.location_exception_button = QPushButton("Wyjątki lokalizacyjne")
        self.location_exception_button.setToolTip("Zarządzaj wyjątkami od domyślnej lokalizacji pracy")
        self.location_exception_button.clicked.connect(self.show_location_exception_dialog)
        button_layout.addWidget(self.location_exception_button)
        button_layout.addStretch()
        self.insert_change_button = QPushButton("Wstaw zmianę")
        self.insert_change_button.setToolTip("Wstaw zmianę grafiku (F3)")
        self.insert_change_button.clicked.connect(self.show_insert_change_dialog)
        button_layout.addWidget(self.insert_change_button)
        self.insert_symbol_button = QPushButton("Wstaw nieobecność")
        self.insert_symbol_button.setToolTip("Wstaw nieobecność (F4)")
        self.insert_symbol_button.clicked.connect(self.show_insert_symbol_dialog)
        button_layout.addWidget(self.insert_symbol_button)
        self.cancel_delegation_button = QPushButton("Odwołaj delegacje")
        self.cancel_delegation_button.setToolTip("Odwołaj delegacje dla zaznaczonych komórek (F5)")
        self.cancel_delegation_button.clicked.connect(self.cancel_delegations)
        button_layout.addWidget(self.cancel_delegation_button)
        self.add_overtime_button = QPushButton("Dodaj nadgodziny")
        self.add_overtime_button.setShortcut("Insert")
        self.add_overtime_button.setToolTip("Dodaj nadgodziny dla zaznaczonych komórek (Insert)")
        self.add_overtime_button.clicked.connect(self.show_add_overtime_dialog)
        button_layout.addWidget(self.add_overtime_button)
        # Usunięto redundantny warunek, widoczność jest zarządzana przez update_buttons_visibility
        return button_frame

    def setup_events_section(self):
        """Tworzy sekcję zdarzeń używając QTableView i od razu konfiguruje jej kolumny."""
        events_frame = QFrame()
        events_frame.setFrameShape(QFrame.Shape.StyledPanel)
        events_frame.setFrameShadow(QFrame.Shadow.Raised)
        events_layout = QVBoxLayout(events_frame)
        events_layout.setContentsMargins(5, 5, 5, 5)

        filters_frame = self.setup_events_filters()
        events_layout.addWidget(filters_frame)

        self.events_table = QTableView()
        self.events_table.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.events_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.events_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)

        events_layout.addWidget(self.events_table)
        return events_frame

    def setup_events_filters(self):
        """Konfiguruje filtry dla tabeli zdarzeń w jednej linii."""
        events_filter_frame = QFrame()
        # ZMIANA: Powrót do układu poziomego
        events_filter_layout = QHBoxLayout(events_filter_frame)
        events_filter_layout.setContentsMargins(0, 5, 0, 5)

        # Filtry daty od-do z przywróconym kalendarzem
        self.date_from = QDateEdit(QDate.currentDate().addDays(-30))
        self.date_from.setCalendarPopup(True)  # POPRAWKA: Przywrócenie kalendarza
        self.date_to = QDateEdit(QDate.currentDate())
        self.date_to.setCalendarPopup(True)  # POPRAWKA: Przywrócenie kalendarza

        # Filtry tekstowe i statusu
        self.topic_filter = QLineEdit()
        self.topic_filter.setPlaceholderText("Filtruj po temacie...")
        self.name_filter = QLineEdit()
        self.name_filter.setPlaceholderText("Filtruj po nazwie...")
        self.status_filter_combo = CustomMultiComboBox()
        self.status_filter_combo.setMinimumWidth(130)

        # Checkboxy
        self.meetings_checkbox = QCheckBox("Spotkania")
        self.trainings_checkbox = QCheckBox("Szkolenia")
        self.overtime_checkbox = QCheckBox("Nadgodziny")
        self.meetings_checkbox.setChecked(True)
        self.trainings_checkbox.setChecked(True)
        self.overtime_checkbox.setChecked(True)

        # Dodanie wszystkich kontrolek do layoutu w poprawnej kolejności
        events_filter_layout.addWidget(QLabel("Data od:"))
        events_filter_layout.addWidget(self.date_from)
        events_filter_layout.addWidget(QLabel("Data do:"))
        events_filter_layout.addWidget(self.date_to)
        events_filter_layout.addWidget(QLabel("Temat:"))
        events_filter_layout.addWidget(self.topic_filter)
        events_filter_layout.addWidget(QLabel("Nazwa:"))
        events_filter_layout.addWidget(self.name_filter)
        events_filter_layout.addWidget(QLabel("Status:"))
        events_filter_layout.addWidget(self.status_filter_combo)

        events_filter_layout.addStretch()  # Wypełniacz, aby odsunąć checkboxy na prawo

        events_filter_layout.addWidget(self.meetings_checkbox)
        events_filter_layout.addWidget(self.trainings_checkbox)
        events_filter_layout.addWidget(self.overtime_checkbox)

        # Połączenie sygnałów (bez zmian)
        self.date_from.dateChanged.connect(self.filter_events_table)
        self.date_to.dateChanged.connect(self.filter_events_table)
        self.topic_filter.textChanged.connect(self.filter_events_table)
        self.name_filter.textChanged.connect(self.filter_events_table)
        self.meetings_checkbox.stateChanged.connect(self.filter_events_table)
        self.trainings_checkbox.stateChanged.connect(self.filter_events_table)
        self.overtime_checkbox.stateChanged.connect(self.filter_events_table)
        self.status_filter_combo.selection_changed.connect(self.filter_events_table)

        return events_filter_frame

    def setup_events_table_columns(self):
        """Konfiguruje kolumny dla tabeli zdarzeń, w tym ich szerokość."""
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        header = self.events_table.horizontalHeader()
        self.events_table.setSortingEnabled(True)

        # ZMIANA: Zaktualizowane indeksy kolumn
        header.setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        header.setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        header.setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        header.setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Użytkownik
        header.setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        header.setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Czas od
        header.setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Czas do
        header.setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        header.setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Data Modyfikacji

        # Ustaw stałą, większą szerokość dla kolumny Akcje (teraz indeks 10)
        header.setSectionResizeMode(10, QHeaderView.Fixed)
        self.events_table.setColumnWidth(10, 80)

    def setup_table_properties(self):
        """Konfiguruje właściwości tabel i tworzy delegatów z ustawieniami."""
        self.events_table.setSortingEnabled(True)
        # Usunięto linię resetującą sortowanie tabeli zdarzeń:
        # self.events_table.sortByColumn(0, Qt.AscendingOrder)

        if hasattr(self, 'table') and hasattr(self.table, 'employees_view'):
            self.table.employees_view.setSortingEnabled(True)
            # Usunięto linię, która czyściła sortowanie tabeli grafiku:
            # self.table.employees_view.sortByColumn(-1, Qt.AscendingOrder)

        if hasattr(self.table, 'employees_view') and hasattr(self.table.employees_view, 'horizontalHeader'):
            self.table.employees_view.horizontalHeader().sortIndicatorChanged.connect(self.on_sort_changed)

        if hasattr(self.events_table, 'horizontalHeader'):
            self.events_table.horizontalHeader().sortIndicatorChanged.connect(self.on_events_sort_changed)
            self.setup_events_table_columns()

        overtime_delegate = OvertimeItemDelegate(settings=self.user_settings)
        self.table.schedule_view.setItemDelegate(overtime_delegate)

        button_delegate = ButtonDelegate(parent=self, button_text="Odwołaj", is_dark_theme=self.is_dark_theme)
        button_delegate.button_clicked.connect(self.delete_event_from_row)
        self.events_table.setItemDelegateForColumn(10, button_delegate)  # "Akcje" to kolumna 10

        self.table.day_sort_requested.connect(self.apply_day_sort)

    def apply_day_sort(self, day: int, order: Qt.SortOrder):
        """
        Wywołuje sortowanie w modelu danych na podstawie wybranego dnia.
        """
        if hasattr(self, 'schedule_model') and self.schedule_model:
            self.schedule_model.sort_by_day(day, order)

    def toggle_left_panel(self):
        """Przełącza widoczność lewego panelu filtrów z zapamiętywaniem rozmiaru."""
        current_sizes = self.main_splitter.sizes()

        # Sprawdź, czy lewy panel jest zwinięty (jego rozmiar jest bliski zeru)
        if current_sizes[0] < 10:
            # Rozwiń panel do ostatniej znanej lub domyślnej szerokości
            right_width = max(0, sum(current_sizes) - self.last_left_panel_width)
            self.main_splitter.setSizes([self.last_left_panel_width, right_width])
        else:
            # Zwiń panel, zapamiętując jego aktualną szerokość
            self.last_left_panel_width = current_sizes[0]
            self.main_splitter.setSizes([0, sum(current_sizes)])


    def toggle_events_panel(self):
        """Przełącza widoczność panelu zdarzeń (dolny panel)"""
        right_splitter = self.centralWidget().findChild(QSplitter, self.main_splitter.objectName()).widget(1).findChild(
            QSplitter)
        if not right_splitter: return

        sizes = right_splitter.sizes()
        if sizes[1] > 0:
            self.events_panel_height = sizes[1]
            right_splitter.setSizes([sum(sizes), 0])
            self.toggle_events_panel_button.setText("Pokaż zdarzenia↑")
        else:
            schedule_height = right_splitter.height() - getattr(self, 'events_panel_height', 300)
            right_splitter.setSizes([schedule_height, getattr(self, 'events_panel_height', 300)])
            self.toggle_events_panel_button.setText("Ukryj zdarzenia↓")

    def export_schedule_to_excel(self):
        """
        Zbiera aktualnie widoczne dane z grafiku i eksportuje je do sformatowanego
        pliku Excel (.xlsx) przy użyciu biblioteki openpyxl.
        """
        if not self.schedule_model or self.schedule_model.rowCount() == 0:
            QMessageBox.warning(self, "Brak danych", "Brak danych do wyeksportowania.")
            return

        default_filename = f"grafik_{self.year}-{self.month:02d}.xlsx"
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Zapisz plik Excel", default_filename, "Pliki Excel (*.xlsx);;Wszystkie pliki (*)"
        )

        if not file_path:
            return

        try:
            # 1. Przygotowanie danych (logika podobna do poprzedniej)
            headers = self.schedule_model._column_headers[:len(self.visible_columns)]
            days_in_month = self.schedule_model._days_in_month
            day_headers = self.schedule_model._column_headers[
                          len(self.visible_columns):len(self.visible_columns) + days_in_month]

            # Bierzemy tylko pierwszą linię z nagłówka dnia (np. "So\n1" -> "So")
            day_letters = [h.split('\n')[0] for h in day_headers]
            day_numbers = [str(d) for d in range(1, days_in_month + 1)]

            visible_keys = self.schedule_model._keys
            data_rows = []
            for key in visible_keys:
                row_data = self.processed_data.get(key, {})
                row_to_write = []
                for col_id in self.visible_columns:
                    # Logika zbierania danych o pracownikach
                    if col_id == 'wydzial':
                        row_to_write.append(key[0])
                    elif col_id == 'przelozony_nazwisko_imie':
                        row_to_write.append(row_data.get('przelozony_nazwisko_imie', ''))
                    elif col_id == 'uzytkownik_dane':
                        row_to_write.append(key[2])
                    else:
                        row_to_write.append(str(row_data.get(col_id, '')))

                # Logika zbierania symboli z grafiku
                days_data = row_data.get('days', {})
                for day in range(1, days_in_month + 1):
                    symbol = days_data.get(day, {}).get('symbol', '')
                    row_to_write.append(symbol)
                data_rows.append(row_to_write)

            # 2. Tworzenie pliku Excel i zapis danych
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = f"Grafik {self.year}-{self.month:02d}"

            # 3. Formatowanie i dodawanie nagłówków
            header_font = Font(bold=True, color="FFFFFF")
            header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
            weekend_fill = PatternFill(start_color="FFF2F2F2", end_color="FFF2F2F2", fill_type="solid")

            # Dodanie dwóch wierszy nagłówków
            ws.append(headers + day_letters)
            ws.append([''] * len(headers) + day_numbers)

            # Stylowanie nagłówków
            for row in ws.iter_rows(min_row=1, max_row=2, min_col=1, max_col=ws.max_column):
                for cell in row:
                    cell.font = header_font
                    cell.fill = header_fill
                    cell.alignment = Alignment(horizontal='center', vertical='center')

            # 4. Zapis danych
            for row in data_rows:
                ws.append(row)

            # 5. Dodatkowe formatowanie
            employee_cols_count = len(self.visible_columns)

            # Zablokowanie okienek (kolumny pracownicze)
            first_day_column_letter = get_column_letter(employee_cols_count + 1)
            ws.freeze_panes = f"{first_day_column_letter}3"

            # Wyróżnienie weekendów
            weekend_columns = self.schedule_model._weekend_columns
            for weekend_col_idx in weekend_columns:
                col_letter = get_column_letter(employee_cols_count + weekend_col_idx + 1)
                for cell in ws[col_letter]:
                    cell.fill = weekend_fill

            # Automatyczne dopasowanie szerokości kolumn
            for i, column_cells in enumerate(ws.columns):
                # Dla dni grafiku ustawiamy stałą szerokość
                if i >= employee_cols_count:
                    ws.column_dimensions[get_column_letter(i + 1)].width = 5
                else:  # Dla kolumn pracowniczych dopasowujemy do zawartości
                    max_length = 0
                    column = get_column_letter(i + 1)
                    for cell in column_cells:
                        try:
                            if len(str(cell.value)) > max_length:
                                max_length = len(cell.value)
                        except:
                            pass
                    adjusted_width = (max_length + 2)
                    ws.column_dimensions[column].width = adjusted_width

            # 6. Zapis pliku
            wb.save(file_path)

            QMessageBox.information(self, "Eksport zakończony",
                                    f"Dane zostały pomyślnie zapisane w pliku:\n{file_path}")

        except Exception as e:
            log_error(f"Błąd podczas eksportu do Excel (.xlsx): {e}", exception=e)
            QMessageBox.critical(self, "Błąd eksportu", f"Wystąpił nieoczekiwany błąd:\n{e}")

    def show_column_select_dialog(self):
        """Wyświetla rozbudowany dialog wyboru kolumn i sortowania."""
        from column_select_dialog import ColumnSelectDialog
        try:
            if not hasattr(self, 'schedule_model'):
                QMessageBox.warning(self, "Błąd", "Model danych nie jest zainicjalizowany.")
                return

            dialog = ColumnSelectDialog(
                self, self.employee_columns, self.visible_columns, self.default_visible_columns,
                user_role=self.current_user_role,
                is_comment_column_checked=self.show_comment_column,
                sort_preferences=self.user_sort_preferences
            )

            if dialog.exec() == QDialog.Accepted:
                # Logika dla widoczności kolumn (bez zmian)
                self.visible_columns = dialog.get_selected_columns()
                self.show_comment_column = dialog.get_comment_column_state()
                self.user_settings['visible_columns'] = self.visible_columns
                self.user_settings['show_schedule_comment'] = self.show_comment_column

                # NOWA LOGIKA: Pobranie i zapisanie preferencji sortowania
                self.user_sort_preferences = dialog.get_sort_preferences()
                self.user_settings['sort_preferences'] = self.user_sort_preferences

                self.settings_db.save_settings(self.user_settings)

                self.schedule_model.set_visible_columns(self.visible_columns)
                self.schedule_model.set_show_comment_column(self.show_comment_column)
                self.refresh_column_configuration()
                if hasattr(self, 'table'):
                    self.table.set_model(self.schedule_model)
                    self.table.adjust_employees_table_width()
                    self._apply_dynamic_sizes()

                # ZMIANA: Zamiast `apply_default_sort` wywołujemy nową metodę
                self.apply_custom_sort()
        except Exception as e:
            log_error(f"Błąd w show_column_select_dialog: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd: {str(e)}")

    def apply_custom_sort(self):
        """
        Sortuje dane w modelu na podstawie preferencji użytkownika, używając
        dedykowanej, wielopoziomowej funkcji porównującej.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model._processed_data:
            return

        sort_prefs = self.user_sort_preferences
        keys_to_sort = self.schedule_model._keys

        self.schedule_model.layoutAboutToBeChanged.emit()

        if sort_prefs:
            debug_print(f"Aplikowanie sortowania niestandardowego (compare func): {sort_prefs}")

            def compare_rows(key_a, key_b):
                """Funkcja porównująca, która analizuje wszystkie kryteria sortowania naraz."""
                for col_id, direction in sort_prefs:
                    val_a = self.schedule_model._get_sort_key(key_a, col_id)
                    val_b = self.schedule_model._get_sort_key(key_b, col_id)

                    # Zabezpieczenie na wypadek porównywania różnych typów (np. None i string)
                    if type(val_a) is not type(val_b):
                        val_a, val_b = str(val_a), str(val_b)

                    result = 0
                    try:
                        if val_a < val_b:
                            result = -1
                        elif val_a > val_b:
                            result = 1
                    except TypeError:  # Dodatkowe zabezpieczenie
                        val_a, val_b = str(val_a), str(val_b)
                        if val_a < val_b:
                            result = -1
                        elif val_a > val_b:
                            result = 1

                    # Jeśli wartości nie są równe, zwracamy wynik (z uwzględnieniem kierunku)
                    # i kończymy porównywanie.
                    if result != 0:
                        return result * -1 if direction == 'desc' else result

                # Jeśli po sprawdzeniu wszystkich kryteriów wiersze są równe, zwracamy 0.
                return 0

            keys_to_sort.sort(key=functools.cmp_to_key(compare_rows))

        self.schedule_model.layoutChanged.emit()

        # Ustaw wskaźnik wizualny w nagłówku, aby odzwierciedlał sortowanie
        emp_header = self.table.employees_view.horizontalHeader()
        sched_header = self.table.schedule_view.horizontalHeader()

        emp_header.setSortIndicator(-1, Qt.AscendingOrder)
        sched_header.setSortIndicator(-1, Qt.AscendingOrder)

        if sort_prefs:
            first_col_id, first_direction = sort_prefs[0]
            order = Qt.DescendingOrder if first_direction == 'desc' else Qt.AscendingOrder

            if hasattr(self, 'visible_columns'):
                try:
                    col_index = self.visible_columns.index(first_col_id)
                    emp_header.setSortIndicator(col_index, order)
                except ValueError:
                    pass

        debug_print("Zakończono sortowanie niestandardowe (compare func).")

    def _apply_dynamic_sizes(self):
        """Ustawia dynamiczne rozmiary w zależności od rozmiaru czcionki ORAZ zapisanych ustawień."""
        if not hasattr(self, 'table') or not self.table.employees_view.model() or self.schedule_model.rowCount() == 0:
            return

        # --- POCZĄTEK ZMIANY: Logika szerokości kolumn ---
        saved_widths = self.user_settings.get('column_widths', {})

        # Zastosuj zapisane szerokości
        visible_columns = self.schedule_model.get_visible_columns()
        for i, col_id in enumerate(visible_columns):
            if col_id in saved_widths:
                self.table.employees_view.setColumnWidth(i, saved_widths[col_id])
        # --- KONIEC ZMIANY ---

        font_size = self.current_font_size
        width_map = {7: 35, 8: 40, 9: 45, 10: 50, 11: 55, 12: 60}
        day_column_width = width_map.get(font_size, 40)
        height_map = {7: 25, 8: 25, 9: 25, 10: 28, 11: 28, 12: 30}
        row_height = height_map.get(font_size, 25)
        header_height_map = {7: 30, 8: 35, 9: 35, 10: 38, 11: 40, 12: 42}
        header_height = header_height_map.get(font_size, 35)

        self.table.set_header_height(header_height)
        header = self.table.schedule_view.horizontalHeader()
        model = self.table.employees_view.model()
        special_widths = {"Suma\\nRBH": 45, "Bilans\\nRBH": 45, "Komentarz": 300}

        for logical_index in range(model.columnCount()):
            header_text = model.headerData(logical_index, Qt.Horizontal, Qt.DisplayRole)
            width_to_set = special_widths.get(header_text, day_column_width)
            header.resizeSection(logical_index, width_to_set)

        days_in_month = model._days_in_month
        employee_cols_count = len(model.get_visible_columns())
        for day in range(1, 32):
            logical_index = employee_cols_count + (day - 1)
            if logical_index < model.columnCount():
                header.setSectionHidden(logical_index, day > days_in_month)

        self.table._force_sync_heights(row_height)

    def showEvent(self, event):
        """Automatycznie wywoływane przez Qt, gdy okno jest pokazywane po raz pierwszy."""
        super().showEvent(event)
        # Dodano sprawdzenie `hasattr(self, 'table')`, aby upewnić się, że tabela istnieje
        if not hasattr(self, '_initial_layout_done') and hasattr(self, 'table'):
            debug_print("Wykryto showEvent - jednorazowe ustawianie szerokości splittera.")
            self.table.adjust_employees_table_width()
            self._initial_layout_done = True

    def delete_event_from_row(self, row):
        """Usuwa zdarzenie na podstawie indeksu wiersza w tabeli zdarzeń."""
        if not hasattr(self, 'events_model') or not self.events_model:
            return
        event = self.events_model.get_event(row)
        if not event:
            return
        event_id = event.get('id')
        event_type = event.get('type')
        if not event_id or not event_type:
            return
        self.delete_event(event_id, event_type)

    def on_sort_changed(self, logical_index, order):
        """Obsługuje zmianę sortowania w tabeli grafiku"""
        self.last_sort_column = logical_index
        self.last_sort_order = order
        debug_print(
            f"Tabela grafiku: Sortowanie po kolumnie {logical_index}, kolejność: {'rosnąco' if order == Qt.AscendingOrder else 'malejąco'}")

    def on_events_sort_changed(self, logical_index, order):
        """Obsługuje zmianę sortowania w tabeli zdarzeń"""
        debug_print(
            f"Tabela zdarzeń: Sortowanie po kolumnie {logical_index}, kolejność: {'rosnąco' if order == Qt.AscendingOrder else 'malejąco'}")

    def update_buttons_visibility(self):
        """Aktualizuje widoczność przycisków na podstawie roli użytkownika"""
        is_next_month_selected = False
        current_data = self.date_combo.currentData()
        if current_data:
            selected_year, selected_month = current_data
            today = QDate.currentDate()
            next_month_date = today.addMonths(1)
            if selected_year == next_month_date.year() and selected_month == next_month_date.month():
                is_next_month_selected = True

        # Użycie centralnej funkcji do zarządzania widocznością przycisków
        if hasattr(self, 'add_overtime_button'):
            self.add_overtime_button.setVisible(
                app_settings.has_permission(self.current_user_role, 'button_add_overtime'))
        if hasattr(self, 'staffing_details_button'):
            self.staffing_details_button.setVisible(
                app_settings.has_permission(self.current_user_role, 'button_staffing_details'))
        if hasattr(self, 'show_audit_button'):
            self.show_audit_button.setVisible(app_settings.has_permission(self.current_user_role, 'button_show_audit'))
        if hasattr(self, 'schedule_control_button'):
            can_see_button = app_settings.has_permission(self.current_user_role, 'button_schedule_control')
            self.schedule_control_button.setVisible(can_see_button and is_next_month_selected)
        # Ukryj przycisk wyjątków lokalizacyjnych dla roli Lider OUT
        if hasattr(self, 'location_exception_button'):
            self.location_exception_button.setVisible(self.current_user_role != 'Lider OUT')
        if hasattr(self, 'send_email_button'):
            self.send_email_button.setVisible(
                app_settings.has_permission(self.current_user_role, 'button_send_email'))

    def show_audit_log_window(self):
        """Tworzy i pokazuje okno historii zmian."""
        # Leniwe importowanie
        from audit_log_window import AuditLogWindow

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Proszę najpierw wybrać miesiąc.")
            return

        year, month = current_data

        def _get_filtered_audit_data():
            full_data = self.data_provider.get_schedule_audit_data(year, month)
            selected_cells = self.table.get_data_for_selected_cells()
            if selected_cells:
                allowed_users_dates = set()
                for cell in selected_cells:
                    if (user_id := cell.get('uzytkownik_id')) and (date_str := cell.get('date_str')):
                        date_obj = QDate.fromString(date_str, "yyyy-MM-dd").toPython()
                        allowed_users_dates.add((user_id, date_obj))
                return [row for row in full_data if
                        row.get('Data') and (int(row.get('Uzytkownik')), row.get('Data').date()) in allowed_users_dates]
            else:
                visible_user_ids = {key[3] for key in self.schedule_model._keys}
                filtered_by_visibility = [row for row in full_data if row.get('Uzytkownik') is not None and int(
                    row.get('Uzytkownik')) in visible_user_ids]
                sorted_data = sorted(filtered_by_visibility, key=lambda x: x.get('DataModyfikacji'), reverse=True)
                return sorted_data[:50]

        selected_cells = self.table.get_data_for_selected_cells()
        is_limited = not selected_cells
        limit_count = 50
        initial_filtered_data = _get_filtered_audit_data()
        if not initial_filtered_data:
            QMessageBox.information(self, "Informacja", "Brak historii zmian dla wybranych filtrów / zaznaczenia.")
            return

        dialog = AuditLogWindow(initial_filtered_data, self.is_dark_theme, self, is_limited_view=is_limited, year=year,
                                month=month, limit=limit_count)

        def on_refresh_requested():
            self.data_provider.clear_audit_cache(year, month)
            fresh_filtered_data = _get_filtered_audit_data()
            dialog.update_model_data(fresh_filtered_data)
            QMessageBox.information(dialog, "Odświeżono", "Historia zmian została zaktualizowana.")

        dialog.refresh_requested.connect(on_refresh_requested)
        dialog.exec()

    def check_user_permissions(self):
        """Sprawdza uprawnienia użytkownika i zapisuje je w atrybutach klasy."""
        user_id, user_app_id, user_app_role, visible_next_month, user_department = get_modifier_id()
        self.current_user_id = user_id
        self.current_user_app_id = user_app_id
        self.current_user_role = user_app_role
        self.can_see_next_month = visible_next_month
        self.current_user_department = user_department

        if not app_settings.has_permission(user_app_role, 'app_access'):
            QMessageBox.critical(self, "Brak uprawnień",
                                 f"Nie masz uprawnień do korzystania z tej aplikacji.\n\nTwoja rola: {user_app_role}",
                                 QMessageBox.Ok)
            return False

        self.update_buttons_visibility()
        debug_print(f"Zalogowano jako: {user_app_id} ({user_app_role}), Wydział: {self.current_user_department}")
        return True

    def _can_modify_cells(self, selected_cells_data: list) -> bool:
        """
        Sprawdza, czy użytkownik ma jakiekolwiek uprawnienia do modyfikacji
        ZAZNACZONYCH komórek. Zwraca True, jeśli choć jedna komórka jest edytowalna.
        """
        if not selected_cells_data:
            return False

        # Sprawdzamy, czy istnieje choć jedna komórka, do której użytkownik ma jakiekolwiek prawo
        can_modify_anything = False
        for cell_data in selected_cells_data:
            permissions = self._get_permission_for_cell(cell_data)
            if any(permissions.values()):
                can_modify_anything = True
                break  # Wystarczy jedna komórka, przerywamy pętlę

        if not can_modify_anything:
            QMessageBox.warning(self, "Brak uprawnień",
                                "Nie posiadasz uprawnień do edycji grafiku dla żadnej z zaznaczonych osób lub komórek.")
            return False

        return True

    def show_insert_symbol_dialog(self):
        """
        Uproszczona metoda: Pokazuje okno dialogowe do wstawiania symbolu,
        a następnie deleguje logikę do scentralizowanej metody.
        """
        if not app_settings.has_permission(self.current_user_role, 'schedule_cell_actions'):
            self.statusBar().showMessage("Brak uprawnień do wstawiania symboli.", 3000)
            return

        from schedule_edit_dialogs import InsertSymbolDialog
        selected_cells_data = self.get_selected_cells_data()
        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono żadnych komórek do edycji.", QMessageBox.Ok)
            return

        dialog = InsertSymbolDialog(self, selected_cells_data=selected_cells_data)
        if dialog.exec():
            selected_symbol = dialog.get_selected_symbol()
            if selected_symbol:
                self._apply_special_symbol_to_selection(selected_symbol)

    def _group_cells_for_symbol_changes(self, schedule_cells):
        """Grupuje komórki dla komunikatu potwierdzenia."""
        grouped_changes = {}
        for cell_data in schedule_cells:
            user_id, user_name, date_str, current_symbol = cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane', ''), cell_data.get('date_str'), cell_data.get('symbol', '').strip()
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str
            user_key = (user_id, user_name)
            if user_key not in grouped_changes:
                grouped_changes[user_key] = {}
            if formatted_date not in grouped_changes[user_key]:
                grouped_changes[user_key][formatted_date] = []
            grouped_changes[user_key][formatted_date].append({'current_symbol': current_symbol, 'cell_data': cell_data})
        return grouped_changes

    def _prepare_symbol_changes_description(self, grouped_changes, new_special_symbol):
        """Przygotowuje opis zmian symboli do komunikatu."""
        changes_info = ""
        for (user_id, user_name), dates in grouped_changes.items():
            changes_info += f"\n👤 {user_name}:\n"
            for date, cells in dates.items():
                changes_info += f"   📅 {date}: "
                # Pokaż przykład jak będzie wyglądał nowy symbol
                example_cell = cells[0]['cell_data']
                current_symbol = cells[0]['current_symbol']
                # Przewiduj jak będzie wyglądał nowy symbol
                predicted_symbol = self._predict_new_symbol(current_symbol, new_special_symbol, example_cell)
                if len(cells) == 1:
                    changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                else:
                    # Jeśli wiele komórek w tym dniu
                    current_symbols = [cell['current_symbol'] for cell in cells]
                    unique_symbols = set(current_symbols)
                    if len(unique_symbols) == 1:
                        changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                    else:
                        symbols_str = ", ".join([f"{s}" for s in unique_symbols])
                        changes_info += f"[{symbols_str}] -> {predicted_symbol}\n"
        return changes_info

    def _predict_new_symbol(self, current_symbol: str, special_symbol: str, cell_data: dict) -> str:
        """
        Przewiduje, jak będzie wyglądał nowy symbol, z uwzględnieniem
        logiki dla lokalizacji i systemu równoważnego.
        """
        parsed_current = parse_symbol(current_symbol)

        final_start_hour = parsed_current.get('start_hour')
        final_work_hours = parsed_current.get('work_hours')

        system_pracy = cell_data.get('system_czasu_pracy', '').strip().lower()
        is_equivalent_system = (system_pracy == 'równoważny')
        is_absence_symbol = special_symbol.upper() in app_settings.get_absence_symbols()

        if is_equivalent_system and is_absence_symbol:
            try:
                final_work_hours = int(float(cell_data.get('etat')))
            except (ValueError, TypeError):
                final_work_hours = 8

        # --- ZMIANA: Poprawiona logika ustalania lokalizacji ---
        final_location = None
        # Warunek: Lokalizację przypisujemy tylko, gdy wstawiany jest symbol "pracujący"
        # lub gdy nie ma symbolu specjalnego (zwykła zmiana robocza).
        if (special_symbol and special_symbol.upper() in app_settings.WORK_LIKE_SYMBOLS) or not special_symbol:
            # Hierarchia:
            # 1. Weź lokalizację, jeśli już istnieje w komórce.
            # 2. Jeśli nie, użyj nowej funkcji, która sprawdzi wyjątki i domyślne.
            final_location = parsed_current.get('location') or self.determine_correct_location(cell_data)
        # Dla zwykłych nieobecności (U, CO) `final_location` pozostanie None.
        # --- KONIEC ZMIANY ---

        new_symbol = build_symbol(
            location=final_location,
            start_hour=final_start_hour,
            work_hours=final_work_hours,
            special_symbol=special_symbol
        )

        if not new_symbol.strip() and special_symbol and special_symbol.strip():
            return special_symbol.strip()

        return new_symbol.strip() if new_symbol else ""

    def determine_correct_location(self, cell_data: dict) -> str | None:
        """
        Określa prawidłową lokalizację dla komórki, wywołując dedykowaną
        funkcję tabelaryczną w bazie danych.

        Args:
            cell_data (dict): Słownik z danymi komórki.

        Returns:
            str | None: Kod lokalizacji ('h', 's', 'p') lub None.
        """
        try:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if not user_id or not date_str:
                return None  # Nie można wykonać zapytania bez kluczowych danych

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # Jedno proste zapytanie do bazy danych
            sql = f"SELECT FinalLocation FROM {SQL_OBJECTS['fn_getcorrectlocation']}(?, ?)"
            cursor.execute(sql, (user_id, date_str))
            result = cursor.fetchone()
            conn.close()

            if result and result[0]:
                return result[0]

            return None  # Zwróć None, jeśli funkcja nic nie zwróciła

        except Exception as e:
            log_error(f"Błąd w determine_correct_location przy wywołaniu TVF: {e}")
            return None  # Bezpieczny fallback

    def _find_events_to_cancel(self, user_date_pairs):
        """
        Znajduje zdarzenia do odwołania dla podanych par użytkownik-data.
        WERSJA ZMODYFIKOWANA: Uwzględnia spotkania/szkolenia tylko w statusie 'Delegowany'.
        """
        events_to_cancel = []
        for user_id, date_str in user_date_pairs:
            # Pobieramy WSZYSTKIE zdarzenia dla komórki, aby sprawdzić ich dokładny status
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str, active_only=False)

            for event in user_events:
                event_type = event.get('type')
                event_status = event.get('status')
                event_id = event.get('id')

                if not event_type or event_id is None:
                    continue

                # Warunek 1: Spotkanie lub Szkolenie musi mieć status 'Delegowany'
                is_cancellable_meeting_or_training = (
                        event_type in ['Spotkanie', 'Szkolenie'] and event_status == 'Delegowany'
                )

                # Warunek 2: Nadgodziny muszą być po prostu "aktywne" (status inny niż '0')
                is_cancellable_overtime = (
                        event_type == 'Nadgodziny' and str(event_status) != '0'
                )

                if is_cancellable_meeting_or_training or is_cancellable_overtime:
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('UzytkownikDane', ''),
                    })
        return events_to_cancel

    def _group_events_by_user_date(self, events_to_cancel):
        """Grupuje zdarzenia według użytkownika i daty"""
        grouped_events = {}
        for event in events_to_cancel:
            key = (event['user_id'], event['date'])
            if key not in grouped_events:
                grouped_events[key] = []
            grouped_events[key].append(event)
        return grouped_events

    # def _apply_absence_symbol_changes(self, schedule_cells, special_symbol, events_to_cancel):
    #     try:
    #         if events_to_cancel: self._cancel_delegations(events_to_cancel)
    #         successful_updates, failed_updates = 0, 0
    #         error_messages, affected_pairs, skipped_employees = [], [], []
    #
    #         for cell_data in schedule_cells:
    #             # --- POCZĄTEK NOWEJ WERYFIKACJI ---
    #             target_dept = cell_data.get('wydzial', '').strip().lower()
    #             if self.current_user_role in ['Lider',
    #                                           'Lider OUT'] and target_dept == 'dtn' and special_symbol.upper() != 'CO':
    #                 # Dodaj do pominiętych z odpowiednim komunikatem i przejdź do następnej komórki
    #                 skipped_employees.append(f"{cell_data.get('uzytkownik_dane', 'Nieznany')} (Tylko 'CO' dla DTN)")
    #                 continue
    #             # --- KONIEC NOWEJ WERYFIKACJI ---
    #
    #             permissions = self._get_permission_for_cell(cell_data)
    #             if not permissions['can_edit_symbol']:
    #                 skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
    #                 continue
    #
    #             user_id, date_str, nr_kadrowy, current_symbol = cell_data.get('uzytkownik_id'), cell_data.get(
    #                 'date_str'), cell_data.get('nr_kadrowy'), cell_data.get('symbol', '')
    #             if not all([user_id, date_str, nr_kadrowy]):
    #                 failed_updates += 1
    #                 error_messages.append(f"Brak danych dla komórki: U:{user_id} D:{date_str} NRK:{nr_kadrowy}")
    #                 continue
    #
    #             new_symbol = self._build_new_symbol_with_absence_fixed(current_symbol, special_symbol, cell_data)
    #             try:
    #                 year_val, month_val, _ = map(int, date_str.split('-'))
    #                 result = self._call_import_changes_procedure(nr_kadrowy=nr_kadrowy, rok=year_val, miesiac=month_val,
    #                                                              data=date_str, symbol=new_symbol)
    #                 if result['success']:
    #                     successful_updates += 1
    #                     affected_pairs.append((user_id, date_str, result.get('returned_symbol')))
    #                 else:
    #                     failed_updates += 1
    #                     error_messages.append(f"{nr_kadrowy} ({date_str}): {result.get('message', 'Nieznany błąd')}")
    #             except Exception as e_proc:
    #                 failed_updates += 1
    #                 error_messages.append(f"{nr_kadrowy} ({date_str}): {str(e_proc)}")
    #                 log_error(f"Błąd procedury importu dla {user_id}, {date_str}: {e_proc}", exception=e_proc)
    #
    #         if successful_updates > 0:
    #             self._update_cells_with_new_symbols(affected_pairs)
    #
    #         self._show_symbol_change_results(successful_updates, failed_updates, error_messages, events_to_cancel,
    #                                          skipped_employees)
    #     except Exception as e:
    #         log_error(f"Błąd podczas wstawiania nieobecności: {e}", exception=e)
    #         QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas wstawiania nieobecności: {str(e)}",
    #                              QMessageBox.Ok)

    def clear_special_symbol_from_selected_cells(self):
        """Usuwa symbol specjalny (F12) z poprawnym sprawdzaniem uprawnień."""
        if not app_settings.has_permission(self.current_user_role, 'action_clear_special_symbol'):
            self.statusBar().showMessage("Brak uprawnień do wykonania tej operacji.", 3000)
            return

        selected_cells_data = self.table.get_data_for_selected_cells()
        if not self._can_modify_cells(selected_cells_data) or not selected_cells_data: return

        cells_to_modify = [cell for cell in selected_cells_data if
                           parse_symbol(cell.get('symbol', '')).get('special_symbol')]
        if not cells_to_modify:
            QMessageBox.information(self, "Brak zmian",
                                    "W zaznaczonych komórkach nie ma symboli specjalnych do usunięcia.")
            return

        reply = QMessageBox.question(self, "Potwierdzenie operacji",
                                     f"Czy na pewno chcesz usunąć symbole specjalne z {len(cells_to_modify)} komórek?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if reply != QMessageBox.Yes: return

        updated_info, error_messages = [], []
        for cell_data in cells_to_modify:
            parsed = parse_symbol(cell_data.get('symbol', ''))
            final_location = parsed.get('location') or self.determine_correct_location(cell_data)

            final_start_hour, final_work_hours = parsed.get('start_hour'), parsed.get('work_hours')
            new_symbol = "" if final_start_hour is None and final_work_hours is None else build_symbol(
                location=final_location,
                start_hour=final_start_hour,
                work_hours=final_work_hours,
                special_symbol=None)
            final_start_hour, final_work_hours = parsed.get('start_hour'), parsed.get('work_hours')
            new_symbol = "" if final_start_hour is None and final_work_hours is None else build_symbol(
                location=final_location, start_hour=final_start_hour, work_hours=final_work_hours, special_symbol=None)
            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month),
                                                             data=date_str, symbol=new_symbol)
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"{cell_data.get('uzytkownik_dane')}: {result.get('message', 'Błąd zapisu.')}")
            except Exception as e:
                log_error(f"Błąd w clear_special_symbol_from_selected_cells: {e}")
                error_messages.append(f"{cell_data.get('uzytkownik_dane')}: Błąd aplikacji: {e}")
        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Pomyślnie usunięto symbole specjalne z {len(updated_info)} komórek.", 4000)
        if error_messages:
            QMessageBox.warning(self, "Błędy podczas zapisu",
                                f"Wystąpiły następujące błędy:\\n\\n" + "\\n".join(error_messages))

    # def _build_new_symbol_with_absence_fixed(self, current_symbol, special_symbol, cell_data):
    #     """Buduje nowy symbol z absencją, poprawnie obsługując puste i wypełnione komórki."""
    #     return self._predict_new_symbol(current_symbol, special_symbol, cell_data)

    def _add_location_exception_batch(self, params_list: list):
        """Dodaje serię wyjątków w jednej transakcji dla wydajności i bezpieczeństwa."""
        errors = []
        conn = None
        try:
            # Krok 1: Otwórz połączenie TYLKO RAZ
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            query = f"EXEC {SQL_OBJECTS['p_lokalizacjewyjatki']} ?, ?, ?, ?, ?, ?, ?, ?"

            # Krok 2: Wykonaj wszystkie operacje w pętli
            for params in params_list:
                try:
                    cursor.execute(query, params)
                except Exception as e:
                    # Zbierz informacje o błędach, które wystąpiły
                    date_str = params[2]  # Data jest na 3. pozycji w krotce
                    errors.append(f"Dzień {date_str}: {e}")

            # Krok 3: Zatwierdź wszystkie udane operacje JEDNYM poleceniem
            conn.commit()

            return {"success": not errors, "errors": errors}

        except Exception as e:
            log_error(f"Błąd krytyczny podczas wsadowego dodawania wyjątków: {e}", exception=e)
            return {"success": False, "errors": [str(e)]}
        finally:
            # Krok 4: Zamknij połączenie na samym końcu
            if conn:
                conn.close()

    def _check_location_exception(self, user_id, change_date):
        """Sprawdza wyjątek lokalizacyjny dla konkretnego dnia używając nowej funkcji TVF."""
        debug_print(
            f"--- Sprawdzanie wyjątku (TVF) dla Użytkownika ID: {user_id}, Data: {change_date.toString('yyyy-MM-dd')} ---")
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            date_str = change_date.toString("yyyy-MM-dd")

            # Wywołanie nowej funkcji tabelarycznej
            fn_name = SQL_OBJECTS.get('fn_getlocationexceptions', 'dbo.fn_GetLocationExceptions')
            query = f"SELECT * FROM {fn_name}(?, ?, ?)"
            cursor.execute(query, (user_id, date_str, date_str))

            results = [dict(zip([column[0] for column in cursor.description], row)) for row in cursor.fetchall()]
            conn.close()

            debug_print(f"Znaleziono {len(results)} wpisów w bazie danych przez TVF.")

            exact_match = None
            range_match = None
            py_change_date = change_date.toPython()

            for row_dict in results:
                data_od = row_dict['Dataod'].date()
                data_do = row_dict['Datado'].date() if row_dict['Datado'] else None
                if data_od == py_change_date and data_do and data_do == py_change_date:
                    exact_match = row_dict
                    break
                if data_od <= py_change_date and (not data_do or data_do >= py_change_date):
                    range_match = row_dict

            debug_print(
                f"Zwracam: exact_match={'TAK' if exact_match else 'NIE'}, range_match={'TAK' if range_match else 'NIE'}")
            return exact_match, range_match

        except Exception as e:
            log_error(f"Błąd podczas sprawdzania wyjątków lokalizacyjnych (TVF): {e}", exception=e)
            return None, None

    def _manage_location_exception(self, params):
        """Zarządza dodawaniem, edycją i usuwaniem wyjątków lokalizacyjnych."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            query = f"EXEC {SQL_OBJECTS['p_lokalizacjewyjatki']} ?, ?, ?, ?, ?, ?, ?, ?"
            cursor.execute(query, params)

            # --- POCZĄTEK KLUCZOWEJ POPRAWKI ---
            # Ta pętla zmusza sterownik do poczekania na pełne wykonanie procedury na serwerze,
            # zanim przejdzie do zamknięcia połączenia. Przetwarza wszystkie "ukryte" komunikaty
            # i zestawy wyników, które procedura mogłaby wygenerować.
            while cursor.nextset():
                pass
            # --- KONIEC KLUCZOWEJ POPRAWKI ---

            conn.commit()
            conn.close()
            return {"success": True}
        except Exception as e:
            log_error(f"Błąd podczas zarządzania wyjątkiem lokalizacyjnym: {e}", exception=e)
            return {"success": False, "message": str(e)}

    def _call_import_changes_procedure(self, nr_kadrowy, rok, miesiac, data, symbol):
        """Wywołuje procedurę i bardziej niezawodnie interpretuje jej wyniki."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(
                f"EXEC {SQL_OBJECTS['p_importzmianynaserwer']} @Nr_Kadrowy = ?, @Rok = ?, @Miesiac = ?, @Data = ?, @Symbol = ?, @CzyPobieranieSugestii = ?",
                (nr_kadrowy, rok, miesiac, data, symbol, None))

            all_results = []
            while True:
                try:
                    rows = cursor.fetchall()
                    if rows: all_results.extend(rows)
                    if not cursor.nextset(): break
                except Exception:
                    break
            conn.commit()
            conn.close()

            returned_symbol, success, message = symbol, True, "Operacja zakończona pomyślnie"
            for row in all_results:
                if row and len(row) > 0 and row[0] is not None:
                    raw_value = row[0]
                    if isinstance(raw_value, int) and raw_value == 0: continue
                    value_str = str(raw_value).strip()
                    if not value_str or value_str == "0": continue

                    is_likely_a_symbol = ' ' not in value_str and len(value_str) <= 50
                    if is_likely_a_symbol:
                        returned_symbol = value_str
                    else:
                        success, message = False, value_str
                        break
            if success:
                self._update_modification_date()
            return {"success": success, "message": message, "returned_symbol": returned_symbol}
        except Exception as e:
            log_error(f"Błąd procedury ImportZmianNaSerwer: {e}")
            return {"success": False, "message": f"Błąd bazy danych: {str(e)}", "returned_symbol": symbol}

    def _process_and_apply_changes(self, change_requests: list, success_message_template: str):
        """
        NOWA, CENTRALNA METODA: Przetwarza listę żądań zmian, wywołuje procedurę,
        a następnie zbiera i wyświetla wyniki (sukcesy na pasku statusu, błędy w oknie).

        Args:
            change_requests (list): Lista słowników, każdy z kluczami:
                                    nr_kadrowy, rok, miesiac, data, symbol, user_id, user_name.
            success_message_template (str): Szablon wiadomości o sukcesie, np. "Zastosowano symbol dla {} komórek."
        """
        if not change_requests:
            return

        updated_info = []
        error_messages = []

        for req in change_requests:
            try:
                result = self._call_import_changes_procedure(
                    nr_kadrowy=req['nr_kadrowy'],
                    rok=req['rok'],
                    miesiac=req['miesiac'],
                    data=req['data'],
                    symbol=req['symbol']
                )
                if result.get('success'):
                    updated_info.append((req['user_id'], req['data'], result.get('returned_symbol')))
                else:
                    error_msg = result.get('message', 'Nieznany błąd')
                    error_messages.append(f"⑭ {req.get('user_name', req['nr_kadrowy'])} ({req['data']}): {error_msg}")
            except Exception as e:
                log_error(f"Błąd krytyczny podczas przetwarzania żądania zmiany: {req}", exception=e)
                error_messages.append(f"⑭ {req.get('user_name', req['nr_kadrowy'])} ({req['data']}): {e}")

        # Aktualizuj UI dla udanych operacji
        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(success_message_template.format(len(updated_info)), 4000)

        # Wyświetl jedno okno ze wszystkimi błędami
        if error_messages:
            QMessageBox.warning(
                self,
                "Błędy podczas zapisu",
                f"Wystąpiły następujące błędy i niektóre zmiany nie zostały zapisane:\\n\\n" + "\\n".join(error_messages),
                QMessageBox.Ok
            )

    def _update_cells_with_new_symbols(self, updated_cells_info: list):
        """Aktualizuje komórki w modelu na podstawie danych zwróconych przez procedurę."""
        if not updated_cells_info or not hasattr(self, 'schedule_model'): return
        for user_id, date_str, new_symbol in updated_cells_info:
            if new_symbol is not None:
                self._update_single_cell_in_model(user_id, date_str, new_symbol, self.year, self.month)
        debug_print(f"Zaktualizowano {len(updated_cells_info)} komórek w modelu.")

    def _update_single_cell_in_model(self, user_id, date_str, new_symbol, year, month):
        """Aktualizuje jedną komórkę w modelu i wymusza jej odświeżenie."""
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model: return False
            row_index = -1
            for idx, key in enumerate(self.schedule_model._keys):
                if str(key[3]) == str(user_id):
                    row_index = idx
                    break
            if row_index == -1: return False

            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)
            if int(year_str) != year or int(month_str) != month: return False

            col_index = len(self.schedule_model.get_visible_columns()) + day - 1
            model_index = self.schedule_model.index(row_index, col_index)
            if model_index.isValid():
                return self.schedule_model.setData(model_index, new_symbol, Qt.EditRole)
            return False
        except Exception as e:
            log_error(f"Błąd aktualizacji komórki {user_id}/{date_str}: {e}")
            return False

    def _get_location_exceptions(self, user_id, start_date, end_date):
        """Pobiera wyjątki lokalizacyjne dla użytkownika w danym zakresie dat używając funkcji TVF."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            fn_name = SQL_OBJECTS.get('fn_getlocationexceptions', 'dbo.fn_GetLocationExceptions')
            query = f"SELECT * FROM {fn_name}(?, ?, ?)"
            cursor.execute(query, (user_id, start_date.toString("yyyy-MM-dd"), end_date.toString("yyyy-MM-dd")))
            results = [dict(zip([column[0] for column in cursor.description], row)) for row in cursor.fetchall()]
            conn.close()
            return sorted(results, key=lambda x: x['Dataod'], reverse=True)
        except Exception as e:
            log_error(f"Błąd podczas pobierania wyjątków (TVF): {e}", exception=e)
            return []

    def show_location_exception_dialog(self):
        """Otwiera okno do zarządzania wyjątkami lokalizacyjnymi."""
        from location_exception_dialog import LocationExceptionDialog

        selected_cells = self.get_selected_cells_data()
        if not selected_cells:
            QMessageBox.warning(self, "Brak zaznaczenia", "Proszę zaznaczyć przynajmniej jedną komórkę pracownika.")
            return

        user_ids = {cell['uzytkownik_id'] for cell in selected_cells}
        if len(user_ids) > 1:
            QMessageBox.warning(self, "Wielu użytkowników", "Proszę zaznaczyć komórki tylko dla jednego pracownika.")
            return

        user_id = user_ids.pop()
        user_name = selected_cells[0]['uzytkownik_dane']

        dates = [QDate.fromString(cell['date_str'], "yyyy-MM-dd") for cell in selected_cells]
        selection_range = {'start': min(dates), 'end': max(dates)}

        dialog = LocationExceptionDialog(self, user_id, user_name, selection_range)
        dialog.data_changed.connect(self.refresh_data)

        # Zapisz stan widoku przed otwarciem dialogu
        self._state_to_restore = self._save_view_state()

        dialog.exec()

    def check_for_new_data(self):
        """Sprawdza nowe dane i wersję, używając jednego połączenia z bazą."""
        conn = None
        try:
            # Krok 1: Otwórz JEDNO połączenie na początku
            conn = DatabaseConnector.get_connection()

            # Krok 2: Załaduj ustawienia, przekazując istniejące połączenie
            if not load_all_app_settings(existing_conn=conn):
                log_warning("Nie udało się odświeżyć ustawień aplikacji w tle.")
                return

            # Krok 3: Sprawdź wersję (korzystając z już załadowanych danych)
            is_update_forced = app_settings.FORCE_UPDATE
            is_version_obsolete = self.check_if_update_is_required()
            if is_update_forced or is_version_obsolete:
                debug_print(
                    f"Wykryto polecenie zdalnej aktualizacji (force: {is_update_forced}, obsolete: {is_version_obsolete}). Zamykanie aplikacji.")
                self.check_timer.stop()
                dialog = UpdateRequiredDialog(self)
                dialog.exec()
                self.close()
                return

            # Krok 4: Sprawdź daty modyfikacji, używając wciąż tego samego połączenia
            current_date_data = self.date_combo.currentData()
            if not current_date_data: return
            year, month = current_date_data
            if not hasattr(self, 'last_modification_date') or not self.last_modification_date:
                self._update_modification_date()  # Ta metoda otworzy własne połączenie, ale tylko raz na początku
                return

            cursor = conn.cursor()
            cursor.execute(
                f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['grafikipracy']} WHERE Rok = ? AND Miesiac = ?",
                (year, month))
            schedule_max_date = cursor.fetchone()[0]
            cursor.execute(f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['fn_geteventsdata']}(?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]

            new_data_types = []
            if schedule_max_date and schedule_max_date > self.last_modification_date:
                new_data_types.append("grafiku")
            if events_max_date and events_max_date > self.last_modification_date:
                new_data_types.append("zdarzeń")
            if new_data_types:
                latest_overall_modification = max(d for d in [schedule_max_date, events_max_date] if d)
                is_self_change = False
                if hasattr(self, 'last_self_modification_date') and self.last_self_modification_date:
                    if abs(latest_overall_modification - self.last_self_modification_date) < timedelta(seconds=2):
                        is_self_change = True
                if not is_self_change:
                    change_type_text = " i ".join(new_data_types)
                    self.refresh_button.setText(f"Nowe dane {change_type_text}!")
                    self.refresh_button.setToolTip(
                        f"Wykryto zmiany w sekcji: {change_type_text}. Kliknij, aby załadować.")
                    new_data_style = "QPushButton { background-color: #f39c12; color: white; font-weight: bold; border: 1px solid #e67e22; } QPushButton:hover { background-color: #e67e22; }"
                    self.refresh_button.setStyleSheet(new_data_style)
                    self.check_timer.stop()
                else:
                    self.last_modification_date = latest_overall_modification

        except Exception as e:
            log_error(f"Błąd podczas sprawdzania nowych danych: {e}", exception=e)
        finally:
            # Krok 5: Zawsze zamknij połączenie na końcu
            if conn:
                try:
                    conn.close()
                except Exception as e:
                    log_warning(f"Problem z zamknięciem połączenia w check_for_new_data: {e}")

    def _save_current_filter_settings(self):
        """Zapisuje aktualny stan filtrów do słownika ustawień i do bazy danych."""
        if not hasattr(self, 'user_settings'):
            return

        # Zaktualizuj słownik o bieżący stan filtrów
        self.user_settings['last_filters'] = self.get_current_filters_state()

        # Zapisz cały, zaktualizowany słownik w bazie danych
        self.settings_db.save_settings(self.user_settings)
        debug_print("Zapisano bieżący stan filtrów do bazy danych.")

    def refresh_data(self):
        """Wymusza odświeżenie danych z bazy, zachowując stan filtrów i sortowania."""
        # Krok 1: Pobierz bieżący stan filtrów do zmiennej.
        filters_to_preserve = self.get_current_filters_state()

        self.refresh_button.setText("Odśwież")
        self.refresh_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.refresh_button.setToolTip("Odśwież dane")

        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            self.update_buttons_visibility()
            self.data_provider.clear_monthly_cache(year, month)
            # Krok 2: Przekaż stan filtrów do procesu aktualizacji danych.
            self.update_data(year, month, self.import_grupa, self.import_funkcja, use_async=True, filters_to_restore=filters_to_preserve)
            self.update_filter_dates()
            self._update_modification_date()
            if hasattr(self, 'check_timer'):
                self.check_timer.start(60000)

    def _update_modification_date(self):
        """Aktualizuje datę ostatniej modyfikacji po dokonaniu zmian."""
        try:
            current_date_data = self.date_combo.currentData()
            if not current_date_data: return
            year, month = current_date_data
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(
                f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['grafikipracy']} WHERE Rok = ? AND Miesiac = ?",
                (year, month))
            schedule_max_date = cursor.fetchone()[0]
            cursor.execute(f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['fn_geteventsdata']}(?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]
            conn.close()
            all_dates = [d for d in [schedule_max_date, events_max_date] if d is not None]
            if not all_dates: return
            latest_modification = max(all_dates)
            self.last_self_modification_date = latest_modification
            self.last_modification_date = latest_modification
        except Exception as e:
            log_error(f"Błąd podczas aktualizacji daty modyfikacji: {e}", exception=e)

    def filter_data(self):
        """Filtruje dane grafiku i ZAWSZE stosuje sortowanie z ustawień użytkownika."""
        if not hasattr(self, 'schedule_model') or not self.schedule_model or getattr(self, '_updating_filters', False):
            return
        self._updating_filters = True
        try:
            # Krok 1: Aktualizacja i zastosowanie filtrów
            self.update_cross_filters()
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

            # Krok 2: Zawsze po filtrowaniu, zastosuj zapisane sortowanie
            self.apply_custom_sort()

        finally:
            self._updating_filters = False
            current_data = self.date_combo.currentData()
            if current_data and self.staffing_details_win and not self.staffing_details_win.isHidden():
                year, month = current_data
                self.staffing_details_win.update_for_new_month_or_filters(year, month)

    def filter_events_table(self):
        """Filtruje tabelę zdarzeń, bazując na danych z modelu."""
        try:
            if not hasattr(self, 'events_model') or not self.events_model: return

            # ZMIANA: Zawsze pobieraj dane źródłowe z modelu,
            # które zostały tam wstawione przez `on_selection_changed`.
            source_data = self.events_model.get_all_events()
            if not source_data:
                self.events_model.filtered_update([])
                return

            filtered_data = source_data.copy()

            # Filtr typów
            allowed_types = []
            if self.meetings_checkbox.isChecked(): allowed_types.append('Spotkanie')
            if self.trainings_checkbox.isChecked(): allowed_types.append('Szkolenie')
            if self.overtime_checkbox.isChecked(): allowed_types.append('Nadgodziny')
            if allowed_types:
                filtered_data = [e for e in filtered_data if e.get('type') in allowed_types]

            # Filtr statusu
            selected_statuses = self.status_filter_combo.get_selected_items()
            if selected_statuses:
                filtered_data = [e for e in filtered_data if e.get('status') in selected_statuses]

            # Filtry tekstowe i dat
            topic_filter = self.topic_filter.text().lower()
            if topic_filter:
                filtered_data = [e for e in filtered_data if topic_filter in str(e.get('topic', '')).lower()]

            name_filter = self.name_filter.text().lower()
            if name_filter:
                filtered_data = [e for e in filtered_data if name_filter in str(e.get('name', '')).lower()]

            date_from_str = self.date_from.date().toString('yyyy-MM-dd')
            date_to_str = self.date_to.date().toString('yyyy-MM-dd')
            if date_from_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') >= date_from_str]
            if date_to_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') <= date_to_str]

            self.events_model.filtered_update(filtered_data)
        except Exception as e:
            log_error(f"Błąd podczas filtrowania zdarzeń: {str(e)}")

    def setup_events_table_columns(self):
        """Konfiguruje kolumny dla tabeli zdarzeń w sposób jawny i niezawodny."""
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        header = self.events_table.horizontalHeader()
        header.setStretchLastSection(False)

        # Ustawiamy tryb interaktywny, aby użytkownik mógł sam zmieniać rozmiar,
        # ale definiujemy rozsądne szerokości startowe.
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(0, 40)  # Id

        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(1, 80)  # Typ

        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)  # Temat
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.Stretch)  # Nazwa

        header.setSectionResizeMode(4, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(4, 150)  # Użytkownik

        header.setSectionResizeMode(5, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(5, 90)  # Data

        header.setSectionResizeMode(6, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(6, 120)  # Czas od

        header.setSectionResizeMode(7, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(7, 120)  # Czas do

        header.setSectionResizeMode(8, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(8, 100)  # Status

        header.setSectionResizeMode(9, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(9, 125)  # Data Modyfikacji

        # Kolumna Akcje - stała i nienaruszalna
        header.setSectionResizeMode(10, QHeaderView.ResizeMode.Fixed)
        self.events_table.setColumnWidth(10, 85)  # Akcje

    def show_schedule_control_dialog(self):
        """Pokazuje odpowiednie okno dialogowe w zależności od roli użytkownika."""
        from schedule_control_dialog import ScheduleControlDialog, SuggestionsOutDialog

        # Główny przycisk jest już chroniony przez 'button_schedule_control'.
        # Poniższa logika jedynie decyduje, które okno pokazać dla uprawnionego użytkownika.
        # Jest to akceptowalne, ponieważ nie nadaje dodatkowych uprawnień.
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Proszę najpierw wybrać miesiąc.")
            return

        year, month = current_data

        if self.current_user_role == "Pracownik WPR":
            dialog = ScheduleControlDialog(self, year, month)
        elif self.current_user_role == "Lider OUT":
            dialog = SuggestionsOutDialog(self, year, month)
        else:
            # Ten komunikat nie powinien się pojawić, jeśli przycisk jest poprawnie ukryty,
            # ale zostawiamy go jako zabezpieczenie.
            QMessageBox.information(self, "Brak dostępu", "Twoja rola nie ma dostępu do tej funkcji.")
            return

        dialog.data_refresh_needed.connect(self.refresh_data)
        dialog.exec()

    def show_insert_change_dialog(self):
        """Pokazuje okno dialogowe do wstawiania zmian w grafiku"""
        if not app_settings.has_permission(self.current_user_role, 'schedule_cell_actions'):
            self.statusBar().showMessage("Brak uprawnień do wstawiania zmian.", 3000)
            return

        # from schedule_edit_dialogs import ScheduleChangeDialog # Ten import już jest wyżej
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Nie wybrano miesiąca. Nie można dodać zmiany grafiku.", QMessageBox.Ok)
            return

        year, month = current_data
        selected_cells = self.table.get_data_for_selected_cells()

        if not selected_cells:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono żadnych komórek do edycji.", QMessageBox.Ok)
            return

        grouped_cells = self.group_cells_by_user_and_day(selected_cells)

        dialog = ScheduleChangeDialog(self, grouped_cells=grouped_cells, year=year, month=month, main_window=self)

        dialog.changes_requested.connect(self.handle_schedule_change_request)
        dialog.exec()

    def handle_schedule_change_request(self, change_requests: list):
        """
        Przetwarza żądania zmian w grafiku z ostateczną walidacją
        przypisania lokalizacji i poprawnym statusem "Brak zmiany".
        """
        dialog = self.sender()

        for request in change_requests:
            visual_row = request['visual_row']
            cell_data = request['cell_data']

            try:
                # --- Krok 1: Pobranie danych (bez zmian) ---
                user_id = cell_data.get('uzytkownik_id')
                nr_kadrowy = cell_data.get('nr_kadrowy')
                user_name = cell_data.get('uzytkownik_dane')
                date_str = cell_data.get('date_str')
                q_date = QDate.fromString(date_str, "yyyy-MM-dd")
                _, modyfikujacy_id, _, _, _ = get_modifier_id()
                location_map = {'h': 1, 's': 3, 'p': 2}
                default_location_code = cell_data.get('lokalizacja_domyslna', 'h')
                target_dept = cell_data.get('wydzial', '').upper()

                from symbol_parser import parse_symbol, build_symbol
                original_symbol = cell_data.get('symbol', '')
                original_parsed_symbol = parse_symbol(original_symbol)

                new_location_code = request['new_location_code']
                new_start_hour = request['new_start_hour']
                new_work_hours = request['new_work_hours']

                # --- Krok 2: Logika biznesowa dla wyjątków (bez zmian) ---
                original_location_code = original_parsed_symbol.get('location') or default_location_code
                loc_changed = new_location_code != original_location_code
                is_reverting_to_default = loc_changed and (new_location_code == default_location_code)
                reason_for_change = None

                if loc_changed:
                    if is_reverting_to_default:
                        reason_for_change = None
                    elif target_dept.startswith('WZP'):
                        reason_for_change = "Zmiana w aplikacji"
                    else:
                        if user_id in dialog.reason_cache:
                            reason_for_change = dialog.reason_cache[user_id]
                        else:
                            reason_dialog = ReasonDialog(dialog)
                            if reason_dialog.exec() == QDialog.Accepted:
                                reason_for_change = reason_dialog.getReason()
                                dialog.reason_cache[user_id] = reason_for_change
                            else:
                                dialog.update_status_for_row(visual_row, 'failure', "Anulowano")
                                continue

                # --- Krok 3: Walidacja lokalizacji i budowa nowego symbolu (bez zmian) ---
                final_location_for_build = new_location_code
                original_special_symbol = original_parsed_symbol.get('special_symbol')

                if original_special_symbol and original_special_symbol.upper() not in app_settings.WORK_LIKE_SYMBOLS:
                    final_location_for_build = None

                new_symbol = build_symbol(
                    location=final_location_for_build,
                    start_hour=new_start_hour,
                    work_hours=new_work_hours,
                    special_symbol=original_special_symbol
                )

                # --- ZMIANA: Ostateczne porównanie symboli przed wysłaniem do bazy ---
                if new_symbol == original_symbol:
                    dialog.update_status_for_row(visual_row, 'no_change')
                    continue  # Przejdź do następnego żądania, pomijając zapis do bazy
                # --- KONIEC ZMIANY ---

                # --- Krok 4: Wywołanie procedur (bez zmian) ---
                result = {}
                new_symbol = build_symbol(
                    location=final_location_for_build,
                    start_hour=new_start_hour,
                    work_hours=new_work_hours,
                    special_symbol=original_special_symbol
                )

                if loc_changed:
                    exact_exception, range_exception = self._check_location_exception(user_id, q_date)
                    new_location_id = location_map.get(new_location_code, 1)
                    if is_reverting_to_default:
                        if range_exception:
                            result = {"success": False,
                                      "message": "Ten dzień jest częścią wielodniowego wyjątku. Zaktualizuj go ręcznie."}
                        else:
                            result = self._call_import_changes_procedure(nr_kadrowy, self.year, self.month, date_str,
                                                                         new_symbol)
                            if result.get("success") and exact_exception:
                                params = (
                                None, modyfikujacy_id, None, None, None, reason_for_change, 3, exact_exception['Id'])
                                self._manage_location_exception(params)
                    else:
                        if exact_exception:
                            if exact_exception['Lokalizacja'] == new_location_id:
                                result = self._call_import_changes_procedure(nr_kadrowy, self.year, self.month,
                                                                             date_str, new_symbol)
                            else:
                                result = self._call_import_changes_procedure(nr_kadrowy, self.year, self.month,
                                                                             date_str, new_symbol)
                                if result.get("success"):
                                    params = (
                                    user_id, modyfikujacy_id, date_str, date_str, new_location_id, reason_for_change, 2,
                                    exact_exception['Id'])
                                    self._manage_location_exception(params)
                        elif range_exception:
                            if range_exception['Lokalizacja'] != new_location_id:
                                result = {"success": False,
                                          "message": "Istnieje wyjątek w zakresie dat z inną lokalizacją."}
                            else:
                                result = self._call_import_changes_procedure(nr_kadrowy, self.year, self.month,
                                                                             date_str, new_symbol)
                        else:
                            result = self._call_import_changes_procedure(nr_kadrowy, self.year, self.month, date_str,
                                                                         new_symbol)
                            if result.get("success"):
                                params = (
                                user_id, modyfikujacy_id, date_str, date_str, new_location_id, reason_for_change, 1,
                                None)
                                self._manage_location_exception(params)
                else:
                    result = self._call_import_changes_procedure(nr_kadrowy, self.year, self.month, date_str,
                                                                 new_symbol)

                if loc_changed and result.get("success"):
                    overtime_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                    overtime_events = [e for e in overtime_events if e.get('type') == 'Nadgodziny']
                    if overtime_events:
                        ot_dialog = OvertimeLocationDialog(dialog, overtime_events, new_location_code,
                                                           dialog.determined_theme)
                        if ot_dialog.exec() == QDialog.Accepted:
                            location_changes = ot_dialog.get_selected_locations()
                            if location_changes: self._update_multiple_overtime_locations(location_changes)

                # --- Krok 5: Przetwarzanie wyniku i aktualizacja UI ---
                if result.get("success", False):
                    returned_symbol = result.get('returned_symbol', new_symbol)
                    self._update_cells_with_new_symbols([(user_id, date_str, returned_symbol)])
                    cell_data['symbol'] = returned_symbol

                    if dialog and hasattr(dialog, 'update_status_for_row'):
                        dialog.update_status_for_row(visual_row, 'success')
                        dialog.cells_table.item(visual_row, 3).setText(returned_symbol)
                else:
                    error_msg = result.get("message", "Nieznany błąd.")
                    if dialog and hasattr(dialog, 'update_status_for_row'):
                        dialog.update_status_for_row(visual_row, 'failure', error_msg)
                    QMessageBox.warning(self, "Błąd",
                                        f"Błąd dla {user_name} ({self.format_date(date_str)}):\\n{error_msg}",
                                        QMessageBox.Ok)

            except Exception as e:
                log_error(f"Błąd krytyczny w handle_schedule_change_request: {e}", exception=e)
                if dialog and hasattr(dialog, 'update_status_for_row'):
                    dialog.update_status_for_row(visual_row, 'failure', str(e))

    def _save_view_state(self):
        """Zapisuje stabilne identyfikatory zaznaczenia, sortowanie i pozycję przewijania."""
        schedule_selection_ids = []
        if self.table.schedule_view.selectionModel():
            for index in self.table.schedule_view.selectionModel().selectedIndexes():
                data = index.data(ROLE_DATA)
                if isinstance(data, dict) and 'uzytkownik_id' in data and 'date_str' in data:
                    schedule_selection_ids.append((data['uzytkownik_id'], data['date_str']))

        employees_selection_ids = set()
        if self.table.employees_view.selectionModel():
            for index in self.table.employees_view.selectionModel().selectedIndexes():
                data = index.data(ROLE_DATA)
                if isinstance(data, dict) and 'uzytkownik_id' in data:
                    employees_selection_ids.add(data['uzytkownik_id'])

        state = {
            'schedule_selection_ids': schedule_selection_ids,
            'employees_selection_ids': list(employees_selection_ids),
            'emp_sort_col': self.table.employees_view.horizontalHeader().sortIndicatorSection(),
            'emp_sort_order': self.table.employees_view.horizontalHeader().sortIndicatorOrder(),
            'sched_sort_col': self.table.schedule_view.horizontalHeader().sortIndicatorSection(),
            'sched_sort_order': self.table.schedule_view.horizontalHeader().sortIndicatorOrder(),
            'v_scroll_pos': self.table.schedule_view.verticalScrollBar().value(),
            'h_scroll_pos': self.table.schedule_view.horizontalScrollBar().value()
        }
        debug_print(
            f"[DB] ZAPISYWANIE STANU: emp_sort_col={state['emp_sort_col']}, sched_sort_col={state['sched_sort_col']}, selections={len(schedule_selection_ids)}")
        return state

    def _restore_view_state(self, state):
        """Przywraca sortowanie, zaznaczenie i pozycję przewijania po resecie modelu."""
        debug_print(f"[DB] ROZPOCZĘTO PRZYWRACANIE STANU...")
        if not self.schedule_model or self.schedule_model.rowCount() == 0:
            debug_print("[DB] PRZERWANO PRZYWRACANIE: Model jest pusty.")
            return

        schedule_sm = self.table.schedule_view.selectionModel()
        employees_sm = self.table.employees_view.selectionModel()
        if schedule_sm: schedule_sm.blockSignals(True)
        if employees_sm: employees_sm.blockSignals(True)

        try:
            # Krok 1: Zawsze stosuj pełne, wielopoziomowe sortowanie z ustawień użytkownika.
            # To jest jedyne źródło prawdy o pożądanym porządku po resecie danych.
            self.apply_custom_sort()

            # Krok 2: Zbuduj mapę do wyszukania nowych indeksów wierszy po posortowaniu.
            user_id_to_new_row_map = {str(key[3]): i for i, key in enumerate(self.schedule_model._keys)}

            # Krok 3: Odtwórz zaznaczenie na podstawie nowych, prawidłowych indeksów.
            schedule_selection = QItemSelection()
            employee_cols_count = len(self.schedule_model.get_visible_columns())
            for user_id, date_str in state['schedule_selection_ids']:
                new_row = user_id_to_new_row_map.get(str(user_id))
                if new_row is not None:
                    try:
                        day = int(date_str.split('-')[2])
                        new_col = employee_cols_count + day - 1
                        model_index = self.schedule_model.index(new_row, new_col)
                        if model_index.isValid():
                            schedule_selection.select(model_index, model_index)
                    except (ValueError, IndexError):
                        continue

            employees_selection = QItemSelection()
            for user_id in state['employees_selection_ids']:
                new_row = user_id_to_new_row_map.get(str(user_id))
                if new_row is not None:
                    top_left = self.schedule_model.index(new_row, 0)
                    bottom_right = self.schedule_model.index(new_row, employee_cols_count - 1)
                    if top_left.isValid() and bottom_right.isValid():
                        employees_selection.select(top_left, bottom_right)

            debug_print(
                f"[DB] Przywracam zaznaczenie: {len(state['schedule_selection_ids'])} komórek, {len(state['employees_selection_ids'])} wierszy.")
            if schedule_sm: schedule_sm.select(schedule_selection, QItemSelectionModel.ClearAndSelect)
            if employees_sm: employees_sm.select(employees_selection,
                                                 QItemSelectionModel.ClearAndSelect | QItemSelectionModel.Rows)

            # Krok 4: Przywróć pozycję pasków przewijania.
            self.table.schedule_view.verticalScrollBar().setValue(state['v_scroll_pos'])
            self.table.schedule_view.horizontalScrollBar().setValue(state['h_scroll_pos'])
            debug_print(f"[DB] Przywrócono pozycję przewijania: V={state['v_scroll_pos']}, H={state['h_scroll_pos']}")

        finally:
            # Zawsze włączaj sygnały z powrotem.
            if schedule_sm: schedule_sm.blockSignals(False)
            if employees_sm: employees_sm.blockSignals(False)
        debug_print(f"[DB] ZAKOŃCZONO PRZYWRACANIE STANU.")

    def format_date(self, date_str: str) -> str:
        """
        Formatuje datę z formatu 'YYYY-MM-DD' na 'DD.MM.YYYY'.

        Args:
            date_str (str): Data w formacie 'YYYY-MM-DD'.

        Returns:
            str: Sformatowana data lub oryginalny ciąg w razie błędu.
        """
        try:
            year, month, day = date_str.split('-')
            return f"{day}.{month}.{year}"
        except (ValueError, AttributeError):
            return date_str

    def show_add_overtime_dialog(self):
        """Pokazuje okno dialogowe do dodawania nadgodzin."""
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Błąd", "Nie wybrano miesiąca.", QMessageBox.Ok)
            return
        year, month = current_data
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not self._can_modify_cells(selected_cells_data) or not selected_cells_data or len(selected_cells_data) > 1:
            QMessageBox.warning(self, "Błąd zaznaczenia", "Zaznacz dokładnie jedną komórkę, aby dodać nadgodziny.",
                                QMessageBox.Ok)
            return

        cell_data = selected_cells_data[0]
        selected_user_id, selected_user_name, day, date_str, nr_kadrowy, start_hour, current_symbol, lokalizacja_domyslna = (
            cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane'), cell_data.get('day'),
            cell_data.get('date_str'), cell_data.get('nr_kadrowy'), cell_data.get('start_hour'),
            cell_data.get('symbol', ''), cell_data.get('lokalizacja_domyslna', 'h')
        )

        if not all([selected_user_id, day, date_str]):
            QMessageBox.warning(self, "Błąd", "Brak wymaganych danych w zaznaczonej komórce.", QMessageBox.Ok)
            return

        selected_date = QDate.fromString(date_str, "yyyy-MM-dd")
        is_day_off = not current_symbol or current_symbol.strip() == ''
        if start_hour is None: start_hour = 9 if is_day_off else 8

        parsed_symbol = parse_symbol(current_symbol)
        current_location = parsed_symbol.get('location') if parsed_symbol and parsed_symbol.get(
            'location') else lokalizacja_domyslna

        dialog = QDialog(self)
        polish_months = ["stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca", "lipca", "sierpnia", "września",
                         "października", "listopada", "grudnia"]
        dialog.setWindowTitle(
            f"Dodaj nadgodziny w dniu {selected_date.day()} {polish_months[selected_date.month() - 1]} {selected_date.year()}")
        dialog.setMinimumWidth(300)
        layout = QVBoxLayout(dialog)
        layout.addWidget(QLabel(f"Pracownik: {selected_user_name}"))
        if nr_kadrowy: layout.addWidget(QLabel(f"Numer kadrowy: {nr_kadrowy}"))
        layout.addWidget(QLabel(f"Miesiąc rozliczenia: {month:02d}.{year}"))
        if is_day_off: layout.addWidget(QLabel("Zaznaczony dzień jest dniem wolnym pracownika."))

        form_frame = QFrame()
        form_layout = QGridLayout(form_frame)
        time_combo = QComboBox()
        for h in range(24):
            for m in [0, 30]:
                time_combo.addItem(f"{h:02d}:{m:02d}")
        default_time = f"{(start_hour + 8) % 24:02d}:00" if not is_day_off else "09:00"
        time_combo.setCurrentText(default_time)

        hours_combo = QComboBox()
        for h in [i * 0.5 for i in range(1, 27)]: hours_combo.addItem(f"{h:.1f}", h)
        hours_combo.setCurrentIndex(1)

        type_combo, ld_combo, overdue_combo = QComboBox(), QComboBox(), QComboBox()
        type_combo.addItems(["wypłata", "odbiór", "odpracowanie"])
        ld_combo.addItems(["h", "p", "s"])
        ld_combo.setCurrentText(current_location)
        overdue_combo.addItems(["nie", "tak"])
        add_button = QPushButton("Dodaj")

        form_layout.addWidget(QLabel("od kiedy"), 0, 0);
        form_layout.addWidget(time_combo, 0, 1)
        form_layout.addWidget(QLabel("ile godzin"), 0, 2);
        form_layout.addWidget(hours_combo, 0, 3)
        form_layout.addWidget(QLabel("typ"), 0, 4);
        form_layout.addWidget(type_combo, 0, 5)
        form_layout.addWidget(QLabel("LD"), 0, 6);
        form_layout.addWidget(ld_combo, 0, 7)
        form_layout.addWidget(QLabel("czy zaległe"), 0, 8);
        form_layout.addWidget(overdue_combo, 0, 9)
        form_layout.addWidget(add_button, 0, 10)
        layout.addWidget(form_frame)

        def add_overtime():
            result = self.call_add_overtime_procedure_fixed(
                selected_user_id, selected_date.year(), selected_date.month(),
                selected_date.toString("yyyy-MM-dd"), time_combo.currentText(),
                float(hours_combo.currentData()), f"{year}-{month:02d}-01",
                overdue_combo.currentIndex(), type_combo.currentText(),
                ld_combo.currentText(), nr_kadrowy
            )
            if result["success"]:
                self.statusBar().showMessage("Pomyślnie dodano nadgodziny.", 3000)
                dialog.accept()
            else:
                QMessageBox.warning(dialog, "Błąd", result["message"], QMessageBox.Ok)

        add_button.clicked.connect(add_overtime)
        dialog.exec()

    def show_settings_dialog(self):
        """Pokazuje okno dialogowe ustawień aplikacji."""
        from settings_dialog import AppSettingsDialog

        dialog = AppSettingsDialog(self, settings=self.user_settings)
        dialog.live_theme_changed.connect(self.apply_theme_settings)
        # --- PODŁĄCZENIE NOWEGO SYGNAŁU ---
        dialog.import_requested.connect(self.on_import_requested)

        if dialog.exec() == QDialog.Accepted:
            # Ta część wykona się po kliknięciu "OK" lub "Importuj teraz"
            new_settings = dialog.get_current_settings()
            should_save = new_settings.pop('save_to_db', False)

            self.user_settings.update(new_settings)

            self.is_dark_theme = self.user_settings.get('theme') == 'dark'
            self.current_font = self.user_settings.get('font_family')
            self.current_font_size = self.user_settings.get('font_size')

            self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font,
                                      self.current_font_size)
            self.setup_table_properties()
            self.table.schedule_view.viewport().update()

            if should_save:
                self.settings_db.save_settings(self.user_settings)
                debug_print(f"Zapisano ustawienia z dialogu.")

    def on_import_requested(self, grupa, funkcja):
        """Obsługuje żądanie importu z okna ustawień."""
        debug_print(f"Otrzymano żądanie importu z ustawieniami: Grupa={grupa}, Funkcja={funkcja}")

        # Zaktualizuj atrybuty w głównym oknie
        self.import_grupa = grupa
        self.import_funkcja = funkcja

        # Wywołaj odświeżenie danych
        self.refresh_data()

    def _update_model_with_new_symbols(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje symbole bezpośrednio w modelu
        """
        try:
            if not updated_symbols or not hasattr(self, 'schedule_model'):
                return

            processed_data = self.schedule_model.get_processed_data()
            if not processed_data:
                return

            updated_count = 0
            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Znajdź klucz użytkownika w processed_data
                target_key = None
                for key in processed_data.keys():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        target_key = key
                        break

                if not target_key:
                    debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                    continue

                # Oblicz dzień z daty
                try:
                    year_str, month_str, day_str = date_str.split('-')
                    day = int(day_str)

                    if int(year_str) != year or int(month_str) != month:
                        continue

                except ValueError:
                    continue

                # Aktualizuj symbol w processed_data
                user_data = processed_data[target_key]
                days_data = user_data.setdefault('days', {})
                day_data = days_data.setdefault(day, {})

                old_symbol = day_data.get('symbol', '')
                day_data['symbol'] = new_symbol

                # Przelicz godziny na podstawie nowego symbolu
                from symbol_parser import parse_symbol
                parsed = parse_symbol(new_symbol)
                day_data['hours'] = parsed.get('work_hours', 0) or 0
                day_data['start_hour'] = parsed.get('start_hour')

                # Aktualizuj total_hours użytkownika
                old_hours = 0
                if old_symbol:
                    old_parsed = parse_symbol(old_symbol)
                    old_hours = old_parsed.get('work_hours', 0) or 0

                new_hours = day_data['hours']
                user_data['total_hours'] = (user_data.get('total_hours', 0) or 0) - old_hours + new_hours

                updated_count += 1
                debug_print(
                    f"Model: Zaktualizowano {user_id}/{day}: '{old_symbol}' -> '{new_symbol}' ({old_hours}h -> {new_hours}h)")

            debug_print(f"Zaktualizowano {updated_count} komórek w modelu")

        except Exception as e:
            log_error(f"Błąd aktualizacji modelu: {e}")

    def _update_data_provider_cache(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje cache w DataProvider
        """
        try:
            if not updated_symbols or not hasattr(self.data_provider, 'monthly_cache'):
                return

            month_key = (year, month)
            if month_key not in self.data_provider.monthly_cache:
                return

            container = self.data_provider.monthly_cache[month_key]

            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Aktualizuj processed_data w kontenerze
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):
                        try:
                            year_str, month_str, day_str = date_str.split('-')
                            day = int(day_str)

                            if int(year_str) == year and int(month_str) == month:
                                days_data = user_data.setdefault('days', {})
                                day_data = days_data.setdefault(day, {})
                                day_data['symbol'] = new_symbol

                                # Przelicz godziny
                                from symbol_parser import parse_symbol
                                parsed = parse_symbol(new_symbol)
                                day_data['hours'] = parsed.get('work_hours', 0) or 0
                                day_data['start_hour'] = parsed.get('start_hour')

                                debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")
                                break
                        except:
                            continue

        except Exception as e:
            log_error(f"Błąd aktualizacji DataProvider cache: {e}")

    def _force_full_refresh(self):
        """Fallback - pełne odświeżenie danych"""
        try:
            current_data = self.date_combo.currentData()
            if current_data:
                year, month = current_data
                self.data_provider.refresh_data(year, month)
                self.update_table_content()
        except Exception as e:
            log_error(f"Błąd pełnego odświeżenia: {e}")

    def _force_refresh_specific_cells(self, affected_pairs, year, month):
        """
        POPRAWIONA METODA: Wymusza odświeżenie konkretnych komórek w widoku
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycję komórki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajdź wiersz użytkownika w modelu
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnę dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymusza odświeżenie komórki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej komórki
                        self.schedule_model.dataChanged.emit(model_index, model_index,
                                                             [Qt.DisplayRole, Qt.BackgroundRole])

                        # Metoda 2: Wymuś update widoku dla tej komórki
                        self.table.schedule_view.update(model_index)

                        refreshed_cells += 1
                        debug_print(f"Odświeżono komórkę tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"Błąd odświeżania komórki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymuś całościowy update viewport jeśli zmieniono jakieś komórki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po odświeżeniu {refreshed_cells} komórek")

                # DODATKOWE: Wymuś też odświeżenie tabeli pracowników (dla sum RBH)
                if hasattr(self.table, 'employees_view'):
                    self.table.employees_view.viewport().update()

        except Exception as e:
            log_error(f"Błąd podczas wymuszania odświeżenia komórek tabeli: {e}")

    def _update_model_cells_directly(self, updated_symbols, year, month):
        """
        Aktualizuje symbole bezpośrednio w modelu i DataProvider

        Args:
            updated_symbols (dict): Słownik {(user_id, date_str): symbol}
            year (int): Rok
            month (int): Miesiąc
        """
        try:
            if not updated_symbols:
                return

            updated_count = 0

            # AKTUALIZACJA 1: Schedule Model processed_data
            if hasattr(self, 'schedule_model') and self.schedule_model:
                processed_data = self.schedule_model.get_processed_data()

                if processed_data:
                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        if self._update_single_cell_in_processed_data(processed_data, user_id, date_str, new_symbol,
                                                                      year, month):
                            updated_count += 1

            # AKTUALIZACJA 2: DataProvider cache (jeśli istnieje)
            if hasattr(self.data_provider, 'monthly_cache'):
                month_key = (year, month)
                if month_key in self.data_provider.monthly_cache:
                    container = self.data_provider.monthly_cache[month_key]

                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        self._update_single_cell_in_data_provider(container, user_id, date_str, new_symbol, year, month)

            debug_print(f"Zaktualizowano {updated_count} komórek w modelu")

        except Exception as e:
            log_error(f"Błąd bezpośredniej aktualizacji modelu: {e}")

    def _update_single_cell_in_processed_data(self, processed_data, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczą komórkę w processed_data

        Returns:
            bool: True jeśli zaktualizowano
        """
        try:
            # Znajdź klucz użytkownika
            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if not target_key:
                debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                return False

            # Oblicz dzień
            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)

            if int(year_str) != year or int(month_str) != month:
                return False

            # Aktualizuj symbol
            user_data = processed_data[target_key]
            days_data = user_data.setdefault('days', {})
            day_data = days_data.setdefault(day, {})

            old_symbol = day_data.get('symbol', '')
            day_data['symbol'] = new_symbol

            # Przelicz godziny i inne parametry
            from symbol_parser import parse_symbol
            parsed = parse_symbol(new_symbol)
            day_data['hours'] = parsed.get('work_hours', 0) or 0
            day_data['start_hour'] = parsed.get('start_hour')

            debug_print(f"Model: {user_id}/{day} '{old_symbol}' -> '{new_symbol}'")
            return True

        except Exception as e:
            log_error(f"Błąd aktualizacji komórki processed_data {user_id}/{date_str}: {e}")
            return False

    def _update_single_cell_in_data_provider(self, container, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczą komórkę w DataProvider cache
        """
        try:
            if not hasattr(container, 'processed_data') or not container.processed_data:
                return

            # Podobna logika jak dla processed_data w modelu
            processed_data = container.processed_data

            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if target_key:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)

                if int(year_str) == year and int(month_str) == month:
                    user_data = processed_data[target_key]
                    days_data = user_data.setdefault('days', {})
                    day_data = days_data.setdefault(day, {})
                    day_data['symbol'] = new_symbol

                    # Przelicz godziny
                    from symbol_parser import parse_symbol
                    parsed = parse_symbol(new_symbol)
                    day_data['hours'] = parsed.get('work_hours', 0) or 0
                    day_data['start_hour'] = parsed.get('start_hour')

                    debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")

        except Exception as e:
            log_error(f"Błąd aktualizacji DataProvider cache: {e}")

    def _force_refresh_table_cells(self, affected_pairs, year, month):
        """
        WYMUSZA odświeżenie konkretnych komórek w widoku tabeli

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
            year (int): Rok
            month (int): Miesiąc
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycję komórki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajdź wiersz użytkownika
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnę dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymuś odświeżenie komórki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej komórki
                        self.schedule_model.dataChanged.emit(model_index, model_index, [])

                        # Metoda 2: Wymuś update widoku (backup)
                        self.table.schedule_view.update(model_index)

                        # Metoda 3: Invalidate item (backup)
                        if hasattr(self.table.schedule_view, 'setDirtyRegion'):
                            rect = self.table.schedule_view.visualRect(model_index)
                            if not rect.isEmpty():
                                self.table.schedule_view.viewport().update(rect)

                        refreshed_cells += 1
                        debug_print(f"Odświeżono komórkę tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"Błąd odświeżania komórki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymuś całościowy update viewport jeśli zmieniono jakieś komórki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po odświeżeniu {refreshed_cells} komórek")

        except Exception as e:
            log_error(f"Błąd podczas wymuszania odświeżenia komórek tabeli: {e}")

    def _find_user_row_in_model(self, user_id):
        """
        POPRAWIONA METODA: Znajduje indeks wiersza dla danego użytkownika w modelu
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return -1

            # Pobierz klucze z modelu
            if hasattr(self.schedule_model, '_keys'):
                keys = self.schedule_model._keys
            else:
                return -1

            user_id_str = str(user_id)

            for row_index, key in enumerate(keys):
                if len(key) > 3 and str(key[3]) == user_id_str:
                    return row_index

            return -1

        except Exception as e:
            log_error(f"Błąd podczas szukania wiersza użytkownika {user_id}: {e}")
            return -1

    def _update_local_events_for_cells(self, affected_pairs):
        """
        Aktualizuje lokalny events_data tylko dla zmienionych komórek

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
        """
        try:
            if not hasattr(self, 'events_data'):
                return

            # Sprawdź czy jakieś z zmienionych komórek są obecnie zaznaczone
            if not hasattr(self, 'table'):
                return

            current_selection = self.table.get_data_for_selected_cells()
            selected_pairs = set()

            for cell_data in current_selection:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    selected_pairs.add((user_id, date_str))

            # Sprawdź czy któraś ze zmienionych komórek jest zaznaczona
            intersection = set(affected_pairs) & selected_pairs

            if intersection:
                debug_print(f"Zaktualizowano {len(intersection)} zmienionych komórek w events_data")
                # Jeśli tak, odśwież events_data tylko dla zaznaczonych komórek
                self.on_selection_changed()

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji lokalnych events: {e}")

    def _show_symbol_change_results(self, successful_updates: int, failed_updates: int, error_messages: list,
                                    events_to_cancel: list, skipped_employees: list):
        """
        Wyświetla uzytkownikowi podsumowanie operacji wstawiania symboli,
        uwzględniając komórki pominięte z powodu braku uprawnień.
        """
        title = ""
        full_message = ""

        # Komunikat o sukcesach
        if successful_updates > 0:
            full_message += f"Pomyślnie zaktualizowano {successful_updates} komórek."
            if events_to_cancel:
                full_message += f" i odwołano {len(events_to_cancel)} delegacji."
            full_message += "\n"

        # Komunikat o pominiętych z powodu braku uprawnień
        if skipped_employees:
            full_message += f"\nPominięto {len(skipped_employees)} komórek z powodu braku uprawnień dla:\n- {', '.join(set(skipped_employees))}\n"

        # Komunikat o błędach
        if failed_updates > 0:
            title = "Częściowy sukces" if successful_updates > 0 or skipped_employees else "Błąd aktualizacji"
            error_list_str = "\n - " + "\n - ".join(error_messages[:10])
            full_message += f"\nNie udało się zaktualizować {failed_updates} komórek z powodu błędów:{error_list_str}"
            if len(error_messages) > 10:
                full_message += f"\n... i {len(error_messages) - 10} więcej błędów."
        elif successful_updates > 0 or skipped_employees:
            title = "Zakończono operację"

        # Wyświetl komunikat tylko jeśli coś się wydarzyło
        if full_message:
            # Jeśli nie było błędów i pominięć, pokaż tylko info na pasku statusu
            if successful_updates > 0 and failed_updates == 0 and not skipped_employees:
                self.statusBar().showMessage(full_message.strip(), 4000)
            else:
                QMessageBox.information(self, title, full_message.strip())

    def _prepare_delegations_description(self, grouped_events, max_groups=10):
        """
        Przygotowuje opis delegacji do odwołania.

        Args:
            grouped_events: Słownik zdarzeń pogrupowanych według użytkownika i daty
            max_groups: Maksymalna liczba grup do wyświetlenia

        Returns:
            str: Opis delegacji do odwołania
        """
        delegations_info = ""

        if not grouped_events:
            return delegations_info

        delegations_info += "\nNastępujące delegacje zostaną automatycznie odwołane:\n"

        # Licznik dla ograniczenia liczby wyświetlanych grup
        group_count = 0

        for (user_id, date_str), events in grouped_events.items():
            # Ograniczenie liczby wyświetlanych grup
            if group_count >= max_groups:
                delegations_info += f"\n...oraz więcej zdarzeń dla innych użytkowników/dni ({len(grouped_events) - max_groups} więcej grup)...\n"
                break

            # Pobierz nazwę użytkownika z pierwszego zdarzenia
            user_name = events[0].get('user_name', f"ID: {user_id}")

            # Przygotuj datę w ładniejszym formacie (DD.MM.YYYY)
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            delegations_info += f"   👤 {user_name} - 📅 {formatted_date}:\n"

            # Wyświetl zdarzenia dla tego użytkownika i daty
            for i, event in enumerate(events):
                delegations_info += f"      {i + 1}. {event['type']}: {event['name']}\n"

            group_count += 1

        return delegations_info

    def filter_processed_data(self):
        """Filtruje przetworzone dane na podstawie wszystkich filtrów."""
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return {}

        # --- Krok 1: Pobranie stanu wszystkich filtrów ---
        show_only_at_work = self.filter_by_presence_check.isChecked()

        selected_wydzialy = set(self.wydzial_combo.get_selected_items())
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)
        selected_dtn = self.dtn_combo.get_selected_items()
        selected_role = self.rola_combo.get_selected_items()
        selected_jezyki = self.jezyk_combo.get_selected_items()
        selected_etaty = self.etat_combo.get_selected_items()
        selected_scp = self.system_czasu_pracy_combo.get_selected_items()
        selected_grupy = self.grupa_main_filter_combo.get_selected_items()
        selected_locations_default = self.default_location_combo.get_selected_items()

        allowed_depts_from_groups = set()
        if selected_grupy:
            group_mapping = app_settings.get_group_mapping()
            for group_name in selected_grupy:
                allowed_depts_from_groups.update(group_mapping.get(group_name, set()))
            if selected_wydzialy:
                selected_wydzialy = selected_wydzialy.intersection(allowed_depts_from_groups)
            else:
                selected_wydzialy = allowed_depts_from_groups

        # --- Krok 2: Iteracja i filtrowanie danych ---
        filtered_data = {}
        for key, data in self.processed_data.items():
            # Najpierw standardowe filtry
            passes_standard_filters = (
                    (not selected_locations_default or data.get(
                        'lokalizacja_domyslna') in selected_locations_default) and
                    (not selected_wydzialy or key[0] in selected_wydzialy) and
                    (not selected_przelozeni or key[1] in selected_przelozeni) and
                    (not selected_uzytkownicy or str(key[2]) in selected_uzytkownicy) and
                    (not selected_dtn or str(data.get('dtn', '')) in selected_dtn) and
                    (not selected_role or data.get('rola_nazwa', '') in selected_role) and
                    (not selected_jezyki or data.get('jezyk', '') in selected_jezyki) and
                    (not selected_etaty or str(data.get('etat', '')) in selected_etaty) and
                    (not selected_scp or data.get('system_czasu_pracy', '') in selected_scp)
            )
            if not passes_standard_filters:
                continue

            # Następnie zaawansowany filtr obecności
            if show_only_at_work:
                # --- NOWA LOGIKA: Wyklucz osoby z DTN=1 z tego filtra ---
                if data.get('dtn') == 1:
                    continue
                # --- KONIEC NOWEJ LOGIKI ---

                selected_date = self.presence_date_edit.date()
                selected_hours_str = self.presence_hour_combo.get_selected_items()
                selected_hours = {int(h.split(':')[0]) for h in selected_hours_str}

                day_to_check = selected_date.day()
                day_data = data.get('days', {}).get(day_to_check, {})
                symbol = day_data.get('symbol', '')
                parsed = parse_symbol(symbol)

                is_working_today = False
                special_symbol = parsed.get('special_symbol')
                if symbol and (not special_symbol or special_symbol in app_settings.WORK_LIKE_SYMBOLS):
                    is_working_today = True

                user_id = key[3]
                date_str = selected_date.toString("yyyy-MM-dd")
                user_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                overtime_events = [e for e in user_events if e.get('type') == 'Nadgodziny']

                if not is_working_today and overtime_events:
                    is_working_today = True

                if not is_working_today:
                    continue

                if selected_hours:
                    is_working_at_hour = False
                    start_hour, work_hours = parsed.get('start_hour'), parsed.get('work_hours')
                    if start_hour is not None and work_hours is not None:
                        shift_hours = {(start_hour + h) % 24 for h in range(int(work_hours))}
                        if not shift_hours.isdisjoint(selected_hours):
                            is_working_at_hour = True

                    if not is_working_at_hour and overtime_events:
                        for event in overtime_events:
                            try:
                                t_from = datetime.strptime(event['time_from'], '%Y-%m-%d %H:%M')
                                t_to = datetime.strptime(event['time_to'], '%Y-%m-%d %H:%M')
                                if t_to <= t_from: t_to += timedelta(days=1)

                                event_hours = set()
                                current_time = t_from
                                while current_time < t_to:
                                    event_hours.add(current_time.hour)
                                    current_time += timedelta(hours=1)

                                if not event_hours.isdisjoint(selected_hours):
                                    is_working_at_hour = True
                                    break
                            except:
                                continue

                    if not is_working_at_hour:
                        continue

                selected_locations_text = self.presence_location_combo.get_selected_items()
                if selected_locations_text:
                    location_map = {"Home Office (h)": "h", "SBC (s)": "s", "Przystanek (p)": "p",
                                    "Bez lokalizacji": "none"}
                    selected_locations = {location_map.get(text) for text in selected_locations_text}

                    shift_location = parsed.get('location') or data.get('lokalizacja_domyslna') or "none"
                    if shift_location not in selected_locations:
                        continue

            filtered_data[key] = data

        return filtered_data

    def _cancel_delegations(self, events_to_cancel_input: List[Dict]):
        debug_print(f"Rozpoczynam _cancel_delegations dla {len(events_to_cancel_input)} zdarzeń.")
        if not events_to_cancel_input:
            return 0

        successful_db_updates = 0
        # Lista par (user_id, date_key) dla zdarzeń, które zostały pomyślnie zaktualizowane w DB
        affected_user_date_pairs_for_refresh = set()

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            _, user_app_id, _, _, _ = get_modifier_id()

            for event_details in events_to_cancel_input:
                event_id = event_details.get('id')
                event_type = event_details.get('type')
                user_id_for_event = event_details.get('user_id')  # Użyj user_id z event_details
                date_key_for_event = event_details.get('date_key', event_details.get('date'))

                if not event_id or not event_type or not user_id_for_event or not date_key_for_event:
                    log_warning(f"Pominięto zdarzenie z niepełnymi danymi w _cancel_delegations: {event_details}")
                    continue

                table_name = ""
                if event_type == "Spotkanie":
                    table_name = SQL_OBJECTS['spotkania']
                elif event_type == "Szkolenie":
                    table_name = SQL_OBJECTS['szkolenia']
                elif event_type == "Nadgodziny":
                    table_name = SQL_OBJECTS['nadgodziny']

                if not table_name:
                    log_warning(f"Nieznany typ zdarzenia w _cancel_delegations: {event_type}")
                    continue

                try:
                    if event_type in ["Spotkanie", "Szkolenie"]:
                        update_query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                        cursor.execute(update_query, (user_app_id, event_id))
                    else:  # Nadgodziny
                        delete_query = f"DELETE FROM {table_name} WHERE Id = ?"
                        cursor.execute(delete_query, (event_id,))

                    if cursor.rowcount > 0:
                        successful_db_updates += 1
                        affected_user_date_pairs_for_refresh.add((user_id_for_event, date_key_for_event))
                        debug_print(f"DB: Pomyślnie zaktualizowano/usunięto {event_type} ID {event_id}")
                    else:
                        log_warning(f"DB: Nie znaleziono {event_type} ID {event_id} do aktualizacji/usunięcia.")

                except Exception as db_err:
                    log_error(f"Błąd DB podczas odwoływania {event_type} ID {event_id}: {db_err}", exception=db_err)

            if successful_db_updates > 0:
                conn.commit()
                debug_print(f"DB: Zatwierdzono {successful_db_updates} zmian.")
                # Rejestrujemy, że to my dokonaliśmy zmiany w bazie danych
                self._update_modification_date()
            conn.close()

        except Exception as e:
            log_error(f"Generalny błąd w _cancel_delegations podczas operacji DB: {e}", exception=e)
            return 0  # Zwróć 0 jeśli wystąpił błąd przed aktualizacją UI

        # Jeśli były jakiekolwiek udane aktualizacje w DB
        if affected_user_date_pairs_for_refresh:
            debug_print(
                f"_cancel_delegations: Uruchamiam odświeżanie DataProvider dla {len(affected_user_date_pairs_for_refresh)} par.")
            # Krok 1: Unieważnij i odśwież cache DataProvider dla dotkniętych zdarzeń/miesięcy
            self.data_provider.invalidate_complete_cache_for_pairs(list(affected_user_date_pairs_for_refresh))

            # Krok 2: Odśwież tabelę zdarzeń - on_selection_changed użyje świeżych danych z DataProvider
            # Ta metoda zaktualizuje self.events_data i self.events_model
            debug_print(f"_cancel_delegations: Uruchamiam on_selection_changed() w celu odświeżenia tabeli zdarzeń.")
            selected_cells_data = self.table.get_data_for_selected_cells()  # Pobierz aktualnie zaznaczone komórki
            if selected_cells_data:
                self.on_selection_changed()  # To powinno teraz poprawnie wyczyścić zdarzenia
            else:  # Jeśli nic nie jest zaznaczone, wyczyść tabelę zdarzeń ręcznie
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])
                debug_print("_cancel_delegations: Brak zaznaczenia, wyczyszczono tabelę zdarzeń.")

            # Krok 3: Zaktualizuj ikony w tabeli grafiku na podstawie świeżych danych z DataProvider
            if hasattr(self, 'schedule_model'):
                debug_print(
                    f"_cancel_delegations: Uruchamiam aktualizację ikon grafiku dla {len(affected_user_date_pairs_for_refresh)} par.")
                for user_id, date_str in affected_user_date_pairs_for_refresh:
                    # Pobierz aktualne aktywne zdarzenia dla tej komórki z DataProvider
                    # DataProvider powinien teraz mieć świeże dane po invalidate_complete_cache_for_pairs
                    remaining_active_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                    has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_active_events)
                    has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_active_events)
                    has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_active_events)

                    self.schedule_model.update_cell_icons_directly(
                        user_id, date_str, has_meetings, has_trainings, has_overtime
                    )

            # Wymuś odświeżenie widoków tabel, jeśli to konieczne
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        debug_print(f"_cancel_delegations: Zakończono, pomyślnie przetworzono w DB: {successful_db_updates} zdarzeń.")
        return successful_db_updates

    def update_filter_dates(self):
        """Aktualizuje daty filtrowania do pierwszego i ostatniego dnia wybranego miesiąca"""
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # KLUCZOWA POPRAWKA: Blokuj sygnały przed zmianą dat
        self.date_from.blockSignals(True)
        self.date_to.blockSignals(True)

        try:
            # Pierwszy dzień miesiąca
            first_day = QDate(year, month, 1)
            self.date_from.setDate(first_day)

            # Ostatni dzień miesiąca
            if month == 12:
                next_month = QDate(year + 1, 1, 1)
            else:
                next_month = QDate(year, month + 1, 1)

            last_day = next_month.addDays(-1)
            self.date_to.setDate(last_day)

        finally:
            # ZAWSZE odblokuj sygnały
            self.date_from.blockSignals(False)
            self.date_to.blockSignals(False)

        # Wywołaj filtrowanie tylko RAZ po wszystkich zmianach
        self.filter_events_table()

    def update_data(self, year, month, grupa, funkcja, use_async=True, filters_to_restore=None):
        """
        NOWA WERSJA: Ładowanie danych z opcją przekazania stanu filtrów do przywrócenia.
        """
        debug_print(f"Rozpoczynam ładowanie danych dla {year}-{month} (async={use_async})")

        self.year = year
        self.month = month

        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            self.schedule_model = ScheduleTableModel(self)
            self.schedule_model.set_theme(self.is_dark_theme)
            ui_columns = self.column_definitions.get_ui_display_columns()
            visible_cols = self.visible_columns
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

        if not hasattr(self, 'events_model') or not self.events_model:
            self.events_model = EventsTableModel(self)
            self.events_model.set_theme(self.is_dark_theme)

        if use_async:
            self._load_data_async(year, month, filters_to_restore=filters_to_restore)
        else:
            self._load_data_sync(year, month, filters_to_restore=filters_to_restore)

    def _load_data_sync(self, year, month):
        """
        Synchroniczne ładowanie danych (fallback), teraz spójne z logiką asynchroniczną.
        """
        debug_print(f"Ładowanie synchroniczne dla {year}-{month}")

        try:
            if hasattr(self, 'statusBar'):
                self.statusBar().showMessage(f"Ładowanie danych {year}-{month}...")

            # Krok 1: Pobierz kontener z danymi bazowymi
            container = self.data_provider._get_or_load_monthly_data(
                year, month, self.import_grupa, self.import_funkcja, use_cache=False
            )

            if container:
                # Krok 2: Pobierz przetworzone dane z nałożonymi ikonami
                processed_data_with_icons = self.data_provider.get_processed_data(
                    year, month, self.import_grupa, self.import_funkcja
                )

                # Krok 3: Zastosuj wszystkie dane
                self._apply_loaded_data({
                    'schedule_data': container.schedule_data,
                    'events_data': container.events_data,
                    'processed_data': processed_data_with_icons,  # Używamy danych z ikonami
                    'year': year,
                    'month': month
                })
            else:
                log_error("Nie udało się pobrać danych z DataProvider w trybie synchronicznym.")

        except Exception as e:
            log_error(f"Błąd podczas synchronicznego ładowania: {e}", exception=e)

        finally:
            if hasattr(self, 'statusBar'):
                self.statusBar().clearMessage()

    def _load_data_async(self, year, month, filters_to_restore=None):
        """Asynchroniczne ładowanie danych z progress dialogiem."""
        from progress_dialog import LoadingProgressDialog
        from functools import partial

        debug_print(f"Uruchamiam async ładowanie dla {year}-{month}")
        self.loading_dialog = LoadingProgressDialog(
            self, self.data_provider, year, month, self.import_grupa, self.import_funkcja
        )
        self.loading_dialog.loading_completed.connect(
            partial(self._on_async_data_loaded, filters_to_restore=filters_to_restore))
        self.loading_dialog.loading_cancelled.connect(self._on_async_loading_cancelled)
        self.loading_dialog.loading_failed.connect(self._on_async_loading_failed)
        self.loading_dialog.exec()
        if hasattr(self, 'loading_dialog'):
            self.loading_dialog.deleteLater()
            delattr(self, 'loading_dialog')

    def _on_async_data_loaded(self, data, filters_to_restore=None):
        """Obsługuje pomyślne załadowanie danych async."""
        debug_print("Otrzymano dane z async loading")
        try:
            is_initial_load = self.schedule_model.rowCount() == 0

            # Zapisz stan widoku (sortowanie i zaznaczenie) przed resetem modelu
            view_state = self._save_view_state()

            self._apply_loaded_data(data, filters_to_restore=filters_to_restore)

            # Zawsze przywracaj stan widoku, chyba że jest to pierwsze ładowanie
            if not is_initial_load:
                self._restore_view_state(view_state)

            debug_print("Pomyślnie zastosowano dane z async loading")
        except Exception as e:
            log_error(f"Błąd podczas stosowania załadowanych danych: {e}")

    def _on_async_loading_cancelled(self):
        """Obsługuje anulowanie ładowania."""
        debug_print("Async loading został anulowany przez użytkownika")

    def _on_async_loading_failed(self, error_message):
        """Obsługuje błędy async loading."""
        debug_print(f"Async loading failed: {error_message}")
        QMessageBox.critical(self, "Błąd ładowania danych", f"Nie udało się załadować danych:\\n{error_message}\\n\\nSpróbuj ponownie lub skontaktuj się z administratorem.", QMessageBox.Ok)
        try:
            debug_print("Próbuję fallback do synchronicznego ładowania")
            self._load_data_sync(self.year, self.month)
        except Exception as e:
            log_error(f"Fallback loading też nie powiódł się: {e}")

    def _apply_loaded_data(self, data, filters_to_restore=None):
        """Aplikuje nowo załadowane dane do modeli i UI."""
        if data is None:
            log_error("Błąd: _apply_loaded_data otrzymało puste dane (None).")
            return

        schedule_data = data.get('schedule_data', [])
        events_data = data.get('events_data', [])
        processed_data = data.get('processed_data', {})
        year = data.get('year')
        month = data.get('month')

        if not all([processed_data, year, month]):
            log_error(f"Niekompletne dane przekazane do _apply_loaded_data: rok={year}, miesiac={month}")
            return

        self.raw_data = schedule_data
        self.all_events_data = events_data
        self.processed_data = processed_data

        is_initial_load = self.schedule_model.rowCount() == 0
        self.schedule_model.update_data(self.processed_data, year, month)

        self.events_data = []
        if hasattr(self, 'events_model'):
            self.events_model.update_data([])
        self.all_events_data = data.get('events_data', [])

        if hasattr(self, 'status_filter_combo'):
            all_statuses = sorted(list(set(e.get('status', '') for e in self.all_events_data if e.get('status'))))
            self.status_filter_combo.add_items(all_statuses)
            self.status_filter_combo.select_items(all_statuses)

        # NOWA LOGIKA:
        # Jeśli przekazano stan filtrów (co dzieje się przy odświeżaniu), użyj go.
        if filters_to_restore:
            self.restore_filters_state(filters_to_restore)
        else:
            # W przeciwnym razie (przy pierwszym ładowaniu) użyj filtrów zapisanych w bazie.
            last_filters = self.user_settings.get('last_filters')
            if last_filters:
                self.restore_filters_state(last_filters)
            else:
                self.update_filters()
                self.filter_data()

        if is_initial_load:
            self.apply_custom_sort()

        self._apply_dynamic_sizes()
        self.setup_events_table_columns()

    def apply_default_sort(self):
        """
        Ręcznie sortuje dane w modelu zgodnie z domyślną, wielopoziomową
        kolejnością i wymusza odświeżenie widoku.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model._processed_data:
            return

        debug_print("Aplikowanie domyślnego, wielopoziomowego sortowania...")

        # Pobieramy klucze i pełne dane do sortowania
        keys_to_sort = self.schedule_model._keys
        processed_data = self.schedule_model._processed_data

        # Sortujemy klucze według docelowej kolejności
        sorted_keys = sorted(keys_to_sort, key=lambda k: (
            processed_data[k].get('dtn', 0),  # 1. Po DTN
            k[0] or '',  # 2. Po Wydziale
            k[1] or '',  # 3. Po Przełożonym
            k[2] or ''  # 4. Po Użytkowniku
        ))

        # Ustawiamy nową, posortowaną listę kluczy w modelu
        self.schedule_model._keys = sorted_keys

        # Informujemy widok, że układ modelu uległ całkowitej zmianie
        self.schedule_model.layoutChanged.emit()
        debug_print("Zakończono domyślne sortowanie. Widok został odświeżony.")

    def clear_events_cache(self, year, month):
        """
        Czyści cache zdarzeń dla danego miesiąca - UPROSZCZONA WERSJA

        Args:
            year: Rok
            month: Miesiąc
        """
        # POPRAWKA: Deleguj TYLKO do DataProvider, bez dodatkowych akcji
        if hasattr(self.data_provider, 'invalidate_icons_cache'):
            self.data_provider.invalidate_icons_cache(year, month)
            debug_print(f"Wyczyszczono cache zdarzeń dla {year}-{month}")
        else:
            debug_print(f"DataProvider nie ma metody invalidate_icons_cache")

    def get_events_for_user_date(self, user_id, date_str):
        """
        UPROSZCZONA METODA: Deleguje do DataProvider
        """
        return self.data_provider.get_events_for_user_date(user_id, date_str)

    def refresh_column_configuration(self):
        """Odświeża konfigurację kolumn z ColumnDefinitions"""
        # ZMODYFIKOWANE: Używaj self.column_definitions zamiast column_manager
        # Pobierz zaktualizowane dane kolumn
        ui_columns = self.column_definitions.get_ui_display_columns()
        visible_cols = self.visible_columns

        # Aktualizuj referencje w głównej klasie
        self.employee_columns = ui_columns

        # Aktualizuj model
        if hasattr(self, 'schedule_model') and self.schedule_model:
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

            # Jeśli tabela już istnieje, zaktualizuj widok
            if hasattr(self, 'table') and self.table:
                self.table.set_model(self.schedule_model)
                # Dostosuj szerokość tabeli pracowników
                self.table.adjust_employees_table_width()

    def setup_event_table_columns(self):
        """
        Konfiguruje szerokości kolumn tabeli zdarzeń.
        Wyodrębnione z metody update_data dla lepszej czytelności.
        """
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Użytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

    def show_loading_indicator(self, message="Ładowanie..."):
        """
        Pokazuje wskaźnik ładowania w UI
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().showMessage(message)

        # Wyłącz niektóre kontrolki podczas ładowania
        self.date_combo.setEnabled(False)
        self.refresh_button.setEnabled(False)

        if hasattr(self, 'left_panel_visible') and self.left_panel_visible:
            self._left_panel.setEnabled(False)

    def hide_loading_indicator(self):
        """
        Ukrywa wskaźnik ładowania
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().clearMessage()

        # Włącz z powrotem kontrolki
        self.date_combo.setEnabled(True)
        self.refresh_button.setEnabled(True)

        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(True)

    def get_loading_preferences(self):
        """
        Zwraca preferencje użytkownika dotyczące ładowania
        """
        # Można dodać ustawienia w settings_db dla kontroli async loading
        # Na razie zawsze async dla dużych zbiorów danych
        return {
            'use_async_threshold': 1000,  # Użyj async dla >1000 wierszy
            'show_progress_dialog': True,
            'auto_fallback_to_sync': True
        }




    def update_cross_filters(self):
        """
        Aktualizuje filtry wzajemnie, ale zamiast przebudowywać listy,
        jedynie ukrywa/pokazuje istniejące elementy, aby zachować pozycję przewijania.
        """
        if not getattr(self, '_cross_filtering_enabled', True):
            return

        if not hasattr(self, 'processed_data') or not self.processed_data:
            return

        if getattr(self, '_updating_cross_filters', False):
            return

        self._updating_cross_filters = True
        try:
            # Pobranie aktualnych wyborów (logika bez zmian)
            selected_wydzialy = self.wydzial_combo.get_selected_items()
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

            # === AKTUALIZACJA LISTY PRZEŁOŻONYCH ===
            if hasattr(self, 'przelozony_list'):
                # Oblicz, którzy przełożeni powinni być widoczni (logika bez zmian)
                available_przelozeni = set()
                if selected_wydzialy:
                    for key in self.processed_data.keys():
                        if key[0] in selected_wydzialy and key[1]:
                            available_przelozeni.add(key[1])
                else:
                    for key in self.processed_data.keys():
                        if key[1]: available_przelozeni.add(key[1])

                # NOWA LOGIKA: Pokaż/ukryj elementy zamiast przebudowywać listę
                for i in range(self.przelozony_list.count()):
                    item = self.przelozony_list.item(i)
                    item.setHidden(item.text() not in available_przelozeni)

            # === AKTUALIZACJA LISTY UŻYTKOWNIKÓW ===
            if hasattr(self, 'uzytkownik_list'):
                # Oblicz, którzy użytkownicy powinni być widoczni (logika bez zmian)
                available_uzytkownicy = set()
                for key in self.processed_data.keys():
                    wydzial, przelozony, uzytkownik_dane, _ = key
                    if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                            (not selected_przelozeni or przelozony in selected_przelozeni):
                        if uzytkownik_dane: available_uzytkownicy.add(str(uzytkownik_dane))

                # NOWA LOGIKA: Pokaż/ukryj elementy zamiast przebudowywać listę
                for i in range(self.uzytkownik_list.count()):
                    item = self.uzytkownik_list.item(i)
                    item.setHidden(item.text() not in available_uzytkownicy)

        except Exception as e:
            log_error(f"Błąd podczas cross-filtrowania: {e}", exception=e)
        finally:
            self._updating_cross_filters = False

    def update_list_safely(self, list_widget, items, selected_items):
        """
        Bezpiecznie aktualizuje QListWidget, blokując sygnały na czas modyfikacji.
        """
        if not list_widget:
            return

        list_widget.blockSignals(True)
        try:
            # Zapamiętanie, co jest aktualnie widoczne z pola wyszukiwania
            search_text = ""
            if list_widget is self.przelozony_list:
                search_text = self.przelozony_filter.text().lower()
            elif list_widget is self.uzytkownik_list:
                search_text = self.uzytkownik_filter.text().lower()

            list_widget.clear()
            for item_text in sorted(items):
                item = QListWidgetItem(item_text)
                list_widget.addItem(item)
                if item_text in selected_items:
                    item.setSelected(True)

                # Przywrócenie ukrycia na podstawie filtra wyszukiwania
                if search_text and search_text not in item_text.lower():
                    item.setHidden(True)

        finally:
            list_widget.blockSignals(False)

    def get_current_filters_state(self):
        """Zapisuje aktualnie wybrane wartości ze wszystkich ISTNIEJĄCYCH filtrów do słownika."""
        state = {
            'grupa': self.grupa_main_filter_combo.currentText(),
            'wydzial': self.wydzial_combo.get_selected_items(),
            'przelozony': self.get_list_selected_items(self.przelozony_list),
            'uzytkownik': self.get_list_selected_items(self.uzytkownik_list),
            'lokalizacja_domyslna': self.default_location_combo.get_selected_items(),
            'system_czasu_pracy': self.system_czasu_pracy_combo.get_selected_items(),
            'rola': self.rola_combo.get_selected_items(),
            'jezyk': self.jezyk_combo.get_selected_items(),
            'etat': self.etat_combo.get_selected_items(),
            'dtn': self.dtn_combo.get_selected_items(),
        }
        debug_print(f"Zapisano stan filtrów: {state}")
        return state

    def restore_filters_state(self, state):
        """
        Przywraca zapisany stan filtrów po załadowaniu nowych danych.
        """
        debug_print("Rozpoczynam przywracanie stanu filtrów...")

        self._cross_filtering_enabled = False

        try:
            self.update_filters()

            self.grupa_main_filter_combo.blockSignals(True)
            self.grupa_main_filter_combo.setCurrentText(state.get('grupa', '(Wszyscy)'))
            self.grupa_main_filter_combo.blockSignals(False)

            self.wydzial_combo.select_items(state.get('wydzial', []))
            self.default_location_combo.select_items(state.get('lokalizacja_domyslna', []))
            self.system_czasu_pracy_combo.select_items(state.get('system_czasu_pracy', []))
            self.rola_combo.select_items(state.get('rola', []))
            self.jezyk_combo.select_items(state.get('jezyk', []))
            self.etat_combo.select_items(state.get('etat', []))
            self.dtn_combo.select_items(state.get('dtn', []))

            przelozeni_items = self._get_unique_values_for_filter('przelozony')
            uzytkownicy_items = self._get_unique_values_for_filter('uzytkownik_dane')
            self.update_list_safely(self.przelozony_list, przelozeni_items, state.get('przelozony', []))
            self.update_list_safely(self.uzytkownik_list, uzytkownicy_items, state.get('uzytkownik', []))

        finally:
            self._cross_filtering_enabled = True
            debug_print("Zakończono przywracanie stanu filtrów.")

        debug_print("Uruchamiam filtrowanie po przywróceniu stanu.")
        self.filter_data()

    def _get_unique_values_for_filter(self, filter_key):
        """
        Pobiera unikalne wartości dla danego filtra z aktualnie załadowanych,
        pełnych danych w self.processed_data.
        """
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return set()

        unique_values = set()

        key_map = {
            'wydzial': 0,
            'przelozony': 1,
            'uzytkownik_dane': 2
        }

        if filter_key in key_map:
            key_index = key_map[filter_key]
            for key_tuple in self.processed_data.keys():
                if len(key_tuple) > key_index and key_tuple[key_index]:
                    unique_values.add(str(key_tuple[key_index]))
        else:
            for data_dict in self.processed_data.values():
                value = data_dict.get(filter_key)
                # --- POPRAWIONY WARUNEK ---
                # Sprawdzamy, czy wartość nie jest None, co poprawnie uwzględni zero.
                if value is not None and value != '':
                    unique_values.add(str(value))

        return unique_values

    def clear_filters(self):
        """Czyści wszystkie filtry i aktualizuje model."""
        self._cross_filtering_enabled = False
        try:
            combo_names_to_clear = [
                'grupa_main_filter_combo', 'wydzial_combo', 'dtn_combo',
                'rola_combo', 'jezyk_combo', 'etat_combo',
                'system_czasu_pracy_combo',
                'default_location_combo'
            ]
            for combo_name in combo_names_to_clear:
                if hasattr(self, combo_name):
                    getattr(self, combo_name).clear_selection()

            if hasattr(self, 'przelozony_list'): self.przelozony_list.clearSelection()
            if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.clearSelection()
            if hasattr(self, 'przelozony_filter'): self.przelozony_filter.clear()
            if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.clear()

            # Czyszczenie filtra obecności
            if hasattr(self, 'filter_by_presence_check'):
                self.filter_by_presence_check.setChecked(False)
            if hasattr(self, 'presence_location_combo'):
                self.presence_location_combo.clear_selection()
            # ZMIANA: Użycie metody `clear_selection` dla nowego filtra
            if hasattr(self, 'presence_hour_combo'):
                self.presence_hour_combo.clear_selection()

        finally:
            self._cross_filtering_enabled = True
            # Wywołanie filtrowania po wyczyszczeniu wszystkich kontrolek
            self.filter_data()

    def filter_przelozony_list(self, text):
        """
        Filtruje listę przełożonych na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'przelozony_list'):
            return

        text = text.lower()
        for i in range(self.przelozony_list.count()):
            item = self.przelozony_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_uzytkownik_list(self, text):
        """
        Filtruje listę użytkowników na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'uzytkownik_list'):
            return

        text = text.lower()
        for i in range(self.uzytkownik_list.count()):
            item = self.uzytkownik_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def update_filtered_table(self):
        """
        Aktualizuje widok tabeli na podstawie zaznaczonych filtrów
        """
        # Bezpośrednio aktualizuj całą tabelę z przefiltrowanymi danymi
        self.update_table_content()

    def get_list_selected_items(self, list_widget):
        """
        Zwraca teksty zaznaczonych elementów z listy.
        POPRAWKA: Zmieniono nazwę metody z get_selected_items na get_list_selected_items,
        aby uniknąć konfliktu z metodą get_selected_items w CustomMultiComboBox.

        Args:
            list_widget: QListWidget do pobrania zaznaczonych elementów

        Returns:
            list: Lista zaznaczonych tekstów
        """
        if not list_widget:
            return []

        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item and item.isSelected():
                selected.append(item.text())
        return selected

    def update_filters(self):
        """
        Wypełnia wszystkie filtry na podstawie załadowanych danych.
        WERSJA POPRAWIONA: Zawiera kompletną logikę dla wszystkich filtrów.
        """
        try:
            if not hasattr(self, 'processed_data') or not self.processed_data:
                debug_print("Brak danych do wypełnienia filtrów, pomijam.")
                return

            debug_print("Rozpoczynam pełną aktualizację filtrów...")

            # Zapamiętanie bieżących wyborów, aby je przywrócić po odświeżeniu list
            selected_grupy = self.grupa_main_filter_combo.get_selected_items()
            selected_wydzialy = self.wydzial_combo.get_selected_items()
            selected_dtn = self.dtn_combo.get_selected_items()
            selected_role = self.rola_combo.get_selected_items()
            selected_jezyki = self.jezyk_combo.get_selected_items()
            selected_etaty = self.etat_combo.get_selected_items()
            selected_scp = self.system_czasu_pracy_combo.get_selected_items()
            selected_locations = self.default_location_combo.get_selected_items()

            # Filtr "Grupa"
            group_mapping = self.data_provider.get_department_to_group_mapping()
            self.grupa_main_filter_combo.add_items(sorted(group_mapping.keys()))
            self.grupa_main_filter_combo.select_items(selected_grupy)

            # Filtr "Wydział"
            wydzialy = sorted(set(key[0] for key in self.processed_data.keys() if key[0]))
            self.wydzial_combo.add_items(wydzialy)
            self.wydzial_combo.select_items(selected_wydzialy)

            # Filtr "Lokalizacja Domyślna"
            locations = sorted(set(data.get('lokalizacja_domyslna', '') for data in self.processed_data.values() if
                                   data.get('lokalizacja_domyslna')))
            self.default_location_combo.add_items(locations)
            self.default_location_combo.select_items(selected_locations)

            # Filtr "System Pracy"
            scp_values = sorted(set(data.get('system_czasu_pracy', '') for data in self.processed_data.values() if
                                    data.get('system_czasu_pracy', '')))
            self.system_czasu_pracy_combo.add_items(scp_values)
            self.system_czasu_pracy_combo.select_items(selected_scp)

            # Filtr "Rola"
            role_values = sorted(
                set(data.get('rola_nazwa', '') for data in self.processed_data.values() if data.get('rola_nazwa', '')))
            self.rola_combo.add_items(role_values)
            self.rola_combo.select_items(selected_role)

            # Filtr "Język"
            jezyki_values = sorted(
                set(data.get('jezyk', '') for data in self.processed_data.values() if data.get('jezyk', '')))
            self.jezyk_combo.add_items(jezyki_values)
            self.jezyk_combo.select_items(selected_jezyki)

            # Filtr "Etat"
            etaty_values = set(str(data.get('etat', '')) for data in self.processed_data.values() if
                               data.get('etat') is not None and str(data.get('etat', '')))
            sorted_etaty = sorted(etaty_values, key=lambda x: float(x) if x.replace('.', '', 1).isdigit() else 0)
            self.etat_combo.add_items(sorted_etaty)
            self.etat_combo.select_items(selected_etaty)

            # Filtr "DTN"
            dtn_values = sorted(set(str(data['dtn']) for data in self.processed_data.values() if data.get('dtn') is not None), key=int)
            self.dtn_combo.add_items(dtn_values)
            self.dtn_combo.select_items(selected_dtn)

            # Aktualizacja list dynamicznych (Przełożony, Użytkownik)
            self.update_przelozony_filter()
            self.update_uzytkownik_filter()

            debug_print("Zakończono pełną aktualizację wszystkich filtrów.")

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji filtrów: {e}", exception=e)

    def update_przelozony_filter(self, selected_przelozeni=None):
        """
        Aktualizuje listę przełożonych na podstawie wybranych wydziałów.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_przelozeni: Lista zaznaczonych przełożonych (opcjonalnie)
        """
        if not hasattr(self, 'przelozony_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiętaj bieżącą selekcję jeśli nie podano
        if selected_przelozeni is None:
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)

        self.przelozony_list.clear()

        # Pobierz wybrane wydziały
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []

        # Zbiór unikalnych przełożonych
        przelozeni = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, _, _ = key

            # Jeśli nie wybrano wydziałów lub wydział pasuje do filtra
            if not selected_wydzialy or wydzial in selected_wydzialy:
                # Dodaj przełożonego do zbioru (tylko niepuste wartości)
                if przelozony:
                    przelozeni.add(przelozony)

        # Dodaj posortowanych przełożonych do listy
        for przelozony in sorted(przelozeni):
            item = QListWidgetItem(przelozony)
            self.przelozony_list.addItem(item)

            # Przywróć zaznaczenie jeśli było
            if przelozony in selected_przelozeni:
                item.setSelected(True)

    def update_uzytkownik_filter(self, selected_uzytkownicy=None):
        """
        Aktualizuje listę użytkowników na podstawie wybranych wydziałów i przełożonych.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_uzytkownicy: Lista zaznaczonych użytkowników (opcjonalnie)
        """
        if not hasattr(self, 'uzytkownik_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiętaj bieżącą selekcję jeśli nie podano
        if selected_uzytkownicy is None:
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

        self.uzytkownik_list.clear()

        # Pobierz wybrane wydziały i przełożonych
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self,
                                                                                            'przelozony_list') else []

        # Zbiór unikalnych użytkowników (użyj stringa jako tekstowej reprezentacji)
        uzytkownicy = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, uzytkownik_dane, _ = key

            # Sprawdź czy dane pasują do filtrów
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni):
                # Dodaj użytkownika do zbioru (tylko niepuste wartości)
                if uzytkownik_dane:
                    # Konwertuj do stringa dla spójności
                    uzytkownicy.add(str(uzytkownik_dane))

        # Dodaj posortowanych użytkowników do listy
        for uzytkownik in sorted(uzytkownicy):
            item = QListWidgetItem(uzytkownik)
            self.uzytkownik_list.addItem(item)

            # Przywróć zaznaczenie jeśli było
            if uzytkownik in selected_uzytkownicy:
                item.setSelected(True)

    def update_table_content(self):
        """
        Aktualizuje zawartość tabeli grafiku używając modelu danych.
        Zoptymalizowana wersja wykorzystująca precyzyjne aktualizacje.
        """
        # Sprawdź czy modele zostały zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # Pobierz aktualny rok i miesiąc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # Ustaw rok i miesiąc w modelu (jeśli jeszcze nie są ustawione)
        if self.schedule_model._year != year or self.schedule_model._month != month:
            # Pobierz dane dla wybranego roku i miesiąca
            schedule_data = self.data_provider.get_schedule_data(year, month, self.import_grupa, self.import_funkcja)

            # Aktualizuj model - to wywoła zoptymalizowaną metodę update_data
            self.schedule_model.update_data(schedule_data, year, month)
            self._apply_dynamic_sizes()
        else:
            # Jeśli rok i miesiąc nie uległy zmianie, tylko zastosuj filtry
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

    def get_cell_color_by_time(self, hour):
        """
        Zwraca kolor tła komórki na podstawie godziny rozpoczęcia.
        Godziny są mapowane na kolory w bardziej czytelnej palecie.

        Args:
            hour (int): Godzina rozpoczęcia zmiany (0-23)

        Returns:
            QColor: Kolor tła komórki
        """
        # Domyślny kolor (przezroczysty) gdy godzina nie jest zdefiniowana
        if hour is None or hour < 0 or hour > 23:
            return QColor(255, 255, 255, 0)  # Przezroczysty

        # Mapowanie godzin na kolory - zharmonizowana paleta
        if hour == 5:
            return QColor(204, 255, 255)  # Jasny błękit (bardzo jasny cyjan)
        elif hour == 6:
            return QColor(204, 255, 255)  # Jasny błękit (bardzo jasny cyjan)
        elif hour == 7:
            return QColor(0, 255, 255)  # Cyjan (akwamaryna)
        elif hour == 8:
            return QColor(0, 204, 255)  # Jasny błękit (niebieskozielony)
        elif hour == 9:
            return QColor(0, 255, 0)  # Limonkowy (czysty zielony)
        elif hour == 10:
            return QColor(153, 204, 0)  # Oliwkowy (żółtozielony)
        elif hour == 11:
            return QColor(204, 255, 204)  # Bardzo jasny zielony (miętowy)
        elif hour == 12:
            return QColor(255, 255, 153)  # Bardzo jasny żółty (kremowy)
        elif hour == 13:
            return QColor(255, 204, 153)  # Jasny łososiowy (brzoskwiniowy)
        elif hour == 14:
            return QColor(255, 153, 0)  # Ciemny pomarańczowy
        elif hour == 15:
            return QColor(255, 0, 255)  # Magenta (fuksja)
        elif hour == 16:
            return QColor(204, 0, 0)  # Ciemnoczerwony
        elif hour == 17:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 18:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 19:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 20:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 21:
            return QColor(150, 150, 150)  # Średni szary
        elif hour == 22:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 23:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 0:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour in [1, 2, 3, 4]:
            return QColor(51, 51, 51)  # Ciemny szary

        # Domyślny kolor dla innych wartości
        return QColor(255, 255, 255, 0)  # Przezroczysty

    def on_selection_changed(self, selected=None, deselected=None):
        """
        POPRAWIONA WERSJA: Debounced selection handling
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # DODANE: Sprawdź czy nie jesteśmy w trakcie aktualizacji
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        # NOWE: Zastop poprzedni timer i uruchom nowy (debouncing)
        if hasattr(self, '_selection_timer'):
            self._selection_timer.stop()
            self._selection_timer.start(self._selection_debounce_delay)

    def _handle_selection_change(self):
        """
        NOWA METODA: Faktyczna obsługa zmiany zaznaczenia (wywoływana po debounce)
        """
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        self._updating_selection = True

        try:
            debug_print("Zmiana zaznaczenia - aktualizuję tabelę zdarzeń...")

            # Pobierz dane dla zaznaczonych komórek
            selected_cells_data = self.table.get_data_for_selected_cells()
            debug_print(f"Zaznaczono {len(selected_cells_data)} komórek")
            self.send_email_button.setEnabled(bool(selected_cells_data))
            if selected_cells_data and len(selected_cells_data) > 0:
                # MAMY ZAZNACZONE KOMÓRKI - pokaż zdarzenia
                events = []

                for cell_data in selected_cells_data:
                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')

                    if user_id and date_str:
                        # --- ZMIANA: Usuwamy przekazywanie self.import_grupa i self.import_funkcja ---
                        user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                        for event in user_events:
                            local_event = self._convert_dp_event_to_local(event)
                            events.append(local_event)

                debug_print(f"Pobrano {len(events)} aktywnych zdarzeń dla zaznaczonych komórek")

                # Zaktualizuj events_data
                self.events_data = events

                # Aktualizuj model zdarzeń
                if hasattr(self, 'events_model'):
                    self.events_model.update_data(self.events_data)

                    # WAŻNE: Zastosuj filtry po aktualizacji danych
                    self.filter_events_table()
            else:
                # BRAK ZAZNACZENIA - wyczyść tabelę zdarzeń
                debug_print("Brak zaznaczenia - czyszczę tabelę zdarzeń")
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])

            # DODANE: Wymuś odświeżenie widoku tabeli zdarzeń
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        finally:
            self._updating_selection = False

    def clear_events_on_startup(self):
        """
        NOWA METODA: Czyści tabelę zdarzeń przy starcie aplikacji
        """
        debug_print("Czyszczę tabelę zdarzeń przy starcie aplikacji")

        # Wyczyść dane zdarzeń
        self.events_data = []

        # Wyczyść model zdarzeń jeśli istnieje
        if hasattr(self, 'events_model') and self.events_model:
            self.events_model.update_data([])

        # Odśwież widok tabeli zdarzeń
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

    def _convert_dp_event_to_local(self, dp_event):
        """Konwertuje format zdarzenia z DataProvider na lokalny format UI."""
        try:
            date_key = dp_event.get('date_key', dp_event.get('date', ''))
            display_date = ".".join(reversed(date_key.split("-"))) if date_key and '-' in date_key else date_key

            # Użyj klucza 'UzytkownikDane' jeśli jest dostępny, w przeciwnym razie 'user_name'
            user_name = dp_event.get('UzytkownikDane') or dp_event.get('user_name', f"ID: {dp_event.get('user_id')}")

            local_event = {
                'type': dp_event.get('type', ''),
                'topic': dp_event.get('topic', ''),
                'name': dp_event.get('name', ''),
                'user_id': dp_event.get('user_id'),
                'UzytkownikDane': user_name,
                'date': display_date,
                'date_key': date_key,
                'time_from': dp_event.get('time_from', ''),
                'time_to': dp_event.get('time_to', ''),
                'status': dp_event.get('status', ''),
                'DataModyfikacji': dp_event.get('DataModyfikacji', ''),
                'id': dp_event.get('id')
            }
            return local_event
        except Exception as e:
            log_error(f"Błąd konwersji zdarzenia: {e}")
            return dp_event

    def temporarily_disable_filters(self):
        """Tymczasowo wyłącza filtry zdarzeń aby zapewnić wyświetlenie wszystkich danych"""
        # Zapamiętaj obecny stan filtrów
        self._saved_filters = {
            'meetings': self.meetings_checkbox.isChecked() if hasattr(self, 'meetings_checkbox') else True,
            'trainings': self.trainings_checkbox.isChecked() if hasattr(self, 'trainings_checkbox') else True,
            'overtime': self.overtime_checkbox.isChecked() if hasattr(self, 'overtime_checkbox') else True,
            'topic': self.topic_filter.text() if hasattr(self, 'topic_filter') else "",
            'name': self.name_filter.text() if hasattr(self, 'name_filter') else "",
            'date_from': self.date_from.date() if hasattr(self, 'date_from') else None,
            'date_to': self.date_to.date() if hasattr(self, 'date_to') else None
        }

        # Ustaw wszystkie filtry na wartości, które pokazują wszystkie dane
        if hasattr(self, 'meetings_checkbox'):
            self.meetings_checkbox.setChecked(True)
        if hasattr(self, 'trainings_checkbox'):
            self.trainings_checkbox.setChecked(True)
        if hasattr(self, 'overtime_checkbox'):
            self.overtime_checkbox.setChecked(True)
        if hasattr(self, 'topic_filter'):
            self.topic_filter.setText("")
        if hasattr(self, 'name_filter'):
            self.name_filter.setText("")

        # Daty zostawiamy bez zmian, filtrowanie będzie nadpisane przez model

        debug_print("Tymczasowo wyłączono filtry zdarzeń")

    def restore_filters(self):
        """Przywraca filtry zdarzeń do ich poprzedniego stanu"""
        if not hasattr(self, '_saved_filters'):
            return

        # Przywróć filtry do ich poprzedniego stanu
        if hasattr(self, 'meetings_checkbox') and 'meetings' in self._saved_filters:
            self.meetings_checkbox.setChecked(self._saved_filters['meetings'])
        if hasattr(self, 'trainings_checkbox') and 'trainings' in self._saved_filters:
            self.trainings_checkbox.setChecked(self._saved_filters['trainings'])
        if hasattr(self, 'overtime_checkbox') and 'overtime' in self._saved_filters:
            self.overtime_checkbox.setChecked(self._saved_filters['overtime'])
        if hasattr(self, 'topic_filter') and 'topic' in self._saved_filters:
            self.topic_filter.setText(self._saved_filters['topic'])
        if hasattr(self, 'name_filter') and 'name' in self._saved_filters:
            self.name_filter.setText(self._saved_filters['name'])

        # Nie przywracamy dat, aby zapewnić spójność z zaznaczonymi komórkami

        debug_print("Przywrócono filtry zdarzeń")

        # Wymuś odświeżenie z nowymi filtrami
        self.filter_events_table()

    def show_email_dialog(self):
        """Zbiera dane zaznaczonych pracowników i otwiera dialog do wysyłki e-mail."""
        selected_cells = self.get_selected_cells_data()
        if not selected_cells:
            QMessageBox.warning(self, "Brak zaznaczenia", "Proszę zaznaczyć przynajmniej jednego pracownika.")
            return

        recipients = []
        processed_ids = set()
        for cell_data in selected_cells:
            user_id = cell_data.get('uzytkownik_id')
            nr_kadrowy = cell_data.get('nr_kadrowy', '').strip()
            name = cell_data.get('uzytkownik_dane')

            if user_id not in processed_ids and nr_kadrowy:
                recipients.append({'name': name, 'id': nr_kadrowy})
                processed_ids.add(user_id)

        if not recipients:
            QMessageBox.warning(self, "Brak danych",
                                "Żaden z zaznaczonych pracowników nie ma przypisanego numeru kadrowego.")
            return

        template_path = self.user_settings.get('outlook_template_path', '')

        dialog = EmailDialog(self, recipients, template_path)
        if dialog.exec() == QDialog.Accepted:
            email_details = dialog.get_email_details()

            if email_details['template_path']:
                # Użyj szablonu
                success, message = create_email_from_template(
                    template_path=email_details['template_path'],
                    recipients=email_details['recipients'],
                    send_individually=email_details['send_individually']
                )
            else:
                # Użyj standardowej wiadomości
                success, message = create_outlook_email(
                    recipients=email_details['recipients'],
                    subject=email_details['subject'],
                    body=email_details['body'],
                    send_individually=email_details['send_individually']
                )

            if success:
                self.statusBar().showMessage("Pomyślnie utworzono wiadomość w programie Outlook.", 4000)
            else:
                QMessageBox.critical(self, "Błąd Outlook", message)

    def standardize_date(self, date_obj):
        """
        Standaryzuje format daty do 'YYYY-MM-DD' dla porównań
        """
        if not date_obj:
            return ''

        # Jeśli to już string, wyciągnij tylko datę
        if isinstance(date_obj, str):
            # Obsługa różnych formatów
            if 'T' in date_obj:  # Format ISO 'YYYY-MM-DDThh:mm:ss'
                return date_obj.split('T')[0]
            elif ' ' in date_obj:  # Format 'YYYY-MM-DD hh:mm:ss'
                return date_obj.split(' ')[0]
            elif len(date_obj) == 10 and date_obj.count('-') == 2:  # Format 'YYYY-MM-DD'
                return date_obj
            # Jeśli nie dopasowano do żadnego formatu, zwróć oryginalny string
            return date_obj

        # Jeśli to obiekt datetime, skonwertuj na string
        if hasattr(date_obj, 'strftime'):
            return date_obj.strftime('%Y-%m-%d')

        # W przypadku nieznanego typu, zwróć pusty string
        return ''

    # def diagnose_table_view(self):
    #     """Metoda diagnostyczna do sprawdzenia stanu SplitTableView"""
    #     if not hasattr(self, 'table') or not self.table:
    #         log_error("ERROR: Brak obiektu table!")
    #         return
    #
    #     if not hasattr(self, 'schedule_model') or not self.schedule_model:
    #         log_error("ERROR: Brak obiektu schedule_model!")
    #         return
    #
    #     debug_print("\n=== DIAGNOSTYKA TABELI ===")
    #
    #     # Sprawdź model
    #     debug_print(f"Model ma {self.schedule_model.rowCount()} wierszy i {self.schedule_model.columnCount()} kolumn")
    #     debug_print(f"Widoczne kolumny: {self.schedule_model.get_visible_columns()}")
    #
    #     # Sprawdź widoki
    #     debug_print(
    #         f"Employees view ma {self.table.employees_view.model().rowCount()} wierszy i {self.table.employees_view.model().columnCount()} kolumn")
    #     debug_print(
    #         f"Schedule view ma {self.table.schedule_view.model().rowCount()} wierszy i {self.table.schedule_view.model().columnCount()} kolumn")
    #
    #     # Sprawdź kolumny w employees_view
    #     for col in range(self.table.employees_view.model().columnCount()):
    #         hidden = self.table.employees_view.isColumnHidden(col)
    #         width = self.table.employees_view.columnWidth(col)
    #         debug_print(f"Kolumna {col} w employees_view: ukryta={hidden}, szerokość={width}px")
    #
    #     # Sprawdź przykładowe dane w pierwszym wierszu
    #     if self.schedule_model.rowCount() > 0:
    #         debug_print("\nPrzykładowe dane z pierwszego wiersza:")
    #         for col in range(len(self.schedule_model.get_visible_columns())):
    #             index = self.schedule_model.index(0, col)
    #             text = self.schedule_model.data(index, Qt.DisplayRole)
    #             debug_print(f"Kolumna {col}: '{text}'")
    #
    #     debug_print("=== KONIEC DIAGNOSTYKI ===\n")

    def diagnose_application_state(self):
        """Wykonuje pełną diagnostykę stanu aplikacji i wyświetla szczegółowe informacje"""
        try:
            debug_print("\n===== DIAGNOSTYKA STANU APLIKACJI =====")

            # 1. Sprawdź tabele i dane
            debug_print("\n--- TABELA GRAFIKU ---")
            debug_print(f"Liczba wierszy: {self.table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.table.columnCount()}")

            # Sprawdź pierwsze 3 wiersze i kolumny dla przykładu
            debug_print("\nPrzykładowe komórki z tabeli grafiku:")
            for row in range(min(3, self.table.rowCount())):
                for col in range(min(6, self.table.columnCount())):
                    item = self.table.item(row, col)
                    if item:
                        debug_print(f"[{row},{col}] Tekst: {item.text()}")
                        user_role_data = item.data(Qt.UserRole)
                        user_role_2 = item.data(Qt.UserRole + 2)
                        user_role_3 = item.data(Qt.UserRole + 3)
                        debug_print(
                            f"  UserRole: {type(user_role_data)}, UserRole+2: {user_role_2}, UserRole+3: {user_role_3}")
                        if isinstance(user_role_data, dict):
                            debug_print(f"  Zawartość: {user_role_data}")
                    else:
                        debug_print(f"[{row},{col}] Brak elementu")

            debug_print("\n--- TABELA ZDARZEŃ ---")
            debug_print(f"Liczba wierszy: {self.events_table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.events_table.columnCount()}")

            # Sprawdź zawartość events_data
            debug_print(
                f"\nLiczba zdarzeń w events_data: {len(self.events_data) if hasattr(self, 'events_data') else 'Brak'}")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print("Pierwsze zdarzenie:")
                for key, value in self.events_data[0].items():
                    debug_print(f"  {key}: {value}")

            # Sprawdź pierwsze 3 wiersze tabeli zdarzeń
            debug_print("\nPrzykładowe wiersze z tabeli zdarzeń:")
            for row in range(min(3, self.events_table.rowCount())):
                row_data = []
                for col in range(self.events_table.columnCount() - 1):  # Pomijamy ostatnią kolumnę z przyciskami
                    item = self.events_table.item(row, col)
                    if item:
                        row_data.append(f"{col}:{item.text()}")
                debug_print(f"Wiersz {row}: {', '.join(row_data)}")

            # 2. Sprawdź delegaty i style
            debug_print("\n--- DELEGATY I STYLE ---")
            item_delegate = self.table.itemDelegate()
            debug_print(f"Delegat tabeli grafiku: {item_delegate.__class__.__name__}")
            if isinstance(item_delegate, OvertimeItemDelegate):
                debug_print("  Delegat OvertimeItemDelegate poprawnie przypisany")
            else:
                debug_print("  UWAGA: Delegat OvertimeItemDelegate nie jest przypisany!")

            # 3. Sprawdź filtrowanie danych
            debug_print("\n--- FILTROWANIE DANYCH ---")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print(f"Liczba zdarzeń przed filtrowaniem: {len(self.events_data)}")
                # Sprawdź, czy metoda filter_events_table jest wywoływana
                debug_print("Spróbuj wykonać filter_events_table:")
                try:
                    self.filter_events_table()
                    debug_print("  Metoda filter_events_table wykonana bez błędów")
                except Exception as e:
                    debug_print(f"  BŁĄD podczas wykonywania filter_events_table: {e}")

            debug_print("\n===== KONIEC DIAGNOSTYKI =====\n")

        except Exception as e:
            debug_print(f"BŁĄD podczas diagnostyki: {e}")
            import traceback
            traceback.print_exc()


    def _get_current_event_filter_params(self):
        """
        Pobiera bieżące parametry filtrowania zdarzeń.

        Returns:
            dict: Parametry filtrowania
        """
        filter_params = {}

        # Dodaj filtr typów zdarzeń
        allowed_types = []
        if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
            allowed_types.append('Spotkanie')
        if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
            allowed_types.append('Szkolenie')
        if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
            allowed_types.append('Nadgodziny')

        if allowed_types:
            filter_params['allowed_types'] = allowed_types

        # Dodaj filtry tematu i nazwy
        topic_filter = self.topic_filter.text().lower() if hasattr(self,
                                                                   'topic_filter') and self.topic_filter.text() else None
        name_filter = self.name_filter.text().lower() if hasattr(self,
                                                                 'name_filter') and self.name_filter.text() else None

        if topic_filter:
            filter_params['topic'] = topic_filter
        if name_filter:
            filter_params['name'] = name_filter

        # Dodaj filtry zakresu dat
        date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
        date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

        if date_from_str:
            filter_params['date_from'] = date_from_str
        if date_to_str:
            filter_params['date_to'] = date_to_str

        return filter_params

    # def find_cell_position(self, user_id, date_str):
    #     """
    #     Znajduje pozycję komórki dla podanego użytkownika i daty, korzystając z modelu.
    #
    #     Args:
    #         user_id: ID użytkownika
    #         date_str: Data w formacie YYYY-MM-DD
    #
    #     Returns:
    #         tuple: (wiersz, dzień) lub (-1, -1) jeśli nie znaleziono
    #     """
    #     if not hasattr(self, 'schedule_model') or not self.schedule_model:
    #         return -1, -1
    #
    #     # Pobierz dzień z daty
    #     try:
    #         year, month, day_str = date_str.split('-')
    #         day = int(day_str)
    #     except:
    #         return -1, -1
    #
    #     # Pobierz liczbę wierszy w modelu
    #     row_count = self.schedule_model.rowCount()
    #
    #     # Dla każdego wiersza sprawdź, czy odpowiada szukanemu użytkownikowi
    #     for row in range(row_count):
    #         # Pobierz ID użytkownika z pierwszej kolumny
    #         index = self.schedule_model.index(row, 0)
    #         user_data = self.schedule_model.data(index, Qt.UserRole)
    #
    #         if isinstance(user_data, dict) and str(user_data.get('uzytkownik_id', '')) == str(user_id):
    #             return row, day
    #
    #     return -1, -1

    def _get_cell_data_for_user_date_pairs(self, user_date_pairs: list) -> list:
        """
        Na podstawie listy par (user_id, date_str) odnajduje i zwraca
        pełne dane komórek z modelu grafiku.
        """
        if not self.schedule_model or not user_date_pairs:
            return []

        cells_data_to_return = []
        user_row_map = {str(key[3]): idx for idx, key in enumerate(self.schedule_model._keys)}

        for user_id, date_str in user_date_pairs:
            row = user_row_map.get(str(user_id))
            if row is not None:
                try:
                    day = int(date_str.split('-')[2])
                    col_offset = len(self.schedule_model.get_visible_columns())
                    col = col_offset + day - 1

                    index = self.schedule_model.index(row, col)

                    # --- ZMIANA: Poprawne odwołanie do ROLE_DATA ---
                    cell_data = self.schedule_model.data(index, ROLE_DATA)

                    if isinstance(cell_data, dict):
                        cells_data_to_return.append(cell_data)
                except (ValueError, IndexError) as e:
                    log_warning(f"Nie udało się znaleźć danych dla komórki ({user_id}, {date_str}): {e}")

        return cells_data_to_return

    def cancel_delegations(self):
        debug_print("\\n=== ROZPOCZYNAM OPERACJĘ ODWOŁYWANIA DELEGACJI ===")

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Brak danych", "Nie wybrano miesiąca.", QMessageBox.Ok)
            return

        selected_cells_data = self.get_selected_cells_data()
        if not self._can_modify_cells(selected_cells_data):
            return

        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Zaznacz komórki, dla których chcesz odwołać delegacje.",
                                QMessageBox.Ok)
            return

        view_state = self._save_view_state()

        user_date_pairs = [(cell.get('uzytkownik_id'), cell.get('date_str')) for cell in selected_cells_data if
                           cell.get('uzytkownik_id') and cell.get('date_str')]
        if not user_date_pairs:
            QMessageBox.information(self, "Brak danych", "Nie znaleziono danych dla zaznaczonych komórek.",
                                    QMessageBox.Ok)
            return

        events_to_cancel = self._find_events_to_cancel(user_date_pairs)
        if not events_to_cancel:
            QMessageBox.information(self, "Brak delegacji",
                                    "Nie znaleziono delegacji do odwołania dla zaznaczonych komórek.", QMessageBox.Ok)
            return

        grouped_events = self._group_events_by_user_date(events_to_cancel)
        delegations_info = self._prepare_delegations_description(grouped_events)
        confirm_message = f"Czy na pewno chcesz odwołać następujące delegacje?\\n\\n{delegations_info}\\n"
        confirm_message += f"Łącznie: {len(events_to_cancel)} delegacji dla {len(user_date_pairs)} komórek"

        reply = QMessageBox.question(self, "Potwierdzenie odwołania delegacji", confirm_message,
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if reply != QMessageBox.Yes:
            debug_print("=== OPERACJA ANULOWANA PRZEZ UŻYTKOWNIKA ===")
            return

        try:
            canceled_count = self._cancel_delegations(events_to_cancel)

            if canceled_count > 0:
                trainings_to_clear = [evt for evt in events_to_cancel if evt.get('type') == 'Szkolenie']
                if trainings_to_clear:
                    pairs_for_trainings = list(
                        set((e.get('user_id'), e.get('date_key', e.get('date'))) for e in trainings_to_clear))
                    cells_data = self._get_cell_data_for_user_date_pairs(pairs_for_trainings)

                    change_requests = []
                    for cell in cells_data:
                        current_symbol = cell.get('symbol', '')
                        if not current_symbol: continue

                        parsed = parse_symbol(current_symbol)
                        if parsed.get('special_symbol') and parsed.get('special_symbol').upper() == 'S':
                            new_symbol = build_symbol(
                                location=parsed.get('location'), start_hour=parsed.get('start_hour'),
                                work_hours=parsed.get('work_hours'), special_symbol=None
                            )
                            try:
                                date_str = cell['date_str']
                                year, month, _ = map(int, date_str.split('-'))
                                change_requests.append({
                                    'nr_kadrowy': cell['nr_kadrowy'], 'rok': year, 'miesiac': month,
                                    'data': date_str, 'symbol': new_symbol, 'user_id': cell['uzytkownik_id'],
                                    'user_name': cell['uzytkownik_dane']
                                })
                            except (ValueError, KeyError) as e:
                                log_warning(f"Pominięto aktualizację symbolu 'S': {e}")

                    if change_requests:
                        self._process_and_apply_changes(change_requests, "Usunięto symbol 'S' z {0} komórek grafiku.")

                affected_pairs = list(
                    set((e.get('user_id'), e.get('date_key', e.get('date'))) for e in events_to_cancel))
                self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)

                self._restore_view_state(view_state)

                self.on_selection_changed()
                QMessageBox.information(self, "Sukces", f"Pomyślnie odwołano {canceled_count} zdarzeń.", QMessageBox.Ok)
            else:
                self._restore_view_state(view_state)
                QMessageBox.warning(self, "Brak zmian", "Nie udało się odwołać żadnej delegacji.", QMessageBox.Ok)

            debug_print(f"=== ZAKOŃCZONO - ODWOŁANO {canceled_count} DELEGACJI ===")

        except Exception as e:
            log_error(f"Błąd podczas odwoływania delegacji: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas odwoływania delegacji: {str(e)}", QMessageBox.Ok)

    def delete_events_for_cells(self, cells_data: list):
        """
        Wyszukuje wszystkie zdarzenia dla podanych komórek, prosi o potwierdzenie
        i odwołuje je. Zwraca True, jeśli użytkownik potwierdził usunięcie.
        """
        if not cells_data:
            return False

        # Zbierz unikalne pary (użytkownik, data) z zaznaczonych komórek
        user_date_pairs = set()
        for cell_data in cells_data:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if user_id and date_str:
                user_date_pairs.add((user_id, date_str))

        # Znajdź wszystkie zdarzenia do odwołania dla tych par
        events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        if not events_to_cancel:
            # Jeśli nie ma zdarzeń do usunięcia, nic więcej nie rób
            return False

        # Przygotuj i pokaż okno dialogowe z potwierdzeniem
        grouped_events = self._group_events_by_user_date(events_to_cancel)
        delegations_info = self._prepare_delegations_description(grouped_events)

        reply = QMessageBox.question(
            self,
            "Potwierdzenie usunięcia zdarzeń",
            f"Wstawienie tego symbolu wymaga odwołania istniejących zdarzeń (spotkań, nadgodzin itp.).\n\n{delegations_info}\nCzy chcesz kontynuować?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply == QMessageBox.Yes:
            # Jeśli użytkownik się zgodzi, odwołaj delegacje
            self._cancel_delegations(events_to_cancel)
            return True
        else:
            # Jeśli użytkownik anuluje, zwróć informację o tym
            self.statusBar().showMessage("Operacja anulowana przez użytkownika.", 3000)
            return False

    def get_data_from_model(self, row, col):
        """
        Pobiera dane z komórki modelu na podstawie wierszy i kolumn.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny

        Returns:
            dict: Dane komórki lub pusty słownik
        """
        if not hasattr(self, 'schedule_model'):
            return {}

        # Pobierz dane z modelu
        index = self.schedule_model.index(row, col)
        cell_data = self.schedule_model.data(index, Qt.UserRole)

        # Upewnij się, że dane są słownikiem
        if not isinstance(cell_data, dict):
            return {}

        return cell_data

    def get_selected_cells_data(self):
        """
        Pobiera dane dla zaznaczonych komórek z modelu.

        Returns:
            list: Lista danych zaznaczonych komórek
        """
        if not hasattr(self, 'table') or not self.table:
            return []

        # Deleguj do metody w SplitTableView, która już obsługuje model
        return self.table.get_data_for_selected_cells()

    def update_model_after_data_change(self, user_id, date_str):
        """
        Aktualizuje dane w modelu po zmianach w bazie danych.

        Args:
            user_id: ID użytkownika
            date_str: Data w formacie YYYY-MM-DD
        """
        if not user_id or not date_str:
            return

        # Pobierz rok i miesiąc z daty
        if date_str.count('-') != 2:
            return

        year, month, _ = date_str.split('-')
        try:
            year = int(year)
            month = int(month)
        except ValueError:
            return

        # Pobierz aktualne dane z DataProvider - wymuś odświeżenie cache
        self.data_provider.clear_cache()
        schedule_data = self.data_provider.get_schedule_data(year, month, use_cache=False)

        # Aktualizuj model
        if schedule_data and hasattr(self, 'schedule_model'):
            # Aktualizuj model bezpośrednio
            self.schedule_model.update_data(schedule_data, year, month)

            # Zaktualizuj przefiltrowane dane
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

            # Odśwież widok
            if hasattr(self, 'table'):
                self.table.update()

    def setup_model_connections(self):
        """
        Łączy sygnały modeli z obsługą interfejsu użytkownika.
        """
        # Połącz zmiany w modelach z aktualizacją interfejsu
        if hasattr(self, 'schedule_model'):
            self.schedule_model.dataChanged.connect(self.on_schedule_data_changed)

        if hasattr(self, 'events_model'):
            self.events_model.dataChanged.connect(self.on_events_data_changed)

    def on_schedule_data_changed(self, topLeft, bottomRight):
        """
        Obsługuje zmianę danych w modelu grafiku.

        Args:
            topLeft: Indeks górnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Odśwież widok
        if hasattr(self, 'table'):
            self.table.update()

        # Jeśli zmieniło się zaznaczenie, zaktualizuj tabelę zdarzeń
        if self.table.selection_changed.receivers() > 0:
            selected_rows = self.table.get_selected_rows()
            if selected_rows:
                self.on_selection_changed()

    def on_events_data_changed(self, topLeft, bottomRight):
        """
        Obsługuje zmianę danych w modelu zdarzeń.

        Args:
            topLeft: Indeks górnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Odśwież tabelę zdarzeń
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()



    def get_selected_schedule_cells(self):
        """Zwraca listę zaznaczonych komórek z siatki grafiku"""
        selected_cells = []
        selected_ranges = self.table.selectedRanges()

        for range_item in selected_ranges:
            for row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawdź czy to komórka z grafikiem
                    if col >= 3:
                        # Pobierz element tabeli
                        cell_item = self.table.item(row, col)
                        if not cell_item:
                            continue

                        # Pobierz dane z komórki
                        cell_data = self.get_cell_data(cell_item)
                        if not cell_data:
                            continue

                        # Dodaj dane do listy wybranych komórek
                        selected_cells.append(cell_data)

        return selected_cells

    def group_cells_by_user_and_day(self, cells):
        """Grupuje komórki według użytkownika i dnia dla łatwiejszej edycji"""
        grouped = {}
        for cell in cells:
            # ZMIANA: Dostosuj do nowej struktury danych z modelu
            user_id = cell.get('uzytkownik_id')  # Zmieniono z 'user_id'
            date_str = cell.get('date_str')  # Zmieniono z 'date'

            if not user_id or not date_str:
                continue

            if user_id not in grouped:
                grouped[user_id] = {}

            if date_str not in grouped[user_id]:
                grouped[user_id][date_str] = []

            grouped[user_id][date_str].append(cell)

        return grouped

    def delete_event(self, event_id, event_type):
        """Wersja z weryfikacją uprawnień oraz usuwaniem symbolu 'S' z grafiku po odwołaniu szkolenia."""
        debug_print(f"--- ROZPOCZĘTO delete_event DLA ID: {event_id}, TYP: {event_type} ---")
        affected_pairs = []
        event_to_delete = None
        for event in (self.events_data or []):
            if event.get('id') == event_id and event.get('type') == event_type:
                user_id = event.get('user_id')
                date_key = event.get('date_key')
                if user_id and date_key:
                    affected_pairs.append((user_id, date_key))
                    event_to_delete = event
                    break

        if not event_to_delete:
            QMessageBox.warning(self, "Błąd", "Nie można odnaleźć zdarzenia do usunięcia.")
            debug_print("[delete_event] Nie znaleziono zdarzenia. Zakończono.")
            return

        cells_to_check = self._get_cell_data_for_user_date_pairs(affected_pairs)
        if not self._can_modify_cells(cells_to_check):
            debug_print("[delete_event] Brak uprawnień. Zakończono.")
            return

        reply = QMessageBox.question(
            self, "Potwierdzenie",
            f"Czy na pewno chcesz usunąć {event_type.lower()} o ID {event_id}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.Yes
        )

        if reply != QMessageBox.StandardButton.Yes:
            debug_print("[delete_event] Użytkownik anulował operację. Zakończono.")
            return

        # Krok 1: Zapisz stan widoku PRZED jakąkolwiek modyfikacją.
        self._state_to_restore = self._save_view_state()
        debug_print(f"[delete_event] Zapisano stan widoku do self._state_to_restore.")

        try:
            # Krok 2: Jeśli odwołujemy szkolenie, NAJPIERW zajmij się usunięciem symbolu 'S' z grafiku.
            # Robimy to teraz, gdy dane w `cells_to_check` są wciąż aktualne.
            if event_type == 'Szkolenie':
                change_requests = []
                for cell_data in cells_to_check:
                    current_symbol = cell_data.get('symbol', '')
                    if not current_symbol: continue

                    parsed = parse_symbol(current_symbol)
                    if parsed.get('special_symbol') and parsed.get('special_symbol').upper() == 'S':
                        debug_print(
                            f"[delete_event] Znaleziono symbol 'S' w komórce: {current_symbol}. Przygotowuję usunięcie.")
                        new_symbol = build_symbol(
                            location=parsed.get('location'), start_hour=parsed.get('start_hour'),
                            work_hours=parsed.get('work_hours'), special_symbol=None
                        )
                        try:
                            date_str = cell_data['date_str']
                            year, month, _ = map(int, date_str.split('-'))
                            change_requests.append({
                                'nr_kadrowy': cell_data['nr_kadrowy'], 'rok': year, 'miesiac': month,
                                'data': date_str, 'symbol': new_symbol, 'user_id': cell_data['uzytkownik_id'],
                                'user_name': cell_data['uzytkownik_dane']
                            })
                        except (ValueError, KeyError) as e:
                            log_warning(f"Pominięto aktualizację symbolu 'S' przy usuwaniu zdarzenia: {e}")

                if change_requests:
                    self._process_and_apply_changes(change_requests, "Usunięto symbol 'S' z {0} komórki grafiku.")

            # Krok 3: Teraz odwołaj zdarzenie w bazie danych.
            _, user_app_id, _, _, _ = get_modifier_id()
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            table_name = ""
            if event_type == "Spotkanie":
                table_name = SQL_OBJECTS['spotkania']
            elif event_type == "Szkolenie":
                table_name = SQL_OBJECTS['szkolenia']
            elif event_type == "Nadgodziny":
                table_name = SQL_OBJECTS['nadgodziny']
            else:
                conn.close()
                return

            if event_type in ["Spotkanie", "Szkolenie"]:
                query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                cursor.execute(query, (user_app_id, event_id))
            else:
                query = f"DELETE FROM {table_name} WHERE Id = ?"
                cursor.execute(query, (event_id,))

            conn.commit()
            conn.close()
            debug_print("[delete_event] Pomyślnie zaktualizowano bazę danych (odwołano zdarzenie).")
            self._update_modification_date()

            # Krok 4: Na samym końcu, zainicjuj odświeżenie danych w interfejsie.
            debug_print(
                "[delete_event] Wywołuję invalidate_complete_cache_for_pairs - za chwilę nastąpi refresh i przywrócenie stanu.")
            self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)
            self.statusBar().showMessage(f"Usunięto zdarzenie o ID {event_id}.", 3000)

        except Exception as e:
            log_error(f"Błąd podczas usuwania zdarzenia: {e}", exception=e)
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd podczas usuwania zdarzenia: {str(e)}",
                                 QMessageBox.StandardButton.Ok)
            self._state_to_restore = None
        debug_print(f"--- ZAKOŃCZONO delete_event DLA ID: {event_id} ---")

    def _update_multiple_overtime_locations(self, location_changes):
        """
        Aktualizuje lokalizację dla wielu wpisów nadgodzin, każdy z inną wartością.
        WERSJA POPRAWIONA: Aktualizuje również nazwę zdarzenia w interfejsie.
        """
        if not location_changes:
            return True  # Brak zmian do wykonania to nie błąd

        location_map = {'h': 1, 's': 3, 'p': 2}

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            for event_id, new_location_code in location_changes:
                location_value = location_map.get(new_location_code)
                if location_value is None:
                    log_warning(
                        f"Pominięto aktualizację nadgodzin dla ID {event_id} z powodu nieznanego kodu lokalizacji: {new_location_code}")
                    continue

                query = f"UPDATE {SQL_OBJECTS['nadgodziny']} SET Lokalizacja = ? WHERE Id = ?"
                params = (location_value, event_id)
                debug_print(f"Aktualizuję lokalizację nadgodzin: ID={event_id}, nowa lokalizacja={location_value}")
                cursor.execute(query, params)

            conn.commit()
            conn.close()

            # --- NOWA LOGIKA: Aktualizacja nazwy w modelu danych po pomyślnym zapisie w bazie ---

            # Mapa kodów na pełne nazwy do wyświetlenia
            location_display_map = {'h': 'Home Office', 's': 'SBC', 'p': 'Przystanek'}

            # Stwórz słownik zmian dla szybszego wyszukiwania
            changes_map = dict(location_changes)

            # Zaktualizuj główną listę wszystkich zdarzeń
            for event in self.all_events_data:
                if event.get('id') in changes_map and event.get('type') == 'Nadgodziny':
                    new_loc_code = changes_map[event['id']]
                    new_loc_name = location_display_map.get(new_loc_code, 'N/A')
                    event['name'] = f"Nadgodziny {new_loc_name}"

            # Zaktualizuj listę zdarzeń aktualnie widoczną w tabeli
            for event in self.events_data:
                if event.get('id') in changes_map and event.get('type') == 'Nadgodziny':
                    new_loc_code = changes_map[event['id']]
                    new_loc_name = location_display_map.get(new_loc_code, 'N/A')
                    event['name'] = f"Nadgodziny {new_loc_name}"

            # Odśwież model tabeli zdarzeń, aby UI pokazał zmiany
            if hasattr(self, 'events_model'):
                self.events_model.update_data(self.events_data)

            debug_print(f"Zaktualizowano {len(location_changes)} wpisów nadgodzin w interfejsie.")
            # --- KONIEC NOWEJ LOGIKI ---

            return True

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji wielu lokalizacji nadgodzin: {e}", exception=e)
            QMessageBox.critical(self, "Błąd Bazy Danych", f"Nie udało się zaktualizować lokalizacji nadgodzin:\n{e}")
            return False

    def _update_overtime_icon_single(self, user_id, date_str, year, month):
        """
        NOWA METODA: Aktualizuje ikonę nadgodzin bez wpływania na cache innych danych.
        """
        try:
            # 1. Aktualizuj bezpośrednio w modelu grafiku
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonę nadgodzin w modelu dla ({user_id}, {date_str})")

            # 2. Wyczyść tylko cache ikon dla tej konkretnej komórki w DataProvider
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla komórki ({user_id}, {date_str})")

            # 3. Odśwież widok grafiku
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"Błąd podczas aktualizacji ikony nadgodzin: {e}")

    def _handle_specific_icons_refresh(self, data_type, year, month):
        """Obsługuje sygnał o zmianie danych ikon z DataProvider i odświeża model."""
        if data_type == "icons":
            current_data = self.date_combo.currentData()
            if current_data and current_data == (year, month):
                debug_print(f"[DB] Otrzymano sygnał odświeżenia ikon dla {year}-{month}. Odświeżam model grafiku.")

                fresh_processed_data = self.data_provider.get_processed_data(
                    year, month, self.import_grupa, self.import_funkcja
                )
                self.processed_data = fresh_processed_data

                # Zamiast wywoływać filter_data(), które powoduje problemy,
                # ręcznie przekazujemy przefiltrowane dane do modelu.
                filtered_data = self.filter_processed_data()
                self.schedule_model.update_filtered_data(filtered_data)

                debug_print(
                    f"[DB] W _handle_specific_icons_refresh, sprawdzam flagę self._state_to_restore. Jest ona: {'USTAWIONA' if self._state_to_restore else 'PUSTA (None)'}")
                if self._state_to_restore:
                    # Jeśli istnieje stan do przywrócenia, odtwarzamy go.
                    # Ta funkcja sama zajmie się przywróceniem sortowania i zaznaczenia.
                    self._restore_view_state(self._state_to_restore)
                    self._state_to_restore = None  # Wyczyść flagę po użyciu
                else:
                    # Jeśli nie ma stanu do przywrócenia, stosujemy domyślne sortowanie z ustawień.
                    debug_print("[DB] Brak stanu do przywrócenia, aplikuję sortowanie niestandardowe.")
                    self.apply_custom_sort()

                # Odświeżamy tabelę zdarzeń na samym końcu, gdy zaznaczenie jest już poprawnie przywrócone.
                self.on_selection_changed()

    def call_add_overtime_procedure_fixed(self, user_id, year, month, date_str, start_time, hours,
                                          settlement_date, is_overdue, overtime_type, location,
                                          nr_kadrowy):
        """
        Dodaje nadgodziny i zapewnia natychmiastową, niezawodną aktualizację
        tabeli zdarzeń oraz ikony w grafiku.
        """
        try:
            # Krok 1: Dodanie rekordu do bazy danych
            location_map = {'h': 1, 'p': 2, 's': 3}
            location_value = location_map.get(location, 1)
            param_value = 1 if overtime_type == 'odpracowanie' else None
            odebrane_value = 1 if overtime_type == 'odbiór' else 0

            from datetime import datetime, timedelta
            start_datetime = datetime.strptime(f"{date_str} {start_time}", "%Y-%m-%d %H:%M")
            end_datetime = start_datetime + timedelta(hours=float(hours))
            end_time = end_datetime.strftime("%H:%M")

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            params = [
                nr_kadrowy, year, month, date_str, start_datetime, end_datetime,
                settlement_date, is_overdue, odebrane_value, location_value,
                param_value
            ]
            sql = f"{{CALL {SQL_OBJECTS['p_nadgodzinywstawienie']} ({', '.join(['?'] * len(params))})}}"
            cursor.execute(sql, params)
            conn.commit()
            conn.close()

            # Krok 2: Rejestracja własnej zmiany i unieważnienie cache
            self._update_modification_date()
            self.data_provider.invalidate_complete_cache_for_pairs([(user_id, date_str)])

            # --- NOWA, KLUCZOWA LOGIKA (skopiowana z `delete_event`) ---
            # Krok 3: Bezpośrednia aktualizacja ikony w modelu
            if hasattr(self, 'schedule_model'):
                # Sprawdzamy, jakie zdarzenia istnieją dla komórki PO dodaniu nowego
                remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)

                # Bezpośrednio aktualizujemy stan ikon w modelu
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_meetings, has_trainings, has_overtime
                )

            # Krok 4: Odświeżenie dolnej tabeli zdarzeń
            self.on_selection_changed()

            # Zwracamy sukces
            return {
                "success": True,
                "message": "Nadgodziny zostały pomyślnie dodane."
            }

        except Exception as e:
            log_error(f"Błąd podczas dodawania nadgodzin: {e}", exception=e)
            return {
                "success": False,
                "message": f"Wystąpił błąd podczas dodawania nadgodzin: {str(e)}"
            }

    def _refresh_data_after_overtime_addition(self, new_id, user_id, date_str, year, month):
        """
        NOWA METODA: Odświeża dane z bazy po dodaniu nadgodzin
        """
        try:
            debug_print(f"Odświeżam dane po dodaniu nadgodzin ID={new_id}")

            # Upewnij się, że column_mapper jest dostępny
            if not hasattr(self, 'column_mapper'):
                from column_mapper import ColumnMapper
                self.column_mapper = ColumnMapper()

            # 1. POBIERZ NOWE ZDARZENIE Z BAZY DANYCH
            new_event = self._fetch_specific_event_from_db(year, month, new_id, 'Nadgodziny')

            if not new_event:
                log_error(f"Nie znaleziono dodanych nadgodzin o ID {new_id} w bazie danych")
                return

            debug_print(f"Pobrano nowe zdarzenie z bazy: {new_event}")

            # 2. AKTUALIZUJ CACHE DATAPROVIDER
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]

                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data")

                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []

                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in
                           container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache")

                # Aktualizuj processed_data - ustaw ikonę nadgodzin
                try:
                    day = int(date_str.split('-')[2])
                    for key, user_data in container.processed_data.items():
                        if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonę nadgodzin w processed_data")
                            break
                except Exception as e:
                    log_error(f"Błąd aktualizacji processed_data: {e}")

            # 3. AKTUALIZUJ LOKALNE DANE
            # Konwertuj na lokalny format
            local_event = self._convert_dp_event_to_local(new_event)

            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(local_event)
                    debug_print(f"Dodano nadgodziny do all_events_data")

            # 4. AKTUALIZUJ events_data TYLKO JEŚLI KOMÓRKA JEST ZAZNACZONA
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )

                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(local_event)
                        debug_print(f"Dodano nadgodziny do events_data")

                        # Aktualizuj model zdarzeń
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # 5. AKTUALIZUJ MODEL GRAFIKU
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_overtime=True
                )
                debug_print(f"Zaktualizowano ikony w schedule_model")

            # 6. WYCZYŚĆ CACHE IKON
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon")

            # 7. ODŚWIEŻ WIDOKI
            if hasattr(self, 'table'):
                if hasattr(self.table, 'schedule_view'):
                    self.table.schedule_view.viewport().update()

            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

            debug_print(f"=== ODŚWIEŻENIE DANYCH ZAKOŃCZONE ===")

        except Exception as e:
            log_error(f"Błąd podczas odświeżania danych: {e}")
            import traceback
            traceback.print_exc()


    def _add_event_to_data_provider(self, new_id, user_id, user_name, date_str, start_time,
                                    end_time, overtime_type, is_overdue, year, month):
        """
        NOWA METODA: Dodaje zdarzenie bezpośrednio do DataProvider i wszystkich cache'y
        """
        try:
            # Utwórz obiekt zdarzenia w formacie DataProvider
            display_date = ".".join(reversed(date_str.split("-")))

            # Status na podstawie typu i flagi zaległości
            if overtime_type == 'wypłata':
                status = "Wypłata - zaległe" if is_overdue else "Wypłata"
            elif overtime_type == 'odbiór':
                status = "Odbiór"
            elif overtime_type == 'odpracowanie':
                status = "Odpracowanie"
            else:
                status = "Aktywne"

            # Utwórz zdarzenie w formacie zgodnym z DataProvider
            new_event_dp_format = {
                'event_type': 'Nadgodziny',
                'event_id': new_id,
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'date': date_str,  # DataProvider oczekuje YYYY-MM-DD
                'time_from': f"{start_time}",  # Format z bazy
                'time_to': f"{end_time}",
                'status': 'Wstawione',  # Status w formacie bazy
                'type': 'Nadgodziny',
                'id': new_id,
                'date_display': display_date,
                'date_key': date_str
            }

            # Utwórz zdarzenie w formacie lokalnym
            new_event_local_format = {
                'type': 'Nadgodziny',
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'user_name': user_name,
                'date': display_date,
                'date_key': date_str,
                'time_from': start_time,
                'time_to': end_time,
                'status': status,
                'id': new_id
            }

            # KLUCZOWA ZMIANA 1: Dodaj do cache DataProvider
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]

                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data (ID: {new_id})")

                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []

                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in
                           container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache (ID: {new_id})")

                # Aktualizuj processed_data - dodaj ikonę nadgodzin
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        try:
                            day = int(date_str.split('-')[2])
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonę nadgodzin w processed_data dla {user_id}, dzień {day}")
                            break
                        except:
                            pass

            # KLUCZOWA ZMIANA 2: Dodaj do lokalnych danych
            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(new_event_local_format)
                    debug_print(f"Dodano nadgodziny do all_events_data (ID: {new_id})")

            # KLUCZOWA ZMIANA 3: Dodaj do events_data tylko jeśli komórka jest zaznaczona
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )

                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(new_event_local_format)
                        debug_print(f"Dodano nadgodziny do events_data (ID: {new_id})")

                        # Aktualizuj model zdarzeń
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # KLUCZOWA ZMIANA 4: Aktualizuj ikonę w modelu
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonę nadgodzin w modelu dla ({user_id}, {date_str})")

            # KLUCZOWA ZMIANA 5: Wyczyść tylko cache ikon dla tej komórki (nie cały cache)
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla komórki ({user_id}, {date_str})")

            # Odśwież widok
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"Błąd podczas dodawania zdarzenia do DataProvider: {e}")

    def debug_check_event_in_index(self, event_id, event_type='Nadgodziny'):
        """
        Sprawdza, czy zdarzenie o podanym ID istnieje w indeksie zdarzeń
        i wyświetla informacje diagnostyczne.

        Args:
            event_id: ID zdarzenia
            event_type: Typ zdarzenia (domyślnie 'Nadgodziny')

        Returns:
            bool: True jeśli znaleziono zdarzenie, False w przeciwnym wypadku
        """
        debug_print(f"\n--- DIAGNOSTYKA INDEKSU ZDARZEŃ ---")
        debug_print(f"Szukam zdarzenia o ID {event_id} i typie {event_type}")

        # Sprawdź w indeksie zdarzeń DataProvider
        if hasattr(self.data_provider, 'events_index'):
            # Sprawdź bezpośrednio przez indeks ID
            event = self.data_provider.events_index.get_event_by_id(event_id)
            if event:
                debug_print(f"ZNALEZIONO w indeksie ID: {event}")
                return True

            # Alternatywnie, przeszukaj wszystkie zdarzenia
            found_in_all = False
            for e in self.data_provider.events_index.all_events:
                if e.get('id') == event_id and e.get('type') == event_type:
                    debug_print(f"ZNALEZIONO w all_events: {e}")
                    found_in_all = True

            # Przeszukaj indeks typów
            found_in_type_index = False
            type_events = self.data_provider.events_index.type_index.get(event_type, [])
            for e in type_events:
                if e.get('id') == event_id:
                    debug_print(f"ZNALEZIONO w type_index: {e}")
                    found_in_type_index = True

            if not found_in_all and not found_in_type_index:
                debug_print("NIE ZNALEZIONO w indeksie zdarzeń")
                return False

            return found_in_all or found_in_type_index
        else:
            debug_print("BRAK indeksu zdarzeń w data_provider")
            return False

    def update_cell_data(self, user_id, date_str, event_type=None, action="update"):
        """
        Aktualizuje dane komórki i ikony po różnych operacjach.
        Zoptymalizowana wersja wykorzystująca precyzyjne aktualizacje.

        Args:
            user_id: ID użytkownika
            date_str: Data w formacie 'YYYY-MM-DD'
            event_type: Typ zdarzenia (Spotkanie, Szkolenie, Nadgodziny lub None)
            action: Rodzaj operacji - "update", "add", "delete"

        Returns:
            bool: True jeśli operacja się powiodła, False w przeciwnym wypadku
        """
        if not user_id or not date_str:
            return False

        # Standardyzuj format daty
        date_str = self.data_provider._standardize_date(date_str)

        # Wyczyść cache dla miesiąca tej daty
        if date_str and date_str.count('-') == 2:
            year, month, _ = date_str.split('-')
            self.clear_events_cache(int(year), int(month))

        # Pobierz zdarzenia dla tej pary (użytkownik, data)
        events = self.data_provider.get_events_for_user_date(user_id, date_str)

        # Sprawdź typy zdarzeń
        has_meeting = any(
            e.get('type') == 'Spotkanie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_training = any(
            e.get('type') == 'Szkolenie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_overtime = any(e.get('type') == 'Nadgodziny' for e in events)

        # Aktualizuj wskaźniki w modelu - używając zoptymalizowanej metody
        if hasattr(self, 'schedule_model'):
            if event_type == 'Spotkanie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Szkolenie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Nadgodziny':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny',
                                                                  is_active=(action != "delete"))
            else:
                # Aktualizuj wszystkie wskaźniki
                result1 = self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', has_meeting)
                result2 = self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', has_training)
                result3 = self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', has_overtime)
                return result1 or result2 or result3

        return False

    def get_all_valid_symbols(self) -> set:
        """Zwraca zbiór wszystkich prawidłowych symboli specjalnych z załadowanej konfiguracji."""
        all_symbols = set()
        for category in app_settings.SYMBOL_CATEGORIES.values():
            all_symbols.update(category.keys())
        return all_symbols

    def apply_symbol_from_keyboard(self, special_symbol: str):
        """
        Uproszczona metoda: Aplikuje symbol z klawiatury, delegując logikę
        do scentralizowanej metody.
        """
        if special_symbol:
            self._apply_special_symbol_to_selection(special_symbol)

    def _apply_special_symbol_to_selection(self, special_symbol: str):
        """
        NOWA, SCENTRALIZOWANA METODA: Wstawia symbol specjalny z uwzględnieniem
        szczegółowej logiki dla ról Lider, Lider OUT i Pracownik WPR.
        """
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not selected_cells_data:
            self.statusBar().showMessage("Nie zaznaczono żadnych komórek do edycji.", 3000)
            return

        if not self._can_modify_cells(selected_cells_data):
            return

        view_state = self._save_view_state()

        processed_cells_to_modify = []
        for cell_data in selected_cells_data:
            parsed_symbol = parse_symbol(cell_data.get('symbol', ''))
            is_empty_cell = parsed_symbol.get('work_hours') is None

            if is_empty_cell:
                if self.current_user_role in ['Lider', 'Pracownik WPR']:
                    continue
                elif self.current_user_role == 'Lider OUT':
                    try:
                        work_hours = int(float(cell_data.get('etat', 8.0)))
                    except (ValueError, TypeError):
                        work_hours = 8

                    default_shift_symbol = build_symbol(
                        location=cell_data.get('lokalizacja_domyslna', 'h'),
                        start_hour=9,
                        work_hours=work_hours,
                        special_symbol=None
                    )
                    modified_cell = cell_data.copy()
                    modified_cell['symbol'] = default_shift_symbol
                    processed_cells_to_modify.append(modified_cell)
                else:
                    processed_cells_to_modify.append(cell_data)
            else:
                processed_cells_to_modify.append(cell_data)

        if not processed_cells_to_modify:
            QMessageBox.information(self, "Informacja",
                                    "Brak prawidłowych komórek do modyfikacji dla Twojej roli i zaznaczenia.")
            return

        cells_to_modify_final = []
        skipped_for_dtn = []
        if self.current_user_role in ['Lider', 'Lider OUT']:
            for cell in processed_cells_to_modify:
                target_dept = cell.get('wydzial', '').strip().lower()
                if target_dept == 'dtn' and special_symbol.upper() != 'CO':
                    skipped_for_dtn.append(cell.get('uzytkownik_dane', 'Nieznany'))
                else:
                    cells_to_modify_final.append(cell)
        else:
            cells_to_modify_final = processed_cells_to_modify

        if skipped_for_dtn:
            QMessageBox.warning(self, "Operacja zablokowana",
                                f"Dla wydziału DTN dozwolony jest tylko symbol 'CO'.\\n"
                                f"Pominięto zmiany dla: {', '.join(set(skipped_for_dtn))}")

        if not cells_to_modify_final:
            return

        events_to_cancel = []
        if special_symbol.upper() in app_settings.get_absence_symbols():
            user_date_pairs = {(c.get('uzytkownik_id'), c.get('date_str')) for c in cells_to_modify_final}
            events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        reply = QMessageBox.Yes
        if self._should_ask_for_confirmation():
            grouped_changes = self._group_cells_for_symbol_changes(cells_to_modify_final)
            changes_info = self._prepare_symbol_changes_description(grouped_changes, special_symbol)
            complete_info = f"Czy na pewno chcesz wprowadzić następujące zmiany?\\n\\n{changes_info}"
            if events_to_cancel:
                grouped_events = self._group_events_by_user_date(events_to_cancel)
                delegations_info = self._prepare_delegations_description(grouped_events)
                complete_info += f"\\n{delegations_info}"
            reply = QMessageBox.question(self, "Potwierdzenie wstawienia symbolu", complete_info,
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

        if reply != QMessageBox.Yes:
            self.statusBar().showMessage("Operacja anulowana przez użytkownika.", 3000)
            return

        if events_to_cancel:
            self.cancel_delegations()

        updated_info, error_messages, skipped_employees = [], [], []

        for cell_data in cells_to_modify_final:
            # --- NOWA LOGIKA: Wyjątek dla Lidera wstawiającego 'U' innemu Liderowi ---
            if self.current_user_role == 'Lider' and special_symbol.upper() == 'U':
                target_role = cell_data.get('rola_nazwa', '')
                target_dept = cell_data.get('wydzial', '')
                # Lider może wstawić 'U' tylko innemu Liderowi w tym samym wydziale
                if not (target_role == 'Lider' and target_dept == self.current_user_department):
                    skipped_employees.append(
                        f"{cell_data.get('uzytkownik_dane', 'Nieznany')} (nie jest Liderem w tym samym wydziale)")
                    continue  # Pomiń tego pracownika
            # --- KONIEC NOWEJ LOGIKI ---

            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_edit_symbol']:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue

            new_symbol = self._predict_new_symbol(cell_data.get('symbol', ''), special_symbol, cell_data)
            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"Błąd: {cell_data.get('uzytkownik_dane')}: {result.get('message', 'Błąd zapisu.')}")
            except Exception as e:
                log_error(f"Błąd w _apply_special_symbol_to_selection: {e}", exception=e)
                error_messages.append(f"Błąd: {cell_data.get('uzytkownik_dane')}: Błąd aplikacji: {e}")

        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Zastosowano symbol '{special_symbol}' dla {len(updated_info)} komórek.",
                                         4000)

        self._show_symbol_change_results(len(updated_info), len(error_messages), error_messages, events_to_cancel,
                                         skipped_employees)

    def apply_theme_settings(self, theme, font_family, font_size):
        """Stosuje wybrane ustawienia motywu z wykorzystaniem centralnych stylów"""
        # Zapamiętaj wybrane ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Zastosuj czcionkę do całej aplikacji
        font = QFont(font_family, font_size)
        QApplication.setFont(font)

        # Zastosuj główny styl dla całego okna aplikacji
        self.setStyleSheet(AppStyles.get_main_window_style(theme))

        # Definicje stylów
        button_style = AppStyles.get_button_style(theme, font_family, font_size)
        combo_style = AppStyles.get_combobox_style(theme)
        line_edit_style = AppStyles.get_line_edit_style(theme)
        list_style = AppStyles.get_list_style(theme)
        date_edit_style = AppStyles.get_date_edit_style(theme)
        checkbox_style = AppStyles.get_checkbox_style(theme)
        table_style = AppStyles.get_table_style(theme)
        left_panel_style = AppStyles.get_left_panel_style(theme)

        # Stosowanie stylów do wszystkich istniejących kontrolek
        all_buttons = self.findChildren(QPushButton)
        for button in all_buttons:
            if "FilterClearButton" not in button.objectName():
                button.setStyleSheet(button_style)

        new_icon = self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light
        for button in self.findChildren(QPushButton, "FilterClearButton"):
            button.setIcon(new_icon)

        # Pola wyboru (ComboBox)
        if hasattr(self, 'date_combo'): self.date_combo.setStyleSheet(combo_style)
        if hasattr(self, 'grupa_main_filter_combo'): self.grupa_main_filter_combo.setStyleSheet(combo_style)
        if hasattr(self, 'wydzial_combo'): self.wydzial_combo.setStyleSheet(combo_style)
        if hasattr(self, 'default_location_combo'): self.default_location_combo.setStyleSheet(combo_style)
        if hasattr(self, 'system_czasu_pracy_combo'): self.system_czasu_pracy_combo.setStyleSheet(combo_style)
        if hasattr(self, 'rola_combo'): self.rola_combo.setStyleSheet(combo_style)
        if hasattr(self, 'jezyk_combo'): self.jezyk_combo.setStyleSheet(combo_style)
        if hasattr(self, 'etat_combo'): self.etat_combo.setStyleSheet(combo_style)
        if hasattr(self, 'dtn_combo'): self.dtn_combo.setStyleSheet(combo_style)
        if hasattr(self, 'presence_location_combo'): self.presence_location_combo.setStyleSheet(combo_style)
        if hasattr(self, 'presence_hour_combo'): self.presence_hour_combo.setStyleSheet(combo_style)
        # ZMIANA: Dodanie stylu dla nowego filtra statusu
        if hasattr(self, 'status_filter_combo'): self.status_filter_combo.setStyleSheet(combo_style)

        # Inne kontrolki
        if hasattr(self, '_left_panel'): self._left_panel.setStyleSheet(left_panel_style)
        if hasattr(self, 'przelozony_filter'): self.przelozony_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'topic_filter'): self.topic_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'name_filter'): self.name_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'przelozony_list'): self.przelozony_list.setStyleSheet(list_style)
        if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.setStyleSheet(list_style)
        if hasattr(self, 'date_from'): self.date_from.setStyleSheet(date_edit_style)
        if hasattr(self, 'date_to'): self.date_to.setStyleSheet(date_edit_style)
        if hasattr(self, 'presence_date_edit'): self.presence_date_edit.setStyleSheet(date_edit_style)
        if hasattr(self, 'meetings_checkbox'): self.meetings_checkbox.setStyleSheet(checkbox_style)
        if hasattr(self, 'trainings_checkbox'): self.trainings_checkbox.setStyleSheet(checkbox_style)
        if hasattr(self, 'overtime_checkbox'): self.overtime_checkbox.setStyleSheet(checkbox_style)
        if hasattr(self, 'filter_by_presence_check'): self.filter_by_presence_check.setStyleSheet(checkbox_style)

        # Aktualizacja modeli i tabel
        if hasattr(self, 'schedule_model'): self.schedule_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'events_model'): self.events_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'table'):
            if hasattr(self.table, 'employees_view'): self.table.employees_view.setStyleSheet(table_style)
            if hasattr(self.table, 'schedule_view'): self.table.schedule_view.setStyleSheet(table_style)
        if hasattr(self, 'events_table'): self.events_table.setStyleSheet(table_style)

        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            self.staffing_details_win.set_current_theme(self.is_dark_theme)

        if hasattr(self, 'table'):
            self._apply_dynamic_sizes()

    def save_user_settings_on_exit(self):
        """Zbiera i zapisuje wszystkie ustawienia użytkownika przy zamykaniu."""
        if not hasattr(self, 'user_settings'):
            return

        # Zbierz dynamiczne ustawienia z UI
        ui_settings = {
            'is_maximized': self.isMaximized(),
            'window_size': (self.size().width(), self.size().height()),
            'last_filters': self.get_current_filters_state(),
            'column_widths': self.table.get_column_widths(),
            'visible_columns': self.visible_columns,
            # DODANE: Jawne zapisanie aktualnych ustawień motywu
            'theme': 'dark' if self.is_dark_theme else 'light',
            'font_family': self.current_font,
            'font_size': self.current_font_size
        }

        # Zaktualizuj główny słownik ustawień
        self.user_settings.update(ui_settings)

        # Zapisz cały słownik do bazy
        self.settings_db.save_settings(self.user_settings)
        debug_print("Zapisano ustawienia użytkownika przy zamknięciu.")

    def copy_selection_to_clipboard(self):
        """
        Zbiera dane z zaznaczonych komórek i kopiuje je do schowka
        w formacie TSV, gotowym do wklejenia w Excelu.
        """
        if not hasattr(self, 'table') or not self.schedule_model:
            return

        selection_model_employees = self.table.employees_view.selectionModel()
        selection_model_schedule = self.table.schedule_view.selectionModel()

        if not selection_model_employees.hasSelection() or not selection_model_schedule.hasSelection():
            self.statusBar().showMessage("Proszę zaznaczyć wiersze pracowników oraz kolumny dni do skopiowania.", 3000)
            return

        # Krok 1: Zbierz unikalne, posortowane indeksy wierszy i kolumn
        selected_rows = sorted(list(set(index.row() for index in selection_model_employees.selectedIndexes())))
        selected_schedule_cols = sorted(
            list(set(index.column() for index in selection_model_schedule.selectedIndexes())))

        if not selected_rows or not selected_schedule_cols:
            return

        # Krok 2: Przygotuj nagłówki
        headers = []
        visible_employee_cols_ids = self.schedule_model.get_visible_columns()
        for col_id in visible_employee_cols_ids:
            # Znajdź nazwę kolumny na podstawie jej ID
            header_name = next((name for id, name, width in self.employee_columns if id == col_id), col_id)
            headers.append(header_name)

        for col in selected_schedule_cols:
            header_text = str(self.schedule_model.headerData(col, Qt.Horizontal, Qt.DisplayRole)).replace('\n', ' ')
            headers.append(header_text)

        clipboard_string = "\t".join(headers) + "\n"

        # Krok 3: Przygotuj wiersze z danymi
        for row in selected_rows:
            row_values = []
            # Dodaj dane pracowników
            for col_idx in range(len(visible_employee_cols_ids)):
                index = self.schedule_model.index(row, col_idx)
                value = self.schedule_model.data(index, Qt.DisplayRole)
                row_values.append(str(value or ''))

            # Dodaj dane z grafiku
            for col in selected_schedule_cols:
                index = self.schedule_model.index(row, col)
                value = self.schedule_model.data(index, Qt.DisplayRole)
                row_values.append(str(value or ''))

            clipboard_string += "\t".join(row_values) + "\n"

        # Krok 4: Wstaw sformatowany tekst do schowka
        QApplication.clipboard().setText(clipboard_string)
        self.statusBar().showMessage(f"Skopiowano {len(selected_rows)} wierszy do schowka.", 3000)

    def closeEvent(self, event):
        """Obsługuje zamknięcie aplikacji i zapisuje ustawienia."""
        try:
            # Wywołaj nową metodę zapisu
            self.save_user_settings_on_exit()

            debug_print("=== ZAMYKANIE APLIKACJI TEAMFLOW ===")
            self.cleanup_keyboard_filter()
            close_log_file()
        except Exception as e:
            log_error(f"Wystąpił błąd podczas zamykania aplikacji: {e}", exception=e)
        finally:
            event.accept()


if __name__ == "__main__":
    app = QApplication(sys.argv)

    # --- NOWA, BEZPIECZNA SEKWENCJA STARTOWA ---

    # Krok 1: Załaduj kluczowe ustawienia PRZED utworzeniem głównego okna
    if not load_all_app_settings():
        QMessageBox.critical(None, "Błąd Krytyczny",
                             "Nie udało się załadować konfiguracji aplikacji z serwera.\n"
                             "Sprawdź połączenie z bazą danych i plik config.ini.\n\n"
                             "Aplikacja nie może zostać uruchomiona.")
        sys.exit(1)

    # Krok 2: Sprawdź wersję aplikacji PRZED utworzeniem głównego okna
    if parse_version(APP_VERSION) != parse_version(app_settings.REQUIRED_VERSION):
        # Inicjalizujemy logowanie z pustymi ustawieniami, aby ewentualne błędy mogły być zapisane
        setup_logging()
        log_error(
            f"Wersja aplikacji jest przestarzała. Wymagana: {app_settings.REQUIRED_VERSION}, Obecna: {APP_VERSION}")

        # Używamy QDialog bezpośrednio, bo główne okno jeszcze nie istnieje
        dialog = UpdateRequiredDialog()
        dialog.exec()
        sys.exit(0)  # Zakończ normalnie po informacji dla użytkownika

    # Krok 3: Zainicjuj logowanie (teraz, gdy wiemy, że aplikacja może wystartować)
    try:
        current_windows_user = getpass.getuser().lower()
    except Exception:
        current_windows_user = "unknown_user"

    log_to_file = current_windows_user in app_settings.LOGGING_USERS_FILE
    log_to_console = current_windows_user in app_settings.LOGGING_USERS_CONSOLE
    setup_logging(log_to_file=log_to_file, log_to_console=log_to_console)

    # Krok 4: Jeśli wszystko jest w porządku, utwórz i pokaż główne okno
    window = WorkScheduleWindow()
    if window.user_settings.get('is_maximized'):
        window.showMaximized()
    else:
        window.show()
    sys.exit(app.exec())
