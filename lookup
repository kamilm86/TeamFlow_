Ten bÅ‚Ä…d: ORA-01439: column to be modified must be empty to change datatype oznacza, Å¼e TwÃ³j skrypt prÃ³buje zmieniÄ‡ typ danych kolumny INITIATEDDATETIME (na NVARCHAR2(22)), ale w tabeli w bazie danych sÄ… juÅ¼ dane, a Oracle na to nie pozwala (chyba Å¼e tabela jest pusta).
Dlaczego to siÄ™ dzieje?
 * W bazie danych kolumna INITIATEDDATETIME ma prawdopodobnie typ DATE lub TIMESTAMP.
 * TwÃ³j DataFrame w Pythonie traktuje tÄ™ kolumnÄ™ jako string (napis) o dÅ‚ugoÅ›ci 22 znakÃ³w.
 * Funkcja check_column_size wykrywa rÃ³Å¼nicÄ™ i prÃ³buje wykonaÄ‡ ALTER TABLE ... MODIFY ... NVARCHAR2(22).
 * Oracle blokuje tÄ™ operacjÄ™, bo zmiana typu DATE -> NVARCHAR2 na niepustej kolumnie jest zabroniona.
ğŸ› ï¸ RozwiÄ…zanie
Musimy zmodyfikowaÄ‡ funkcjÄ™ check_column_size w klasie DatabaseManager. Musimy dodaÄ‡ obsÅ‚ugÄ™ bÅ‚Ä™du (try-except), aby zignorowaÄ‡ ten bÅ‚Ä…d w przypadku Oracle. JeÅ›li nie moÅ¼emy zmieniÄ‡ typu kolumny, powinniÅ›my po prostu zostawiÄ‡ jÄ… takÄ…, jaka jest, i sprÃ³bowaÄ‡ wstawiÄ‡ dane (Oracle czÄ™sto poradzi sobie z niejawnÄ… konwersjÄ… string->date przy insercie).
Oto poprawiona funkcja check_column_size. PodmieÅ„ jÄ… w swoim pliku.
    def check_column_size(self, engine, df: pd.DataFrame, table_name: str, schema: str, target_db: str):
        """
        Sprawdza i ewentualnie zwiÄ™ksza rozmiar kolumn w bazie danych.
        Ignoruje bÅ‚Ä™dy zmiany typu danych (ORA-01439) dla niepustych tabel.
        """
        if df.empty:
            return

        # Mapowanie typÃ³w dla sprawdzenia dÅ‚ugoÅ›ci
        # UÅ¼ywamy uproszczonego mapowania, bo interesuje nas gÅ‚Ã³wnie VARCHAR/NVARCHAR
        column_types = self.map_data_types(df, target_db)
        
        try:
            with engine.connect() as connection:
                # Pobranie informacji o kolumnach z bazy (dla Oracle)
                if target_db.lower() == 'oracle':
                    # Pobieramy obecne definicje kolumn z Oracle
                    # Uwaga: user_tab_columns przechowuje nazwy wielkimi literami
                    sql_check = f"""
                        SELECT COLUMN_NAME, DATA_TYPE, DATA_LENGTH, CHAR_LENGTH 
                        FROM ALL_TAB_COLUMNS 
                        WHERE TABLE_NAME = '{table_name.upper()}' 
                          AND OWNER = '{schema.upper()}'
                    """
                    existing_cols = connection.execute(text(sql_check)).fetchall()
                    existing_cols_dict = {row[0]: {'type': row[1], 'len': row[3] if row[3] else row[2]} for row in existing_cols}

                    for col_name in df.columns:
                        col_upper = col_name.upper()
                        
                        # JeÅ›li kolumny nie ma w bazie, zostanie dodana przy insercie (lub moÅ¼na tu dodaÄ‡ ALTER ADD)
                        if col_upper not in existing_cols_dict:
                            continue

                        current_type_info = existing_cols_dict[col_upper]
                        current_len = current_type_info['len']
                        
                        # Sprawdzamy typ w Pythonie
                        # JeÅ›li w Pythonie mamy string/object, a w bazie jest VARCHAR/CHAR, sprawdzamy dÅ‚ugoÅ›Ä‡
                        col_type_obj = column_types.get(col_name)
                        
                        # Interesuje nas tylko zwiÄ™kszanie VARCHAR-Ã³w
                        is_varchar_in_python = 'VARCHAR' in str(col_type_obj).upper() or 'STRING' in str(col_type_obj).upper() or 'CLOB' in str(col_type_obj).upper()
                        
                        if is_varchar_in_python:
                            # Obliczamy wymaganÄ… dÅ‚ugoÅ›Ä‡
                            max_len_in_df = df[col_name].astype(str).map(len).max()
                            if pd.isna(max_len_in_df): max_len_in_df = 0
                            required_len = int(max_len_in_df * 1.2) # Margines

                            # JeÅ›li wymagana dÅ‚ugoÅ›Ä‡ jest wiÄ™ksza niÅ¼ obecna (i obecna to nie CLOB)
                            if required_len > current_len and current_type_info['type'] not in ['CLOB', 'NCLOB', 'LONG']:
                                
                                try:
                                    alter_sql = ""
                                    if required_len > 4000:
                                        self.logger.info(f"Zmiana typu kolumny {col_name} na CLOB")
                                        alter_sql = f'ALTER TABLE "{schema}"."{table_name}" MODIFY ("{col_name}" CLOB)'
                                    else:
                                        self.logger.info(f"ZwiÄ™kszanie kolumny {col_name} z {current_len} na {required_len}")
                                        alter_sql = f'ALTER TABLE "{schema}"."{table_name}" MODIFY ("{col_name}" VARCHAR2({required_len}))'
                                    
                                    connection.execute(text(alter_sql))
                                    
                                except Exception as e:
                                    # ğŸ’¥ TUTAJ JEST NAPRAWA TWOJEGO BÅÄ˜DU ğŸ’¥
                                    error_str = str(e)
                                    if "ORA-01439" in error_str:
                                        self.logger.warning(f"Nie moÅ¼na zmieniÄ‡ typu kolumny '{col_name}' (ORA-01439). "
                                                            f"Kolumna nie jest pusta, a typy sÄ… niekompatybilne. "
                                                            f"IgnorujÄ™ zmianÄ™ i prÃ³bujÄ™ wstawiÄ‡ dane.")
                                    else:
                                        self.logger.error(f"BÅ‚Ä…d podczas zmiany rozmiaru kolumny {col_name}: {e}")
                                        # Nie podnosimy raise, prÃ³bujemy wstawiaÄ‡ dalej

                elif target_db.lower() == 'sqlserver':
                    # (Tutaj Twoja istniejÄ…ca logika dla SQL Server lub uproszczona wersja)
                    pass

        except Exception as e:
            self.logger.error(f"BÅ‚Ä…d w check_column_size: {e}")
            # Nie przerywamy procesu, bo insert moÅ¼e siÄ™ udaÄ‡ mimo to

Co zmieniÄ‡ w kodzie?
Musisz dodaÄ‡ import text z sqlalchemy na gÃ³rze pliku, jeÅ›li go nie masz:
from sqlalchemy import text
Kluczowa zmiana to blok except, ktÃ³ry wyÅ‚apuje ORA-01439. DziÄ™ki temu skrypt:
 * SprÃ³buje zmieniÄ‡ kolumnÄ™.
 * Oracle rzuci bÅ‚Ä…d "nie mogÄ™, bo sÄ… dane".
 * Python zÅ‚apie bÅ‚Ä…d, wypisze ostrzeÅ¼enie (warning) zamiast bÅ‚Ä™du (error).
 * Proces pÃ³jdzie dalej do insert_data i sprÃ³buje wstawiÄ‡ dane. JeÅ›li INITIATEDDATETIME to data w formacie stringowym pasujÄ…cym do formatu Oracle, wstawienie siÄ™ uda.
