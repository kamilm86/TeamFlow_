from PySide6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QLabel,
                               QPushButton, QComboBox, QGroupBox, QRadioButton,
                               QFontComboBox, QSpinBox, QColorDialog, QCheckBox, QWidget, QTextEdit,
    QFrame, QButtonGroup, QTabWidget, QGridLayout, QMessageBox, QLineEdit, QApplication, QSpacerItem, QSizePolicy,
    QTableWidget, QTableWidgetItem, QHeaderView)  # Dodaj QTableWidget, QTableWidgetItem, QHeaderView
from PySide6.QtCore import Qt, Signal, QTime
from PySide6.QtGui import QFont
from db_connector import DatabaseConnector, get_modifier_id  # Dodaj import get_modifier_id

class ThemeSettingsDialog(QDialog):
    """
    Dialog do wyboru ustawień motywu aplikacji.
    """
    settings_changed = Signal(str, str, int)  # Sygnał: motyw, czcionka, rozmiar

    def __init__(self, parent=None, current_theme="dark", current_font="", current_font_size=9):
        super().__init__(parent)

        self.setWindowTitle("Ustawienia motywu")
        self.setMinimumWidth(400)

        # Wartości początkowe
        self.current_theme = current_theme
        self.current_font = current_font
        self.current_font_size = current_font_size
        self.parent = parent

        # NOWE: Zastosuj styl dialogu
        self.apply_dialog_theme()

        self.setup_ui()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu"""
        if self.parent and hasattr(self.parent, 'is_dark_theme'):
            theme = "dark" if self.parent.is_dark_theme else "light"
        else:
            theme = self.current_theme

        from styles import AppStyles
        self.setStyleSheet(AppStyles.get_dialog_style(theme))

    def setup_ui(self):
        main_layout = QVBoxLayout(self)

        # Grupa wyboru motywu - BEZ DODATKOWYCH STYLÓW (używa globalnego)
        theme_group = QGroupBox("Motyw")
        theme_layout = QVBoxLayout()

        # Zostawiamy tylko ciemny i jasny motyw
        self.dark_theme_radio = QRadioButton("Ciemny")
        self.light_theme_radio = QRadioButton("Jasny")

        # Ustawienie bieżącego motywu
        if self.current_theme == "dark":
            self.dark_theme_radio.setChecked(True)
        elif self.current_theme == "light":
            self.light_theme_radio.setChecked(True)
        else:
            self.dark_theme_radio.setChecked(True)  # Domyślnie ciemny

        theme_layout.addWidget(self.dark_theme_radio)
        theme_layout.addWidget(self.light_theme_radio)
        theme_group.setLayout(theme_layout)

        # Grupa ustawień czcionki
        font_group = QGroupBox("Czcionka")
        font_layout = QVBoxLayout()

        # Wybór rodzaju czcionki
        font_type_layout = QHBoxLayout()
        font_type_label = QLabel("Typ czcionki:")
        self.font_combo = QFontComboBox()
        if self.current_font:
            self.font_combo.setCurrentFont(QFont(self.current_font))
        font_type_layout.addWidget(font_type_label)
        font_type_layout.addWidget(self.font_combo)

        # Wybór rozmiaru czcionki
        font_size_layout = QHBoxLayout()
        font_size_label = QLabel("Rozmiar czcionki:")
        self.font_size_spin = QSpinBox()
        self.font_size_spin.setRange(6, 24)
        self.font_size_spin.setValue(self.current_font_size)
        font_size_layout.addWidget(font_size_label)
        font_size_layout.addWidget(self.font_size_spin)

        font_layout.addLayout(font_type_layout)
        font_layout.addLayout(font_size_layout)
        font_group.setLayout(font_layout)

        # Opcja zapisania ustawień
        self.save_settings_checkbox = QCheckBox("Zapamiętaj ustawienia")
        self.save_settings_checkbox.setChecked(True)

        # Przyciski OK i Anuluj
        buttons_layout = QHBoxLayout()
        self.ok_button = QPushButton("OK")
        self.cancel_button = QPushButton("Anuluj")

        # NOWE: Zastosuj style przycisków
        theme = "dark" if self.current_theme == "dark" else "light"
        from styles import AppStyles
        self.ok_button.setStyleSheet(AppStyles.get_button_style(theme))
        self.cancel_button.setStyleSheet(AppStyles.get_button_style(theme))

        self.ok_button.clicked.connect(self.accept)
        self.cancel_button.clicked.connect(self.reject)

        buttons_layout.addStretch()
        buttons_layout.addWidget(self.ok_button)
        buttons_layout.addWidget(self.cancel_button)

        # Dodanie wszystkich elementów do głównego layoutu
        main_layout.addWidget(theme_group)
        main_layout.addWidget(font_group)
        main_layout.addWidget(self.save_settings_checkbox)
        main_layout.addLayout(buttons_layout)

        # Podłączenie sygnałów do natychmiastowej zmiany - ale dopiero po utworzeniu komponentów
        self.dark_theme_radio.toggled.connect(lambda checked: self.apply_immediate_changes() if checked else None)
        self.light_theme_radio.toggled.connect(lambda checked: self.apply_immediate_changes() if checked else None)
        self.font_combo.currentFontChanged.connect(self.apply_immediate_changes)
        self.font_size_spin.valueChanged.connect(self.apply_immediate_changes)

    def apply_immediate_changes(self):
        """Aplikuje zmiany natychmiastowo podczas wybierania opcji"""
        # Upewnij się, że komponenty zostały już utworzone
        if not hasattr(self, 'font_combo') or not hasattr(self, 'font_size_spin'):
            return

        # Ustal bieżący motyw
        theme = self.get_current_theme()

        # Pobierz wybraną czcionkę i rozmiar
        font = self.font_combo.currentFont().family()
        font_size = self.font_size_spin.value()

        # Emituj sygnał z ustawieniami
        self.settings_changed.emit(theme, font, font_size)

    def get_current_theme(self):
        """Zwraca nazwę aktualnie wybranego motywu"""
        if self.dark_theme_radio.isChecked():
            return "dark"
        elif self.light_theme_radio.isChecked():
            return "light"
        else:
            return "dark"


class InsertSymbolDialog(QDialog):
    """
    Dialog do wyboru symbolu urlopu lub nieobecności z zakładkami.
    Zmniejszony, z podpowiedziami zamiast legendy i ulepszoną obsługą.
    """
    symbol_selected = Signal(str)  # Sygnał z wybranym symbolem

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Wstaw symbol")
        self.setMinimumWidth(300)  # Zmniejszone okno
        self.setMinimumHeight(200)  # Zmniejszone okno

        self.selected_symbol = ""
        self.user_role = ""  # Będzie ustawiane na podstawie roli użytkownika
        self.valid_symbols = set()  # Zbiór wszystkich dostępnych symboli

        # Pobierz rolę użytkownika z rodzica (głównego okna)
        if parent and hasattr(parent, 'current_user_role'):
            self.user_role = parent.current_user_role

        # Pobierz czcionkę z głównego okna aplikacji
        self.parent_font = QApplication.font()
        if parent:
            self.parent_font = parent.font()

        # NOWE: Zastosuj motyw dialogu
        self.apply_dialog_theme()

        self.setup_ui()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu"""
        if hasattr(self, 'parent') and self.parent and hasattr(self.parent, 'is_dark_theme'):
            theme = "dark" if self.parent.is_dark_theme else "light"
        else:
            theme = "dark"  # domyślny

        from styles import AppStyles
        self.setStyleSheet(AppStyles.get_dialog_style(theme))

    def setup_ui(self):
        main_layout = QVBoxLayout(self)

        # Dodaj instrukcję nad polem do wprowadzania symbolu
        instruction_label = QLabel("Wpisz symbol lub wybierz z poniższych zakładek")
        instruction_label.setStyleSheet("color: gray; font-style: italic;")
        instruction_label.setFont(self.parent_font)  # Użyj czcionki z głównego okna
        main_layout.addWidget(instruction_label)

        # Pole do ręcznego wpisania symbolu
        input_layout = QHBoxLayout()
        input_label = QLabel("Symbol:")
        input_label.setFont(self.parent_font)  # Użyj czcionki z głównego okna

        self.symbol_input = QLineEdit()
        self.symbol_input.setMaxLength(5)  # Ograniczenie długości

        # NOWE: Zastosuj styl dla LineEdit
        theme = "dark" if (hasattr(self, 'parent') and self.parent and
                           hasattr(self.parent, 'is_dark_theme') and
                           self.parent.is_dark_theme) else "light"
        from styles import AppStyles
        self.symbol_input.setStyleSheet(AppStyles.get_line_edit_style(theme))

        # Utwórz czcionkę na podstawie rodzica, ale pogrubioną i większą
        font = QFont(self.parent_font)
        font.setBold(True)
        font.setPointSize(font.pointSize() + 2)  # Nieco większa czcionka
        self.symbol_input.setFont(font)

        # Ustaw transformację tekstu na duże litery
        self.symbol_input.textChanged.connect(self.on_symbol_input_changed)
        # Dodajemy obsługę klawisza Enter z własną metodą weryfikacji
        self.symbol_input.returnPressed.connect(self.check_and_accept)

        input_layout.addWidget(input_label)
        input_layout.addWidget(self.symbol_input)
        main_layout.addLayout(input_layout)

        # Zakładki
        self.tabs = QTabWidget()
        self.tabs.setFont(self.parent_font)  # Użyj czcionki z głównego okna

        # Definicje symboli w kategoriach
        popularne_symbole = [
            ("UZ", "Urlop na żądanie"),
            ("CO", "Zwolnienie lekarskie"),
            ("CR", "Zwolnienie lekarskie na inną osobę we wspólnym gospodarstwie")
        ]
        urlopy_symbole = [
            ("U", "Urlop wypoczynkowy"),
            ("UB", "Urlop bezpłatny"),
            ("UD", "Urlop dodatkowy z tytułu niepełnosprawności"),
            ("UM", "Urlop macierzyński (20 tyg., Dodatkowy 6 tyg., Rodzicielski 26 tyg.)"),
            ("UO", "Urlop okolicznościowy"),
            ("UOD", "Opieka nad dzieckiem do lat 14"),
            ("US", "Urlop szkolny"),
            ("UT", "Urlop ojcowski"),
            ("UW", "Urlop wychowawczy"),
            ("UZ", "Urlop na żądanie"),
            ("UOP", "5 dni opieki na dziecko lub członka rodziny - urlop opiekuńczy")
        ]
        zwolnienia_symbole = [
            ("CO", "Zwolnienie lekarskie"),
            ("CR", "Zwolnienie lekarskie na inną osobę we wspólnym gospodarstwie"),
            ("CRW", "Zwolnienie lekarskie na opiekę (sytuacja wyjątkowa)"),
            ("CSR", "Świadczenie rehabilitacyjne"),
            ("ZO", "Zwolnienie z obowiązku świadczenia pracy"),
            ("ZS", "Zwolnienie z obowiązku świadczenia pracy (sytuacja wyjątkowa)")
        ]
        delegacje_symbole = [
            ("DK", "Podróż służbowa krajowa"),
            ("DZ", "Podróż służbowa zagraniczna"),
            ("HO", "Home Office"),
            ("P", "Czasowe oddelegowanie"),
            ("PD", "Prace dodatkowe")
        ]
        inne_symbole = [
            ("BC", "Doradca w backup"),
            ("BK", "Badanie kontrolne"),
            ("BO", "Badanie okresowe"),
            ("CW", "Ćwiczenia wojskowe"),
            ("DYS", "Realizacja dyspozycji"),
            ("MW", "mWolne"),
            ("NN", "Nieobecność nieusprawiedliwiona"),
            ("NU", "Nieobecność usprawiedliwiona"),
            ("NW", "Nieobecność do wyjaśnienia"),
            ("O", "Nieobecność usprawiedliwiona z tytułu odbioru godzin"),
            ("OS", "Odbiór dnia wolnego za święto przypadające w sobotę"),
            ("S", "Szkolenie po programie adaptacyjnym"),
            ("T", "Testy"),
            ("USW", "2 dni wolne na zwolnienie od pracy z powodu siły wyższej"),
            ("Z", "Rozwiązanie umowy")
        ]

        # Zbierz wszystkie dostępne symbole
        all_symbol_lists = [popularne_symbole, urlopy_symbole, zwolnienia_symbole, delegacje_symbole, inne_symbole]
        for symbol_list in all_symbol_lists:
            for symbol, _ in symbol_list:
                self.valid_symbols.add(symbol)

        # Dodanie zakładek w zależności od roli
        if self.user_role == "Lider":
            # Lider widzi tylko Zwolnienia i Popularne symbole
            # self.add_tab_with_symbols(popularne_symbole, "Popularne symbole")
            self.add_tab_with_symbols(zwolnienia_symbole, "Zwolnienia")
        elif self.user_role == "Pracownik WPR":
            # Menadżer widzi wszystko
            # self.add_tab_with_symbols(popularne_symbole, "Popularne symbole")
            # self.add_tab_with_symbols(urlopy_symbole, "Urlopy")
            self.add_tab_with_symbols(zwolnienia_symbole, "Zwolnienia")
            # self.add_tab_with_symbols(delegacje_symbole, "Delegacje i praca zdalna")
            # self.add_tab_with_symbols(inne_symbole, "Inne")
        else:
            pass
            # # Domyślnie - użytkownik standardowy widzi wszystkie zakładki
            # self.add_tab_with_symbols(popularne_symbole, "Popularne symbole")
            # self.add_tab_with_symbols(urlopy_symbole, "Urlopy")
            # self.add_tab_with_symbols(zwolnienia_symbole, "Zwolnienia")
            # self.add_tab_with_symbols(delegacje_symbole, "Delegacje i praca zdalna")
            # self.add_tab_with_symbols(inne_symbole, "Inne")

        # Przyciski
        buttons_layout = QHBoxLayout()
        self.cancel_button = QPushButton("Anuluj")
        self.cancel_button.setFont(self.parent_font)

        # NOWE: Zastosuj styl przycisku
        self.cancel_button.setStyleSheet(AppStyles.get_button_style(theme))

        self.cancel_button.clicked.connect(self.reject)

        # Dodaj informację o prawidłowości symbolu
        self.validation_label = QLabel("")
        self.validation_label.setFont(self.parent_font)  # Użyj czcionki z głównego okna

        buttons_layout.addWidget(self.validation_label)
        buttons_layout.addStretch()
        buttons_layout.addWidget(self.cancel_button)

        # Dodanie elementów do głównego layoutu
        main_layout.addWidget(self.tabs)
        main_layout.addLayout(buttons_layout)

        # Ustaw focus na pole wpisywania
        self.symbol_input.setFocus()

    def add_tab_with_symbols(self, symbols, tab_name):
        """Dodaje zakładkę z symbolami do tabwidget"""
        tab = QWidget()
        tab_layout = QGridLayout(tab)
        tab_layout.setSpacing(5)

        for idx, (symbol, desc) in enumerate(symbols):
            button = QPushButton(symbol)
            button.setFont(self.parent_font)
            button.setFixedSize(60, 20)
            button.setToolTip(desc)
            button.setProperty("symbol", symbol)
            button.setFocusPolicy(Qt.NoFocus)  # Wyłącz fokus dla przycisku
            button.clicked.connect(self.on_symbol_button_clicked)
            row = idx // 4
            col = idx % 4
            tab_layout.addWidget(button, row, col)

        tab_layout.addItem(QSpacerItem(10, 10, QSizePolicy.Expanding, QSizePolicy.Expanding),
                           (len(symbols) // 4) + 1, 0, 1, 4)
        self.tabs.addTab(tab, tab_name)

    def on_symbol_button_clicked(self):
        """Obsługuje kliknięcie przycisku z symbolem"""
        button = self.sender()  # Pobierz obiekt, który wysłał sygnał
        if button:
            symbol = button.property("symbol")
            if symbol:
                self.accept_symbol(symbol)

    def on_symbol_input_changed(self, text):
        """Obsługuje zmianę symbolu wpisanego z klawiatury"""
        # Konwersja do dużych liter
        uppercase_text = text.upper()
        if text != uppercase_text:
            # Blokuj sygnał, aby uniknąć nieskończonej pętli
            self.symbol_input.blockSignals(True)
            self.symbol_input.setText(uppercase_text)
            self.symbol_input.blockSignals(False)

        self.selected_symbol = uppercase_text.strip()

        # Sprawdź, czy symbol jest na liście dostępnych
        if self.selected_symbol:
            if self.selected_symbol in self.valid_symbols:
                self.validation_label.setText("Symbol prawidłowy")
                self.validation_label.setStyleSheet("color: green;")
            else:
                self.validation_label.setText("Symbol niedostępny!")
                self.validation_label.setStyleSheet("color: red;")
        else:
            self.validation_label.setText("")

    def accept_symbol(self, symbol):
        """Akceptuje symbol i zamyka dialog"""
        self.selected_symbol = symbol

        # Blokuj sygnał, aby uniknąć wywołania on_symbol_input_changed
        self.symbol_input.blockSignals(True)
        self.symbol_input.setText(symbol)
        self.symbol_input.blockSignals(False)

        # Aktualizuj etykietę walidacji
        self.validation_label.setText("Symbol prawidłowy")
        self.validation_label.setStyleSheet("color: green;")

        # Wywołaj metodę sprawdzającą
        self.check_and_accept()

    def check_and_accept(self):
        if self.selected_symbol and self.selected_symbol in self.valid_symbols:
            super().accept()
        elif self.selected_symbol:
            QMessageBox.warning(
                self,
                "Nieprawidłowy symbol",
                f"Symbol '{self.selected_symbol}' nie znajduje się na liście dostępnych symboli.",
                QMessageBox.Ok
            )
            self.selected_symbol = ""
            self.symbol_input.setText("")
            self.symbol_input.setFocus()
        else:
            QMessageBox.warning(
                self,
                "Brak symbolu",
                "Proszę wpisać lub wybrać symbol.",
                QMessageBox.Ok
            )
            self.selected_symbol = ""
            self.symbol_input.setText("")
            self.symbol_input.setFocus()

    def get_selected_symbol(self):
        """Zwraca wybrany symbol"""
        return self.selected_symbol

class ScheduleChangeDialog(QDialog):
    """Dialog do edycji zmian w grafiku"""

    def __init__(self, parent=None, grouped_cells=None, year=None, month=None):
        super().__init__(parent)
        self.setWindowTitle("Wstaw zmianę grafiku")
        self.setMinimumWidth(800)  # Zwiększona szerokość dla dodatkowej kolumny
        self.setMinimumHeight(500)  # Zwiększona wysokość dla większej liczby wierszy

        self.parent = parent
        self.grouped_cells = grouped_cells
        self.year = year
        self.month = month

        # Spłaszcz dane - wszystkie komórki w jednej liście
        self.flattened_cells = self.flatten_grouped_cells(grouped_cells)

        # Wypisz dane do debugowania
        print("\nDane komórek przekazane do dialogu:")
        for i, cell in enumerate(self.flattened_cells):
            print(f"Komórka {i + 1}:")
            for key, value in cell.items():
                print(f"  {key}: {value}")

        # NOWE: Zastosuj motyw dialogu
        self.apply_dialog_theme()

        self.setup_ui()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu"""
        if self.parent and hasattr(self.parent, 'is_dark_theme'):
            theme = "dark" if self.parent.is_dark_theme else "light"
        else:
            theme = "dark"

        from styles import AppStyles
        self.setStyleSheet(AppStyles.get_dialog_style(theme))

    def flatten_grouped_cells(self, grouped_cells):
        """Spłaszcza pogrupowane komórki do jednej listy"""
        flattened = []
        if not grouped_cells:
            return flattened

        for user_id, dates in grouped_cells.items():
            for date, cells in dates.items():
                for cell in cells:
                    flattened.append(cell)
        return flattened

    def setup_ui(self):
        main_layout = QVBoxLayout(self)

        # Nagłówek
        header_label = QLabel("Edycja zmian w grafiku")
        main_layout.addWidget(header_label)

        # Tabela - NOWY STYL
        self.cells_table = QTableWidget()
        self.cells_table.setColumnCount(7)
        self.cells_table.setHorizontalHeaderLabels([
            "Data", "Użytkownik", "Symbol", "Lokalizacja",
            "Godzina rozpoczęcia", "Liczba godzin", "Akcje"
        ])

        # NOWE: Zastosuj styl tabeli
        theme = "dark" if (self.parent and hasattr(self.parent, 'is_dark_theme') and
                           self.parent.is_dark_theme) else "light"
        from styles import AppStyles
        self.cells_table.setStyleSheet(AppStyles.get_tablewidget_style(theme))

        # Ustaw właściwości dla lepszego wyświetlania
        self.cells_table.horizontalHeader().setStretchLastSection(False)
        self.cells_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Data
        self.cells_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Użytkownik
        self.cells_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeToContents)  # Symbol
        self.cells_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.ResizeToContents)  # Lokalizacja
        self.cells_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # Godzina rozpoczęcia
        self.cells_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Liczba godzin
        self.cells_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.Stretch)  # Akcje

        # Dodaj wiersze dla każdej komórki
        self.cells_table.setRowCount(len(self.flattened_cells))

        for row, cell in enumerate(self.flattened_cells):
            # Kolumna daty
            date_str = cell.get('date_str', '')
            date_item = QTableWidgetItem(self.format_date(date_str))
            date_item.setFlags(date_item.flags() & ~Qt.ItemIsEditable)  # Tylko do odczytu
            self.cells_table.setItem(row, 0, date_item)

            # Kolumna użytkownika
            user_name = cell.get('uzytkownik_dane', 'Nieznany')
            user_item = QTableWidgetItem(user_name)
            user_item.setFlags(user_item.flags() & ~Qt.ItemIsEditable)  # Tylko do odczytu
            self.cells_table.setItem(row, 1, user_item)

            # Kolumna symbolu
            symbol = cell.get('symbol', '')
            symbol_item = QTableWidgetItem(symbol)
            symbol_item.setFlags(symbol_item.flags() & ~Qt.ItemIsEditable)  # Tylko do odczytu
            self.cells_table.setItem(row, 2, symbol_item)

            # Parsowanie symbolu do składowych
            location_code = "h"  # Domyślnie HomeOffice
            start_hour = 8  # Domyślnie 8:00
            work_hours = 8  # Domyślnie 8h

            # Analiza symbolu
            from symbol_parser import parse_symbol

            parsed_symbol = parse_symbol(symbol)
            if parsed_symbol['location']:
                location_code = parsed_symbol['location']
            if parsed_symbol['start_hour'] is not None:
                start_hour = parsed_symbol['start_hour']
            if parsed_symbol['work_hours'] is not None:
                work_hours = parsed_symbol['work_hours']


            # Kolumna lokalizacji (Combo box)
            location_combo = QComboBox()
            location_combo.addItem("SBC (s)", "s")
            location_combo.addItem("mPrzystanek (p)", "p")
            location_combo.addItem("HomeOffice (h)", "h")

            # Ustaw odpowiednią lokalizację
            location_index = {'s': 0, 'p': 1, 'h': 2}.get(location_code, 2)
            location_combo.setCurrentIndex(location_index)
            self.cells_table.setCellWidget(row, 3, location_combo)

            # Kolumna godziny rozpoczęcia
            time_button = QPushButton(str(start_hour))
            time_button.setProperty("cell_index", row)
            time_button.setProperty("field_type", "hour")
            time_button.clicked.connect(self.show_digit_selection)
            time_button.setMinimumWidth(50)
            self.cells_table.setCellWidget(row, 4, time_button)

            # NOWA KOLUMNA: Liczba godzin (SpinBox)
            hours_button = QPushButton(str(work_hours))
            hours_button.setProperty("cell_index", row)
            hours_button.setProperty("field_type", "hours")
            hours_button.clicked.connect(self.show_digit_selection)
            hours_button.setMinimumWidth(50)
            self.cells_table.setCellWidget(row, 5, hours_button)

            # Przycisk akcji
            apply_button = QPushButton("Zastosuj")
            apply_button.setStyleSheet("background-color: #2196F3; color: white;")

            # Zapisz oryginalny indeks komórki w danych przycisku
            apply_button.setProperty("cell_index", row)

            # Połącz przycisk z obsługą z danymi komórki - używając indeksu komórki
            apply_button.clicked.connect(self.apply_change_by_index)

            self.cells_table.setCellWidget(row, 6, apply_button)

        main_layout.addWidget(self.cells_table)

        # Dodaj przyciski na dole
        button_layout = QHBoxLayout()

        # Przycisk zamknięcia
        close_button = QPushButton("Zamknij")
        # NOWE: Zastosuj styl przycisku
        close_button.setStyleSheet(AppStyles.get_button_style(theme))

        close_button.clicked.connect(self.close)

        button_layout.addStretch()
        button_layout.addWidget(close_button)
        main_layout.addLayout(button_layout)

    def show_digit_selection(self):
        """
        NOWA METODA: Pokazuje dialog wyboru cyfr
        """
        button = self.sender()
        if not button:
            return

        field_type = button.property("field_type")
        cell_index = button.property("cell_index")

        if field_type == "hour":
            # Godzina rozpoczęcia: 0-23
            values = list(range(24))
            title = "Wybierz godzinę rozpoczęcia"
        elif field_type == "hours":
            # Liczba godzin: 1-13
            values = list(range(1, 14))
            title = "Wybierz liczbę godzin"
        else:
            return

        # Pokaż dialog wyboru
        dialog = DigitSelectionDialog(self, title, values)
        if dialog.exec() == QDialog.Accepted:
            selected_value = dialog.get_selected_value()
            if selected_value is not None:
                button.setText(str(selected_value))
                # Zapisz wartość w danych przycisku
                button.setProperty("selected_value", selected_value)

    def apply_change_by_index(self):
        """
        POPRAWIONA WERSJA: Używa tej samej procedury co edycja klawiatury i "Wstaw nieobecność"
        """
        # Pobierz przycisk, który wywołał tę funkcję
        button = self.sender()
        if not button:
            return

        # Pobierz indeks komórki z właściwości przycisku
        cell_index = button.property("cell_index")
        if cell_index is None or cell_index >= len(self.flattened_cells):
            return

        # Pobierz dane komórki
        cell = self.flattened_cells[cell_index]

        # Pobierz wartości z kontrolek
        location_combo = self.cells_table.cellWidget(cell_index, 3)
        time_button = self.cells_table.cellWidget(cell_index, 4)  # Zmieniono
        hours_button = self.cells_table.cellWidget(cell_index, 5)  # Zmieniono

        if not location_combo or not time_button or not hours_button:
            QMessageBox.warning(self, "Błąd", "Nie można odczytać wartości.", QMessageBox.Ok)
            return

        location = location_combo.currentData()
        start_hour = time_button.property("selected_value")  # Zmieniono
        work_hours = hours_button.property("selected_value")  # Zmieniono

        # Sprawdź czy wartości zostały wybrane
        if start_hour is None:
            start_hour = int(time_button.text())  # Fallback na tekst przycisku
        if work_hours is None:
            work_hours = int(hours_button.text())  # Fallback na tekst przycisku

        # Pobierz dane potrzebne do wywołania procedury
        user_id = cell.get('uzytkownik_id')
        date_str = cell.get('date_str')
        nr_kadrowy = cell.get('nr_kadrowy')

        if not user_id or not date_str or not nr_kadrowy:
            QMessageBox.warning(self, "Błąd", "Niepełne dane komórki.", QMessageBox.Ok)
            return

        # KLUCZOWA ZMIANA: Zbuduj symbol z pól dialogu
        new_symbol = f"{location};{start_hour};{work_hours};"

        try:
            year, month, day = date_str.split('-')
            date_obj = f"{year}-{month}-{day}"

            # KLUCZOWA ZMIANA: Użyj tej samej procedury co edycja klawiatury
            result = self.parent._call_import_changes_procedure(
                nr_kadrowy=nr_kadrowy,
                rok=int(year),
                miesiac=int(month),
                data=date_obj,
                symbol=new_symbol
            )

            if result["success"]:
                # Zaktualizuj przycisk
                button.setText("Zmieniono ✓")
                button.setStyleSheet("background-color: #4CAF50; color: white;")

                # Zaktualizuj symbol w tabeli
                symbol_item = self.cells_table.item(cell_index, 2)
                if symbol_item:
                    symbol_item.setText(new_symbol)

                # KLUCZOWA ZMIANA: Odśwież tylko tę komórkę
                if self.parent and hasattr(self.parent, '_refresh_data_after_symbol_changes'):
                    self.parent._refresh_data_after_symbol_changes([(user_id, date_str)])
            else:
                QMessageBox.warning(self, "Błąd", result["message"], QMessageBox.Ok)

        except Exception as e:
            QMessageBox.critical(self, "Błąd", f"Wystąpił błąd: {str(e)}", QMessageBox.Ok)

    def format_date(self, date_str):
        """Formatuje ciąg daty z YYYY-MM-DD do DD.MM.YYYY"""
        try:
            year, month, day = date_str.split('-')
            return f"{day}.{month}.{year}"
        except:
            return date_str


class DigitSelectionDialog(QDialog):
    """
    Dialog do wyboru cyfry z siatki przycisków
    """

    def __init__(self, parent=None, title="Wybierz wartość", values=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setModal(True)
        self.selected_value = None

        if values is None:
            values = list(range(10))  # 0-9 domyślnie

        self.values = values

        # Ustaw stały rozmiar okna
        self.setFixedSize(200, 150)

        # Zastosuj motyw
        self.apply_dialog_theme()

        self.setup_ui()

    def apply_dialog_theme(self):
        """Stosuje motyw dla dialogu"""
        if hasattr(self, 'parent') and self.parent and hasattr(self.parent, 'is_dark_theme'):
            theme = "dark" if self.parent.is_dark_theme else "light"
        else:
            theme = "dark"

        from styles import AppStyles
        self.setStyleSheet(AppStyles.get_dialog_style(theme))

    def setup_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(10, 10, 10, 10)

        # Siatka przycisków
        grid_layout = QGridLayout()
        grid_layout.setSpacing(5)

        # Oblicz liczbę kolumn (maksymalnie 6)
        cols = min(6, len(self.values))

        for i, value in enumerate(self.values):
            row = i // cols
            col = i % cols

            button = QPushButton(str(value))
            button.setFixedSize(25, 25)
            button.setProperty("value", value)
            button.clicked.connect(self.on_value_selected)

            # Zastosuj styl przycisku
            theme = "dark" if (hasattr(self, 'parent') and self.parent and
                               hasattr(self.parent, 'is_dark_theme') and
                               self.parent.is_dark_theme) else "light"
            from styles import AppStyles
            button.setStyleSheet(AppStyles.get_button_style(theme))

            grid_layout.addWidget(button, row, col)

        main_layout.addLayout(grid_layout)

        # Przycisk Anuluj
        cancel_button = QPushButton("Anuluj")
        cancel_button.clicked.connect(self.reject)
        cancel_button.setStyleSheet(AppStyles.get_button_style(theme))

        button_layout = QHBoxLayout()
        button_layout.addStretch()
        button_layout.addWidget(cancel_button)
        main_layout.addLayout(button_layout)

    def on_value_selected(self):
        """Obsługuje wybór wartości"""
        button = self.sender()
        if button:
            self.selected_value = button.property("value")
            self.accept()

    def get_selected_value(self):
        """Zwraca wybraną wartość"""
        return self.selected_value
