import sys
import time
import getpass
from datetime import datetime, timedelta
from typing import List, Dict
import openpyxl
from openpyxl.styles import Font, Alignment, PatternFill
from openpyxl.utils import get_column_letter
import functools
# --- G≈Å√ìWNE IMPORTY (NIEZBƒòDNE PRZY STARCIE) ---
from PySide6.QtWidgets import (QApplication, QMainWindow, QTableView,
                               QVBoxLayout, QHBoxLayout, QWidget, QLabel, QComboBox,
                               QPushButton, QHeaderView, QAbstractItemView, QListWidget,
                               QListWidgetItem, QLineEdit, QDialog, QCheckBox, QFrame, QDateEdit,
                               QMessageBox, QSplitter, QStyledItemDelegate, QFileDialog,
                               QGridLayout, QSizePolicy, QScrollArea, QGroupBox, QStyle)
from PySide6.QtCore import Qt, Signal, QDate, QTimer, QEvent, QObject, QItemSelection, QItemSelectionModel
from packaging.version import parse as parse_version
from PySide6.QtGui import QShortcut, QKeySequence, QFont, QColor, QStandardItem, QStandardItemModel, QPixmap, QPainter, QPen, QIcon

from data_provider import DataProvider
from db_connector import DatabaseConnector, get_modifier_id, load_all_app_settings
from config import APP_VERSION, SQL_OBJECTS
from app_settings import app_settings
from settings_db import SettingsDatabase
from styles import AppStyles
from column_definitions import ColumnDefinitions
from schedule_model import ScheduleTableModel, ROLE_DATA
from events_model import EventsTableModel
from split_table_view import SplitTableView
from schedule_delegates import OvertimeItemDelegate
from schedule_edit_dialogs import ScheduleChangeDialog, ReasonDialog, OvertimeLocationDialog
from events_delegates import ButtonDelegate
from debug_utils import debug_print, log_warning, log_error, setup_logging, close_log_file
from symbol_parser import parse_symbol, build_symbol, get_symbol_description
from email_dialog import EmailDialog
from outlook_connector import create_outlook_email, create_email_from_template


class ScheduleKeyboardFilter(QObject):
    """
    Dedykowany filtr zdarze≈Ñ klawiatury dla tabeli grafiku z obs≈Çuga:
    - dwucyfrowych godzin i wieloznakowych symboli (z buforowaniem)
    - modyfikacji liczby godzin (+/-/=) z poprawnym od≈õwie≈ºaniem bilansu.
    """

    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self._digit_buffer = ""
        self._buffer_timer = QTimer()
        self._buffer_timer.setSingleShot(True)
        self._buffer_timer.timeout.connect(self._process_digit_buffer_on_timeout)
        self._buffer_timeout = 1200
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1200

        # Bufor i timer dla wieloznakowych symboli
        self._char_buffer = ""
        self._char_buffer_timer = QTimer()
        self._char_buffer_timer.setSingleShot(True)
        self._char_buffer_timer.timeout.connect(self._process_char_buffer)
        self._char_buffer_timeout = 1200

    def eventFilter(self, obj, event):
        """G≈Ç√≥wna metoda filtrujƒÖca zdarzenia klawiatury."""
        if not (hasattr(self.main_window, 'table') and
                hasattr(self.main_window.table, 'schedule_view') and
                obj == self.main_window.table.schedule_view and
                event.type() == QEvent.KeyPress):
            return False

        key = event.key()
        role = self.main_window.current_user_role

        if key in (Qt.Key_Plus, Qt.Key_Equal, Qt.Key_Minus):
            self._clear_digit_buffer()
            self._clear_char_buffer()
            # ZMIANA: Odwo≈Çanie do app_settings
            if app_settings.has_permission(role, 'schedule_keyboard_edit'):
                self._handle_hour_modification(key)
            return True

        # ZMIANA: Odwo≈Çanie do app_settings
        can_edit_hours_symbols = app_settings.has_permission(role, 'schedule_keyboard_edit')

        is_digit_key = (Qt.Key_0 <= key <= Qt.Key_9)
        is_char_key = (Qt.Key_A <= key <= Qt.Key_Z)
        is_delete_key = key in [Qt.Key_Delete, Qt.Key_Backspace]
        is_escape_key = key == Qt.Key_Escape

        if not can_edit_hours_symbols and (is_digit_key or is_char_key or is_delete_key):
            return True

        if is_digit_key or is_char_key or is_delete_key:
            if not self._validate_selected_cells():
                return True

        if is_digit_key:
            self._handle_digit_input(key - Qt.Key_0)
            return True

        if is_char_key:
            self._handle_char_input(event.text())
            return True

        if is_delete_key:
            # ZMIANA: Odwo≈Çanie do app_settings
            if app_settings.has_permission(role, 'action_delete_symbol'):
                self.main_window.clear_selected_cells()
            self._clear_digit_buffer()
            self._clear_char_buffer()
            return True

        if is_escape_key:
            self._clear_digit_buffer()
            self._clear_char_buffer()
            self.main_window.table.schedule_view.clearSelection()
            return True

        if key in [Qt.Key_Space, Qt.Key_Enter, Qt.Key_Return, Qt.Key_Tab]:
            return True

        return False

    def _handle_hour_modification(self, key):
        """Obs≈Çuguje zwiƒôkszanie/zmniejszanie liczby godzin (+/-/=) z uwzglƒôdnieniem uprawnie≈Ñ."""
        selected_cells_data = self.main_window.table.get_data_for_selected_cells()
        if not selected_cells_data: return

        updated_info = []
        error_messages = []
        skipped_count = 0
        permission_denied_count = 0
        current_user_role = self.main_window.current_user_role  # Pobierz rolƒô bie≈ºƒÖcego u≈ºytkownika

        for cell_data in selected_cells_data:
            permissions = self.main_window._get_permission_for_cell(cell_data)
            if not permissions['can_edit_hours']:
                permission_denied_count += 1
                continue

            system_pracy = cell_data.get('system_czasu_pracy', '')

            # --- POCZƒÑTEK ZMIANY ---
            # Sprawd≈∫ system pracy, ale zezw√≥l na edycjƒô dla roli 'Pracownik WPR'
            is_equivalent_system = system_pracy.strip().lower() == 'r√≥wnowa≈ºny'
            if not is_equivalent_system and current_user_role != 'Pracownik WPR':
                skipped_count += 1
                continue
            # --- KONIEC ZMIANY ---

            current_symbol = cell_data.get('symbol', '')
            if not current_symbol: continue

            try:
                parsed = parse_symbol(current_symbol)
                if parsed.get('work_hours') is None: continue

                current_hours = int(parsed['work_hours'])
                new_hours = min(12, current_hours + 1) if key in (Qt.Key_Plus, Qt.Key_Equal) else max(1,
                                                                                                      current_hours - 1)
                if new_hours == current_hours: continue

                new_symbol = build_symbol(
                    location=parsed.get('location'), start_hour=parsed.get('start_hour'),
                    work_hours=new_hours, special_symbol=parsed.get('special_symbol')
                )

                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self.main_window._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )

                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"‚ë≠ {cell_data.get('uzytkownik_dane')}: {result.get('message', 'B≈ÇƒÖd zapisu.')}")
            except (ValueError, TypeError) as e:
                log_warning(f"B≈ÇƒÖd modyfikacji godzin dla symbolu '{current_symbol}': {e}")
                error_messages.append(f"‚ë≠ {cell_data.get('uzytkownik_dane')}: B≈ÇƒÖd aplikacji: {e}")

        if permission_denied_count > 0:
            self.main_window.statusBar().showMessage(
                f"Pominiƒôto {permission_denied_count} kom√≥rek z powodu braku uprawnie≈Ñ do zmiany godzin.", 4000)

        if updated_info:
            self.main_window._update_cells_with_new_symbols(updated_info)
            self.main_window.statusBar().showMessage(f"Zmieniono liczbƒô godzin dla {len(updated_info)} kom√≥rek.", 4000)

        if error_messages:
            QMessageBox.warning(self.main_window, "B≈Çƒôdy podczas zapisu",
                                "WystƒÖpi≈Çy nastƒôpujƒÖce b≈Çƒôdy:\\n\\n" + "\\n".join(error_messages))
        elif not updated_info and skipped_count > 0 and skipped_count == len(selected_cells_data):
            self.main_window.statusBar().showMessage("Operacja dozwolona tylko dla R√≥wnowa≈ºnego Systemu Czasu Pracy.",
                                                     5000)

    def _handle_char_input(self, char: str):
        self._clear_digit_buffer()
        self._char_buffer += char.upper()
        self.main_window.statusBar().showMessage(f"Wpisywanie symbolu: {self._char_buffer}", self._char_buffer_timeout)
        if len(self._char_buffer) >= 3:
            self._char_buffer_timer.stop()
            self._process_char_buffer()
        else:
            self._char_buffer_timer.start(self._char_buffer_timeout)

    def _process_char_buffer(self):
        symbol = self._char_buffer
        self._clear_char_buffer()
        if not symbol: return

        # Krok 1: Sprawd≈∫, czy symbol jest w og√≥le poprawny
        if symbol in self.main_window.get_all_valid_symbols():

            # --- POCZƒÑTEK POPRAWKI ---
            # Krok 2: Sprawd≈∫, czy bie≈ºƒÖca rola ma uprawnienia do tego symbolu
            current_role = self.main_window.current_user_role
            if app_settings.has_symbol_permission(current_role, symbol):
                self.main_window.apply_symbol_from_keyboard(symbol)
            else:
                # Symbol jest poprawny, ale u≈ºytkownik nie ma uprawnie≈Ñ
                self.main_window.statusBar().showMessage(
                    f"Brak uprawnie≈Ñ do u≈ºycia symbolu '{symbol}' dla Twojej roli.", 4000)
            # --- KONIEC POPRAWKI ---

        else:
            # Symbol jest nieprawid≈Çowy
            self.main_window.statusBar().showMessage(f"B≈ÇƒÖd: Symbol '{symbol}' jest nieprawid≈Çowy!", 4000)

    def _handle_digit_input(self, digit: int):
        self._clear_char_buffer()
        self._digit_buffer += str(digit)
        self.main_window.statusBar().showMessage(f"Wpisywanie godziny: {self._digit_buffer}", self._buffer_timeout)

        if len(self._digit_buffer) == 1:
            if int(self._digit_buffer) >= 3:
                self.main_window.quick_edit_selected_cells(int(self._digit_buffer))
                self._clear_digit_buffer()
            else:
                self._buffer_timer.start(self._buffer_timeout)
        elif len(self._digit_buffer) == 2:
            self._buffer_timer.stop()
            potential_hour = int(self._digit_buffer)
            hour = potential_hour if 0 <= potential_hour <= 23 else int(self._digit_buffer[0])
            self.main_window.quick_edit_selected_cells(hour)
            self._clear_digit_buffer()
        else:
            self._buffer_timer.stop()
            self.main_window.quick_edit_selected_cells(digit)
            self._clear_digit_buffer()

    def _process_digit_buffer_on_timeout(self):
        if self._digit_buffer:
            self.main_window.quick_edit_selected_cells(int(self._digit_buffer))
            self._clear_digit_buffer()

    def _clear_digit_buffer(self):
        self._digit_buffer = ""
        if self._buffer_timer.isActive(): self._buffer_timer.stop()
        if self.main_window.statusBar().currentMessage().startswith("Wpisywanie godziny:"):
            self.main_window.statusBar().clearMessage()

    def _clear_char_buffer(self):
        self._char_buffer = ""
        if self._char_buffer_timer.isActive(): self._char_buffer_timer.stop()
        if self.main_window.statusBar().currentMessage().startswith("Wpisywanie symbolu:"):
            self.main_window.statusBar().clearMessage()

    def _validate_selected_cells(self) -> bool:
        selected_cells_data = self.main_window.table.get_data_for_selected_cells()
        if not selected_cells_data: return False
        return self.main_window._can_modify_cells(selected_cells_data)


class CustomMultiComboBox(QComboBox):
    """Niestandardowy ComboBox z obs≈Çuga wielokrotnego wyboru (wersja poprawiona)."""
    selection_changed = Signal()

    def __init__(self, parent=None):
        super().__init__(parent)

        self._selected_items = set()
        self._select_all_text = "-Wszystkie-"

        # Konfiguracja modelu
        self.setModel(QStandardItemModel(self))

        # Konfiguracja wyglƒÖdu
        self.setEditable(True)
        self.lineEdit().setReadOnly(True)
        self.setEditText("-Wszystkie-")
        self.setSizeAdjustPolicy(QComboBox.AdjustToContents)

        # U≈ºywamy filtra zdarze≈Ñ do przechwytywania klikniƒôƒá, co zapobiega zamykaniu listy
        self.view().viewport().installEventFilter(self)
        self.lineEdit().installEventFilter(self)

        # Delegat jest potrzebny do poprawnego renderowania
        self.setItemDelegate(QStyledItemDelegate(self))

    def eventFilter(self, obj, event):
        # Przechwytujemy klikniƒôcie myszƒÖ w polu tekstowym, aby pokazaƒá listƒô
        if obj == self.lineEdit() and event.type() == QEvent.MouseButtonPress:
            self.showPopup()
            return True

        # Przechwytujemy zwolnienie przycisku myszy na li≈õcie (widoku)
        if obj == self.view().viewport() and event.type() == QEvent.MouseButtonRelease:
            index = self.view().indexAt(event.position().toPoint())  # U≈ºyj .position().toPoint() zamiast .pos()
            if index.isValid():
                self.handle_item_pressed(index)
            return True

        return False

    def handle_item_pressed(self, index):
        """Logika zaznaczania/odznaczania elementu."""
        item = self.model().itemFromIndex(index)
        if not item:
            return

        if item.text() == self._select_all_text:
            # Logika dla przycisku "Zaznacz wszystkie"
            is_checked = (item.checkState() == Qt.Checked)
            new_state = Qt.Unchecked if is_checked else Qt.Checked
            for i in range(1, self.model().rowCount()):
                self.model().item(i).setCheckState(new_state)
        else:
            # Logika dla zwyk≈Çego elementu
            current_state = item.checkState()
            item.setCheckState(Qt.Checked if current_state == Qt.Unchecked else Qt.Unchecked)

        self._rebuild_selected_items()
        self.update_display_text()

        self.selection_changed.emit()

    def _rebuild_selected_items(self):
        """Przebudowuje zbi√≥r zaznaczonych element√≥w na podstawie stanu modelu."""
        self._selected_items.clear()
        all_selected = True
        # Pƒôtla od 1, aby pominƒÖƒá element "Zaznacz wszystkie"
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.checkState() == Qt.Checked:
                self._selected_items.add(item.text())
            else:
                all_selected = False

        # Aktualizuj stan checkboxa "Zaznacz wszystkie"
        if self.model().rowCount() > 0:
            select_all_item = self.model().item(0)
            select_all_item.setCheckState(Qt.Checked if all_selected else Qt.Unchecked)

    def hidePopup(self):
        """Aktualizuje tekst po zamkniƒôciu listy."""
        self.update_display_text()
        super().hidePopup()

    def add_items(self, items):
        """Dodaje elementy do ComboBoxa."""
        self.clear()

        select_all_item = QStandardItem(self._select_all_text)
        select_all_item.setCheckable(True)
        self.model().appendRow(select_all_item)

        for item_text in sorted(items):
            item = QStandardItem(item_text)
            item.setCheckable(True)
            self.model().appendRow(item)

        self.update_display_text()

    def showPopup(self):
        """Poka≈º menu rozwijane z dostosowanƒÖ szeroko≈õciƒÖ."""
        super().showPopup()

        width = self.view().sizeHintForColumn(0) + 20
        width = min(width, 450)
        self.view().setMinimumWidth(width)

    def clear(self):
        """Czy≈õci listƒô element√≥w."""
        self.model().clear()
        self._selected_items.clear()
        self.setEditText("-Wszystkie-")

    def clear_selection(self):
        """Czy≈õci zaznaczenie wszystkich element√≥w i emituje sygna≈Ç o zmianie."""
        for i in range(self.model().rowCount()):
            self.model().item(i).setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()
        # ZMIANA: Dodano emisjƒô sygna≈Çu, aby od≈õwie≈ºyƒá filtrowanie
        self.selection_changed.emit()

    def get_selected_items(self):
        """Zwraca listƒô zaznaczonych element√≥w."""
        return list(self._selected_items)

    def select_items(self, items_to_select):
        """Zaznacza programowo okre≈õlone elementy na li≈õcie."""
        lookup = set(items_to_select)
        for i in range(1, self.model().rowCount()):
            item = self.model().item(i)
            if item.text() in lookup:
                item.setCheckState(Qt.Checked)
            else:
                item.setCheckState(Qt.Unchecked)
        self._rebuild_selected_items()
        self.update_display_text()

    def update_display_text(self):
        """Aktualizuje tekst wy≈õwietlany w comboboxie."""
        if not self._selected_items or len(self._selected_items) == (self.model().rowCount() - 1):
            self.setEditText("-Wszystkie-")
        else:
            self.setEditText(f"Wybrano {len(self._selected_items)} z {self.model().rowCount() - 1}")

class UpdateRequiredDialog(QDialog):
    """Modalne okno informujƒÖce o konieczno≈õci aktualizacji i wymuszajƒÖce zamkniƒôcie."""

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Wymagana aktualizacja")
        self.setModal(True)
        self.setWindowFlags(Qt.Dialog | Qt.CustomizeWindowHint | Qt.WindowTitleHint)

        self.countdown = 15

        layout = QVBoxLayout(self)
        info_label = QLabel(
            "<b>Dostƒôpna jest nowa wersja aplikacji.</b><br><br>"
            "Aby zapewniƒá sp√≥jno≈õƒá danych i dostƒôp do nowych funkcji, dalsza praca na tej wersji nie jest mo≈ºliwa.<br>"

        )
        info_label.setAlignment(Qt.AlignCenter)
        layout.addWidget(info_label)

        self.countdown_label = QLabel(f"Aplikacja zostanie zamkniƒôta za {self.countdown} sekund...")
        self.countdown_label.setAlignment(Qt.AlignCenter)
        self.countdown_label.setStyleSheet("font-weight: bold; color: #e74c3c;")
        layout.addWidget(self.countdown_label)

        self.timer = QTimer(self)
        self.timer.setInterval(1000)
        self.timer.timeout.connect(self.update_countdown)
        self.timer.start()

    def update_countdown(self):
        self.countdown -= 1
        self.countdown_label.setText(f"Aplikacja zostanie zamkniƒôta za {self.countdown} sekund...")
        if self.countdown <= 0:
            self.timer.stop()
            self.accept()


class WorkScheduleWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self._state_to_restore = None

        self.settings_db = SettingsDatabase()
        try:
            current_windows_user = getpass.getuser().lower()
        except Exception:
            current_windows_user = "unknown_user"

        self.user_settings = self.settings_db.load_settings(login_windows=current_windows_user)
        debug_print(f"ZA≈ÅADOWANE USTAWIENIA U≈ªYTKOWNIKA: {self.user_settings}")

        self.clear_icon_dark = self._create_clear_icon(QColor("#d0d0d0"))
        self.clear_icon_light = self._create_clear_icon(QColor("#505050"))
        self.is_dark_theme = self.user_settings.get('theme') == 'dark'
        self.current_font = self.user_settings.get('font_family', 'Segoe UI')
        self.current_font_size = self.user_settings.get('font_size', 9)
        self.import_grupa = self.user_settings.get('import_grupa', 3)
        self.import_funkcja = self.user_settings.get('import_funkcja', 1)
        self.column_definitions = ColumnDefinitions()
        self.default_visible_columns = self.column_definitions.DEFAULT_VISIBLE_COLUMNS
        saved_columns = self.user_settings.get('visible_columns')
        self.visible_columns = saved_columns if saved_columns else self.default_visible_columns.copy()
        self.user_sort_preferences = self.user_settings.get('sort_preferences', [])
        self.show_comment_column = self.user_settings.get('show_schedule_comment', False)

        self.staffing_details_win = None
        self.current_user_role = None
        self.data_provider = DataProvider()
        self.data_provider.data_changed.connect(self._handle_specific_icons_refresh)
        self.employee_columns = self.column_definitions.get_ui_display_columns()

        self.setWindowTitle("TeamFlowApp")

        self._selection_timer = QTimer()
        self._selection_timer.setSingleShot(True)
        self._selection_timer.timeout.connect(self._handle_selection_change)
        self._selection_debounce_delay = 50

        font = QFont(self.current_font, self.current_font_size)
        QApplication.setFont(font)

        self.schedule_model = ScheduleTableModel(self)
        self.schedule_model.set_visible_columns(self.visible_columns)
        self.events_model = EventsTableModel(self)

        self._create_central_widget()

        self.table.set_model(self.schedule_model)
        self.events_table.setModel(self.events_model)
        self.manage_columns_button.clicked.connect(self.show_column_select_dialog)

        if self.table.employees_view.selectionModel():
            self.table.employees_view.selectionModel().selectionChanged.connect(self.on_selection_changed)
        if self.table.schedule_view.selectionModel():
            self.table.schedule_view.selectionModel().selectionChanged.connect(self.on_selection_changed)

        self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font, self.current_font_size)

        self.shortcut_f1 = QShortcut(QKeySequence(Qt.Key_F1), self)
        self.shortcut_f1.activated.connect(self.toggle_left_panel)

        self.shortcut_f2 = QShortcut(QKeySequence(Qt.Key_F2), self)
        self.shortcut_f2.activated.connect(self.toggle_events_panel)

        self.shortcut_f3 = QShortcut(QKeySequence(Qt.Key_F3), self)
        self.shortcut_f3.activated.connect(self.show_insert_change_dialog)

        self.shortcut_f4 = QShortcut(QKeySequence(Qt.Key_F4), self)
        self.shortcut_f4.activated.connect(self.show_insert_symbol_dialog)

        self.shortcut_insert = QShortcut(QKeySequence(Qt.Key_Insert), self)
        self.shortcut_insert.activated.connect(self.show_add_overtime_dialog)

        self.shortcut_f12 = QShortcut(QKeySequence(Qt.Key_F12), self)
        self.shortcut_f12.activated.connect(self.clear_special_symbol_from_selected_cells)

        self.copy_shortcut = QShortcut(QKeySequence.Copy, self)
        self.copy_shortcut.activated.connect(self.copy_selection_to_clipboard)

        self.start_full_initialization()

        # PRZENIESIONY BLOK: Ustawienie rozmiaru i pokazanie okna na samym ko≈Ñcu
        if self.user_settings.get('is_maximized'):
            self.showMaximized()
        else:
            width, height = self.user_settings.get('window_size', (1600, 800))
            self.setGeometry(100, 100, width, height)

        debug_print("=== APLIKACJA URUCHOMIONA W TRYBIE AUTOMATYCZNYM ===")

    def manage_ui_state(self, enabled: bool):
        """W≈ÇƒÖcza lub wy≈ÇƒÖcza kluczowe elementy interfejsu u≈ºytkownika."""
        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(enabled)

        action_buttons = [
            self.settings_button, self.refresh_button, self.show_audit_button,
            self.staffing_details_button, self.schedule_control_button,
            self.manage_columns_button, self.toggle_events_panel_button,
            self.insert_change_button, self.insert_symbol_button,
            self.cancel_delegation_button, self.add_overtime_button
        ]
        for button in action_buttons:
            if hasattr(self, button.objectName()):
                button.setEnabled(enabled)

        if hasattr(self, 'date_combo'):
            self.date_combo.setEnabled(enabled)

    def start_full_initialization(self):
        """Uruchamia pe≈ÇnƒÖ inicjalizacjƒô po sprawdzeniu wersji i uprawnie≈Ñ."""
        self.load_data_button.setText("Sprawdzanie uprawnie≈Ñ...")
        self.load_data_button.setEnabled(False)
        QApplication.processEvents()

        if not self.check_user_permissions():
            QTimer.singleShot(10, self.close)
            return

        self.manage_ui_state(enabled=True)
        self.load_data_button.setVisible(False)
        self.refresh_button.setVisible(True)

        self.setup_table_properties()
        self.setup_keyboard_editing()

        self.setup_date_combo()
        self.load_initial_data()

        self.check_timer = QTimer(self)
        self.check_timer.timeout.connect(self.check_for_new_data)
        self.check_timer.start(60000)

    def check_if_update_is_required(self) -> bool:
        """Sprawdza wersjƒô aplikacji na podstawie za≈Çadowanych ustawie≈Ñ."""
        # Por√≥wnujemy wersje. Funkcja zwraca tylko wynik, nie zamyka ju≈º aplikacji.
        return parse_version(APP_VERSION) != parse_version(app_settings.REQUIRED_VERSION)

    def show_staffing_details_window(self):
        from staffing_details_window import StaffingDetailsWindow
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Brak danych", "Proszƒô wybraƒá miesiƒÖc, aby wy≈õwietliƒá szczeg√≥≈Çy obsady.",
                                QMessageBox.Ok)
            return
        year, month = current_data
        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            self.staffing_details_win.activateWindow()
            self.staffing_details_win.raise_()
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.update_for_new_month_or_filters(year, month)
        else:
            self.staffing_details_win = StaffingDetailsWindow(
                self, self.data_provider, year, month, self.import_grupa, self.import_funkcja
            )
            self.staffing_details_win.set_current_theme(self.is_dark_theme)
            self.staffing_details_win.show()

    def setup_keyboard_editing(self):
        """Konfiguruje edycjƒô klawiatury dla kom√≥rek grafiku"""
        if not app_settings.has_permission(self.current_user_role, 'schedule_keyboard_edit'):
            debug_print(f"Edycja klawiatury wy≈ÇƒÖczona - rola '{self.current_user_role}' nie ma uprawnie≈Ñ.")
            return

        self.keyboard_filter = ScheduleKeyboardFilter(self)
        if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
            self.table.schedule_view.installEventFilter(self.keyboard_filter)
            debug_print(f"W≈ÇƒÖczono edycjƒô klawiatury dla roli: {self.current_user_role}")

    def cleanup_keyboard_filter(self):
        """Czy≈õci filtr klawiatury przy zamykaniu aplikacji"""
        if hasattr(self, 'keyboard_filter'):
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.removeEventFilter(self.keyboard_filter)
            del self.keyboard_filter
            debug_print("Wyczyszczono filtr klawiatury")

    def _should_ask_for_confirmation(self) -> bool:
        """
        Sprawdza, czy nale≈ºy wy≈õwietliƒá okno dialogowe z pro≈õbƒÖ o potwierdzenie.
        Zwraca False, je≈õli grafik nie jest opublikowany (praca "na brudno"), True w przeciwnym wypadku.
        """
        current_data = self.date_combo.currentData()
        if not current_data:
            return True  # W razie wƒÖtpliwo≈õci, dla bezpiecze≈Ñstwa pytaj

        year, month = current_data
        is_published = self.data_provider.is_schedule_published(year, month)

        # Pytamy o potwierdzenie tylko wtedy, gdy grafik JEST opublikowany.
        return is_published

    def _get_permission_for_cell(self, cell_data: dict) -> dict:
        permissions = {'can_edit_hours': False, 'can_edit_symbol': False, 'can_edit_location': False,
                       'can_delete': False}
        if not cell_data: return permissions

        user_role, user_dept = self.current_user_role, self.current_user_department
        target_role, target_dept = cell_data.get('rola_nazwa'), cell_data.get('wydzial')

        # --- POCZƒÑTEK NOWEJ LOGIKI ---
        # Specjalna regu≈Ça: Lider i Lider OUT mogƒÖ wstawiƒá symbol 'CO' osobom z wydzia≈Çu DTN.
        # Przyznajemy im tylko uprawnienie do edycji symbolu w tym konkretnym przypadku.
        if user_role in ['Lider', 'Lider OUT'] and target_dept and target_dept.strip().lower() == 'dtn':
            return {'can_edit_hours': False, 'can_edit_symbol': True, 'can_edit_location': False, 'can_delete': False}
        # --- KONIEC NOWEJ LOGIKI ---

        if user_role == 'Pracownik WPR':
            return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}

        is_in_same_department = False
        if user_dept and target_dept:
            if target_dept.strip().lower().startswith(user_dept.strip().lower()):
                is_in_same_department = True

        if not is_in_same_department: return permissions

        if user_role == 'Lider OUT':
            return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}

        if user_role == 'Lider':
            if target_role == 'Lider':
                return {'can_edit_hours': True, 'can_edit_symbol': True, 'can_edit_location': True, 'can_delete': True}
            else:
                return {'can_edit_hours': False, 'can_edit_symbol': True, 'can_edit_location': True,
                        'can_delete': False}

        return permissions

    def quick_edit_selected_cells(self, start_hour):
        """Szybka edycja zaznaczonych kom√≥rek z klawiatury"""
        try:
            if not app_settings.has_permission(self.current_user_role, 'schedule_keyboard_edit'):
                return

            selected_cells_data = self.table.get_data_for_selected_cells()
            if not self._can_modify_cells(selected_cells_data) or not selected_cells_data:
                return

            schedule_cells = [cell for cell in selected_cells_data if isinstance(cell, dict) and 'date_str' in cell and 'uzytkownik_id' in cell]
            if not schedule_cells:
                return

            grouped_changes = {}
            for cell_data in schedule_cells:
                user_id, user_name, date_str = cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane', ''), cell_data.get('date_str')
                try:
                    year, month, day = date_str.split('-')
                    formatted_date = f"{day}.{month}.{year}"
                except:
                    formatted_date = date_str
                user_key = (user_id, user_name)
                if user_key not in grouped_changes:
                    grouped_changes[user_key] = []
                grouped_changes[user_key].append(formatted_date)

            changes_info = f"Zmiana godziny rozpoczƒôcia na {start_hour}:00 dla:\n\n"
            for (user_id, user_name), dates in grouped_changes.items():
                changes_info += f"üßë {user_name}:\n"
                dates_str = ", ".join(sorted(dates))
                changes_info += f"   üìÖ {dates_str}\n\n"
            changes_info += f"≈ÅƒÖcznie: {len(schedule_cells)} kom√≥rek"

            reply = QMessageBox.Yes  # Domy≈õlnie zak≈Çadamy, ≈ºe u≈ºytkownik siƒô zgadza
            if self._should_ask_for_confirmation():
                reply = QMessageBox.question(self, "Potwierdzenie szybkiej edycji", changes_info, QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
            if reply == QMessageBox.Yes:
                self._apply_quick_changes(schedule_cells, start_hour)
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas szybkiej edycji: {e}")
            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas edycji: {str(e)}", QMessageBox.Ok)

    def _apply_quick_changes(self, schedule_cells, start_hour):
        """Stosuje szybkƒÖ zmianƒô godziny z indywidualnym sprawdzaniem uprawnie≈Ñ."""
        updated_info, error_messages, skipped_employees = [], [], []

        for cell_data in schedule_cells:
            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_edit_hours']:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue

            current_symbol = cell_data.get('symbol', '')
            parsed = parse_symbol(current_symbol)
            try:
                work_hours = int(float(cell_data.get('etat', 8.0)))
            except (ValueError, TypeError):
                work_hours = 8

            location_for_build = parsed.get('location') or self.determine_correct_location(cell_data)

            new_symbol = build_symbol(
                location=location_for_build,
                start_hour=start_hour,
                work_hours=parsed.get('work_hours') or work_hours,
                special_symbol=parsed.get('special_symbol')
            )
            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"üó£Ô∏è {cell_data.get('uzytkownik_dane')}: {result.get('message', 'B≈ÇƒÖd zapisu.')}")
            except Exception as e:
                log_error(f"B≈ÇƒÖd krytyczny w _apply_quick_changes: {e}")
                error_messages.append(f"üó£Ô∏è {cell_data.get('uzytkownik_dane')}: B≈ÇƒÖd aplikacji: {e}")

        if updated_info:
            self._update_cells_with_new_symbols(updated_info)

        success_msg = f"Zmieniono godzinƒô rozpoczƒôcia dla {len(updated_info)} kom√≥rek."
        if skipped_employees:
            QMessageBox.information(self, "Czƒô≈õciowy sukces",
                                    f"{success_msg}\\n\\nPominiƒôto {len(skipped_employees)} kom√≥rek z powodu braku uprawnie≈Ñ dla:\\n"
                                    f"- {', '.join(set(skipped_employees))}")
        elif updated_info:
            self.statusBar().showMessage(success_msg, 4000)

        if error_messages:
            QMessageBox.warning(self, "B≈Çƒôdy podczas zapisu",
                                "WystƒÖpi≈Çy nastƒôpujƒÖce b≈Çƒôdy:\\n\\n" + "\\n".join(error_messages))

    def _show_keyboard_edit_results(self, successful_updates, failed_updates, error_messages, start_hour):
        """Pokazuje wyniki edycji klawiatury - uproszczone komunikaty"""
        if successful_updates > 0:
            message = f"Pomy≈õlnie zaktualizowano {successful_updates} kom√≥rek (cyfra: {start_hour})"
            if failed_updates > 0:
                message += f"\n\n‚ö†Ô∏è {failed_updates} aktualizacji nie powiod≈Ço siƒô"
                if error_messages:
                    message += ":\n" + "\n".join(error_messages[:3])
                    if len(error_messages) > 3:
                        message += f"\n... i {len(error_messages) - 3} wiƒôcej b≈Çƒôd√≥w"
            QMessageBox.information(self, "Edycja klawiatury", message, QMessageBox.Ok)
        else:
            message = f"Nie uda≈Ço siƒô zaktualizowaƒá ≈ºadnej kom√≥rki (cyfra: {start_hour})"
            if error_messages:
                message += f"\n\nB≈Çƒôdy:\n" + "\n".join(error_messages[:5])
            QMessageBox.warning(self, "B≈ÇƒÖd edycji klawiatury", message, QMessageBox.Ok)

    def _prepare_deletion_summary_message(self, schedule_cells: list) -> str:
        """
        Przygotowuje sformatowanƒÖ wiadomo≈õƒá podsumowujƒÖcƒÖ, kt√≥re symbole zostanƒÖ usuniƒôte,
        grupujƒÖc je wed≈Çug u≈ºytkownika i dat.
        """
        if not schedule_cells:
            return "Nie wybrano ≈ºadnych kom√≥rek z symbolami do usuniƒôcia."
        grouped_deletions = {}
        for cell_data in schedule_cells:
            user_name = cell_data.get('uzytkownik_dane', 'Nieznany U≈ºytkownik')
            date_str = cell_data.get('date_str', 'Nieznana Data')
            symbol = cell_data.get('symbol', '??')
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except ValueError:
                formatted_date = date_str
            if user_name not in grouped_deletions:
                grouped_deletions[user_name] = []
            grouped_deletions[user_name].append(f"{formatted_date} (symbol: {symbol})")

        summary_lines = ["Czy na pewno chcesz usunƒÖƒá symbole dla nastƒôpujƒÖcych pozycji?\n"]
        for user_name, date_symbol_list in grouped_deletions.items():
            summary_lines.append(f"üßë {user_name}:")
            for date_with_symbol in sorted(date_symbol_list):
                summary_lines.append(f"   ‚Ä¢ {date_with_symbol}")
            summary_lines.append("")
        summary_lines.append(f"≈ÅƒÖcznie zostanie wyczyszczonych: {len(schedule_cells)} kom√≥rek.")
        return "\n".join(summary_lines)

    def clear_selected_cells(self):
        try:
            if hasattr(self, 'keyboard_filter') and hasattr(self.keyboard_filter, '_buffer_timer'):
                self.keyboard_filter._buffer_timer.stop()
                self.keyboard_filter._digit_buffer = ""

            selected_cells_data = self.table.get_data_for_selected_cells()
            if not selected_cells_data:
                return

            schedule_cells = [cell for cell in selected_cells_data if cell.get('symbol', '').strip()]
            if not schedule_cells:
                QMessageBox.information(self, "Brak symboli do usuniƒôcia", "Zaznaczone kom√≥rki sƒÖ ju≈º puste.", QMessageBox.Ok)
                return

            # Wstƒôpne sprawdzenie (mo≈ºna pominƒÖƒá, bo i tak sprawdzamy w pƒôtli, ale zostawiamy dla szybkiego feedbacku)
            if not any(self._get_permission_for_cell(c)['can_delete'] for c in schedule_cells):
                 QMessageBox.warning(self, "Brak uprawnie≈Ñ", "Nie posiadasz uprawnie≈Ñ do usuniƒôcia symboli dla ≈ºadnej z zaznaczonych os√≥b.")
                 return

            user_date_pairs = {(cell.get('uzytkownik_id'), cell.get('date_str')) for cell in schedule_cells}
            events_to_cancel = self._find_events_to_cancel(user_date_pairs)

            reply = QMessageBox.Yes
            if self._should_ask_for_confirmation():
                confirmation_message = self._prepare_deletion_summary_message(schedule_cells)
                if events_to_cancel:
                    grouped_events = self._group_events_by_user_date(events_to_cancel)
                    delegations_info = self._prepare_delegations_description(grouped_events)
                    confirmation_message += f"\n\n{delegations_info}"
                reply = QMessageBox.question(self, "Potwierdzenie usuniƒôcia", confirmation_message, QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

            if reply == QMessageBox.Yes:
                if events_to_cancel: self._cancel_delegations(events_to_cancel)
                self._clear_cells_symbols(schedule_cells)
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas czyszczenia kom√≥rek: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd krytyczny", f"WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd: {str(e)}")


    def _clear_cells_symbols(self, schedule_cells: list):
        """Usuwa symbole z indywidualnym sprawdzaniem uprawnie≈Ñ."""
        successful_updates, failed_updates = 0, 0
        error_messages, affected_pairs, skipped_employees = [], [], []

        for cell_data in schedule_cells:
            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_delete']:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue

            user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get('date_str'), cell_data.get('nr_kadrowy')

            if not all([user_id, date_str, nr_kadrowy]):
                failed_updates += 1
                error_messages.append(f"Niekompletne dane dla kom√≥rki: user_id={user_id}, data={date_str}, nr_kadrowy={nr_kadrowy}.")
                continue

            try:
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol="")
                if result.get('success', False):
                    successful_updates += 1
                    affected_pairs.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    failed_updates += 1
                    error_msg = result.get('message', 'Nieznany b≈ÇƒÖd.')
                    error_messages.append(f"Pracownik {nr_kadrowy} (dnia {date_str}): {error_msg}")
            except Exception as e:
                failed_updates += 1
                error_messages.append(f"{nr_kadrowy} ({date_str}): B≈ÇƒÖd krytyczny - {str(e)}")
                log_error(f"Krytyczny b≈ÇƒÖd podczas usuwania symbolu dla {user_id}, {date_str}: {e}", exception=e)

        if successful_updates > 0:
            self._update_cells_with_new_symbols(affected_pairs)

        self._show_clear_symbols_results(successful_updates, failed_updates, error_messages, skipped_employees)

    def _show_clear_symbols_results(self, successful_updates: int, failed_updates: int, error_messages: list,
                                    skipped_employees: list):
        """
        Wy≈õwietla u≈ºytkownikowi podsumowanie operacji usuwania symboli,
        uwzglƒôdniajƒÖc kom√≥rki pominiƒôte z powodu braku uprawnie≈Ñ.
        """
        title = ""
        full_message = ""

        # Komunikat o sukcesach
        if successful_updates > 0:
            full_message += f"Pomy≈õlnie usuniƒôto symbole z {successful_updates} kom√≥rek.\\n"

        # Komunikat o pominiƒôtych pracownikach z powodu braku uprawnie≈Ñ
        if skipped_employees:
            # U≈ºywamy set(), aby uniknƒÖƒá duplikat√≥w nazwisk w komunikacie
            unique_skipped = set(skipped_employees)
            full_message += (f"\\nPominiƒôto {len(skipped_employees)} kom√≥rek z powodu braku uprawnie≈Ñ dla:\\n"
                             f"- {', '.join(unique_skipped)}\\n")

        # Komunikat o b≈Çƒôdach
        if failed_updates > 0:
            title = "Czƒô≈õciowy sukces" if successful_updates > 0 or skipped_employees else "B≈ÇƒÖd usuwania"
            error_list_str = "\\n - " + "\\n - ".join(error_messages[:10])
            full_message += f"\\nNie uda≈Ço siƒô usunƒÖƒá {failed_updates} symboli z powodu b≈Çƒôd√≥w:{error_list_str}"
            if len(error_messages) > 10:
                full_message += f"\\n... i {len(error_messages) - 10} wiƒôcej b≈Çƒôd√≥w."

        elif successful_updates > 0 or skipped_employees:
            title = "Zako≈Ñczono operacjƒô"

        # Wy≈õwietl komunikat tylko, je≈õli cokolwiek siƒô wydarzy≈Ço
        if full_message:
            # Je≈õli nie by≈Ço b≈Çƒôd√≥w ani pominiƒôƒá, poka≈º tylko informacjƒô na pasku statusu
            if successful_updates > 0 and failed_updates == 0 and not skipped_employees:
                self.statusBar().showMessage(full_message.strip(), 4000)
            else:
                # W przeciwnym razie, poka≈º pe≈Çne okno dialogowe z podsumowaniem
                QMessageBox.information(self, title, full_message.strip())

    def set_cell_data(self, row, col, data_dict):
        """Ustawia dane w kom√≥rce modelu."""
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return False

        if not isinstance(data_dict, dict):
            log_error(f"B≈ÇƒÖd: data_dict nie jest s≈Çownikiem: {type(data_dict)}")
            return False

        # Utw√≥rz indeks modelu dla podanej pozycji
        index = self.schedule_model.index(row, col)
        if not index.isValid():
            return False

        # Ustaw dane w modelu
        return self.schedule_model.setData(index, data_dict, Qt.UserRole)

    def on_data_changed(self, data_type, year, month):
        """Obs≈Çuguje powiadomienie o zmianie danych z DataProvider."""
        current_data = self.date_combo.currentData()
        if not (current_data and current_data == (year, month)):
            return

        if data_type == "schedule":
            self.update_table_content()
        elif data_type == "events":
            # Po prostu od≈õwie≈ºamy tabelƒô zdarze≈Ñ, je≈õli co≈õ siƒô w nich zmieni≈Ço
            self.on_selection_changed()

    def log_time(self, label, start_time):
        """Pomocnicza funkcja do logowania czasu"""
        end_time = time.time()
        elapsed = end_time - start_time
        debug_print(f"[CZAS] {label}: {elapsed:.3f} sekundy")
        return end_time

    def _create_central_widget(self):
        """Tworzy i ustawia g≈Ç√≥wny widget aplikacji."""
        central_widget = QWidget()
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(10, 0, 10, 0)
        main_layout.setSpacing(0)

        top_bar = self.setup_top_bar(main_layout)
        main_layout.addWidget(top_bar)

        middle_splitter = self.setup_middle_section(main_layout)
        main_layout.addWidget(middle_splitter, 1)

        self.setCentralWidget(central_widget)
        
    def setup_top_bar(self, main_layout):
        top_bar_frame = QFrame()
        top_bar_frame.setFrameShape(QFrame.StyledPanel)
        top_bar_frame.setFrameShadow(QFrame.Raised)
        top_bar_frame.setFixedHeight(50)
        top_bar_layout = QHBoxLayout(top_bar_frame)
        top_bar_layout.setContentsMargins(5, 5, 5, 5)
        top_bar_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)

        self.toggle_menu_button = QPushButton("‚ò∞")
        self.toggle_menu_button.setFixedSize(32, 32)
        self.toggle_menu_button.setToolTip("Poka≈º/ukryj panel filtr√≥w (F1)")
        self.toggle_menu_button.clicked.connect(self.toggle_left_panel)
        top_bar_layout.addWidget(self.toggle_menu_button)

        self.settings_button = QPushButton("Ustawienia")
        self.settings_button.clicked.connect(self.show_settings_dialog)
        top_bar_layout.addWidget(self.settings_button)

        top_bar_layout.addWidget(self.create_separator())

        top_bar_layout.addWidget(QLabel("MiesiƒÖc:"))
        self.date_combo = QComboBox()
        self.date_combo.setMinimumWidth(120)
        # --- POCZƒÑTEK POPRAWKI: Pozostawiono tylko jedno, poprawne pod≈ÇƒÖczenie ---
        self.date_combo.currentIndexChanged.connect(self.refresh_data)
        # --- KONIEC POPRAWKI ---
        top_bar_layout.addWidget(self.date_combo)

        self.load_data_button = QPushButton("üöÄ Pobierz Dane")
        self.load_data_button.setToolTip("Kliknij, aby po≈ÇƒÖczyƒá siƒô z bazƒÖ i za≈Çadowaƒá dane.")
        top_bar_layout.addWidget(self.load_data_button)
        self.load_data_button.setVisible(True)

        self.refresh_button = QPushButton("Od≈õwie≈º")
        self.refresh_button.setToolTip("Od≈õwie≈º dane dla bie≈ºƒÖcych filtr√≥w")
        self.refresh_button.clicked.connect(self.refresh_data)
        top_bar_layout.addWidget(self.refresh_button)
        self.refresh_button.setVisible(False)

        self.export_button = QPushButton("Eksportuj do Excel")
        self.export_button.setToolTip("Zapisz aktualny widok grafiku do pliku Excel (.xlsx)")
        self.export_button.clicked.connect(self.export_schedule_to_excel)
        top_bar_layout.addWidget(self.export_button)

        self.show_audit_button = QPushButton("Historia Zmian")
        self.show_audit_button.clicked.connect(self.show_audit_log_window)
        top_bar_layout.addWidget(self.show_audit_button)

        self.staffing_details_button = QPushButton("Obsada")
        self.staffing_details_button.clicked.connect(self.show_staffing_details_window)
        top_bar_layout.addWidget(self.staffing_details_button)

        self.schedule_control_button = QPushButton("ZarzƒÖdzaj Grafikiem")
        self.schedule_control_button.clicked.connect(self.show_schedule_control_dialog)
        top_bar_layout.addWidget(self.schedule_control_button)

        self.send_email_button = QPushButton("Wy≈õlij e-mail")
        self.send_email_button.setToolTip("Wy≈õlij wiadomo≈õƒá e-mail do zaznaczonych pracownik√≥w")
        self.send_email_button.clicked.connect(self.show_email_dialog)
        self.send_email_button.setEnabled(False)  # Domy≈õlnie wy≈ÇƒÖczony
        top_bar_layout.addWidget(self.send_email_button)

        top_bar_layout.addStretch()

        return top_bar_frame

    def create_separator(self):
        separator = QFrame()
        separator.setFrameShape(QFrame.VLine)
        separator.setFrameShadow(QFrame.Sunken)
        return separator

    def setup_date_combo(self):
        """Konfiguruje combobox z datami, uwzglƒôdniajƒÖc uprawnienia."""
        self.date_combo.blockSignals(True)
        current_date = datetime.now()
        months_to_show = []
        year, month = current_date.year, current_date.month

        for i in range(3, 0, -1):
            prev_month, prev_year = (month - i, year)
            while prev_month <= 0:
                prev_month += 12
                prev_year -= 1
            months_to_show.append((prev_year, prev_month))

        months_to_show.append((year, month))

        if self.can_see_next_month:
            next_month, next_year = (month + 1, year)
            if next_month > 12:
                next_month = 1
                next_year += 1
            months_to_show.append((next_year, next_month))

        current_index = self.date_combo.currentIndex()
        if current_index == -1:
            current_index = 3

        self.date_combo.clear()
        for y, m in months_to_show:
            self.date_combo.addItem(f"{y}-{m:02d}", (y, m))

        self.date_combo.setCurrentIndex(min(current_index, self.date_combo.count() - 1))
        self.date_combo.blockSignals(False)

    def setup_middle_section(self, main_layout):
        """Tworzy ≈õrodkowƒÖ sekcjƒô z filtrem i tabelami"""
        main_splitter = QSplitter(Qt.Horizontal)
        main_splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.setup_left_panel()
        right_panel = self.setup_right_panel()
        main_splitter.addWidget(self._left_panel)
        main_splitter.addWidget(right_panel)

        # Ustawienie rozmiar√≥w poczƒÖtkowych
        main_splitter.setSizes([260, 1200])
        self.main_splitter = main_splitter

        self.main_splitter.setStretchFactor(0, 0)
        self.main_splitter.setStretchFactor(1, 1)

        return main_splitter

    def setup_left_panel(self):
        """Tworzy lewy panel z filtrami, w tym z rozbudowanym filtrem obecno≈õci."""
        self._left_panel = QWidget()
        self._left_panel.setMinimumSize(0, 0)
        panel_main_layout = QVBoxLayout(self._left_panel)
        panel_main_layout.setContentsMargins(0, 0, 0, 0)

        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.NoFrame)

        filter_container = QWidget()
        filters_layout = QVBoxLayout(filter_container)
        filters_layout.setContentsMargins(10, 10, 10, 10)
        filters_layout.setSpacing(6)
        filter_container.setMinimumWidth(240)

        # --- ZMIANA: Rozbudowa panelu "Obecni w pracy w dniu" ---
        presence_group = QGroupBox("Obecni w pracy w dniu:")
        presence_group.setCheckable(True)
        presence_group.setChecked(False)
        self.filter_by_presence_check = presence_group

        presence_layout = QGridLayout(presence_group)
        presence_layout.setContentsMargins(5, 10, 5, 5)

        self.presence_date_edit = QDateEdit(QDate.currentDate())
        self.presence_date_edit.setCalendarPopup(True)
        self.presence_date_edit.setDisplayFormat("dd.MM.yyyy")

        self.presence_location_combo = CustomMultiComboBox()
        location_items = ["Home Office (h)", "SBC (s)", "Przystanek (p)", "Bez lokalizacji"]
        self.presence_location_combo.add_items(location_items)

        # ZMIANA: Zamiana QComboBox na CustomMultiComboBox
        self.presence_hour_combo = CustomMultiComboBox()
        self.presence_hour_combo.add_items([f"{h:02d}:00" for h in range(24)])

        presence_layout.addWidget(QLabel("Data:"), 0, 0)
        presence_layout.addWidget(self.presence_date_edit, 0, 1)
        presence_layout.addWidget(QLabel("Lokalizacja:"), 1, 0)
        presence_layout.addWidget(self.presence_location_combo, 1, 1)
        presence_layout.addWidget(QLabel("Godzina:"), 2, 0)
        presence_layout.addWidget(self.presence_hour_combo, 2, 1)

        # ZMIANA: Pod≈ÇƒÖczenie sygna≈Çu `selection_changed`
        self.filter_by_presence_check.toggled.connect(self.filter_data)
        self.presence_date_edit.dateChanged.connect(self.filter_data)
        self.presence_location_combo.selection_changed.connect(self.filter_data)
        self.presence_hour_combo.selection_changed.connect(self.filter_data)

        filters_layout.addWidget(presence_group)

        # 2. Zmiana pod≈ÇƒÖczanych sygna≈Ç√≥w
        self.filter_by_presence_check.toggled.connect(self.filter_data)
        self.presence_date_edit.dateChanged.connect(self.filter_data)
        self.presence_location_combo.selection_changed.connect(self.filter_data)

        # --- KONIEC ZMIAN ---

        separator = QFrame()
        separator.setFrameShape(QFrame.HLine)
        separator.setFrameShadow(QFrame.Sunken)
        filters_layout.addWidget(separator)

        self.add_horizontal_filter("Grupa:", "grupa_main_filter_combo", filters_layout)
        self.add_horizontal_filter("Wydzia≈Ç:", "wydzial_combo", filters_layout)
        # ZMIANA: Przekazanie referencji do list do metody tworzƒÖcej filtr
        self.przelozony_list = QListWidget()
        self.add_horizontal_search_filter("Prze≈Ço≈ºony:", "przelozony_filter", filters_layout,
                                          list_widget_to_clear=self.przelozony_list)
        self.przelozony_filter.textChanged.connect(self.filter_przelozony_list)
        self.przelozony_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.przelozony_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.przelozony_list)

        self.uzytkownik_list = QListWidget()
        self.add_horizontal_search_filter("U≈ºytkownik:", "uzytkownik_filter", filters_layout,
                                          list_widget_to_clear=self.uzytkownik_list)
        self.uzytkownik_filter.textChanged.connect(self.filter_uzytkownik_list)
        self.uzytkownik_list.setSelectionMode(QAbstractItemView.ExtendedSelection)
        self.uzytkownik_list.itemSelectionChanged.connect(self.filter_data)
        filters_layout.addWidget(self.uzytkownik_list)

        self.add_horizontal_filter("LD:", "default_location_combo", filters_layout)
        self.add_horizontal_filter("System Pracy:", "system_czasu_pracy_combo", filters_layout)
        self.add_horizontal_filter("Rola:", "rola_combo", filters_layout)
        self.add_horizontal_filter("Jƒôzyk:", "jezyk_combo", filters_layout)
        self.add_horizontal_filter("Etat:", "etat_combo", filters_layout)
        self.add_horizontal_filter("DTN:", "dtn_combo", filters_layout)

        self.clear_filters_button = QPushButton("Wyczy≈õƒá filtry")
        self.clear_filters_button.clicked.connect(self.clear_filters)
        filters_layout.addStretch()
        filters_layout.addWidget(self.clear_filters_button)

        scroll_area.setWidget(filter_container)
        panel_main_layout.addWidget(scroll_area)

    def _create_clear_icon(self, color: QColor) -> QIcon:
        """Tworzy ikonƒô 'X' o zadanym kolorze."""
        pixmap = QPixmap(16, 16)
        pixmap.fill(Qt.transparent)
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        pen = QPen(color, 2)
        painter.setPen(pen)
        painter.drawLine(4, 4, 12, 12)
        painter.drawLine(4, 12, 12, 4)
        painter.end()
        return QIcon(pixmap)

    def add_horizontal_filter(self, label_text, combo_name, parent_layout):
        """Dodaje filtr w uk≈Çadzie poziomym z poprawnie dzia≈ÇajƒÖcym rozmiarem."""
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)
        filter_layout.setSpacing(4)

        filter_label = QLabel(label_text)
        filter_label.setFixedWidth(65)
        filter_layout.addWidget(filter_label)

        combo = CustomMultiComboBox()
        combo.setFixedHeight(24)
        combo.view().setMaximumWidth(240)
        combo.selection_changed.connect(self.filter_data)
        setattr(self, combo_name, combo)

        # ZMIANA: Dodajemy kontrolkƒô z priorytetem rozciƒÖgania (stretch=1)
        filter_layout.addWidget(combo, 1)

        clear_button = QPushButton()
        icon = self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light
        clear_button.setIcon(icon)
        clear_button.setObjectName("FilterClearButton")
        clear_button.setFixedSize(22, 22)
        clear_button.setToolTip(f"Wyczy≈õƒá filtr '{label_text}'")
        clear_button.setFlat(True)
        clear_button.clicked.connect(lambda: combo.clear_selection())

        # ZMIANA: Dodajemy przycisk bez priorytetu rozciƒÖgania (stretch=0)
        filter_layout.addWidget(clear_button, 0)

        parent_layout.addLayout(filter_layout)

    def add_horizontal_search_filter(self, label_text, filter_name, parent_layout, list_widget_to_clear=None):
        """Dodaje filtr wyszukiwania z poprawnie dzia≈ÇajƒÖcym rozmiarem."""
        filter_layout = QHBoxLayout()
        filter_layout.setContentsMargins(0, 0, 0, 0)
        filter_layout.setSpacing(4)

        filter_label = QLabel(label_text)
        filter_label.setFixedWidth(65)
        filter_layout.addWidget(filter_label)

        text_edit = QLineEdit()
        text_edit.setPlaceholderText(f"Filtruj {label_text.lower()[:-1]}...")
        text_edit.setFixedHeight(24)
        setattr(self, filter_name, text_edit)

        # ZMIANA: Dodajemy kontrolkƒô z priorytetem rozciƒÖgania (stretch=1)
        filter_layout.addWidget(text_edit, 1)

        clear_button = QPushButton()
        icon = self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light
        clear_button.setIcon(icon)
        clear_button.setObjectName("FilterClearButton")
        clear_button.setFixedSize(22, 22)
        clear_button.setToolTip(f"Wyczy≈õƒá filtr '{label_text}'")
        clear_button.setFlat(True)

        def clear_action():
            text_edit.blockSignals(True)
            if list_widget_to_clear: list_widget_to_clear.blockSignals(True)
            text_edit.clear()
            if list_widget_to_clear: list_widget_to_clear.clearSelection()
            text_edit.blockSignals(False)
            if list_widget_to_clear: list_widget_to_clear.blockSignals(False)
            self.filter_data()

        clear_button.clicked.connect(clear_action)

        # ZMIANA: Dodajemy przycisk bez priorytetu rozciƒÖgania (stretch=0)
        filter_layout.addWidget(clear_button, 0)

        parent_layout.addLayout(filter_layout)

    def load_initial_data(self):
        """Uruchamia proces ≈Çadowania danych i jednorazowo aplikuje zapisane sortowanie."""
        debug_print("Uruchamianie leniwego ≈Çadowania danych poczƒÖtkowych...")
        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            # Tworzymy jednorazowƒÖ funkcjƒô obs≈Çugi, aby zastosowaƒá sortowanie po za≈Çadowaniu danych
            def initial_load_handler(data):
                # Najpierw standardowo zastosuj dane
                self._on_async_data_loaded(data)
                # A nastƒôpnie, tylko ten jeden raz, zastosuj zapisane sortowanie
                self.apply_custom_sort()
                # Od≈ÇƒÖcz ten handler, aby nie zosta≈Ç ponownie wywo≈Çany
                if hasattr(self, 'loading_dialog') and self.loading_dialog:
                    try:
                        self.loading_dialog.loading_completed.disconnect(initial_load_handler)
                    except (TypeError, RuntimeError):
                        pass  # Ignoruj b≈ÇƒÖd, je≈õli sygna≈Ç by≈Ç ju≈º od≈ÇƒÖczony

            # Rozpocznij asynchroniczne ≈Çadowanie
            self.update_data(year, month, self.import_grupa, self.import_funkcja, use_async=True)

            # Pod≈ÇƒÖcz nasz jednorazowy handler do sygna≈Çu zako≈Ñczenia ≈Çadowania
            if hasattr(self, 'loading_dialog') and self.loading_dialog:
                self.loading_dialog.loading_completed.connect(initial_load_handler)

            self.update_filter_dates()

    def setup_right_panel(self):
        """Tworzy prawy panel z tabelami"""
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(10)
        right_splitter = QSplitter(Qt.Vertical)
        schedule_frame = self.setup_schedule_section()
        events_frame = self.setup_events_section()
        right_splitter.addWidget(schedule_frame)
        right_splitter.addWidget(events_frame)
        right_splitter.setSizes([650, 350])
        right_layout.addWidget(right_splitter)
        return right_panel

    def setup_schedule_section(self):
        """Tworzy sekcjƒô grafiku (g√≥rna czƒô≈õƒá prawego panelu) u≈ºywajƒÖc SplitTableView."""
        schedule_frame = QFrame()
        schedule_layout = QVBoxLayout(schedule_frame)
        schedule_layout.setContentsMargins(5, 5, 5, 5)

        self.table = SplitTableView()
        schedule_layout.addWidget(self.table)

        # Tworzymy przycisk i kontener na pozosta≈Çe przyciski
        self.manage_columns_button = QPushButton("Dostosuj widok")
        button_frame = self.setup_schedule_buttons()
        button_layout = button_frame.layout()

        # Wstawiamy przycisk zarzƒÖdzania kolumnami na poczƒÖtek layoutu z przyciskami
        if isinstance(button_layout, QHBoxLayout):
            button_layout.insertWidget(0, self.manage_columns_button)

        # --- POCZƒÑTEK POPRAWKI ---
        # Dodajemy kontener z WSZYSTKIMI przyciskami do layoutu sekcji grafiku - TYLKO RAZ.
        # Usuniƒôto zduplikowanƒÖ liniƒô, kt√≥ra powodowa≈Ça b≈ÇƒÖd.
        schedule_layout.addWidget(button_frame)
        # --- KONIEC POPRAWKI ---

        return schedule_frame

    def setup_schedule_buttons(self):
        """Tworzy przyciski akcji dla sekcji grafiku"""
        button_frame = QFrame()
        button_layout = QHBoxLayout(button_frame)
        button_layout.setContentsMargins(0, 0, 0, 0)
        button_frame.setFixedHeight(40)
        button_frame.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.toggle_events_panel_button = QPushButton("Ukryj zdarzenia‚Üì")
        self.toggle_events_panel_button.setToolTip("Ukryj panel zdarze≈Ñ (dla wiƒôkszego widoku grafiku) (F2)")
        self.toggle_events_panel_button.clicked.connect(self.toggle_events_panel)
        self.location_exception_button = QPushButton("WyjƒÖtki lokalizacyjne")
        self.location_exception_button.setToolTip("ZarzƒÖdzaj wyjƒÖtkami od domy≈õlnej lokalizacji pracy")
        self.location_exception_button.clicked.connect(self.show_location_exception_dialog)
        button_layout.addWidget(self.location_exception_button)
        button_layout.addStretch()
        self.insert_change_button = QPushButton("Wstaw zmianƒô")
        self.insert_change_button.setToolTip("Wstaw zmianƒô grafiku (F3)")
        self.insert_change_button.clicked.connect(self.show_insert_change_dialog)
        button_layout.addWidget(self.insert_change_button)
        self.insert_symbol_button = QPushButton("Wstaw nieobecno≈õƒá")
        self.insert_symbol_button.setToolTip("Wstaw nieobecno≈õƒá (F4)")
        self.insert_symbol_button.clicked.connect(self.show_insert_symbol_dialog)
        button_layout.addWidget(self.insert_symbol_button)
        self.cancel_delegation_button = QPushButton("Odwo≈Çaj delegacje")
        self.cancel_delegation_button.setToolTip("Odwo≈Çaj delegacje dla zaznaczonych kom√≥rek (F5)")
        self.cancel_delegation_button.clicked.connect(self.cancel_delegations)
        button_layout.addWidget(self.cancel_delegation_button)
        self.add_overtime_button = QPushButton("Dodaj nadgodziny")
        self.add_overtime_button.setShortcut("Insert")
        self.add_overtime_button.setToolTip("Dodaj nadgodziny dla zaznaczonych kom√≥rek (Insert)")
        self.add_overtime_button.clicked.connect(self.show_add_overtime_dialog)
        button_layout.addWidget(self.add_overtime_button)
        # Usuniƒôto redundantny warunek, widoczno≈õƒá jest zarzƒÖdzana przez update_buttons_visibility
        return button_frame

    def setup_events_section(self):
        """Tworzy sekcjƒô zdarze≈Ñ u≈ºywajƒÖc QTableView i od razu konfiguruje jej kolumny."""
        events_frame = QFrame()
        events_frame.setFrameShape(QFrame.Shape.StyledPanel)
        events_frame.setFrameShadow(QFrame.Shadow.Raised)
        events_layout = QVBoxLayout(events_frame)
        events_layout.setContentsMargins(5, 5, 5, 5)

        filters_frame = self.setup_events_filters()
        events_layout.addWidget(filters_frame)

        self.events_table = QTableView()
        self.events_table.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.events_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.events_table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)

        events_layout.addWidget(self.events_table)
        return events_frame

    def setup_events_filters(self):
        """Konfiguruje filtry dla tabeli zdarze≈Ñ w jednej linii."""
        events_filter_frame = QFrame()
        # ZMIANA: Powr√≥t do uk≈Çadu poziomego
        events_filter_layout = QHBoxLayout(events_filter_frame)
        events_filter_layout.setContentsMargins(0, 5, 0, 5)

        # Filtry daty od-do z przywr√≥conym kalendarzem
        self.date_from = QDateEdit(QDate.currentDate().addDays(-30))
        self.date_from.setCalendarPopup(True)  # POPRAWKA: Przywr√≥cenie kalendarza
        self.date_to = QDateEdit(QDate.currentDate())
        self.date_to.setCalendarPopup(True)  # POPRAWKA: Przywr√≥cenie kalendarza

        # Filtry tekstowe i statusu
        self.topic_filter = QLineEdit()
        self.topic_filter.setPlaceholderText("Filtruj po temacie...")
        self.name_filter = QLineEdit()
        self.name_filter.setPlaceholderText("Filtruj po nazwie...")
        self.status_filter_combo = CustomMultiComboBox()
        self.status_filter_combo.setMinimumWidth(130)

        # Checkboxy
        self.meetings_checkbox = QCheckBox("Spotkania")
        self.trainings_checkbox = QCheckBox("Szkolenia")
        self.overtime_checkbox = QCheckBox("Nadgodziny")
        self.meetings_checkbox.setChecked(True)
        self.trainings_checkbox.setChecked(True)
        self.overtime_checkbox.setChecked(True)

        # Dodanie wszystkich kontrolek do layoutu w poprawnej kolejno≈õci
        events_filter_layout.addWidget(QLabel("Data od:"))
        events_filter_layout.addWidget(self.date_from)
        events_filter_layout.addWidget(QLabel("Data do:"))
        events_filter_layout.addWidget(self.date_to)
        events_filter_layout.addWidget(QLabel("Temat:"))
        events_filter_layout.addWidget(self.topic_filter)
        events_filter_layout.addWidget(QLabel("Nazwa:"))
        events_filter_layout.addWidget(self.name_filter)
        events_filter_layout.addWidget(QLabel("Status:"))
        events_filter_layout.addWidget(self.status_filter_combo)

        events_filter_layout.addStretch()  # Wype≈Çniacz, aby odsunƒÖƒá checkboxy na prawo

        events_filter_layout.addWidget(self.meetings_checkbox)
        events_filter_layout.addWidget(self.trainings_checkbox)
        events_filter_layout.addWidget(self.overtime_checkbox)

        # Po≈ÇƒÖczenie sygna≈Ç√≥w (bez zmian)
        self.date_from.dateChanged.connect(self.filter_events_table)
        self.date_to.dateChanged.connect(self.filter_events_table)
        self.topic_filter.textChanged.connect(self.filter_events_table)
        self.name_filter.textChanged.connect(self.filter_events_table)
        self.meetings_checkbox.stateChanged.connect(self.filter_events_table)
        self.trainings_checkbox.stateChanged.connect(self.filter_events_table)
        self.overtime_checkbox.stateChanged.connect(self.filter_events_table)
        self.status_filter_combo.selection_changed.connect(self.filter_events_table)

        return events_filter_frame

    def setup_events_table_columns(self):
        """Konfiguruje kolumny dla tabeli zdarze≈Ñ, w tym ich szeroko≈õƒá."""
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        header = self.events_table.horizontalHeader()
        self.events_table.setSortingEnabled(True)

        # ZMIANA: Zaktualizowane indeksy kolumn
        header.setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        header.setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        header.setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        header.setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        header.setSectionResizeMode(4, QHeaderView.ResizeToContents)  # U≈ºytkownik
        header.setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        header.setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Czas od
        header.setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Czas do
        header.setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        header.setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Data Modyfikacji

        # Ustaw sta≈ÇƒÖ, wiƒôkszƒÖ szeroko≈õƒá dla kolumny Akcje (teraz indeks 10)
        header.setSectionResizeMode(10, QHeaderView.Fixed)
        self.events_table.setColumnWidth(10, 80)

    def setup_table_properties(self):
        """Konfiguruje w≈Ça≈õciwo≈õci tabel i tworzy delegat√≥w z ustawieniami."""
        self.events_table.setSortingEnabled(True)
        # Usuniƒôto liniƒô resetujƒÖcƒÖ sortowanie tabeli zdarze≈Ñ:
        # self.events_table.sortByColumn(0, Qt.AscendingOrder)

        if hasattr(self, 'table') and hasattr(self.table, 'employees_view'):
            self.table.employees_view.setSortingEnabled(True)
            # Usuniƒôto liniƒô, kt√≥ra czy≈õci≈Ça sortowanie tabeli grafiku:
            # self.table.employees_view.sortByColumn(-1, Qt.AscendingOrder)

        if hasattr(self.table, 'employees_view') and hasattr(self.table.employees_view, 'horizontalHeader'):
            self.table.employees_view.horizontalHeader().sortIndicatorChanged.connect(self.on_sort_changed)

        if hasattr(self.events_table, 'horizontalHeader'):
            self.events_table.horizontalHeader().sortIndicatorChanged.connect(self.on_events_sort_changed)
            self.setup_events_table_columns()

        overtime_delegate = OvertimeItemDelegate(settings=self.user_settings)
        self.table.schedule_view.setItemDelegate(overtime_delegate)

        button_delegate = ButtonDelegate(parent=self, button_text="Odwo≈Çaj", is_dark_theme=self.is_dark_theme)
        button_delegate.button_clicked.connect(self.delete_event_from_row)
        self.events_table.setItemDelegateForColumn(10, button_delegate)  # "Akcje" to kolumna 10

        self.table.day_sort_requested.connect(self.apply_day_sort)

    def apply_day_sort(self, day: int, order: Qt.SortOrder):
        """
        Wywo≈Çuje sortowanie w modelu danych na podstawie wybranego dnia.
        """
        if hasattr(self, 'schedule_model') and self.schedule_model:
            self.schedule_model.sort_by_day(day, order)

    def toggle_left_panel(self):
        """Prze≈ÇƒÖcza widoczno≈õƒá lewego panelu filtr√≥w z zapamiƒôtywaniem rozmiaru."""
        current_sizes = self.main_splitter.sizes()

        # Sprawd≈∫, czy lewy panel jest zwiniƒôty (jego rozmiar jest bliski zeru)
        if current_sizes[0] < 10:
            # Rozwi≈Ñ panel do ostatniej znanej lub domy≈õlnej szeroko≈õci
            right_width = max(0, sum(current_sizes) - self.last_left_panel_width)
            self.main_splitter.setSizes([self.last_left_panel_width, right_width])
        else:
            # Zwi≈Ñ panel, zapamiƒôtujƒÖc jego aktualnƒÖ szeroko≈õƒá
            self.last_left_panel_width = current_sizes[0]
            self.main_splitter.setSizes([0, sum(current_sizes)])


    def toggle_events_panel(self):
        """Prze≈ÇƒÖcza widoczno≈õƒá panelu zdarze≈Ñ (dolny panel)"""
        right_splitter = self.centralWidget().findChild(QSplitter, self.main_splitter.objectName()).widget(1).findChild(
            QSplitter)
        if not right_splitter: return

        sizes = right_splitter.sizes()
        if sizes[1] > 0:
            self.events_panel_height = sizes[1]
            right_splitter.setSizes([sum(sizes), 0])
            self.toggle_events_panel_button.setText("Poka≈º zdarzenia‚Üë")
        else:
            schedule_height = right_splitter.height() - getattr(self, 'events_panel_height', 300)
            right_splitter.setSizes([schedule_height, getattr(self, 'events_panel_height', 300)])
            self.toggle_events_panel_button.setText("Ukryj zdarzenia‚Üì")

    def export_schedule_to_excel(self):
        """
        Zbiera aktualnie widoczne dane z grafiku i eksportuje je do sformatowanego
        pliku Excel (.xlsx) przy u≈ºyciu biblioteki openpyxl.
        """
        if not self.schedule_model or self.schedule_model.rowCount() == 0:
            QMessageBox.warning(self, "Brak danych", "Brak danych do wyeksportowania.")
            return

        default_filename = f"grafik_{self.year}-{self.month:02d}.xlsx"
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Zapisz plik Excel", default_filename, "Pliki Excel (*.xlsx);;Wszystkie pliki (*)"
        )

        if not file_path:
            return

        try:
            # 1. Przygotowanie danych (logika podobna do poprzedniej)
            headers = self.schedule_model._column_headers[:len(self.visible_columns)]
            days_in_month = self.schedule_model._days_in_month
            day_headers = self.schedule_model._column_headers[
                          len(self.visible_columns):len(self.visible_columns) + days_in_month]

            # Bierzemy tylko pierwszƒÖ liniƒô z nag≈Ç√≥wka dnia (np. "So\n1" -> "So")
            day_letters = [h.split('\n')[0] for h in day_headers]
            day_numbers = [str(d) for d in range(1, days_in_month + 1)]

            visible_keys = self.schedule_model._keys
            data_rows = []
            for key in visible_keys:
                row_data = self.processed_data.get(key, {})
                row_to_write = []
                for col_id in self.visible_columns:
                    # Logika zbierania danych o pracownikach
                    if col_id == 'wydzial':
                        row_to_write.append(key[0])
                    elif col_id == 'przelozony_nazwisko_imie':
                        row_to_write.append(row_data.get('przelozony_nazwisko_imie', ''))
                    elif col_id == 'uzytkownik_dane':
                        row_to_write.append(key[2])
                    else:
                        row_to_write.append(str(row_data.get(col_id, '')))

                # Logika zbierania symboli z grafiku
                days_data = row_data.get('days', {})
                for day in range(1, days_in_month + 1):
                    symbol = days_data.get(day, {}).get('symbol', '')
                    row_to_write.append(symbol)
                data_rows.append(row_to_write)

            # 2. Tworzenie pliku Excel i zapis danych
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = f"Grafik {self.year}-{self.month:02d}"

            # 3. Formatowanie i dodawanie nag≈Ç√≥wk√≥w
            header_font = Font(bold=True, color="FFFFFF")
            header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")
            weekend_fill = PatternFill(start_color="FFF2F2F2", end_color="FFF2F2F2", fill_type="solid")

            # Dodanie dw√≥ch wierszy nag≈Ç√≥wk√≥w
            ws.append(headers + day_letters)
            ws.append([''] * len(headers) + day_numbers)

            # Stylowanie nag≈Ç√≥wk√≥w
            for row in ws.iter_rows(min_row=1, max_row=2, min_col=1, max_col=ws.max_column):
                for cell in row:
                    cell.font = header_font
                    cell.fill = header_fill
                    cell.alignment = Alignment(horizontal='center', vertical='center')

            # 4. Zapis danych
            for row in data_rows:
                ws.append(row)

            # 5. Dodatkowe formatowanie
            employee_cols_count = len(self.visible_columns)

            # Zablokowanie okienek (kolumny pracownicze)
            first_day_column_letter = get_column_letter(employee_cols_count + 1)
            ws.freeze_panes = f"{first_day_column_letter}3"

            # Wyr√≥≈ºnienie weekend√≥w
            weekend_columns = self.schedule_model._weekend_columns
            for weekend_col_idx in weekend_columns:
                col_letter = get_column_letter(employee_cols_count + weekend_col_idx + 1)
                for cell in ws[col_letter]:
                    cell.fill = weekend_fill

            # Automatyczne dopasowanie szeroko≈õci kolumn
            for i, column_cells in enumerate(ws.columns):
                # Dla dni grafiku ustawiamy sta≈ÇƒÖ szeroko≈õƒá
                if i >= employee_cols_count:
                    ws.column_dimensions[get_column_letter(i + 1)].width = 5
                else:  # Dla kolumn pracowniczych dopasowujemy do zawarto≈õci
                    max_length = 0
                    column = get_column_letter(i + 1)
                    for cell in column_cells:
                        try:
                            if len(str(cell.value)) > max_length:
                                max_length = len(cell.value)
                        except:
                            pass
                    adjusted_width = (max_length + 2)
                    ws.column_dimensions[column].width = adjusted_width

            # 6. Zapis pliku
            wb.save(file_path)

            QMessageBox.information(self, "Eksport zako≈Ñczony",
                                    f"Dane zosta≈Çy pomy≈õlnie zapisane w pliku:\n{file_path}")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas eksportu do Excel (.xlsx): {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd eksportu", f"WystƒÖpi≈Ç nieoczekiwany b≈ÇƒÖd:\n{e}")

    def show_column_select_dialog(self):
        """Wy≈õwietla rozbudowany dialog wyboru kolumn i sortowania."""
        from column_select_dialog import ColumnSelectDialog
        try:
            if not hasattr(self, 'schedule_model'):
                QMessageBox.warning(self, "B≈ÇƒÖd", "Model danych nie jest zainicjalizowany.")
                return

            dialog = ColumnSelectDialog(
                self, self.employee_columns, self.visible_columns, self.default_visible_columns,
                user_role=self.current_user_role,
                is_comment_column_checked=self.show_comment_column,
                sort_preferences=self.user_sort_preferences
            )

            if dialog.exec() == QDialog.Accepted:
                # Logika dla widoczno≈õci kolumn (bez zmian)
                self.visible_columns = dialog.get_selected_columns()
                self.show_comment_column = dialog.get_comment_column_state()
                self.user_settings['visible_columns'] = self.visible_columns
                self.user_settings['show_schedule_comment'] = self.show_comment_column

                # NOWA LOGIKA: Pobranie i zapisanie preferencji sortowania
                self.user_sort_preferences = dialog.get_sort_preferences()
                self.user_settings['sort_preferences'] = self.user_sort_preferences

                self.settings_db.save_settings(self.user_settings)

                self.schedule_model.set_visible_columns(self.visible_columns)
                self.schedule_model.set_show_comment_column(self.show_comment_column)
                self.refresh_column_configuration()
                if hasattr(self, 'table'):
                    self.table.set_model(self.schedule_model)
                    self.table.adjust_employees_table_width()
                    self._apply_dynamic_sizes()

                # ZMIANA: Zamiast `apply_default_sort` wywo≈Çujemy nowƒÖ metodƒô
                self.apply_custom_sort()
        except Exception as e:
            log_error(f"B≈ÇƒÖd w show_column_select_dialog: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd: {str(e)}")

    def apply_custom_sort(self):
        """
        Sortuje dane w modelu na podstawie preferencji u≈ºytkownika, u≈ºywajƒÖc
        dedykowanej, wielopoziomowej funkcji por√≥wnujƒÖcej.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model._processed_data:
            return

        sort_prefs = self.user_sort_preferences
        keys_to_sort = self.schedule_model._keys

        self.schedule_model.layoutAboutToBeChanged.emit()

        if sort_prefs:
            debug_print(f"Aplikowanie sortowania niestandardowego (compare func): {sort_prefs}")

            def compare_rows(key_a, key_b):
                """Funkcja por√≥wnujƒÖca, kt√≥ra analizuje wszystkie kryteria sortowania naraz."""
                for col_id, direction in sort_prefs:
                    val_a = self.schedule_model._get_sort_key(key_a, col_id)
                    val_b = self.schedule_model._get_sort_key(key_b, col_id)

                    # Zabezpieczenie na wypadek por√≥wnywania r√≥≈ºnych typ√≥w (np. None i string)
                    if type(val_a) is not type(val_b):
                        val_a, val_b = str(val_a), str(val_b)

                    result = 0
                    try:
                        if val_a < val_b:
                            result = -1
                        elif val_a > val_b:
                            result = 1
                    except TypeError:  # Dodatkowe zabezpieczenie
                        val_a, val_b = str(val_a), str(val_b)
                        if val_a < val_b:
                            result = -1
                        elif val_a > val_b:
                            result = 1

                    # Je≈õli warto≈õci nie sƒÖ r√≥wne, zwracamy wynik (z uwzglƒôdnieniem kierunku)
                    # i ko≈Ñczymy por√≥wnywanie.
                    if result != 0:
                        return result * -1 if direction == 'desc' else result

                # Je≈õli po sprawdzeniu wszystkich kryteri√≥w wiersze sƒÖ r√≥wne, zwracamy 0.
                return 0

            keys_to_sort.sort(key=functools.cmp_to_key(compare_rows))

        self.schedule_model.layoutChanged.emit()

        # Ustaw wska≈∫nik wizualny w nag≈Ç√≥wku, aby odzwierciedla≈Ç sortowanie
        emp_header = self.table.employees_view.horizontalHeader()
        sched_header = self.table.schedule_view.horizontalHeader()

        emp_header.setSortIndicator(-1, Qt.AscendingOrder)
        sched_header.setSortIndicator(-1, Qt.AscendingOrder)

        if sort_prefs:
            first_col_id, first_direction = sort_prefs[0]
            order = Qt.DescendingOrder if first_direction == 'desc' else Qt.AscendingOrder

            if hasattr(self, 'visible_columns'):
                try:
                    col_index = self.visible_columns.index(first_col_id)
                    emp_header.setSortIndicator(col_index, order)
                except ValueError:
                    pass

        debug_print("Zako≈Ñczono sortowanie niestandardowe (compare func).")

    def _apply_dynamic_sizes(self):
        """Ustawia dynamiczne rozmiary w zale≈ºno≈õci od rozmiaru czcionki ORAZ zapisanych ustawie≈Ñ."""
        if not hasattr(self, 'table') or not self.table.employees_view.model() or self.schedule_model.rowCount() == 0:
            return

        # --- POCZƒÑTEK ZMIANY: Logika szeroko≈õci kolumn ---
        saved_widths = self.user_settings.get('column_widths', {})

        # Zastosuj zapisane szeroko≈õci
        visible_columns = self.schedule_model.get_visible_columns()
        for i, col_id in enumerate(visible_columns):
            if col_id in saved_widths:
                self.table.employees_view.setColumnWidth(i, saved_widths[col_id])
        # --- KONIEC ZMIANY ---

        font_size = self.current_font_size
        width_map = {7: 35, 8: 40, 9: 45, 10: 50, 11: 55, 12: 60}
        day_column_width = width_map.get(font_size, 40)
        height_map = {7: 25, 8: 25, 9: 25, 10: 28, 11: 28, 12: 30}
        row_height = height_map.get(font_size, 25)
        header_height_map = {7: 30, 8: 35, 9: 35, 10: 38, 11: 40, 12: 42}
        header_height = header_height_map.get(font_size, 35)

        self.table.set_header_height(header_height)
        header = self.table.schedule_view.horizontalHeader()
        model = self.table.employees_view.model()
        special_widths = {"Suma\\nRBH": 45, "Bilans\\nRBH": 45, "Komentarz": 300}

        for logical_index in range(model.columnCount()):
            header_text = model.headerData(logical_index, Qt.Horizontal, Qt.DisplayRole)
            width_to_set = special_widths.get(header_text, day_column_width)
            header.resizeSection(logical_index, width_to_set)

        days_in_month = model._days_in_month
        employee_cols_count = len(model.get_visible_columns())
        for day in range(1, 32):
            logical_index = employee_cols_count + (day - 1)
            if logical_index < model.columnCount():
                header.setSectionHidden(logical_index, day > days_in_month)

        self.table._force_sync_heights(row_height)

    def showEvent(self, event):
        """Automatycznie wywo≈Çywane przez Qt, gdy okno jest pokazywane po raz pierwszy."""
        super().showEvent(event)
        # Dodano sprawdzenie `hasattr(self, 'table')`, aby upewniƒá siƒô, ≈ºe tabela istnieje
        if not hasattr(self, '_initial_layout_done') and hasattr(self, 'table'):
            debug_print("Wykryto showEvent - jednorazowe ustawianie szeroko≈õci splittera.")
            self.table.adjust_employees_table_width()
            self._initial_layout_done = True

    def delete_event_from_row(self, row):
        """Usuwa zdarzenie na podstawie indeksu wiersza w tabeli zdarze≈Ñ."""
        if not hasattr(self, 'events_model') or not self.events_model:
            return
        event = self.events_model.get_event(row)
        if not event:
            return
        event_id = event.get('id')
        event_type = event.get('type')
        if not event_id or not event_type:
            return
        self.delete_event(event_id, event_type)

    def on_sort_changed(self, logical_index, order):
        """Obs≈Çuguje zmianƒô sortowania w tabeli grafiku"""
        self.last_sort_column = logical_index
        self.last_sort_order = order
        debug_print(
            f"Tabela grafiku: Sortowanie po kolumnie {logical_index}, kolejno≈õƒá: {'rosnƒÖco' if order == Qt.AscendingOrder else 'malejƒÖco'}")

    def on_events_sort_changed(self, logical_index, order):
        """Obs≈Çuguje zmianƒô sortowania w tabeli zdarze≈Ñ"""
        debug_print(
            f"Tabela zdarze≈Ñ: Sortowanie po kolumnie {logical_index}, kolejno≈õƒá: {'rosnƒÖco' if order == Qt.AscendingOrder else 'malejƒÖco'}")

    def update_buttons_visibility(self):
        """Aktualizuje widoczno≈õƒá przycisk√≥w na podstawie roli u≈ºytkownika"""
        is_next_month_selected = False
        current_data = self.date_combo.currentData()
        if current_data:
            selected_year, selected_month = current_data
            today = QDate.currentDate()
            next_month_date = today.addMonths(1)
            if selected_year == next_month_date.year() and selected_month == next_month_date.month():
                is_next_month_selected = True

        # U≈ºycie centralnej funkcji do zarzƒÖdzania widoczno≈õciƒÖ przycisk√≥w
        if hasattr(self, 'add_overtime_button'):
            self.add_overtime_button.setVisible(
                app_settings.has_permission(self.current_user_role, 'button_add_overtime'))
        if hasattr(self, 'staffing_details_button'):
            self.staffing_details_button.setVisible(
                app_settings.has_permission(self.current_user_role, 'button_staffing_details'))
        if hasattr(self, 'show_audit_button'):
            self.show_audit_button.setVisible(app_settings.has_permission(self.current_user_role, 'button_show_audit'))
        if hasattr(self, 'schedule_control_button'):
            can_see_button = app_settings.has_permission(self.current_user_role, 'button_schedule_control')
            self.schedule_control_button.setVisible(can_see_button and is_next_month_selected)
        # Ukryj przycisk wyjƒÖtk√≥w lokalizacyjnych dla roli Lider OUT
        if hasattr(self, 'location_exception_button'):
            self.location_exception_button.setVisible(self.current_user_role != 'Lider OUT')
        if hasattr(self, 'send_email_button'):
            self.send_email_button.setVisible(
                app_settings.has_permission(self.current_user_role, 'button_send_email'))

    def show_audit_log_window(self):
        """Tworzy i pokazuje okno historii zmian."""
        # Leniwe importowanie
        from audit_log_window import AuditLogWindow

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Proszƒô najpierw wybraƒá miesiƒÖc.")
            return

        year, month = current_data

        def _get_filtered_audit_data():
            full_data = self.data_provider.get_schedule_audit_data(year, month)
            selected_cells = self.table.get_data_for_selected_cells()
            if selected_cells:
                allowed_users_dates = set()
                for cell in selected_cells:
                    if (user_id := cell.get('uzytkownik_id')) and (date_str := cell.get('date_str')):
                        date_obj = QDate.fromString(date_str, "yyyy-MM-dd").toPython()
                        allowed_users_dates.add((user_id, date_obj))
                return [row for row in full_data if
                        row.get('Data') and (int(row.get('Uzytkownik')), row.get('Data').date()) in allowed_users_dates]
            else:
                visible_user_ids = {key[3] for key in self.schedule_model._keys}
                filtered_by_visibility = [row for row in full_data if row.get('Uzytkownik') is not None and int(
                    row.get('Uzytkownik')) in visible_user_ids]
                sorted_data = sorted(filtered_by_visibility, key=lambda x: x.get('DataModyfikacji'), reverse=True)
                return sorted_data[:50]

        selected_cells = self.table.get_data_for_selected_cells()
        is_limited = not selected_cells
        limit_count = 50
        initial_filtered_data = _get_filtered_audit_data()
        if not initial_filtered_data:
            QMessageBox.information(self, "Informacja", "Brak historii zmian dla wybranych filtr√≥w / zaznaczenia.")
            return

        dialog = AuditLogWindow(initial_filtered_data, self.is_dark_theme, self, is_limited_view=is_limited, year=year,
                                month=month, limit=limit_count)

        def on_refresh_requested():
            self.data_provider.clear_audit_cache(year, month)
            fresh_filtered_data = _get_filtered_audit_data()
            dialog.update_model_data(fresh_filtered_data)
            QMessageBox.information(dialog, "Od≈õwie≈ºono", "Historia zmian zosta≈Ça zaktualizowana.")

        dialog.refresh_requested.connect(on_refresh_requested)
        dialog.exec()

    def check_user_permissions(self):
        """Sprawdza uprawnienia u≈ºytkownika i zapisuje je w atrybutach klasy."""
        user_id, user_app_id, user_app_role, visible_next_month, user_department = get_modifier_id()
        self.current_user_id = user_id
        self.current_user_app_id = user_app_id
        self.current_user_role = user_app_role
        self.can_see_next_month = visible_next_month
        self.current_user_department = user_department

        if not app_settings.has_permission(user_app_role, 'app_access'):
            QMessageBox.critical(self, "Brak uprawnie≈Ñ",
                                 f"Nie masz uprawnie≈Ñ do korzystania z tej aplikacji.\n\nTwoja rola: {user_app_role}",
                                 QMessageBox.Ok)
            return False

        self.update_buttons_visibility()
        debug_print(f"Zalogowano jako: {user_app_id} ({user_app_role}), Wydzia≈Ç: {self.current_user_department}")
        return True

    def _can_modify_cells(self, selected_cells_data: list) -> bool:
        """
        Sprawdza, czy u≈ºytkownik ma jakiekolwiek uprawnienia do modyfikacji
        ZAZNACZONYCH kom√≥rek. Zwraca True, je≈õli choƒá jedna kom√≥rka jest edytowalna.
        """
        if not selected_cells_data:
            return False

        # Sprawdzamy, czy istnieje choƒá jedna kom√≥rka, do kt√≥rej u≈ºytkownik ma jakiekolwiek prawo
        can_modify_anything = False
        for cell_data in selected_cells_data:
            permissions = self._get_permission_for_cell(cell_data)
            if any(permissions.values()):
                can_modify_anything = True
                break  # Wystarczy jedna kom√≥rka, przerywamy pƒôtlƒô

        if not can_modify_anything:
            QMessageBox.warning(self, "Brak uprawnie≈Ñ",
                                "Nie posiadasz uprawnie≈Ñ do edycji grafiku dla ≈ºadnej z zaznaczonych os√≥b lub kom√≥rek.")
            return False

        return True

    def show_insert_symbol_dialog(self):
        """
        Uproszczona metoda: Pokazuje okno dialogowe do wstawiania symbolu,
        a nastƒôpnie deleguje logikƒô do scentralizowanej metody.
        """
        if not app_settings.has_permission(self.current_user_role, 'schedule_cell_actions'):
            self.statusBar().showMessage("Brak uprawnie≈Ñ do wstawiania symboli.", 3000)
            return

        from schedule_edit_dialogs import InsertSymbolDialog
        selected_cells_data = self.get_selected_cells_data()
        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono ≈ºadnych kom√≥rek do edycji.", QMessageBox.Ok)
            return

        dialog = InsertSymbolDialog(self, selected_cells_data=selected_cells_data)
        if dialog.exec():
            selected_symbol = dialog.get_selected_symbol()
            if selected_symbol:
                self._apply_special_symbol_to_selection(selected_symbol)

    def _group_cells_for_symbol_changes(self, schedule_cells):
        """Grupuje kom√≥rki dla komunikatu potwierdzenia."""
        grouped_changes = {}
        for cell_data in schedule_cells:
            user_id, user_name, date_str, current_symbol = cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane', ''), cell_data.get('date_str'), cell_data.get('symbol', '').strip()
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str
            user_key = (user_id, user_name)
            if user_key not in grouped_changes:
                grouped_changes[user_key] = {}
            if formatted_date not in grouped_changes[user_key]:
                grouped_changes[user_key][formatted_date] = []
            grouped_changes[user_key][formatted_date].append({'current_symbol': current_symbol, 'cell_data': cell_data})
        return grouped_changes

    def _prepare_symbol_changes_description(self, grouped_changes, new_special_symbol):
        """Przygotowuje opis zmian symboli do komunikatu."""
        changes_info = ""
        for (user_id, user_name), dates in grouped_changes.items():
            changes_info += f"\nüë§ {user_name}:\n"
            for date, cells in dates.items():
                changes_info += f"   üìÖ {date}: "
                # Poka≈º przyk≈Çad jak bƒôdzie wyglƒÖda≈Ç nowy symbol
                example_cell = cells[0]['cell_data']
                current_symbol = cells[0]['current_symbol']
                # Przewiduj jak bƒôdzie wyglƒÖda≈Ç nowy symbol
                predicted_symbol = self._predict_new_symbol(current_symbol, new_special_symbol, example_cell)
                if len(cells) == 1:
                    changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                else:
                    # Je≈õli wiele kom√≥rek w tym dniu
                    current_symbols = [cell['current_symbol'] for cell in cells]
                    unique_symbols = set(current_symbols)
                    if len(unique_symbols) == 1:
                        changes_info += f"{current_symbol} -> {predicted_symbol}\n"
                    else:
                        symbols_str = ", ".join([f"{s}" for s in unique_symbols])
                        changes_info += f"[{symbols_str}] -> {predicted_symbol}\n"
        return changes_info

    def _predict_new_symbol(self, current_symbol: str, special_symbol: str, cell_data: dict) -> str:
        """
        Przewiduje, jak bƒôdzie wyglƒÖda≈Ç nowy symbol, z uwzglƒôdnieniem
        logiki dla lokalizacji i systemu r√≥wnowa≈ºnego.
        """
        parsed_current = parse_symbol(current_symbol)

        final_start_hour = parsed_current.get('start_hour')
        final_work_hours = parsed_current.get('work_hours')

        system_pracy = cell_data.get('system_czasu_pracy', '').strip().lower()
        is_equivalent_system = (system_pracy == 'r√≥wnowa≈ºny')
        is_absence_symbol = special_symbol.upper() in app_settings.get_absence_symbols()

        if is_equivalent_system and is_absence_symbol:
            try:
                final_work_hours = int(float(cell_data.get('etat')))
            except (ValueError, TypeError):
                final_work_hours = 8

        # --- ZMIANA: Poprawiona logika ustalania lokalizacji ---
        final_location = None
        # Warunek: Lokalizacjƒô przypisujemy tylko, gdy wstawiany jest symbol "pracujƒÖcy"
        # lub gdy nie ma symbolu specjalnego (zwyk≈Ça zmiana robocza).
        if (special_symbol and special_symbol.upper() in app_settings.WORK_LIKE_SYMBOLS) or not special_symbol:
            # Hierarchia:
            # 1. We≈∫ lokalizacjƒô, je≈õli ju≈º istnieje w kom√≥rce.
            # 2. Je≈õli nie, u≈ºyj nowej funkcji, kt√≥ra sprawdzi wyjƒÖtki i domy≈õlne.
            final_location = parsed_current.get('location') or self.determine_correct_location(cell_data)
        # Dla zwyk≈Çych nieobecno≈õci (U, CO) `final_location` pozostanie None.
        # --- KONIEC ZMIANY ---

        new_symbol = build_symbol(
            location=final_location,
            start_hour=final_start_hour,
            work_hours=final_work_hours,
            special_symbol=special_symbol
        )

        if not new_symbol.strip() and special_symbol and special_symbol.strip():
            return special_symbol.strip()

        return new_symbol.strip() if new_symbol else ""

    def determine_correct_location(self, cell_data: dict) -> str | None:
        """
        Okre≈õla prawid≈ÇowƒÖ lokalizacjƒô dla kom√≥rki, wywo≈ÇujƒÖc dedykowanƒÖ
        funkcjƒô tabelarycznƒÖ w bazie danych.

        Args:
            cell_data (dict): S≈Çownik z danymi kom√≥rki.

        Returns:
            str | None: Kod lokalizacji ('h', 's', 'p') lub None.
        """
        try:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if not user_id or not date_str:
                return None  # Nie mo≈ºna wykonaƒá zapytania bez kluczowych danych

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            # Jedno proste zapytanie do bazy danych
            sql = f"SELECT FinalLocation FROM {SQL_OBJECTS['fn_getcorrectlocation']}(?, ?)"
            cursor.execute(sql, (user_id, date_str))
            result = cursor.fetchone()
            conn.close()

            if result and result[0]:
                return result[0]

            return None  # Zwr√≥ƒá None, je≈õli funkcja nic nie zwr√≥ci≈Ça

        except Exception as e:
            log_error(f"B≈ÇƒÖd w determine_correct_location przy wywo≈Çaniu TVF: {e}")
            return None  # Bezpieczny fallback

    def _find_events_to_cancel(self, user_date_pairs):
        """
        Znajduje zdarzenia do odwo≈Çania dla podanych par u≈ºytkownik-data.
        WERSJA ZMODYFIKOWANA: Uwzglƒôdnia spotkania/szkolenia tylko w statusie 'Delegowany'.
        """
        events_to_cancel = []
        for user_id, date_str in user_date_pairs:
            # Pobieramy WSZYSTKIE zdarzenia dla kom√≥rki, aby sprawdziƒá ich dok≈Çadny status
            user_events = self.data_provider.get_events_for_user_date(user_id, date_str, active_only=False)

            for event in user_events:
                event_type = event.get('type')
                event_status = event.get('status')
                event_id = event.get('id')

                if not event_type or event_id is None:
                    continue

                # Warunek 1: Spotkanie lub Szkolenie musi mieƒá status 'Delegowany'
                is_cancellable_meeting_or_training = (
                        event_type in ['Spotkanie', 'Szkolenie'] and event_status == 'Delegowany'
                )

                # Warunek 2: Nadgodziny muszƒÖ byƒá po prostu "aktywne" (status inny ni≈º '0')
                is_cancellable_overtime = (
                        event_type == 'Nadgodziny' and str(event_status) != '0'
                )

                if is_cancellable_meeting_or_training or is_cancellable_overtime:
                    events_to_cancel.append({
                        'id': event_id,
                        'type': event_type,
                        'user_id': user_id,
                        'date': date_str,
                        'date_key': event.get('date_key', date_str),
                        'name': event.get('name', ''),
                        'user_name': event.get('UzytkownikDane', ''),
                    })
        return events_to_cancel

    def _group_events_by_user_date(self, events_to_cancel):
        """Grupuje zdarzenia wed≈Çug u≈ºytkownika i daty"""
        grouped_events = {}
        for event in events_to_cancel:
            key = (event['user_id'], event['date'])
            if key not in grouped_events:
                grouped_events[key] = []
            grouped_events[key].append(event)
        return grouped_events

    # def _apply_absence_symbol_changes(self, schedule_cells, special_symbol, events_to_cancel):
    #     try:
    #         if events_to_cancel: self._cancel_delegations(events_to_cancel)
    #         successful_updates, failed_updates = 0, 0
    #         error_messages, affected_pairs, skipped_employees = [], [], []
    #
    #         for cell_data in schedule_cells:
    #             # --- POCZƒÑTEK NOWEJ WERYFIKACJI ---
    #             target_dept = cell_data.get('wydzial', '').strip().lower()
    #             if self.current_user_role in ['Lider',
    #                                           'Lider OUT'] and target_dept == 'dtn' and special_symbol.upper() != 'CO':
    #                 # Dodaj do pominiƒôtych z odpowiednim komunikatem i przejd≈∫ do nastƒôpnej kom√≥rki
    #                 skipped_employees.append(f"{cell_data.get('uzytkownik_dane', 'Nieznany')} (Tylko 'CO' dla DTN)")
    #                 continue
    #             # --- KONIEC NOWEJ WERYFIKACJI ---
    #
    #             permissions = self._get_permission_for_cell(cell_data)
    #             if not permissions['can_edit_symbol']:
    #                 skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
    #                 continue
    #
    #             user_id, date_str, nr_kadrowy, current_symbol = cell_data.get('uzytkownik_id'), cell_data.get(
    #                 'date_str'), cell_data.get('nr_kadrowy'), cell_data.get('symbol', '')
    #             if not all([user_id, date_str, nr_kadrowy]):
    #                 failed_updates += 1
    #                 error_messages.append(f"Brak danych dla kom√≥rki: U:{user_id} D:{date_str} NRK:{nr_kadrowy}")
    #                 continue
    #
    #             new_symbol = self._build_new_symbol_with_absence_fixed(current_symbol, special_symbol, cell_data)
    #             try:
    #                 year_val, month_val, _ = map(int, date_str.split('-'))
    #                 result = self._call_import_changes_procedure(nr_kadrowy=nr_kadrowy, rok=year_val, miesiac=month_val,
    #                                                              data=date_str, symbol=new_symbol)
    #                 if result['success']:
    #                     successful_updates += 1
    #                     affected_pairs.append((user_id, date_str, result.get('returned_symbol')))
    #                 else:
    #                     failed_updates += 1
    #                     error_messages.append(f"{nr_kadrowy} ({date_str}): {result.get('message', 'Nieznany b≈ÇƒÖd')}")
    #             except Exception as e_proc:
    #                 failed_updates += 1
    #                 error_messages.append(f"{nr_kadrowy} ({date_str}): {str(e_proc)}")
    #                 log_error(f"B≈ÇƒÖd procedury importu dla {user_id}, {date_str}: {e_proc}", exception=e_proc)
    #
    #         if successful_updates > 0:
    #             self._update_cells_with_new_symbols(affected_pairs)
    #
    #         self._show_symbol_change_results(successful_updates, failed_updates, error_messages, events_to_cancel,
    #                                          skipped_employees)
    #     except Exception as e:
    #         log_error(f"B≈ÇƒÖd podczas wstawiania nieobecno≈õci: {e}", exception=e)
    #         QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas wstawiania nieobecno≈õci: {str(e)}",
    #                              QMessageBox.Ok)

    def clear_special_symbol_from_selected_cells(self):
        """Usuwa symbol specjalny (F12) z poprawnym sprawdzaniem uprawnie≈Ñ."""
        if not app_settings.has_permission(self.current_user_role, 'action_clear_special_symbol'):
            self.statusBar().showMessage("Brak uprawnie≈Ñ do wykonania tej operacji.", 3000)
            return

        selected_cells_data = self.table.get_data_for_selected_cells()
        if not self._can_modify_cells(selected_cells_data) or not selected_cells_data: return

        cells_to_modify = [cell for cell in selected_cells_data if
                           parse_symbol(cell.get('symbol', '')).get('special_symbol')]
        if not cells_to_modify:
            QMessageBox.information(self, "Brak zmian",
                                    "W zaznaczonych kom√≥rkach nie ma symboli specjalnych do usuniƒôcia.")
            return

        reply = QMessageBox.question(self, "Potwierdzenie operacji",
                                     f"Czy na pewno chcesz usunƒÖƒá symbole specjalne z {len(cells_to_modify)} kom√≥rek?",
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if reply != QMessageBox.Yes: return

        updated_info, error_messages = [], []
        for cell_data in cells_to_modify:
            parsed = parse_symbol(cell_data.get('symbol', ''))
            final_location = parsed.get('location') or self.determine_correct_location(cell_data)

            final_start_hour, final_work_hours = parsed.get('start_hour'), parsed.get('work_hours')
            new_symbol = "" if final_start_hour is None and final_work_hours is None else build_symbol(
                location=final_location,
                start_hour=final_start_hour,
                work_hours=final_work_hours,
                special_symbol=None)
            final_start_hour, final_work_hours = parsed.get('start_hour'), parsed.get('work_hours')
            new_symbol = "" if final_start_hour is None and final_work_hours is None else build_symbol(
                location=final_location, start_hour=final_start_hour, work_hours=final_work_hours, special_symbol=None)
            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month),
                                                             data=date_str, symbol=new_symbol)
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"{cell_data.get('uzytkownik_dane')}: {result.get('message', 'B≈ÇƒÖd zapisu.')}")
            except Exception as e:
                log_error(f"B≈ÇƒÖd w clear_special_symbol_from_selected_cells: {e}")
                error_messages.append(f"{cell_data.get('uzytkownik_dane')}: B≈ÇƒÖd aplikacji: {e}")
        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Pomy≈õlnie usuniƒôto symbole specjalne z {len(updated_info)} kom√≥rek.", 4000)
        if error_messages:
            QMessageBox.warning(self, "B≈Çƒôdy podczas zapisu",
                                f"WystƒÖpi≈Çy nastƒôpujƒÖce b≈Çƒôdy:\\n\\n" + "\\n".join(error_messages))

    # def _build_new_symbol_with_absence_fixed(self, current_symbol, special_symbol, cell_data):
    #     """Buduje nowy symbol z absencjƒÖ, poprawnie obs≈ÇugujƒÖc puste i wype≈Çnione kom√≥rki."""
    #     return self._predict_new_symbol(current_symbol, special_symbol, cell_data)

    def _add_location_exception_batch(self, params_list: list):
        """Dodaje seriƒô wyjƒÖtk√≥w w jednej transakcji dla wydajno≈õci i bezpiecze≈Ñstwa."""
        errors = []
        conn = None
        try:
            # Krok 1: Otw√≥rz po≈ÇƒÖczenie TYLKO RAZ
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            query = f"EXEC {SQL_OBJECTS['p_lokalizacjewyjatki']} ?, ?, ?, ?, ?, ?, ?, ?"

            # Krok 2: Wykonaj wszystkie operacje w pƒôtli
            for params in params_list:
                try:
                    cursor.execute(query, params)
                except Exception as e:
                    # Zbierz informacje o b≈Çƒôdach, kt√≥re wystƒÖpi≈Çy
                    date_str = params[2]  # Data jest na 3. pozycji w krotce
                    errors.append(f"Dzie≈Ñ {date_str}: {e}")

            # Krok 3: Zatwierd≈∫ wszystkie udane operacje JEDNYM poleceniem
            conn.commit()

            return {"success": not errors, "errors": errors}

        except Exception as e:
            log_error(f"B≈ÇƒÖd krytyczny podczas wsadowego dodawania wyjƒÖtk√≥w: {e}", exception=e)
            return {"success": False, "errors": [str(e)]}
        finally:
            # Krok 4: Zamknij po≈ÇƒÖczenie na samym ko≈Ñcu
            if conn:
                conn.close()

    def _check_location_exception(self, user_id, change_date):
        """Sprawdza wyjƒÖtek lokalizacyjny dla konkretnego dnia u≈ºywajƒÖc nowej funkcji TVF."""
        debug_print(
            f"--- Sprawdzanie wyjƒÖtku (TVF) dla U≈ºytkownika ID: {user_id}, Data: {change_date.toString('yyyy-MM-dd')} ---")
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            date_str = change_date.toString("yyyy-MM-dd")

            # Wywo≈Çanie nowej funkcji tabelarycznej
            fn_name = SQL_OBJECTS.get('fn_getlocationexceptions', 'dbo.fn_GetLocationExceptions')
            query = f"SELECT * FROM {fn_name}(?, ?, ?)"
            cursor.execute(query, (user_id, date_str, date_str))

            results = [dict(zip([column[0] for column in cursor.description], row)) for row in cursor.fetchall()]
            conn.close()

            debug_print(f"Znaleziono {len(results)} wpis√≥w w bazie danych przez TVF.")

            exact_match = None
            range_match = None
            py_change_date = change_date.toPython()

            for row_dict in results:
                data_od = row_dict['Dataod'].date()
                data_do = row_dict['Datado'].date() if row_dict['Datado'] else None
                if data_od == py_change_date and data_do and data_do == py_change_date:
                    exact_match = row_dict
                    break
                if data_od <= py_change_date and (not data_do or data_do >= py_change_date):
                    range_match = row_dict

            debug_print(
                f"Zwracam: exact_match={'TAK' if exact_match else 'NIE'}, range_match={'TAK' if range_match else 'NIE'}")
            return exact_match, range_match

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas sprawdzania wyjƒÖtk√≥w lokalizacyjnych (TVF): {e}", exception=e)
            return None, None

    def _manage_location_exception(self, params):
        """ZarzƒÖdza dodawaniem, edycjƒÖ i usuwaniem wyjƒÖtk√≥w lokalizacyjnych."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            query = f"EXEC {SQL_OBJECTS['p_lokalizacjewyjatki']} ?, ?, ?, ?, ?, ?, ?, ?"
            cursor.execute(query, params)

            # --- POCZƒÑTEK KLUCZOWEJ POPRAWKI ---
            # Ta pƒôtla zmusza sterownik do poczekania na pe≈Çne wykonanie procedury na serwerze,
            # zanim przejdzie do zamkniƒôcia po≈ÇƒÖczenia. Przetwarza wszystkie "ukryte" komunikaty
            # i zestawy wynik√≥w, kt√≥re procedura mog≈Çaby wygenerowaƒá.
            while cursor.nextset():
                pass
            # --- KONIEC KLUCZOWEJ POPRAWKI ---

            conn.commit()
            conn.close()
            return {"success": True}
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas zarzƒÖdzania wyjƒÖtkiem lokalizacyjnym: {e}", exception=e)
            return {"success": False, "message": str(e)}

    def _call_import_changes_procedure(self, nr_kadrowy, rok, miesiac, data, symbol):
        """Wywo≈Çuje procedurƒô i bardziej niezawodnie interpretuje jej wyniki."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(
                f"EXEC {SQL_OBJECTS['p_importzmianynaserwer']} @Nr_Kadrowy = ?, @Rok = ?, @Miesiac = ?, @Data = ?, @Symbol = ?, @CzyPobieranieSugestii = ?",
                (nr_kadrowy, rok, miesiac, data, symbol, None))

            all_results = []
            while True:
                try:
                    rows = cursor.fetchall()
                    if rows: all_results.extend(rows)
                    if not cursor.nextset(): break
                except Exception:
                    break
            conn.commit()
            conn.close()

            returned_symbol, success, message = symbol, True, "Operacja zako≈Ñczona pomy≈õlnie"
            for row in all_results:
                if row and len(row) > 0 and row[0] is not None:
                    raw_value = row[0]
                    if isinstance(raw_value, int) and raw_value == 0: continue
                    value_str = str(raw_value).strip()
                    if not value_str or value_str == "0": continue

                    is_likely_a_symbol = ' ' not in value_str and len(value_str) <= 50
                    if is_likely_a_symbol:
                        returned_symbol = value_str
                    else:
                        success, message = False, value_str
                        break
            if success:
                self._update_modification_date()
            return {"success": success, "message": message, "returned_symbol": returned_symbol}
        except Exception as e:
            log_error(f"B≈ÇƒÖd procedury ImportZmianNaSerwer: {e}")
            return {"success": False, "message": f"B≈ÇƒÖd bazy danych: {str(e)}", "returned_symbol": symbol}

    def _process_and_apply_changes(self, change_requests: list, success_message_template: str):
        """
        NOWA, CENTRALNA METODA: Przetwarza listƒô ≈ºƒÖda≈Ñ zmian, wywo≈Çuje procedurƒô,
        a nastƒôpnie zbiera i wy≈õwietla wyniki (sukcesy na pasku statusu, b≈Çƒôdy w oknie).

        Args:
            change_requests (list): Lista s≈Çownik√≥w, ka≈ºdy z kluczami:
                                    nr_kadrowy, rok, miesiac, data, symbol, user_id, user_name.
            success_message_template (str): Szablon wiadomo≈õci o sukcesie, np. "Zastosowano symbol dla {} kom√≥rek."
        """
        if not change_requests:
            return

        updated_info = []
        error_messages = []

        for req in change_requests:
            try:
                result = self._call_import_changes_procedure(
                    nr_kadrowy=req['nr_kadrowy'],
                    rok=req['rok'],
                    miesiac=req['miesiac'],
                    data=req['data'],
                    symbol=req['symbol']
                )
                if result.get('success'):
                    updated_info.append((req['user_id'], req['data'], result.get('returned_symbol')))
                else:
                    error_msg = result.get('message', 'Nieznany b≈ÇƒÖd')
                    error_messages.append(f"‚ë≠ {req.get('user_name', req['nr_kadrowy'])} ({req['data']}): {error_msg}")
            except Exception as e:
                log_error(f"B≈ÇƒÖd krytyczny podczas przetwarzania ≈ºƒÖdania zmiany: {req}", exception=e)
                error_messages.append(f"‚ë≠ {req.get('user_name', req['nr_kadrowy'])} ({req['data']}): {e}")

        # Aktualizuj UI dla udanych operacji
        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(success_message_template.format(len(updated_info)), 4000)

        # Wy≈õwietl jedno okno ze wszystkimi b≈Çƒôdami
        if error_messages:
            QMessageBox.warning(
                self,
                "B≈Çƒôdy podczas zapisu",
                f"WystƒÖpi≈Çy nastƒôpujƒÖce b≈Çƒôdy i niekt√≥re zmiany nie zosta≈Çy zapisane:\\n\\n" + "\\n".join(error_messages),
                QMessageBox.Ok
            )

    def _update_cells_with_new_symbols(self, updated_cells_info: list):
        """Aktualizuje kom√≥rki w modelu na podstawie danych zwr√≥conych przez procedurƒô."""
        if not updated_cells_info or not hasattr(self, 'schedule_model'): return
        for user_id, date_str, new_symbol in updated_cells_info:
            if new_symbol is not None:
                self._update_single_cell_in_model(user_id, date_str, new_symbol, self.year, self.month)
        debug_print(f"Zaktualizowano {len(updated_cells_info)} kom√≥rek w modelu.")

    def _update_single_cell_in_model(self, user_id, date_str, new_symbol, year, month):
        """Aktualizuje jednƒÖ kom√≥rkƒô w modelu i wymusza jej od≈õwie≈ºenie."""
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model: return False
            row_index = -1
            for idx, key in enumerate(self.schedule_model._keys):
                if str(key[3]) == str(user_id):
                    row_index = idx
                    break
            if row_index == -1: return False

            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)
            if int(year_str) != year or int(month_str) != month: return False

            col_index = len(self.schedule_model.get_visible_columns()) + day - 1
            model_index = self.schedule_model.index(row_index, col_index)
            if model_index.isValid():
                return self.schedule_model.setData(model_index, new_symbol, Qt.EditRole)
            return False
        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji kom√≥rki {user_id}/{date_str}: {e}")
            return False

    def _get_location_exceptions(self, user_id, start_date, end_date):
        """Pobiera wyjƒÖtki lokalizacyjne dla u≈ºytkownika w danym zakresie dat u≈ºywajƒÖc funkcji TVF."""
        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            fn_name = SQL_OBJECTS.get('fn_getlocationexceptions', 'dbo.fn_GetLocationExceptions')
            query = f"SELECT * FROM {fn_name}(?, ?, ?)"
            cursor.execute(query, (user_id, start_date.toString("yyyy-MM-dd"), end_date.toString("yyyy-MM-dd")))
            results = [dict(zip([column[0] for column in cursor.description], row)) for row in cursor.fetchall()]
            conn.close()
            return sorted(results, key=lambda x: x['Dataod'], reverse=True)
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas pobierania wyjƒÖtk√≥w (TVF): {e}", exception=e)
            return []

    def show_location_exception_dialog(self):
        """Otwiera okno do zarzƒÖdzania wyjƒÖtkami lokalizacyjnymi."""
        from location_exception_dialog import LocationExceptionDialog

        selected_cells = self.get_selected_cells_data()
        if not selected_cells:
            QMessageBox.warning(self, "Brak zaznaczenia", "Proszƒô zaznaczyƒá przynajmniej jednƒÖ kom√≥rkƒô pracownika.")
            return

        user_ids = {cell['uzytkownik_id'] for cell in selected_cells}
        if len(user_ids) > 1:
            QMessageBox.warning(self, "Wielu u≈ºytkownik√≥w", "Proszƒô zaznaczyƒá kom√≥rki tylko dla jednego pracownika.")
            return

        user_id = user_ids.pop()
        user_name = selected_cells[0]['uzytkownik_dane']

        dates = [QDate.fromString(cell['date_str'], "yyyy-MM-dd") for cell in selected_cells]
        selection_range = {'start': min(dates), 'end': max(dates)}

        dialog = LocationExceptionDialog(self, user_id, user_name, selection_range)
        dialog.data_changed.connect(self.refresh_data)

        # Zapisz stan widoku przed otwarciem dialogu
        self._state_to_restore = self._save_view_state()

        dialog.exec()

    def check_for_new_data(self):
        """Sprawdza nowe dane i wersjƒô, u≈ºywajƒÖc jednego po≈ÇƒÖczenia z bazƒÖ."""
        conn = None
        try:
            # Krok 1: Otw√≥rz JEDNO po≈ÇƒÖczenie na poczƒÖtku
            conn = DatabaseConnector.get_connection()

            # Krok 2: Za≈Çaduj ustawienia, przekazujƒÖc istniejƒÖce po≈ÇƒÖczenie
            if not load_all_app_settings(existing_conn=conn):
                log_warning("Nie uda≈Ço siƒô od≈õwie≈ºyƒá ustawie≈Ñ aplikacji w tle.")
                return

            # Krok 3: Sprawd≈∫ wersjƒô (korzystajƒÖc z ju≈º za≈Çadowanych danych)
            is_update_forced = app_settings.FORCE_UPDATE
            is_version_obsolete = self.check_if_update_is_required()
            if is_update_forced or is_version_obsolete:
                debug_print(
                    f"Wykryto polecenie zdalnej aktualizacji (force: {is_update_forced}, obsolete: {is_version_obsolete}). Zamykanie aplikacji.")
                self.check_timer.stop()
                dialog = UpdateRequiredDialog(self)
                dialog.exec()
                self.close()
                return

            # Krok 4: Sprawd≈∫ daty modyfikacji, u≈ºywajƒÖc wciƒÖ≈º tego samego po≈ÇƒÖczenia
            current_date_data = self.date_combo.currentData()
            if not current_date_data: return
            year, month = current_date_data
            if not hasattr(self, 'last_modification_date') or not self.last_modification_date:
                self._update_modification_date()  # Ta metoda otworzy w≈Çasne po≈ÇƒÖczenie, ale tylko raz na poczƒÖtku
                return

            cursor = conn.cursor()
            cursor.execute(
                f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['grafikipracy']} WHERE Rok = ? AND Miesiac = ?",
                (year, month))
            schedule_max_date = cursor.fetchone()[0]
            cursor.execute(f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['fn_geteventsdata']}(?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]

            new_data_types = []
            if schedule_max_date and schedule_max_date > self.last_modification_date:
                new_data_types.append("grafiku")
            if events_max_date and events_max_date > self.last_modification_date:
                new_data_types.append("zdarze≈Ñ")
            if new_data_types:
                latest_overall_modification = max(d for d in [schedule_max_date, events_max_date] if d)
                is_self_change = False
                if hasattr(self, 'last_self_modification_date') and self.last_self_modification_date:
                    if abs(latest_overall_modification - self.last_self_modification_date) < timedelta(seconds=2):
                        is_self_change = True
                if not is_self_change:
                    change_type_text = " i ".join(new_data_types)
                    self.refresh_button.setText(f"Nowe dane {change_type_text}!")
                    self.refresh_button.setToolTip(
                        f"Wykryto zmiany w sekcji: {change_type_text}. Kliknij, aby za≈Çadowaƒá.")
                    new_data_style = "QPushButton { background-color: #f39c12; color: white; font-weight: bold; border: 1px solid #e67e22; } QPushButton:hover { background-color: #e67e22; }"
                    self.refresh_button.setStyleSheet(new_data_style)
                    self.check_timer.stop()
                else:
                    self.last_modification_date = latest_overall_modification

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas sprawdzania nowych danych: {e}", exception=e)
        finally:
            # Krok 5: Zawsze zamknij po≈ÇƒÖczenie na ko≈Ñcu
            if conn:
                try:
                    conn.close()
                except Exception as e:
                    log_warning(f"Problem z zamkniƒôciem po≈ÇƒÖczenia w check_for_new_data: {e}")

    def _save_current_filter_settings(self):
        """Zapisuje aktualny stan filtr√≥w do s≈Çownika ustawie≈Ñ i do bazy danych."""
        if not hasattr(self, 'user_settings'):
            return

        # Zaktualizuj s≈Çownik o bie≈ºƒÖcy stan filtr√≥w
        self.user_settings['last_filters'] = self.get_current_filters_state()

        # Zapisz ca≈Çy, zaktualizowany s≈Çownik w bazie danych
        self.settings_db.save_settings(self.user_settings)
        debug_print("Zapisano bie≈ºƒÖcy stan filtr√≥w do bazy danych.")

    def refresh_data(self):
        """Wymusza od≈õwie≈ºenie danych z bazy, zachowujƒÖc stan filtr√≥w i sortowania."""
        # Krok 1: Pobierz bie≈ºƒÖcy stan filtr√≥w do zmiennej.
        filters_to_preserve = self.get_current_filters_state()

        self.refresh_button.setText("Od≈õwie≈º")
        self.refresh_button.setStyleSheet(AppStyles.get_button_style("dark" if self.is_dark_theme else "light"))
        self.refresh_button.setToolTip("Od≈õwie≈º dane")

        current_data = self.date_combo.currentData()
        if current_data:
            year, month = current_data

            self.update_buttons_visibility()
            self.data_provider.clear_monthly_cache(year, month)
            # Krok 2: Przeka≈º stan filtr√≥w do procesu aktualizacji danych.
            self.update_data(year, month, self.import_grupa, self.import_funkcja, use_async=True, filters_to_restore=filters_to_preserve)
            self.update_filter_dates()
            self._update_modification_date()
            if hasattr(self, 'check_timer'):
                self.check_timer.start(60000)

    def _update_modification_date(self):
        """Aktualizuje datƒô ostatniej modyfikacji po dokonaniu zmian."""
        try:
            current_date_data = self.date_combo.currentData()
            if not current_date_data: return
            year, month = current_date_data
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            cursor.execute(
                f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['grafikipracy']} WHERE Rok = ? AND Miesiac = ?",
                (year, month))
            schedule_max_date = cursor.fetchone()[0]
            cursor.execute(f"SELECT MAX(DataModyfikacji) FROM {SQL_OBJECTS['fn_geteventsdata']}(?, ?)", (year, month))
            events_max_date = cursor.fetchone()[0]
            conn.close()
            all_dates = [d for d in [schedule_max_date, events_max_date] if d is not None]
            if not all_dates: return
            latest_modification = max(all_dates)
            self.last_self_modification_date = latest_modification
            self.last_modification_date = latest_modification
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji daty modyfikacji: {e}", exception=e)

    def filter_data(self):
        """Filtruje dane grafiku i ZAWSZE stosuje sortowanie z ustawie≈Ñ u≈ºytkownika."""
        if not hasattr(self, 'schedule_model') or not self.schedule_model or getattr(self, '_updating_filters', False):
            return
        self._updating_filters = True
        try:
            # Krok 1: Aktualizacja i zastosowanie filtr√≥w
            self.update_cross_filters()
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

            # Krok 2: Zawsze po filtrowaniu, zastosuj zapisane sortowanie
            self.apply_custom_sort()

        finally:
            self._updating_filters = False
            current_data = self.date_combo.currentData()
            if current_data and self.staffing_details_win and not self.staffing_details_win.isHidden():
                year, month = current_data
                self.staffing_details_win.update_for_new_month_or_filters(year, month)

    def filter_events_table(self):
        """Filtruje tabelƒô zdarze≈Ñ, bazujƒÖc na danych z modelu."""
        try:
            if not hasattr(self, 'events_model') or not self.events_model: return

            # ZMIANA: Zawsze pobieraj dane ≈∫r√≥d≈Çowe z modelu,
            # kt√≥re zosta≈Çy tam wstawione przez `on_selection_changed`.
            source_data = self.events_model.get_all_events()
            if not source_data:
                self.events_model.filtered_update([])
                return

            filtered_data = source_data.copy()

            # Filtr typ√≥w
            allowed_types = []
            if self.meetings_checkbox.isChecked(): allowed_types.append('Spotkanie')
            if self.trainings_checkbox.isChecked(): allowed_types.append('Szkolenie')
            if self.overtime_checkbox.isChecked(): allowed_types.append('Nadgodziny')
            if allowed_types:
                filtered_data = [e for e in filtered_data if e.get('type') in allowed_types]

            # Filtr statusu
            selected_statuses = self.status_filter_combo.get_selected_items()
            if selected_statuses:
                filtered_data = [e for e in filtered_data if e.get('status') in selected_statuses]

            # Filtry tekstowe i dat
            topic_filter = self.topic_filter.text().lower()
            if topic_filter:
                filtered_data = [e for e in filtered_data if topic_filter in str(e.get('topic', '')).lower()]

            name_filter = self.name_filter.text().lower()
            if name_filter:
                filtered_data = [e for e in filtered_data if name_filter in str(e.get('name', '')).lower()]

            date_from_str = self.date_from.date().toString('yyyy-MM-dd')
            date_to_str = self.date_to.date().toString('yyyy-MM-dd')
            if date_from_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') >= date_from_str]
            if date_to_str:
                filtered_data = [e for e in filtered_data if e.get('date_key', '') <= date_to_str]

            self.events_model.filtered_update(filtered_data)
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas filtrowania zdarze≈Ñ: {str(e)}")

    def setup_events_table_columns(self):
        """Konfiguruje kolumny dla tabeli zdarze≈Ñ w spos√≥b jawny i niezawodny."""
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        header = self.events_table.horizontalHeader()
        header.setStretchLastSection(False)

        # Ustawiamy tryb interaktywny, aby u≈ºytkownik m√≥g≈Ç sam zmieniaƒá rozmiar,
        # ale definiujemy rozsƒÖdne szeroko≈õci startowe.
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(0, 40)  # Id

        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(1, 80)  # Typ

        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)  # Temat
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.Stretch)  # Nazwa

        header.setSectionResizeMode(4, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(4, 150)  # U≈ºytkownik

        header.setSectionResizeMode(5, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(5, 90)  # Data

        header.setSectionResizeMode(6, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(6, 120)  # Czas od

        header.setSectionResizeMode(7, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(7, 120)  # Czas do

        header.setSectionResizeMode(8, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(8, 100)  # Status

        header.setSectionResizeMode(9, QHeaderView.ResizeMode.Interactive)
        self.events_table.setColumnWidth(9, 125)  # Data Modyfikacji

        # Kolumna Akcje - sta≈Ça i nienaruszalna
        header.setSectionResizeMode(10, QHeaderView.ResizeMode.Fixed)
        self.events_table.setColumnWidth(10, 85)  # Akcje

    def show_schedule_control_dialog(self):
        """Pokazuje odpowiednie okno dialogowe w zale≈ºno≈õci od roli u≈ºytkownika."""
        from schedule_control_dialog import ScheduleControlDialog, SuggestionsOutDialog

        # G≈Ç√≥wny przycisk jest ju≈º chroniony przez 'button_schedule_control'.
        # Poni≈ºsza logika jedynie decyduje, kt√≥re okno pokazaƒá dla uprawnionego u≈ºytkownika.
        # Jest to akceptowalne, poniewa≈º nie nadaje dodatkowych uprawnie≈Ñ.
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Proszƒô najpierw wybraƒá miesiƒÖc.")
            return

        year, month = current_data

        if self.current_user_role == "Pracownik WPR":
            dialog = ScheduleControlDialog(self, year, month)
        elif self.current_user_role == "Lider OUT":
            dialog = SuggestionsOutDialog(self, year, month)
        else:
            # Ten komunikat nie powinien siƒô pojawiƒá, je≈õli przycisk jest poprawnie ukryty,
            # ale zostawiamy go jako zabezpieczenie.
            QMessageBox.information(self, "Brak dostƒôpu", "Twoja rola nie ma dostƒôpu do tej funkcji.")
            return

        dialog.data_refresh_needed.connect(self.refresh_data)
        dialog.exec()

    def show_insert_change_dialog(self):
        """Pokazuje okno dialogowe do wstawiania zmian w grafiku"""
        if not app_settings.has_permission(self.current_user_role, 'schedule_cell_actions'):
            self.statusBar().showMessage("Brak uprawnie≈Ñ do wstawiania zmian.", 3000)
            return

        # from schedule_edit_dialogs import ScheduleChangeDialog # Ten import ju≈º jest wy≈ºej
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Nie wybrano miesiƒÖca. Nie mo≈ºna dodaƒá zmiany grafiku.", QMessageBox.Ok)
            return

        year, month = current_data
        selected_cells = self.table.get_data_for_selected_cells()

        if not selected_cells:
            QMessageBox.warning(self, "Brak zaznaczenia", "Nie zaznaczono ≈ºadnych kom√≥rek do edycji.", QMessageBox.Ok)
            return

        grouped_cells = self.group_cells_by_user_and_day(selected_cells)

        dialog = ScheduleChangeDialog(self, grouped_cells=grouped_cells, year=year, month=month, main_window=self)

        dialog.changes_requested.connect(self.handle_schedule_change_request)
        dialog.exec()

    def handle_schedule_change_request(self, change_requests: list):
        """
        Przetwarza ≈ºƒÖdania zmian w grafiku z ostatecznƒÖ walidacjƒÖ
        przypisania lokalizacji i poprawnym statusem "Brak zmiany".
        """
        dialog = self.sender()

        for request in change_requests:
            visual_row = request['visual_row']
            cell_data = request['cell_data']

            try:
                # --- Krok 1: Pobranie danych (bez zmian) ---
                user_id = cell_data.get('uzytkownik_id')
                nr_kadrowy = cell_data.get('nr_kadrowy')
                user_name = cell_data.get('uzytkownik_dane')
                date_str = cell_data.get('date_str')
                q_date = QDate.fromString(date_str, "yyyy-MM-dd")
                _, modyfikujacy_id, _, _, _ = get_modifier_id()
                location_map = {'h': 1, 's': 3, 'p': 2}
                default_location_code = cell_data.get('lokalizacja_domyslna', 'h')
                target_dept = cell_data.get('wydzial', '').upper()

                from symbol_parser import parse_symbol, build_symbol
                original_symbol = cell_data.get('symbol', '')
                original_parsed_symbol = parse_symbol(original_symbol)

                new_location_code = request['new_location_code']
                new_start_hour = request['new_start_hour']
                new_work_hours = request['new_work_hours']

                # --- Krok 2: Logika biznesowa dla wyjƒÖtk√≥w (bez zmian) ---
                original_location_code = original_parsed_symbol.get('location') or default_location_code
                loc_changed = new_location_code != original_location_code
                is_reverting_to_default = loc_changed and (new_location_code == default_location_code)
                reason_for_change = None

                if loc_changed:
                    if is_reverting_to_default:
                        reason_for_change = None
                    elif target_dept.startswith('WZP'):
                        reason_for_change = "Zmiana w aplikacji"
                    else:
                        if user_id in dialog.reason_cache:
                            reason_for_change = dialog.reason_cache[user_id]
                        else:
                            reason_dialog = ReasonDialog(dialog)
                            if reason_dialog.exec() == QDialog.Accepted:
                                reason_for_change = reason_dialog.getReason()
                                dialog.reason_cache[user_id] = reason_for_change
                            else:
                                dialog.update_status_for_row(visual_row, 'failure', "Anulowano")
                                continue

                # --- Krok 3: Walidacja lokalizacji i budowa nowego symbolu (bez zmian) ---
                final_location_for_build = new_location_code
                original_special_symbol = original_parsed_symbol.get('special_symbol')

                if original_special_symbol and original_special_symbol.upper() not in app_settings.WORK_LIKE_SYMBOLS:
                    final_location_for_build = None

                new_symbol = build_symbol(
                    location=final_location_for_build,
                    start_hour=new_start_hour,
                    work_hours=new_work_hours,
                    special_symbol=original_special_symbol
                )

                # --- ZMIANA: Ostateczne por√≥wnanie symboli przed wys≈Çaniem do bazy ---
                if new_symbol == original_symbol:
                    dialog.update_status_for_row(visual_row, 'no_change')
                    continue  # Przejd≈∫ do nastƒôpnego ≈ºƒÖdania, pomijajƒÖc zapis do bazy
                # --- KONIEC ZMIANY ---

                # --- Krok 4: Wywo≈Çanie procedur (bez zmian) ---
                result = {}
                new_symbol = build_symbol(
                    location=final_location_for_build,
                    start_hour=new_start_hour,
                    work_hours=new_work_hours,
                    special_symbol=original_special_symbol
                )

                if loc_changed:
                    exact_exception, range_exception = self._check_location_exception(user_id, q_date)
                    new_location_id = location_map.get(new_location_code, 1)
                    if is_reverting_to_default:
                        if range_exception:
                            result = {"success": False,
                                      "message": "Ten dzie≈Ñ jest czƒô≈õciƒÖ wielodniowego wyjƒÖtku. Zaktualizuj go rƒôcznie."}
                        else:
                            result = self._call_import_changes_procedure(nr_kadrowy, self.year, self.month, date_str,
                                                                         new_symbol)
                            if result.get("success") and exact_exception:
                                params = (
                                None, modyfikujacy_id, None, None, None, reason_for_change, 3, exact_exception['Id'])
                                self._manage_location_exception(params)
                    else:
                        if exact_exception:
                            if exact_exception['Lokalizacja'] == new_location_id:
                                result = self._call_import_changes_procedure(nr_kadrowy, self.year, self.month,
                                                                             date_str, new_symbol)
                            else:
                                result = self._call_import_changes_procedure(nr_kadrowy, self.year, self.month,
                                                                             date_str, new_symbol)
                                if result.get("success"):
                                    params = (
                                    user_id, modyfikujacy_id, date_str, date_str, new_location_id, reason_for_change, 2,
                                    exact_exception['Id'])
                                    self._manage_location_exception(params)
                        elif range_exception:
                            if range_exception['Lokalizacja'] != new_location_id:
                                result = {"success": False,
                                          "message": "Istnieje wyjƒÖtek w zakresie dat z innƒÖ lokalizacjƒÖ."}
                            else:
                                result = self._call_import_changes_procedure(nr_kadrowy, self.year, self.month,
                                                                             date_str, new_symbol)
                        else:
                            result = self._call_import_changes_procedure(nr_kadrowy, self.year, self.month, date_str,
                                                                         new_symbol)
                            if result.get("success"):
                                params = (
                                user_id, modyfikujacy_id, date_str, date_str, new_location_id, reason_for_change, 1,
                                None)
                                self._manage_location_exception(params)
                else:
                    result = self._call_import_changes_procedure(nr_kadrowy, self.year, self.month, date_str,
                                                                 new_symbol)

                if loc_changed and result.get("success"):
                    overtime_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                    overtime_events = [e for e in overtime_events if e.get('type') == 'Nadgodziny']
                    if overtime_events:
                        ot_dialog = OvertimeLocationDialog(dialog, overtime_events, new_location_code,
                                                           dialog.determined_theme)
                        if ot_dialog.exec() == QDialog.Accepted:
                            location_changes = ot_dialog.get_selected_locations()
                            if location_changes: self._update_multiple_overtime_locations(location_changes)

                # --- Krok 5: Przetwarzanie wyniku i aktualizacja UI ---
                if result.get("success", False):
                    returned_symbol = result.get('returned_symbol', new_symbol)
                    self._update_cells_with_new_symbols([(user_id, date_str, returned_symbol)])
                    cell_data['symbol'] = returned_symbol

                    if dialog and hasattr(dialog, 'update_status_for_row'):
                        dialog.update_status_for_row(visual_row, 'success')
                        dialog.cells_table.item(visual_row, 3).setText(returned_symbol)
                else:
                    error_msg = result.get("message", "Nieznany b≈ÇƒÖd.")
                    if dialog and hasattr(dialog, 'update_status_for_row'):
                        dialog.update_status_for_row(visual_row, 'failure', error_msg)
                    QMessageBox.warning(self, "B≈ÇƒÖd",
                                        f"B≈ÇƒÖd dla {user_name} ({self.format_date(date_str)}):\\n{error_msg}",
                                        QMessageBox.Ok)

            except Exception as e:
                log_error(f"B≈ÇƒÖd krytyczny w handle_schedule_change_request: {e}", exception=e)
                if dialog and hasattr(dialog, 'update_status_for_row'):
                    dialog.update_status_for_row(visual_row, 'failure', str(e))

    def _save_view_state(self):
        """Zapisuje stabilne identyfikatory zaznaczenia, sortowanie i pozycjƒô przewijania."""
        schedule_selection_ids = []
        if self.table.schedule_view.selectionModel():
            for index in self.table.schedule_view.selectionModel().selectedIndexes():
                data = index.data(ROLE_DATA)
                if isinstance(data, dict) and 'uzytkownik_id' in data and 'date_str' in data:
                    schedule_selection_ids.append((data['uzytkownik_id'], data['date_str']))

        employees_selection_ids = set()
        if self.table.employees_view.selectionModel():
            for index in self.table.employees_view.selectionModel().selectedIndexes():
                data = index.data(ROLE_DATA)
                if isinstance(data, dict) and 'uzytkownik_id' in data:
                    employees_selection_ids.add(data['uzytkownik_id'])

        state = {
            'schedule_selection_ids': schedule_selection_ids,
            'employees_selection_ids': list(employees_selection_ids),
            'emp_sort_col': self.table.employees_view.horizontalHeader().sortIndicatorSection(),
            'emp_sort_order': self.table.employees_view.horizontalHeader().sortIndicatorOrder(),
            'sched_sort_col': self.table.schedule_view.horizontalHeader().sortIndicatorSection(),
            'sched_sort_order': self.table.schedule_view.horizontalHeader().sortIndicatorOrder(),
            'v_scroll_pos': self.table.schedule_view.verticalScrollBar().value(),
            'h_scroll_pos': self.table.schedule_view.horizontalScrollBar().value()
        }
        debug_print(
            f"[DB] ZAPISYWANIE STANU: emp_sort_col={state['emp_sort_col']}, sched_sort_col={state['sched_sort_col']}, selections={len(schedule_selection_ids)}")
        return state

    def _restore_view_state(self, state):
        """Przywraca sortowanie, zaznaczenie i pozycjƒô przewijania po resecie modelu."""
        debug_print(f"[DB] ROZPOCZƒòTO PRZYWRACANIE STANU...")
        if not self.schedule_model or self.schedule_model.rowCount() == 0:
            debug_print("[DB] PRZERWANO PRZYWRACANIE: Model jest pusty.")
            return

        schedule_sm = self.table.schedule_view.selectionModel()
        employees_sm = self.table.employees_view.selectionModel()
        if schedule_sm: schedule_sm.blockSignals(True)
        if employees_sm: employees_sm.blockSignals(True)

        try:
            # Krok 1: Zawsze stosuj pe≈Çne, wielopoziomowe sortowanie z ustawie≈Ñ u≈ºytkownika.
            # To jest jedyne ≈∫r√≥d≈Ço prawdy o po≈ºƒÖdanym porzƒÖdku po resecie danych.
            self.apply_custom_sort()

            # Krok 2: Zbuduj mapƒô do wyszukania nowych indeks√≥w wierszy po posortowaniu.
            user_id_to_new_row_map = {str(key[3]): i for i, key in enumerate(self.schedule_model._keys)}

            # Krok 3: Odtw√≥rz zaznaczenie na podstawie nowych, prawid≈Çowych indeks√≥w.
            schedule_selection = QItemSelection()
            employee_cols_count = len(self.schedule_model.get_visible_columns())
            for user_id, date_str in state['schedule_selection_ids']:
                new_row = user_id_to_new_row_map.get(str(user_id))
                if new_row is not None:
                    try:
                        day = int(date_str.split('-')[2])
                        new_col = employee_cols_count + day - 1
                        model_index = self.schedule_model.index(new_row, new_col)
                        if model_index.isValid():
                            schedule_selection.select(model_index, model_index)
                    except (ValueError, IndexError):
                        continue

            employees_selection = QItemSelection()
            for user_id in state['employees_selection_ids']:
                new_row = user_id_to_new_row_map.get(str(user_id))
                if new_row is not None:
                    top_left = self.schedule_model.index(new_row, 0)
                    bottom_right = self.schedule_model.index(new_row, employee_cols_count - 1)
                    if top_left.isValid() and bottom_right.isValid():
                        employees_selection.select(top_left, bottom_right)

            debug_print(
                f"[DB] Przywracam zaznaczenie: {len(state['schedule_selection_ids'])} kom√≥rek, {len(state['employees_selection_ids'])} wierszy.")
            if schedule_sm: schedule_sm.select(schedule_selection, QItemSelectionModel.ClearAndSelect)
            if employees_sm: employees_sm.select(employees_selection,
                                                 QItemSelectionModel.ClearAndSelect | QItemSelectionModel.Rows)

            # Krok 4: Przywr√≥ƒá pozycjƒô pask√≥w przewijania.
            self.table.schedule_view.verticalScrollBar().setValue(state['v_scroll_pos'])
            self.table.schedule_view.horizontalScrollBar().setValue(state['h_scroll_pos'])
            debug_print(f"[DB] Przywr√≥cono pozycjƒô przewijania: V={state['v_scroll_pos']}, H={state['h_scroll_pos']}")

        finally:
            # Zawsze w≈ÇƒÖczaj sygna≈Çy z powrotem.
            if schedule_sm: schedule_sm.blockSignals(False)
            if employees_sm: employees_sm.blockSignals(False)
        debug_print(f"[DB] ZAKO≈ÉCZONO PRZYWRACANIE STANU.")

    def format_date(self, date_str: str) -> str:
        """
        Formatuje datƒô z formatu 'YYYY-MM-DD' na 'DD.MM.YYYY'.

        Args:
            date_str (str): Data w formacie 'YYYY-MM-DD'.

        Returns:
            str: Sformatowana data lub oryginalny ciƒÖg w razie b≈Çƒôdu.
        """
        try:
            year, month, day = date_str.split('-')
            return f"{day}.{month}.{year}"
        except (ValueError, AttributeError):
            return date_str

    def show_add_overtime_dialog(self):
        """Pokazuje okno dialogowe do dodawania nadgodzin."""
        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Nie wybrano miesiƒÖca.", QMessageBox.Ok)
            return
        year, month = current_data
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not self._can_modify_cells(selected_cells_data) or not selected_cells_data or len(selected_cells_data) > 1:
            QMessageBox.warning(self, "B≈ÇƒÖd zaznaczenia", "Zaznacz dok≈Çadnie jednƒÖ kom√≥rkƒô, aby dodaƒá nadgodziny.",
                                QMessageBox.Ok)
            return

        cell_data = selected_cells_data[0]
        selected_user_id, selected_user_name, day, date_str, nr_kadrowy, start_hour, current_symbol, lokalizacja_domyslna = (
            cell_data.get('uzytkownik_id'), cell_data.get('uzytkownik_dane'), cell_data.get('day'),
            cell_data.get('date_str'), cell_data.get('nr_kadrowy'), cell_data.get('start_hour'),
            cell_data.get('symbol', ''), cell_data.get('lokalizacja_domyslna', 'h')
        )

        if not all([selected_user_id, day, date_str]):
            QMessageBox.warning(self, "B≈ÇƒÖd", "Brak wymaganych danych w zaznaczonej kom√≥rce.", QMessageBox.Ok)
            return

        selected_date = QDate.fromString(date_str, "yyyy-MM-dd")
        is_day_off = not current_symbol or current_symbol.strip() == ''
        if start_hour is None: start_hour = 9 if is_day_off else 8

        parsed_symbol = parse_symbol(current_symbol)
        current_location = parsed_symbol.get('location') if parsed_symbol and parsed_symbol.get(
            'location') else lokalizacja_domyslna

        dialog = QDialog(self)
        polish_months = ["stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca", "lipca", "sierpnia", "wrze≈õnia",
                         "pa≈∫dziernika", "listopada", "grudnia"]
        dialog.setWindowTitle(
            f"Dodaj nadgodziny w dniu {selected_date.day()} {polish_months[selected_date.month() - 1]} {selected_date.year()}")
        dialog.setMinimumWidth(300)
        layout = QVBoxLayout(dialog)
        layout.addWidget(QLabel(f"Pracownik: {selected_user_name}"))
        if nr_kadrowy: layout.addWidget(QLabel(f"Numer kadrowy: {nr_kadrowy}"))
        layout.addWidget(QLabel(f"MiesiƒÖc rozliczenia: {month:02d}.{year}"))
        if is_day_off: layout.addWidget(QLabel("Zaznaczony dzie≈Ñ jest dniem wolnym pracownika."))

        form_frame = QFrame()
        form_layout = QGridLayout(form_frame)
        time_combo = QComboBox()
        for h in range(24):
            for m in [0, 30]:
                time_combo.addItem(f"{h:02d}:{m:02d}")
        default_time = f"{(start_hour + 8) % 24:02d}:00" if not is_day_off else "09:00"
        time_combo.setCurrentText(default_time)

        hours_combo = QComboBox()
        for h in [i * 0.5 for i in range(1, 27)]: hours_combo.addItem(f"{h:.1f}", h)
        hours_combo.setCurrentIndex(1)

        type_combo, ld_combo, overdue_combo = QComboBox(), QComboBox(), QComboBox()
        type_combo.addItems(["wyp≈Çata", "odbi√≥r", "odpracowanie"])
        ld_combo.addItems(["h", "p", "s"])
        ld_combo.setCurrentText(current_location)
        overdue_combo.addItems(["nie", "tak"])
        add_button = QPushButton("Dodaj")

        form_layout.addWidget(QLabel("od kiedy"), 0, 0);
        form_layout.addWidget(time_combo, 0, 1)
        form_layout.addWidget(QLabel("ile godzin"), 0, 2);
        form_layout.addWidget(hours_combo, 0, 3)
        form_layout.addWidget(QLabel("typ"), 0, 4);
        form_layout.addWidget(type_combo, 0, 5)
        form_layout.addWidget(QLabel("LD"), 0, 6);
        form_layout.addWidget(ld_combo, 0, 7)
        form_layout.addWidget(QLabel("czy zaleg≈Çe"), 0, 8);
        form_layout.addWidget(overdue_combo, 0, 9)
        form_layout.addWidget(add_button, 0, 10)
        layout.addWidget(form_frame)

        def add_overtime():
            result = self.call_add_overtime_procedure_fixed(
                selected_user_id, selected_date.year(), selected_date.month(),
                selected_date.toString("yyyy-MM-dd"), time_combo.currentText(),
                float(hours_combo.currentData()), f"{year}-{month:02d}-01",
                overdue_combo.currentIndex(), type_combo.currentText(),
                ld_combo.currentText(), nr_kadrowy
            )
            if result["success"]:
                self.statusBar().showMessage("Pomy≈õlnie dodano nadgodziny.", 3000)
                dialog.accept()
            else:
                QMessageBox.warning(dialog, "B≈ÇƒÖd", result["message"], QMessageBox.Ok)

        add_button.clicked.connect(add_overtime)
        dialog.exec()

    def show_settings_dialog(self):
        """Pokazuje okno dialogowe ustawie≈Ñ aplikacji."""
        from settings_dialog import AppSettingsDialog

        dialog = AppSettingsDialog(self, settings=self.user_settings)
        dialog.live_theme_changed.connect(self.apply_theme_settings)
        # --- POD≈ÅƒÑCZENIE NOWEGO SYGNA≈ÅU ---
        dialog.import_requested.connect(self.on_import_requested)

        if dialog.exec() == QDialog.Accepted:
            # Ta czƒô≈õƒá wykona siƒô po klikniƒôciu "OK" lub "Importuj teraz"
            new_settings = dialog.get_current_settings()
            should_save = new_settings.pop('save_to_db', False)

            self.user_settings.update(new_settings)

            self.is_dark_theme = self.user_settings.get('theme') == 'dark'
            self.current_font = self.user_settings.get('font_family')
            self.current_font_size = self.user_settings.get('font_size')

            self.apply_theme_settings('dark' if self.is_dark_theme else 'light', self.current_font,
                                      self.current_font_size)
            self.setup_table_properties()
            self.table.schedule_view.viewport().update()

            if should_save:
                self.settings_db.save_settings(self.user_settings)
                debug_print(f"Zapisano ustawienia z dialogu.")

    def on_import_requested(self, grupa, funkcja):
        """Obs≈Çuguje ≈ºƒÖdanie importu z okna ustawie≈Ñ."""
        debug_print(f"Otrzymano ≈ºƒÖdanie importu z ustawieniami: Grupa={grupa}, Funkcja={funkcja}")

        # Zaktualizuj atrybuty w g≈Ç√≥wnym oknie
        self.import_grupa = grupa
        self.import_funkcja = funkcja

        # Wywo≈Çaj od≈õwie≈ºenie danych
        self.refresh_data()

    def _update_model_with_new_symbols(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje symbole bezpo≈õrednio w modelu
        """
        try:
            if not updated_symbols or not hasattr(self, 'schedule_model'):
                return

            processed_data = self.schedule_model.get_processed_data()
            if not processed_data:
                return

            updated_count = 0
            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Znajd≈∫ klucz u≈ºytkownika w processed_data
                target_key = None
                for key in processed_data.keys():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        target_key = key
                        break

                if not target_key:
                    debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                    continue

                # Oblicz dzie≈Ñ z daty
                try:
                    year_str, month_str, day_str = date_str.split('-')
                    day = int(day_str)

                    if int(year_str) != year or int(month_str) != month:
                        continue

                except ValueError:
                    continue

                # Aktualizuj symbol w processed_data
                user_data = processed_data[target_key]
                days_data = user_data.setdefault('days', {})
                day_data = days_data.setdefault(day, {})

                old_symbol = day_data.get('symbol', '')
                day_data['symbol'] = new_symbol

                # Przelicz godziny na podstawie nowego symbolu
                from symbol_parser import parse_symbol
                parsed = parse_symbol(new_symbol)
                day_data['hours'] = parsed.get('work_hours', 0) or 0
                day_data['start_hour'] = parsed.get('start_hour')

                # Aktualizuj total_hours u≈ºytkownika
                old_hours = 0
                if old_symbol:
                    old_parsed = parse_symbol(old_symbol)
                    old_hours = old_parsed.get('work_hours', 0) or 0

                new_hours = day_data['hours']
                user_data['total_hours'] = (user_data.get('total_hours', 0) or 0) - old_hours + new_hours

                updated_count += 1
                debug_print(
                    f"Model: Zaktualizowano {user_id}/{day}: '{old_symbol}' -> '{new_symbol}' ({old_hours}h -> {new_hours}h)")

            debug_print(f"Zaktualizowano {updated_count} kom√≥rek w modelu")

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji modelu: {e}")

    def _update_data_provider_cache(self, updated_symbols, year, month):
        """
        NOWA METODA: Aktualizuje cache w DataProvider
        """
        try:
            if not updated_symbols or not hasattr(self.data_provider, 'monthly_cache'):
                return

            month_key = (year, month)
            if month_key not in self.data_provider.monthly_cache:
                return

            container = self.data_provider.monthly_cache[month_key]

            for (user_id, date_str), new_symbol in updated_symbols.items():
                # Aktualizuj processed_data w kontenerze
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):
                        try:
                            year_str, month_str, day_str = date_str.split('-')
                            day = int(day_str)

                            if int(year_str) == year and int(month_str) == month:
                                days_data = user_data.setdefault('days', {})
                                day_data = days_data.setdefault(day, {})
                                day_data['symbol'] = new_symbol

                                # Przelicz godziny
                                from symbol_parser import parse_symbol
                                parsed = parse_symbol(new_symbol)
                                day_data['hours'] = parsed.get('work_hours', 0) or 0
                                day_data['start_hour'] = parsed.get('start_hour')

                                debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")
                                break
                        except:
                            continue

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji DataProvider cache: {e}")

    def _force_full_refresh(self):
        """Fallback - pe≈Çne od≈õwie≈ºenie danych"""
        try:
            current_data = self.date_combo.currentData()
            if current_data:
                year, month = current_data
                self.data_provider.refresh_data(year, month)
                self.update_table_content()
        except Exception as e:
            log_error(f"B≈ÇƒÖd pe≈Çnego od≈õwie≈ºenia: {e}")

    def _force_refresh_specific_cells(self, affected_pairs, year, month):
        """
        POPRAWIONA METODA: Wymusza od≈õwie≈ºenie konkretnych kom√≥rek w widoku
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycjƒô kom√≥rki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajd≈∫ wiersz u≈ºytkownika w modelu
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnƒô dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymusza od≈õwie≈ºenie kom√≥rki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej kom√≥rki
                        self.schedule_model.dataChanged.emit(model_index, model_index,
                                                             [Qt.DisplayRole, Qt.BackgroundRole])

                        # Metoda 2: Wymu≈õ update widoku dla tej kom√≥rki
                        self.table.schedule_view.update(model_index)

                        refreshed_cells += 1
                        debug_print(f"Od≈õwie≈ºono kom√≥rkƒô tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"B≈ÇƒÖd od≈õwie≈ºania kom√≥rki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymu≈õ ca≈Ço≈õciowy update viewport je≈õli zmieniono jakie≈õ kom√≥rki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po od≈õwie≈ºeniu {refreshed_cells} kom√≥rek")

                # DODATKOWE: Wymu≈õ te≈º od≈õwie≈ºenie tabeli pracownik√≥w (dla sum RBH)
                if hasattr(self.table, 'employees_view'):
                    self.table.employees_view.viewport().update()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas wymuszania od≈õwie≈ºenia kom√≥rek tabeli: {e}")

    def _update_model_cells_directly(self, updated_symbols, year, month):
        """
        Aktualizuje symbole bezpo≈õrednio w modelu i DataProvider

        Args:
            updated_symbols (dict): S≈Çownik {(user_id, date_str): symbol}
            year (int): Rok
            month (int): MiesiƒÖc
        """
        try:
            if not updated_symbols:
                return

            updated_count = 0

            # AKTUALIZACJA 1: Schedule Model processed_data
            if hasattr(self, 'schedule_model') and self.schedule_model:
                processed_data = self.schedule_model.get_processed_data()

                if processed_data:
                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        if self._update_single_cell_in_processed_data(processed_data, user_id, date_str, new_symbol,
                                                                      year, month):
                            updated_count += 1

            # AKTUALIZACJA 2: DataProvider cache (je≈õli istnieje)
            if hasattr(self.data_provider, 'monthly_cache'):
                month_key = (year, month)
                if month_key in self.data_provider.monthly_cache:
                    container = self.data_provider.monthly_cache[month_key]

                    for (user_id, date_str), new_symbol in updated_symbols.items():
                        self._update_single_cell_in_data_provider(container, user_id, date_str, new_symbol, year, month)

            debug_print(f"Zaktualizowano {updated_count} kom√≥rek w modelu")

        except Exception as e:
            log_error(f"B≈ÇƒÖd bezpo≈õredniej aktualizacji modelu: {e}")

    def _update_single_cell_in_processed_data(self, processed_data, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczƒÖ kom√≥rkƒô w processed_data

        Returns:
            bool: True je≈õli zaktualizowano
        """
        try:
            # Znajd≈∫ klucz u≈ºytkownika
            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if not target_key:
                debug_print(f"Nie znaleziono klucza dla user_id {user_id}")
                return False

            # Oblicz dzie≈Ñ
            year_str, month_str, day_str = date_str.split('-')
            day = int(day_str)

            if int(year_str) != year or int(month_str) != month:
                return False

            # Aktualizuj symbol
            user_data = processed_data[target_key]
            days_data = user_data.setdefault('days', {})
            day_data = days_data.setdefault(day, {})

            old_symbol = day_data.get('symbol', '')
            day_data['symbol'] = new_symbol

            # Przelicz godziny i inne parametry
            from symbol_parser import parse_symbol
            parsed = parse_symbol(new_symbol)
            day_data['hours'] = parsed.get('work_hours', 0) or 0
            day_data['start_hour'] = parsed.get('start_hour')

            debug_print(f"Model: {user_id}/{day} '{old_symbol}' -> '{new_symbol}'")
            return True

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji kom√≥rki processed_data {user_id}/{date_str}: {e}")
            return False

    def _update_single_cell_in_data_provider(self, container, user_id, date_str, new_symbol, year, month):
        """
        Aktualizuje pojedynczƒÖ kom√≥rkƒô w DataProvider cache
        """
        try:
            if not hasattr(container, 'processed_data') or not container.processed_data:
                return

            # Podobna logika jak dla processed_data w modelu
            processed_data = container.processed_data

            target_key = None
            for key in processed_data.keys():
                if str(key[3]) == str(user_id):
                    target_key = key
                    break

            if target_key:
                year_str, month_str, day_str = date_str.split('-')
                day = int(day_str)

                if int(year_str) == year and int(month_str) == month:
                    user_data = processed_data[target_key]
                    days_data = user_data.setdefault('days', {})
                    day_data = days_data.setdefault(day, {})
                    day_data['symbol'] = new_symbol

                    # Przelicz godziny
                    from symbol_parser import parse_symbol
                    parsed = parse_symbol(new_symbol)
                    day_data['hours'] = parsed.get('work_hours', 0) or 0
                    day_data['start_hour'] = parsed.get('start_hour')

                    debug_print(f"DataProvider: Zaktualizowano {user_id}/{day}")

        except Exception as e:
            log_error(f"B≈ÇƒÖd aktualizacji DataProvider cache: {e}")

    def _force_refresh_table_cells(self, affected_pairs, year, month):
        """
        WYMUSZA od≈õwie≈ºenie konkretnych kom√≥rek w widoku tabeli

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
            year (int): Rok
            month (int): MiesiƒÖc
        """
        try:
            if not hasattr(self, 'table') or not hasattr(self.table, 'schedule_view'):
                return

            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return

            refreshed_cells = 0

            for user_id, date_str in affected_pairs:
                try:
                    # Oblicz pozycjƒô kom√≥rki
                    year_str, month_str, day_str = date_str.split('-')
                    if int(year_str) != year or int(month_str) != month:
                        continue

                    day = int(day_str)

                    # Znajd≈∫ wiersz u≈ºytkownika
                    row_index = self._find_user_row_in_model(user_id)
                    if row_index == -1:
                        debug_print(f"Nie znaleziono wiersza dla user_id {user_id}")
                        continue

                    # Oblicz kolumnƒô dnia
                    visible_columns_count = len(self.schedule_model.get_visible_columns())
                    col_index = visible_columns_count + day - 1

                    # KLUCZOWE: Wymu≈õ od≈õwie≈ºenie kom√≥rki
                    model_index = self.schedule_model.index(row_index, col_index)
                    if model_index.isValid():
                        # Metoda 1: Emituj dataChanged dla konkretnej kom√≥rki
                        self.schedule_model.dataChanged.emit(model_index, model_index, [])

                        # Metoda 2: Wymu≈õ update widoku (backup)
                        self.table.schedule_view.update(model_index)

                        # Metoda 3: Invalidate item (backup)
                        if hasattr(self.table.schedule_view, 'setDirtyRegion'):
                            rect = self.table.schedule_view.visualRect(model_index)
                            if not rect.isEmpty():
                                self.table.schedule_view.viewport().update(rect)

                        refreshed_cells += 1
                        debug_print(f"Od≈õwie≈ºono kom√≥rkƒô tabeli: wiersz {row_index}, kolumna {col_index}")

                except Exception as e:
                    log_error(f"B≈ÇƒÖd od≈õwie≈ºania kom√≥rki tabeli {user_id}/{date_str}: {e}")
                    continue

            # KLUCZOWE: Wymu≈õ ca≈Ço≈õciowy update viewport je≈õli zmieniono jakie≈õ kom√≥rki
            if refreshed_cells > 0:
                self.table.schedule_view.viewport().update()
                debug_print(f"Wymuszono update viewport po od≈õwie≈ºeniu {refreshed_cells} kom√≥rek")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas wymuszania od≈õwie≈ºenia kom√≥rek tabeli: {e}")

    def _find_user_row_in_model(self, user_id):
        """
        POPRAWIONA METODA: Znajduje indeks wiersza dla danego u≈ºytkownika w modelu
        """
        try:
            if not hasattr(self, 'schedule_model') or not self.schedule_model:
                return -1

            # Pobierz klucze z modelu
            if hasattr(self.schedule_model, '_keys'):
                keys = self.schedule_model._keys
            else:
                return -1

            user_id_str = str(user_id)

            for row_index, key in enumerate(keys):
                if len(key) > 3 and str(key[3]) == user_id_str:
                    return row_index

            return -1

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas szukania wiersza u≈ºytkownika {user_id}: {e}")
            return -1

    def _update_local_events_for_cells(self, affected_pairs):
        """
        Aktualizuje lokalny events_data tylko dla zmienionych kom√≥rek

        Args:
            affected_pairs (list): Lista par (user_id, date_str)
        """
        try:
            if not hasattr(self, 'events_data'):
                return

            # Sprawd≈∫ czy jakie≈õ z zmienionych kom√≥rek sƒÖ obecnie zaznaczone
            if not hasattr(self, 'table'):
                return

            current_selection = self.table.get_data_for_selected_cells()
            selected_pairs = set()

            for cell_data in current_selection:
                user_id = cell_data.get('uzytkownik_id')
                date_str = cell_data.get('date_str')
                if user_id and date_str:
                    selected_pairs.add((user_id, date_str))

            # Sprawd≈∫ czy kt√≥ra≈õ ze zmienionych kom√≥rek jest zaznaczona
            intersection = set(affected_pairs) & selected_pairs

            if intersection:
                debug_print(f"Zaktualizowano {len(intersection)} zmienionych kom√≥rek w events_data")
                # Je≈õli tak, od≈õwie≈º events_data tylko dla zaznaczonych kom√≥rek
                self.on_selection_changed()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji lokalnych events: {e}")

    def _show_symbol_change_results(self, successful_updates: int, failed_updates: int, error_messages: list,
                                    events_to_cancel: list, skipped_employees: list):
        """
        Wy≈õwietla uzytkownikowi podsumowanie operacji wstawiania symboli,
        uwzglƒôdniajƒÖc kom√≥rki pominiƒôte z powodu braku uprawnie≈Ñ.
        """
        title = ""
        full_message = ""

        # Komunikat o sukcesach
        if successful_updates > 0:
            full_message += f"Pomy≈õlnie zaktualizowano {successful_updates} kom√≥rek."
            if events_to_cancel:
                full_message += f" i odwo≈Çano {len(events_to_cancel)} delegacji."
            full_message += "\n"

        # Komunikat o pominiƒôtych z powodu braku uprawnie≈Ñ
        if skipped_employees:
            full_message += f"\nPominiƒôto {len(skipped_employees)} kom√≥rek z powodu braku uprawnie≈Ñ dla:\n- {', '.join(set(skipped_employees))}\n"

        # Komunikat o b≈Çƒôdach
        if failed_updates > 0:
            title = "Czƒô≈õciowy sukces" if successful_updates > 0 or skipped_employees else "B≈ÇƒÖd aktualizacji"
            error_list_str = "\n - " + "\n - ".join(error_messages[:10])
            full_message += f"\nNie uda≈Ço siƒô zaktualizowaƒá {failed_updates} kom√≥rek z powodu b≈Çƒôd√≥w:{error_list_str}"
            if len(error_messages) > 10:
                full_message += f"\n... i {len(error_messages) - 10} wiƒôcej b≈Çƒôd√≥w."
        elif successful_updates > 0 or skipped_employees:
            title = "Zako≈Ñczono operacjƒô"

        # Wy≈õwietl komunikat tylko je≈õli co≈õ siƒô wydarzy≈Ço
        if full_message:
            # Je≈õli nie by≈Ço b≈Çƒôd√≥w i pominiƒôƒá, poka≈º tylko info na pasku statusu
            if successful_updates > 0 and failed_updates == 0 and not skipped_employees:
                self.statusBar().showMessage(full_message.strip(), 4000)
            else:
                QMessageBox.information(self, title, full_message.strip())

    def _prepare_delegations_description(self, grouped_events, max_groups=10):
        """
        Przygotowuje opis delegacji do odwo≈Çania.

        Args:
            grouped_events: S≈Çownik zdarze≈Ñ pogrupowanych wed≈Çug u≈ºytkownika i daty
            max_groups: Maksymalna liczba grup do wy≈õwietlenia

        Returns:
            str: Opis delegacji do odwo≈Çania
        """
        delegations_info = ""

        if not grouped_events:
            return delegations_info

        delegations_info += "\nNastƒôpujƒÖce delegacje zostanƒÖ automatycznie odwo≈Çane:\n"

        # Licznik dla ograniczenia liczby wy≈õwietlanych grup
        group_count = 0

        for (user_id, date_str), events in grouped_events.items():
            # Ograniczenie liczby wy≈õwietlanych grup
            if group_count >= max_groups:
                delegations_info += f"\n...oraz wiƒôcej zdarze≈Ñ dla innych u≈ºytkownik√≥w/dni ({len(grouped_events) - max_groups} wiƒôcej grup)...\n"
                break

            # Pobierz nazwƒô u≈ºytkownika z pierwszego zdarzenia
            user_name = events[0].get('user_name', f"ID: {user_id}")

            # Przygotuj datƒô w ≈Çadniejszym formacie (DD.MM.YYYY)
            try:
                year, month, day = date_str.split('-')
                formatted_date = f"{day}.{month}.{year}"
            except:
                formatted_date = date_str

            delegations_info += f"   üë§ {user_name} - üìÖ {formatted_date}:\n"

            # Wy≈õwietl zdarzenia dla tego u≈ºytkownika i daty
            for i, event in enumerate(events):
                delegations_info += f"      {i + 1}. {event['type']}: {event['name']}\n"

            group_count += 1

        return delegations_info

    def filter_processed_data(self):
        """Filtruje przetworzone dane na podstawie wszystkich filtr√≥w."""
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return {}

        # --- Krok 1: Pobranie stanu wszystkich filtr√≥w ---
        show_only_at_work = self.filter_by_presence_check.isChecked()

        selected_wydzialy = set(self.wydzial_combo.get_selected_items())
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
        selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)
        selected_dtn = self.dtn_combo.get_selected_items()
        selected_role = self.rola_combo.get_selected_items()
        selected_jezyki = self.jezyk_combo.get_selected_items()
        selected_etaty = self.etat_combo.get_selected_items()
        selected_scp = self.system_czasu_pracy_combo.get_selected_items()
        selected_grupy = self.grupa_main_filter_combo.get_selected_items()
        selected_locations_default = self.default_location_combo.get_selected_items()

        allowed_depts_from_groups = set()
        if selected_grupy:
            group_mapping = app_settings.get_group_mapping()
            for group_name in selected_grupy:
                allowed_depts_from_groups.update(group_mapping.get(group_name, set()))
            if selected_wydzialy:
                selected_wydzialy = selected_wydzialy.intersection(allowed_depts_from_groups)
            else:
                selected_wydzialy = allowed_depts_from_groups

        # --- Krok 2: Iteracja i filtrowanie danych ---
        filtered_data = {}
        for key, data in self.processed_data.items():
            # Najpierw standardowe filtry
            passes_standard_filters = (
                    (not selected_locations_default or data.get(
                        'lokalizacja_domyslna') in selected_locations_default) and
                    (not selected_wydzialy or key[0] in selected_wydzialy) and
                    (not selected_przelozeni or key[1] in selected_przelozeni) and
                    (not selected_uzytkownicy or str(key[2]) in selected_uzytkownicy) and
                    (not selected_dtn or str(data.get('dtn', '')) in selected_dtn) and
                    (not selected_role or data.get('rola_nazwa', '') in selected_role) and
                    (not selected_jezyki or data.get('jezyk', '') in selected_jezyki) and
                    (not selected_etaty or str(data.get('etat', '')) in selected_etaty) and
                    (not selected_scp or data.get('system_czasu_pracy', '') in selected_scp)
            )
            if not passes_standard_filters:
                continue

            # Nastƒôpnie zaawansowany filtr obecno≈õci
            if show_only_at_work:
                # --- NOWA LOGIKA: Wyklucz osoby z DTN=1 z tego filtra ---
                if data.get('dtn') == 1:
                    continue
                # --- KONIEC NOWEJ LOGIKI ---

                selected_date = self.presence_date_edit.date()
                selected_hours_str = self.presence_hour_combo.get_selected_items()
                selected_hours = {int(h.split(':')[0]) for h in selected_hours_str}

                day_to_check = selected_date.day()
                day_data = data.get('days', {}).get(day_to_check, {})
                symbol = day_data.get('symbol', '')
                parsed = parse_symbol(symbol)

                is_working_today = False
                special_symbol = parsed.get('special_symbol')
                if symbol and (not special_symbol or special_symbol in app_settings.WORK_LIKE_SYMBOLS):
                    is_working_today = True

                user_id = key[3]
                date_str = selected_date.toString("yyyy-MM-dd")
                user_events = self.data_provider.get_events_for_user_date(user_id, date_str)
                overtime_events = [e for e in user_events if e.get('type') == 'Nadgodziny']

                if not is_working_today and overtime_events:
                    is_working_today = True

                if not is_working_today:
                    continue

                if selected_hours:
                    is_working_at_hour = False
                    start_hour, work_hours = parsed.get('start_hour'), parsed.get('work_hours')
                    if start_hour is not None and work_hours is not None:
                        shift_hours = {(start_hour + h) % 24 for h in range(int(work_hours))}
                        if not shift_hours.isdisjoint(selected_hours):
                            is_working_at_hour = True

                    if not is_working_at_hour and overtime_events:
                        for event in overtime_events:
                            try:
                                t_from = datetime.strptime(event['time_from'], '%Y-%m-%d %H:%M')
                                t_to = datetime.strptime(event['time_to'], '%Y-%m-%d %H:%M')
                                if t_to <= t_from: t_to += timedelta(days=1)

                                event_hours = set()
                                current_time = t_from
                                while current_time < t_to:
                                    event_hours.add(current_time.hour)
                                    current_time += timedelta(hours=1)

                                if not event_hours.isdisjoint(selected_hours):
                                    is_working_at_hour = True
                                    break
                            except:
                                continue

                    if not is_working_at_hour:
                        continue

                selected_locations_text = self.presence_location_combo.get_selected_items()
                if selected_locations_text:
                    location_map = {"Home Office (h)": "h", "SBC (s)": "s", "Przystanek (p)": "p",
                                    "Bez lokalizacji": "none"}
                    selected_locations = {location_map.get(text) for text in selected_locations_text}

                    shift_location = parsed.get('location') or data.get('lokalizacja_domyslna') or "none"
                    if shift_location not in selected_locations:
                        continue

            filtered_data[key] = data

        return filtered_data

    def _cancel_delegations(self, events_to_cancel_input: List[Dict]):
        debug_print(f"Rozpoczynam _cancel_delegations dla {len(events_to_cancel_input)} zdarze≈Ñ.")
        if not events_to_cancel_input:
            return 0

        successful_db_updates = 0
        # Lista par (user_id, date_key) dla zdarze≈Ñ, kt√≥re zosta≈Çy pomy≈õlnie zaktualizowane w DB
        affected_user_date_pairs_for_refresh = set()

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            _, user_app_id, _, _, _ = get_modifier_id()

            for event_details in events_to_cancel_input:
                event_id = event_details.get('id')
                event_type = event_details.get('type')
                user_id_for_event = event_details.get('user_id')  # U≈ºyj user_id z event_details
                date_key_for_event = event_details.get('date_key', event_details.get('date'))

                if not event_id or not event_type or not user_id_for_event or not date_key_for_event:
                    log_warning(f"Pominiƒôto zdarzenie z niepe≈Çnymi danymi w _cancel_delegations: {event_details}")
                    continue

                table_name = ""
                if event_type == "Spotkanie":
                    table_name = SQL_OBJECTS['spotkania']
                elif event_type == "Szkolenie":
                    table_name = SQL_OBJECTS['szkolenia']
                elif event_type == "Nadgodziny":
                    table_name = SQL_OBJECTS['nadgodziny']

                if not table_name:
                    log_warning(f"Nieznany typ zdarzenia w _cancel_delegations: {event_type}")
                    continue

                try:
                    if event_type in ["Spotkanie", "Szkolenie"]:
                        update_query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                        cursor.execute(update_query, (user_app_id, event_id))
                    else:  # Nadgodziny
                        delete_query = f"DELETE FROM {table_name} WHERE Id = ?"
                        cursor.execute(delete_query, (event_id,))

                    if cursor.rowcount > 0:
                        successful_db_updates += 1
                        affected_user_date_pairs_for_refresh.add((user_id_for_event, date_key_for_event))
                        debug_print(f"DB: Pomy≈õlnie zaktualizowano/usuniƒôto {event_type} ID {event_id}")
                    else:
                        log_warning(f"DB: Nie znaleziono {event_type} ID {event_id} do aktualizacji/usuniƒôcia.")

                except Exception as db_err:
                    log_error(f"B≈ÇƒÖd DB podczas odwo≈Çywania {event_type} ID {event_id}: {db_err}", exception=db_err)

            if successful_db_updates > 0:
                conn.commit()
                debug_print(f"DB: Zatwierdzono {successful_db_updates} zmian.")
                # Rejestrujemy, ≈ºe to my dokonali≈õmy zmiany w bazie danych
                self._update_modification_date()
            conn.close()

        except Exception as e:
            log_error(f"Generalny b≈ÇƒÖd w _cancel_delegations podczas operacji DB: {e}", exception=e)
            return 0  # Zwr√≥ƒá 0 je≈õli wystƒÖpi≈Ç b≈ÇƒÖd przed aktualizacjƒÖ UI

        # Je≈õli by≈Çy jakiekolwiek udane aktualizacje w DB
        if affected_user_date_pairs_for_refresh:
            debug_print(
                f"_cancel_delegations: Uruchamiam od≈õwie≈ºanie DataProvider dla {len(affected_user_date_pairs_for_refresh)} par.")
            # Krok 1: Uniewa≈ºnij i od≈õwie≈º cache DataProvider dla dotkniƒôtych zdarze≈Ñ/miesiƒôcy
            self.data_provider.invalidate_complete_cache_for_pairs(list(affected_user_date_pairs_for_refresh))

            # Krok 2: Od≈õwie≈º tabelƒô zdarze≈Ñ - on_selection_changed u≈ºyje ≈õwie≈ºych danych z DataProvider
            # Ta metoda zaktualizuje self.events_data i self.events_model
            debug_print(f"_cancel_delegations: Uruchamiam on_selection_changed() w celu od≈õwie≈ºenia tabeli zdarze≈Ñ.")
            selected_cells_data = self.table.get_data_for_selected_cells()  # Pobierz aktualnie zaznaczone kom√≥rki
            if selected_cells_data:
                self.on_selection_changed()  # To powinno teraz poprawnie wyczy≈õciƒá zdarzenia
            else:  # Je≈õli nic nie jest zaznaczone, wyczy≈õƒá tabelƒô zdarze≈Ñ rƒôcznie
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])
                debug_print("_cancel_delegations: Brak zaznaczenia, wyczyszczono tabelƒô zdarze≈Ñ.")

            # Krok 3: Zaktualizuj ikony w tabeli grafiku na podstawie ≈õwie≈ºych danych z DataProvider
            if hasattr(self, 'schedule_model'):
                debug_print(
                    f"_cancel_delegations: Uruchamiam aktualizacjƒô ikon grafiku dla {len(affected_user_date_pairs_for_refresh)} par.")
                for user_id, date_str in affected_user_date_pairs_for_refresh:
                    # Pobierz aktualne aktywne zdarzenia dla tej kom√≥rki z DataProvider
                    # DataProvider powinien teraz mieƒá ≈õwie≈ºe dane po invalidate_complete_cache_for_pairs
                    remaining_active_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                    has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_active_events)
                    has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_active_events)
                    has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_active_events)

                    self.schedule_model.update_cell_icons_directly(
                        user_id, date_str, has_meetings, has_trainings, has_overtime
                    )

            # Wymu≈õ od≈õwie≈ºenie widok√≥w tabel, je≈õli to konieczne
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        debug_print(f"_cancel_delegations: Zako≈Ñczono, pomy≈õlnie przetworzono w DB: {successful_db_updates} zdarze≈Ñ.")
        return successful_db_updates

    def update_filter_dates(self):
        """Aktualizuje daty filtrowania do pierwszego i ostatniego dnia wybranego miesiƒÖca"""
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # KLUCZOWA POPRAWKA: Blokuj sygna≈Çy przed zmianƒÖ dat
        self.date_from.blockSignals(True)
        self.date_to.blockSignals(True)

        try:
            # Pierwszy dzie≈Ñ miesiƒÖca
            first_day = QDate(year, month, 1)
            self.date_from.setDate(first_day)

            # Ostatni dzie≈Ñ miesiƒÖca
            if month == 12:
                next_month = QDate(year + 1, 1, 1)
            else:
                next_month = QDate(year, month + 1, 1)

            last_day = next_month.addDays(-1)
            self.date_to.setDate(last_day)

        finally:
            # ZAWSZE odblokuj sygna≈Çy
            self.date_from.blockSignals(False)
            self.date_to.blockSignals(False)

        # Wywo≈Çaj filtrowanie tylko RAZ po wszystkich zmianach
        self.filter_events_table()

    def update_data(self, year, month, grupa, funkcja, use_async=True, filters_to_restore=None):
        """
        NOWA WERSJA: ≈Åadowanie danych z opcjƒÖ przekazania stanu filtr√≥w do przywr√≥cenia.
        """
        debug_print(f"Rozpoczynam ≈Çadowanie danych dla {year}-{month} (async={use_async})")

        self.year = year
        self.month = month

        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            self.schedule_model = ScheduleTableModel(self)
            self.schedule_model.set_theme(self.is_dark_theme)
            ui_columns = self.column_definitions.get_ui_display_columns()
            visible_cols = self.visible_columns
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

        if not hasattr(self, 'events_model') or not self.events_model:
            self.events_model = EventsTableModel(self)
            self.events_model.set_theme(self.is_dark_theme)

        if use_async:
            self._load_data_async(year, month, filters_to_restore=filters_to_restore)
        else:
            self._load_data_sync(year, month, filters_to_restore=filters_to_restore)

    def _load_data_sync(self, year, month):
        """
        Synchroniczne ≈Çadowanie danych (fallback), teraz sp√≥jne z logikƒÖ asynchronicznƒÖ.
        """
        debug_print(f"≈Åadowanie synchroniczne dla {year}-{month}")

        try:
            if hasattr(self, 'statusBar'):
                self.statusBar().showMessage(f"≈Åadowanie danych {year}-{month}...")

            # Krok 1: Pobierz kontener z danymi bazowymi
            container = self.data_provider._get_or_load_monthly_data(
                year, month, self.import_grupa, self.import_funkcja, use_cache=False
            )

            if container:
                # Krok 2: Pobierz przetworzone dane z na≈Ço≈ºonymi ikonami
                processed_data_with_icons = self.data_provider.get_processed_data(
                    year, month, self.import_grupa, self.import_funkcja
                )

                # Krok 3: Zastosuj wszystkie dane
                self._apply_loaded_data({
                    'schedule_data': container.schedule_data,
                    'events_data': container.events_data,
                    'processed_data': processed_data_with_icons,  # U≈ºywamy danych z ikonami
                    'year': year,
                    'month': month
                })
            else:
                log_error("Nie uda≈Ço siƒô pobraƒá danych z DataProvider w trybie synchronicznym.")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas synchronicznego ≈Çadowania: {e}", exception=e)

        finally:
            if hasattr(self, 'statusBar'):
                self.statusBar().clearMessage()

    def _load_data_async(self, year, month, filters_to_restore=None):
        """Asynchroniczne ≈Çadowanie danych z progress dialogiem."""
        from progress_dialog import LoadingProgressDialog
        from functools import partial

        debug_print(f"Uruchamiam async ≈Çadowanie dla {year}-{month}")
        self.loading_dialog = LoadingProgressDialog(
            self, self.data_provider, year, month, self.import_grupa, self.import_funkcja
        )
        self.loading_dialog.loading_completed.connect(
            partial(self._on_async_data_loaded, filters_to_restore=filters_to_restore))
        self.loading_dialog.loading_cancelled.connect(self._on_async_loading_cancelled)
        self.loading_dialog.loading_failed.connect(self._on_async_loading_failed)
        self.loading_dialog.exec()
        if hasattr(self, 'loading_dialog'):
            self.loading_dialog.deleteLater()
            delattr(self, 'loading_dialog')

    def _on_async_data_loaded(self, data, filters_to_restore=None):
        """Obs≈Çuguje pomy≈õlne za≈Çadowanie danych async."""
        debug_print("Otrzymano dane z async loading")
        try:
            is_initial_load = self.schedule_model.rowCount() == 0

            # Zapisz stan widoku (sortowanie i zaznaczenie) przed resetem modelu
            view_state = self._save_view_state()

            self._apply_loaded_data(data, filters_to_restore=filters_to_restore)

            # Zawsze przywracaj stan widoku, chyba ≈ºe jest to pierwsze ≈Çadowanie
            if not is_initial_load:
                self._restore_view_state(view_state)

            debug_print("Pomy≈õlnie zastosowano dane z async loading")
        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas stosowania za≈Çadowanych danych: {e}")

    def _on_async_loading_cancelled(self):
        """Obs≈Çuguje anulowanie ≈Çadowania."""
        debug_print("Async loading zosta≈Ç anulowany przez u≈ºytkownika")

    def _on_async_loading_failed(self, error_message):
        """Obs≈Çuguje b≈Çƒôdy async loading."""
        debug_print(f"Async loading failed: {error_message}")
        QMessageBox.critical(self, "B≈ÇƒÖd ≈Çadowania danych", f"Nie uda≈Ço siƒô za≈Çadowaƒá danych:\\n{error_message}\\n\\nSpr√≥buj ponownie lub skontaktuj siƒô z administratorem.", QMessageBox.Ok)
        try:
            debug_print("Pr√≥bujƒô fallback do synchronicznego ≈Çadowania")
            self._load_data_sync(self.year, self.month)
        except Exception as e:
            log_error(f"Fallback loading te≈º nie powi√≥d≈Ç siƒô: {e}")

    def _apply_loaded_data(self, data, filters_to_restore=None):
        """Aplikuje nowo za≈Çadowane dane do modeli i UI."""
        if data is None:
            log_error("B≈ÇƒÖd: _apply_loaded_data otrzyma≈Ço puste dane (None).")
            return

        schedule_data = data.get('schedule_data', [])
        events_data = data.get('events_data', [])
        processed_data = data.get('processed_data', {})
        year = data.get('year')
        month = data.get('month')

        if not all([processed_data, year, month]):
            log_error(f"Niekompletne dane przekazane do _apply_loaded_data: rok={year}, miesiac={month}")
            return

        self.raw_data = schedule_data
        self.all_events_data = events_data
        self.processed_data = processed_data

        is_initial_load = self.schedule_model.rowCount() == 0
        self.schedule_model.update_data(self.processed_data, year, month)

        self.events_data = []
        if hasattr(self, 'events_model'):
            self.events_model.update_data([])
        self.all_events_data = data.get('events_data', [])

        if hasattr(self, 'status_filter_combo'):
            all_statuses = sorted(list(set(e.get('status', '') for e in self.all_events_data if e.get('status'))))
            self.status_filter_combo.add_items(all_statuses)
            self.status_filter_combo.select_items(all_statuses)

        # NOWA LOGIKA:
        # Je≈õli przekazano stan filtr√≥w (co dzieje siƒô przy od≈õwie≈ºaniu), u≈ºyj go.
        if filters_to_restore:
            self.restore_filters_state(filters_to_restore)
        else:
            # W przeciwnym razie (przy pierwszym ≈Çadowaniu) u≈ºyj filtr√≥w zapisanych w bazie.
            last_filters = self.user_settings.get('last_filters')
            if last_filters:
                self.restore_filters_state(last_filters)
            else:
                self.update_filters()
                self.filter_data()

        if is_initial_load:
            self.apply_custom_sort()

        self._apply_dynamic_sizes()
        self.setup_events_table_columns()

    def apply_default_sort(self):
        """
        Rƒôcznie sortuje dane w modelu zgodnie z domy≈õlnƒÖ, wielopoziomowƒÖ
        kolejno≈õciƒÖ i wymusza od≈õwie≈ºenie widoku.
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model._processed_data:
            return

        debug_print("Aplikowanie domy≈õlnego, wielopoziomowego sortowania...")

        # Pobieramy klucze i pe≈Çne dane do sortowania
        keys_to_sort = self.schedule_model._keys
        processed_data = self.schedule_model._processed_data

        # Sortujemy klucze wed≈Çug docelowej kolejno≈õci
        sorted_keys = sorted(keys_to_sort, key=lambda k: (
            processed_data[k].get('dtn', 0),  # 1. Po DTN
            k[0] or '',  # 2. Po Wydziale
            k[1] or '',  # 3. Po Prze≈Ço≈ºonym
            k[2] or ''  # 4. Po U≈ºytkowniku
        ))

        # Ustawiamy nowƒÖ, posortowanƒÖ listƒô kluczy w modelu
        self.schedule_model._keys = sorted_keys

        # Informujemy widok, ≈ºe uk≈Çad modelu uleg≈Ç ca≈Çkowitej zmianie
        self.schedule_model.layoutChanged.emit()
        debug_print("Zako≈Ñczono domy≈õlne sortowanie. Widok zosta≈Ç od≈õwie≈ºony.")

    def clear_events_cache(self, year, month):
        """
        Czy≈õci cache zdarze≈Ñ dla danego miesiƒÖca - UPROSZCZONA WERSJA

        Args:
            year: Rok
            month: MiesiƒÖc
        """
        # POPRAWKA: Deleguj TYLKO do DataProvider, bez dodatkowych akcji
        if hasattr(self.data_provider, 'invalidate_icons_cache'):
            self.data_provider.invalidate_icons_cache(year, month)
            debug_print(f"Wyczyszczono cache zdarze≈Ñ dla {year}-{month}")
        else:
            debug_print(f"DataProvider nie ma metody invalidate_icons_cache")

    def get_events_for_user_date(self, user_id, date_str):
        """
        UPROSZCZONA METODA: Deleguje do DataProvider
        """
        return self.data_provider.get_events_for_user_date(user_id, date_str)

    def refresh_column_configuration(self):
        """Od≈õwie≈ºa konfiguracjƒô kolumn z ColumnDefinitions"""
        # ZMODYFIKOWANE: U≈ºywaj self.column_definitions zamiast column_manager
        # Pobierz zaktualizowane dane kolumn
        ui_columns = self.column_definitions.get_ui_display_columns()
        visible_cols = self.visible_columns

        # Aktualizuj referencje w g≈Ç√≥wnej klasie
        self.employee_columns = ui_columns

        # Aktualizuj model
        if hasattr(self, 'schedule_model') and self.schedule_model:
            self.schedule_model.set_employee_columns(ui_columns, visible_cols)

            # Je≈õli tabela ju≈º istnieje, zaktualizuj widok
            if hasattr(self, 'table') and self.table:
                self.table.set_model(self.schedule_model)
                # Dostosuj szeroko≈õƒá tabeli pracownik√≥w
                self.table.adjust_employees_table_width()

    def setup_event_table_columns(self):
        """
        Konfiguruje szeroko≈õci kolumn tabeli zdarze≈Ñ.
        Wyodrƒôbnione z metody update_data dla lepszej czytelno≈õci.
        """
        if not hasattr(self, 'events_table') or not self.events_table.model():
            return

        self.events_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)  # Id
        self.events_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeToContents)  # Typ
        self.events_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Stretch)  # Temat
        self.events_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)  # Nazwa
        self.events_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeToContents)  # U≈ºytkownik
        self.events_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.ResizeToContents)  # Data
        self.events_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.ResizeToContents)  # Od
        self.events_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.ResizeToContents)  # Do
        self.events_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.ResizeToContents)  # Status
        self.events_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.ResizeToContents)  # Akcje

    def show_loading_indicator(self, message="≈Åadowanie..."):
        """
        Pokazuje wska≈∫nik ≈Çadowania w UI
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().showMessage(message)

        # Wy≈ÇƒÖcz niekt√≥re kontrolki podczas ≈Çadowania
        self.date_combo.setEnabled(False)
        self.refresh_button.setEnabled(False)

        if hasattr(self, 'left_panel_visible') and self.left_panel_visible:
            self._left_panel.setEnabled(False)

    def hide_loading_indicator(self):
        """
        Ukrywa wska≈∫nik ≈Çadowania
        """
        if hasattr(self, 'statusBar'):
            self.statusBar().clearMessage()

        # W≈ÇƒÖcz z powrotem kontrolki
        self.date_combo.setEnabled(True)
        self.refresh_button.setEnabled(True)

        if hasattr(self, '_left_panel'):
            self._left_panel.setEnabled(True)

    def get_loading_preferences(self):
        """
        Zwraca preferencje u≈ºytkownika dotyczƒÖce ≈Çadowania
        """
        # Mo≈ºna dodaƒá ustawienia w settings_db dla kontroli async loading
        # Na razie zawsze async dla du≈ºych zbior√≥w danych
        return {
            'use_async_threshold': 1000,  # U≈ºyj async dla >1000 wierszy
            'show_progress_dialog': True,
            'auto_fallback_to_sync': True
        }




    def update_cross_filters(self):
        """
        Aktualizuje filtry wzajemnie, ale zamiast przebudowywaƒá listy,
        jedynie ukrywa/pokazuje istniejƒÖce elementy, aby zachowaƒá pozycjƒô przewijania.
        """
        if not getattr(self, '_cross_filtering_enabled', True):
            return

        if not hasattr(self, 'processed_data') or not self.processed_data:
            return

        if getattr(self, '_updating_cross_filters', False):
            return

        self._updating_cross_filters = True
        try:
            # Pobranie aktualnych wybor√≥w (logika bez zmian)
            selected_wydzialy = self.wydzial_combo.get_selected_items()
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

            # === AKTUALIZACJA LISTY PRZE≈ÅO≈ªONYCH ===
            if hasattr(self, 'przelozony_list'):
                # Oblicz, kt√≥rzy prze≈Ço≈ºeni powinni byƒá widoczni (logika bez zmian)
                available_przelozeni = set()
                if selected_wydzialy:
                    for key in self.processed_data.keys():
                        if key[0] in selected_wydzialy and key[1]:
                            available_przelozeni.add(key[1])
                else:
                    for key in self.processed_data.keys():
                        if key[1]: available_przelozeni.add(key[1])

                # NOWA LOGIKA: Poka≈º/ukryj elementy zamiast przebudowywaƒá listƒô
                for i in range(self.przelozony_list.count()):
                    item = self.przelozony_list.item(i)
                    item.setHidden(item.text() not in available_przelozeni)

            # === AKTUALIZACJA LISTY U≈ªYTKOWNIK√ìW ===
            if hasattr(self, 'uzytkownik_list'):
                # Oblicz, kt√≥rzy u≈ºytkownicy powinni byƒá widoczni (logika bez zmian)
                available_uzytkownicy = set()
                for key in self.processed_data.keys():
                    wydzial, przelozony, uzytkownik_dane, _ = key
                    if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                            (not selected_przelozeni or przelozony in selected_przelozeni):
                        if uzytkownik_dane: available_uzytkownicy.add(str(uzytkownik_dane))

                # NOWA LOGIKA: Poka≈º/ukryj elementy zamiast przebudowywaƒá listƒô
                for i in range(self.uzytkownik_list.count()):
                    item = self.uzytkownik_list.item(i)
                    item.setHidden(item.text() not in available_uzytkownicy)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas cross-filtrowania: {e}", exception=e)
        finally:
            self._updating_cross_filters = False

    def update_list_safely(self, list_widget, items, selected_items):
        """
        Bezpiecznie aktualizuje QListWidget, blokujƒÖc sygna≈Çy na czas modyfikacji.
        """
        if not list_widget:
            return

        list_widget.blockSignals(True)
        try:
            # Zapamiƒôtanie, co jest aktualnie widoczne z pola wyszukiwania
            search_text = ""
            if list_widget is self.przelozony_list:
                search_text = self.przelozony_filter.text().lower()
            elif list_widget is self.uzytkownik_list:
                search_text = self.uzytkownik_filter.text().lower()

            list_widget.clear()
            for item_text in sorted(items):
                item = QListWidgetItem(item_text)
                list_widget.addItem(item)
                if item_text in selected_items:
                    item.setSelected(True)

                # Przywr√≥cenie ukrycia na podstawie filtra wyszukiwania
                if search_text and search_text not in item_text.lower():
                    item.setHidden(True)

        finally:
            list_widget.blockSignals(False)

    def get_current_filters_state(self):
        """Zapisuje aktualnie wybrane warto≈õci ze wszystkich ISTNIEJƒÑCYCH filtr√≥w do s≈Çownika."""
        state = {
            'grupa': self.grupa_main_filter_combo.currentText(),
            'wydzial': self.wydzial_combo.get_selected_items(),
            'przelozony': self.get_list_selected_items(self.przelozony_list),
            'uzytkownik': self.get_list_selected_items(self.uzytkownik_list),
            'lokalizacja_domyslna': self.default_location_combo.get_selected_items(),
            'system_czasu_pracy': self.system_czasu_pracy_combo.get_selected_items(),
            'rola': self.rola_combo.get_selected_items(),
            'jezyk': self.jezyk_combo.get_selected_items(),
            'etat': self.etat_combo.get_selected_items(),
            'dtn': self.dtn_combo.get_selected_items(),
        }
        debug_print(f"Zapisano stan filtr√≥w: {state}")
        return state

    def restore_filters_state(self, state):
        """
        Przywraca zapisany stan filtr√≥w po za≈Çadowaniu nowych danych.
        """
        debug_print("Rozpoczynam przywracanie stanu filtr√≥w...")

        self._cross_filtering_enabled = False

        try:
            self.update_filters()

            self.grupa_main_filter_combo.blockSignals(True)
            self.grupa_main_filter_combo.setCurrentText(state.get('grupa', '(Wszyscy)'))
            self.grupa_main_filter_combo.blockSignals(False)

            self.wydzial_combo.select_items(state.get('wydzial', []))
            self.default_location_combo.select_items(state.get('lokalizacja_domyslna', []))
            self.system_czasu_pracy_combo.select_items(state.get('system_czasu_pracy', []))
            self.rola_combo.select_items(state.get('rola', []))
            self.jezyk_combo.select_items(state.get('jezyk', []))
            self.etat_combo.select_items(state.get('etat', []))
            self.dtn_combo.select_items(state.get('dtn', []))

            przelozeni_items = self._get_unique_values_for_filter('przelozony')
            uzytkownicy_items = self._get_unique_values_for_filter('uzytkownik_dane')
            self.update_list_safely(self.przelozony_list, przelozeni_items, state.get('przelozony', []))
            self.update_list_safely(self.uzytkownik_list, uzytkownicy_items, state.get('uzytkownik', []))

        finally:
            self._cross_filtering_enabled = True
            debug_print("Zako≈Ñczono przywracanie stanu filtr√≥w.")

        debug_print("Uruchamiam filtrowanie po przywr√≥ceniu stanu.")
        self.filter_data()

    def _get_unique_values_for_filter(self, filter_key):
        """
        Pobiera unikalne warto≈õci dla danego filtra z aktualnie za≈Çadowanych,
        pe≈Çnych danych w self.processed_data.
        """
        if not hasattr(self, 'processed_data') or not self.processed_data:
            return set()

        unique_values = set()

        key_map = {
            'wydzial': 0,
            'przelozony': 1,
            'uzytkownik_dane': 2
        }

        if filter_key in key_map:
            key_index = key_map[filter_key]
            for key_tuple in self.processed_data.keys():
                if len(key_tuple) > key_index and key_tuple[key_index]:
                    unique_values.add(str(key_tuple[key_index]))
        else:
            for data_dict in self.processed_data.values():
                value = data_dict.get(filter_key)
                # --- POPRAWIONY WARUNEK ---
                # Sprawdzamy, czy warto≈õƒá nie jest None, co poprawnie uwzglƒôdni zero.
                if value is not None and value != '':
                    unique_values.add(str(value))

        return unique_values

    def clear_filters(self):
        """Czy≈õci wszystkie filtry i aktualizuje model."""
        self._cross_filtering_enabled = False
        try:
            combo_names_to_clear = [
                'grupa_main_filter_combo', 'wydzial_combo', 'dtn_combo',
                'rola_combo', 'jezyk_combo', 'etat_combo',
                'system_czasu_pracy_combo',
                'default_location_combo'
            ]
            for combo_name in combo_names_to_clear:
                if hasattr(self, combo_name):
                    getattr(self, combo_name).clear_selection()

            if hasattr(self, 'przelozony_list'): self.przelozony_list.clearSelection()
            if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.clearSelection()
            if hasattr(self, 'przelozony_filter'): self.przelozony_filter.clear()
            if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.clear()

            # Czyszczenie filtra obecno≈õci
            if hasattr(self, 'filter_by_presence_check'):
                self.filter_by_presence_check.setChecked(False)
            if hasattr(self, 'presence_location_combo'):
                self.presence_location_combo.clear_selection()
            # ZMIANA: U≈ºycie metody `clear_selection` dla nowego filtra
            if hasattr(self, 'presence_hour_combo'):
                self.presence_hour_combo.clear_selection()

        finally:
            self._cross_filtering_enabled = True
            # Wywo≈Çanie filtrowania po wyczyszczeniu wszystkich kontrolek
            self.filter_data()

    def filter_przelozony_list(self, text):
        """
        Filtruje listƒô prze≈Ço≈ºonych na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'przelozony_list'):
            return

        text = text.lower()
        for i in range(self.przelozony_list.count()):
            item = self.przelozony_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def filter_uzytkownik_list(self, text):
        """
        Filtruje listƒô u≈ºytkownik√≥w na podstawie wpisanego tekstu.
        Zoptymalizowana wersja dla modelu danych.
        """
        if not hasattr(self, 'uzytkownik_list'):
            return

        text = text.lower()
        for i in range(self.uzytkownik_list.count()):
            item = self.uzytkownik_list.item(i)
            if text == "" or text in item.text().lower():
                item.setHidden(False)
            else:
                item.setHidden(True)

    def update_filtered_table(self):
        """
        Aktualizuje widok tabeli na podstawie zaznaczonych filtr√≥w
        """
        # Bezpo≈õrednio aktualizuj ca≈ÇƒÖ tabelƒô z przefiltrowanymi danymi
        self.update_table_content()

    def get_list_selected_items(self, list_widget):
        """
        Zwraca teksty zaznaczonych element√≥w z listy.
        POPRAWKA: Zmieniono nazwƒô metody z get_selected_items na get_list_selected_items,
        aby uniknƒÖƒá konfliktu z metodƒÖ get_selected_items w CustomMultiComboBox.

        Args:
            list_widget: QListWidget do pobrania zaznaczonych element√≥w

        Returns:
            list: Lista zaznaczonych tekst√≥w
        """
        if not list_widget:
            return []

        selected = []
        for i in range(list_widget.count()):
            item = list_widget.item(i)
            if item and item.isSelected():
                selected.append(item.text())
        return selected

    def update_filters(self):
        """
        Wype≈Çnia wszystkie filtry na podstawie za≈Çadowanych danych.
        WERSJA POPRAWIONA: Zawiera kompletnƒÖ logikƒô dla wszystkich filtr√≥w.
        """
        try:
            if not hasattr(self, 'processed_data') or not self.processed_data:
                debug_print("Brak danych do wype≈Çnienia filtr√≥w, pomijam.")
                return

            debug_print("Rozpoczynam pe≈ÇnƒÖ aktualizacjƒô filtr√≥w...")

            # Zapamiƒôtanie bie≈ºƒÖcych wybor√≥w, aby je przywr√≥ciƒá po od≈õwie≈ºeniu list
            selected_grupy = self.grupa_main_filter_combo.get_selected_items()
            selected_wydzialy = self.wydzial_combo.get_selected_items()
            selected_dtn = self.dtn_combo.get_selected_items()
            selected_role = self.rola_combo.get_selected_items()
            selected_jezyki = self.jezyk_combo.get_selected_items()
            selected_etaty = self.etat_combo.get_selected_items()
            selected_scp = self.system_czasu_pracy_combo.get_selected_items()
            selected_locations = self.default_location_combo.get_selected_items()

            # Filtr "Grupa"
            group_mapping = self.data_provider.get_department_to_group_mapping()
            self.grupa_main_filter_combo.add_items(sorted(group_mapping.keys()))
            self.grupa_main_filter_combo.select_items(selected_grupy)

            # Filtr "Wydzia≈Ç"
            wydzialy = sorted(set(key[0] for key in self.processed_data.keys() if key[0]))
            self.wydzial_combo.add_items(wydzialy)
            self.wydzial_combo.select_items(selected_wydzialy)

            # Filtr "Lokalizacja Domy≈õlna"
            locations = sorted(set(data.get('lokalizacja_domyslna', '') for data in self.processed_data.values() if
                                   data.get('lokalizacja_domyslna')))
            self.default_location_combo.add_items(locations)
            self.default_location_combo.select_items(selected_locations)

            # Filtr "System Pracy"
            scp_values = sorted(set(data.get('system_czasu_pracy', '') for data in self.processed_data.values() if
                                    data.get('system_czasu_pracy', '')))
            self.system_czasu_pracy_combo.add_items(scp_values)
            self.system_czasu_pracy_combo.select_items(selected_scp)

            # Filtr "Rola"
            role_values = sorted(
                set(data.get('rola_nazwa', '') for data in self.processed_data.values() if data.get('rola_nazwa', '')))
            self.rola_combo.add_items(role_values)
            self.rola_combo.select_items(selected_role)

            # Filtr "Jƒôzyk"
            jezyki_values = sorted(
                set(data.get('jezyk', '') for data in self.processed_data.values() if data.get('jezyk', '')))
            self.jezyk_combo.add_items(jezyki_values)
            self.jezyk_combo.select_items(selected_jezyki)

            # Filtr "Etat"
            etaty_values = set(str(data.get('etat', '')) for data in self.processed_data.values() if
                               data.get('etat') is not None and str(data.get('etat', '')))
            sorted_etaty = sorted(etaty_values, key=lambda x: float(x) if x.replace('.', '', 1).isdigit() else 0)
            self.etat_combo.add_items(sorted_etaty)
            self.etat_combo.select_items(selected_etaty)

            # Filtr "DTN"
            dtn_values = sorted(set(str(data['dtn']) for data in self.processed_data.values() if data.get('dtn') is not None), key=int)
            self.dtn_combo.add_items(dtn_values)
            self.dtn_combo.select_items(selected_dtn)

            # Aktualizacja list dynamicznych (Prze≈Ço≈ºony, U≈ºytkownik)
            self.update_przelozony_filter()
            self.update_uzytkownik_filter()

            debug_print("Zako≈Ñczono pe≈ÇnƒÖ aktualizacjƒô wszystkich filtr√≥w.")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji filtr√≥w: {e}", exception=e)

    def update_przelozony_filter(self, selected_przelozeni=None):
        """
        Aktualizuje listƒô prze≈Ço≈ºonych na podstawie wybranych wydzia≈Ç√≥w.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_przelozeni: Lista zaznaczonych prze≈Ço≈ºonych (opcjonalnie)
        """
        if not hasattr(self, 'przelozony_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiƒôtaj bie≈ºƒÖcƒÖ selekcjƒô je≈õli nie podano
        if selected_przelozeni is None:
            selected_przelozeni = self.get_list_selected_items(self.przelozony_list)

        self.przelozony_list.clear()

        # Pobierz wybrane wydzia≈Çy
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []

        # Zbi√≥r unikalnych prze≈Ço≈ºonych
        przelozeni = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, _, _ = key

            # Je≈õli nie wybrano wydzia≈Ç√≥w lub wydzia≈Ç pasuje do filtra
            if not selected_wydzialy or wydzial in selected_wydzialy:
                # Dodaj prze≈Ço≈ºonego do zbioru (tylko niepuste warto≈õci)
                if przelozony:
                    przelozeni.add(przelozony)

        # Dodaj posortowanych prze≈Ço≈ºonych do listy
        for przelozony in sorted(przelozeni):
            item = QListWidgetItem(przelozony)
            self.przelozony_list.addItem(item)

            # Przywr√≥ƒá zaznaczenie je≈õli by≈Ço
            if przelozony in selected_przelozeni:
                item.setSelected(True)

    def update_uzytkownik_filter(self, selected_uzytkownicy=None):
        """
        Aktualizuje listƒô u≈ºytkownik√≥w na podstawie wybranych wydzia≈Ç√≥w i prze≈Ço≈ºonych.
        Zoptymalizowana wersja dla modelu danych.

        Args:
            selected_uzytkownicy: Lista zaznaczonych u≈ºytkownik√≥w (opcjonalnie)
        """
        if not hasattr(self, 'uzytkownik_list') or not hasattr(self, 'processed_data'):
            return

        # Zapamiƒôtaj bie≈ºƒÖcƒÖ selekcjƒô je≈õli nie podano
        if selected_uzytkownicy is None:
            selected_uzytkownicy = self.get_list_selected_items(self.uzytkownik_list)

        self.uzytkownik_list.clear()

        # Pobierz wybrane wydzia≈Çy i prze≈Ço≈ºonych
        selected_wydzialy = self.wydzial_combo.get_selected_items() if hasattr(self, 'wydzial_combo') else []
        selected_przelozeni = self.get_list_selected_items(self.przelozony_list) if hasattr(self,
                                                                                            'przelozony_list') else []

        # Zbi√≥r unikalnych u≈ºytkownik√≥w (u≈ºyj stringa jako tekstowej reprezentacji)
        uzytkownicy = set()

        # Dla wszystkich danych w processed_data
        for key in self.processed_data.keys():
            wydzial, przelozony, uzytkownik_dane, _ = key

            # Sprawd≈∫ czy dane pasujƒÖ do filtr√≥w
            if (not selected_wydzialy or wydzial in selected_wydzialy) and \
                    (not selected_przelozeni or przelozony in selected_przelozeni):
                # Dodaj u≈ºytkownika do zbioru (tylko niepuste warto≈õci)
                if uzytkownik_dane:
                    # Konwertuj do stringa dla sp√≥jno≈õci
                    uzytkownicy.add(str(uzytkownik_dane))

        # Dodaj posortowanych u≈ºytkownik√≥w do listy
        for uzytkownik in sorted(uzytkownicy):
            item = QListWidgetItem(uzytkownik)
            self.uzytkownik_list.addItem(item)

            # Przywr√≥ƒá zaznaczenie je≈õli by≈Ço
            if uzytkownik in selected_uzytkownicy:
                item.setSelected(True)

    def update_table_content(self):
        """
        Aktualizuje zawarto≈õƒá tabeli grafiku u≈ºywajƒÖc modelu danych.
        Zoptymalizowana wersja wykorzystujƒÖca precyzyjne aktualizacje.
        """
        # Sprawd≈∫ czy modele zosta≈Çy zainicjalizowane
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # Pobierz aktualny rok i miesiƒÖc
        current_data = self.date_combo.currentData()
        if not current_data:
            return

        year, month = current_data

        # Ustaw rok i miesiƒÖc w modelu (je≈õli jeszcze nie sƒÖ ustawione)
        if self.schedule_model._year != year or self.schedule_model._month != month:
            # Pobierz dane dla wybranego roku i miesiƒÖca
            schedule_data = self.data_provider.get_schedule_data(year, month, self.import_grupa, self.import_funkcja)

            # Aktualizuj model - to wywo≈Ça zoptymalizowanƒÖ metodƒô update_data
            self.schedule_model.update_data(schedule_data, year, month)
            self._apply_dynamic_sizes()
        else:
            # Je≈õli rok i miesiƒÖc nie uleg≈Çy zmianie, tylko zastosuj filtry
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

    def get_cell_color_by_time(self, hour):
        """
        Zwraca kolor t≈Ça kom√≥rki na podstawie godziny rozpoczƒôcia.
        Godziny sƒÖ mapowane na kolory w bardziej czytelnej palecie.

        Args:
            hour (int): Godzina rozpoczƒôcia zmiany (0-23)

        Returns:
            QColor: Kolor t≈Ça kom√≥rki
        """
        # Domy≈õlny kolor (przezroczysty) gdy godzina nie jest zdefiniowana
        if hour is None or hour < 0 or hour > 23:
            return QColor(255, 255, 255, 0)  # Przezroczysty

        # Mapowanie godzin na kolory - zharmonizowana paleta
        if hour == 5:
            return QColor(204, 255, 255)  # Jasny b≈Çƒôkit (bardzo jasny cyjan)
        elif hour == 6:
            return QColor(204, 255, 255)  # Jasny b≈Çƒôkit (bardzo jasny cyjan)
        elif hour == 7:
            return QColor(0, 255, 255)  # Cyjan (akwamaryna)
        elif hour == 8:
            return QColor(0, 204, 255)  # Jasny b≈Çƒôkit (niebieskozielony)
        elif hour == 9:
            return QColor(0, 255, 0)  # Limonkowy (czysty zielony)
        elif hour == 10:
            return QColor(153, 204, 0)  # Oliwkowy (≈º√≥≈Çtozielony)
        elif hour == 11:
            return QColor(204, 255, 204)  # Bardzo jasny zielony (miƒôtowy)
        elif hour == 12:
            return QColor(255, 255, 153)  # Bardzo jasny ≈º√≥≈Çty (kremowy)
        elif hour == 13:
            return QColor(255, 204, 153)  # Jasny ≈Çososiowy (brzoskwiniowy)
        elif hour == 14:
            return QColor(255, 153, 0)  # Ciemny pomara≈Ñczowy
        elif hour == 15:
            return QColor(255, 0, 255)  # Magenta (fuksja)
        elif hour == 16:
            return QColor(204, 0, 0)  # Ciemnoczerwony
        elif hour == 17:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 18:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 19:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 20:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 21:
            return QColor(150, 150, 150)  # ≈öredni szary
        elif hour == 22:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 23:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour == 0:
            return QColor(51, 51, 51)  # Ciemny szary
        elif hour in [1, 2, 3, 4]:
            return QColor(51, 51, 51)  # Ciemny szary

        # Domy≈õlny kolor dla innych warto≈õci
        return QColor(255, 255, 255, 0)  # Przezroczysty

    def on_selection_changed(self, selected=None, deselected=None):
        """
        POPRAWIONA WERSJA: Debounced selection handling
        """
        if not hasattr(self, 'schedule_model') or not self.schedule_model:
            return

        # DODANE: Sprawd≈∫ czy nie jeste≈õmy w trakcie aktualizacji
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        # NOWE: Zastop poprzedni timer i uruchom nowy (debouncing)
        if hasattr(self, '_selection_timer'):
            self._selection_timer.stop()
            self._selection_timer.start(self._selection_debounce_delay)

    def _handle_selection_change(self):
        """
        NOWA METODA: Faktyczna obs≈Çuga zmiany zaznaczenia (wywo≈Çywana po debounce)
        """
        if hasattr(self, '_updating_selection') and self._updating_selection:
            return

        self._updating_selection = True

        try:
            debug_print("Zmiana zaznaczenia - aktualizujƒô tabelƒô zdarze≈Ñ...")

            # Pobierz dane dla zaznaczonych kom√≥rek
            selected_cells_data = self.table.get_data_for_selected_cells()
            debug_print(f"Zaznaczono {len(selected_cells_data)} kom√≥rek")
            self.send_email_button.setEnabled(bool(selected_cells_data))
            if selected_cells_data and len(selected_cells_data) > 0:
                # MAMY ZAZNACZONE KOM√ìRKI - poka≈º zdarzenia
                events = []

                for cell_data in selected_cells_data:
                    user_id = cell_data.get('uzytkownik_id')
                    date_str = cell_data.get('date_str')

                    if user_id and date_str:
                        # --- ZMIANA: Usuwamy przekazywanie self.import_grupa i self.import_funkcja ---
                        user_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                        for event in user_events:
                            local_event = self._convert_dp_event_to_local(event)
                            events.append(local_event)

                debug_print(f"Pobrano {len(events)} aktywnych zdarze≈Ñ dla zaznaczonych kom√≥rek")

                # Zaktualizuj events_data
                self.events_data = events

                # Aktualizuj model zdarze≈Ñ
                if hasattr(self, 'events_model'):
                    self.events_model.update_data(self.events_data)

                    # WA≈ªNE: Zastosuj filtry po aktualizacji danych
                    self.filter_events_table()
            else:
                # BRAK ZAZNACZENIA - wyczy≈õƒá tabelƒô zdarze≈Ñ
                debug_print("Brak zaznaczenia - czyszczƒô tabelƒô zdarze≈Ñ")
                self.events_data = []
                if hasattr(self, 'events_model'):
                    self.events_model.update_data([])

            # DODANE: Wymu≈õ od≈õwie≈ºenie widoku tabeli zdarze≈Ñ
            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

        finally:
            self._updating_selection = False

    def clear_events_on_startup(self):
        """
        NOWA METODA: Czy≈õci tabelƒô zdarze≈Ñ przy starcie aplikacji
        """
        debug_print("Czyszczƒô tabelƒô zdarze≈Ñ przy starcie aplikacji")

        # Wyczy≈õƒá dane zdarze≈Ñ
        self.events_data = []

        # Wyczy≈õƒá model zdarze≈Ñ je≈õli istnieje
        if hasattr(self, 'events_model') and self.events_model:
            self.events_model.update_data([])

        # Od≈õwie≈º widok tabeli zdarze≈Ñ
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()

    def _convert_dp_event_to_local(self, dp_event):
        """Konwertuje format zdarzenia z DataProvider na lokalny format UI."""
        try:
            date_key = dp_event.get('date_key', dp_event.get('date', ''))
            display_date = ".".join(reversed(date_key.split("-"))) if date_key and '-' in date_key else date_key

            # U≈ºyj klucza 'UzytkownikDane' je≈õli jest dostƒôpny, w przeciwnym razie 'user_name'
            user_name = dp_event.get('UzytkownikDane') or dp_event.get('user_name', f"ID: {dp_event.get('user_id')}")

            local_event = {
                'type': dp_event.get('type', ''),
                'topic': dp_event.get('topic', ''),
                'name': dp_event.get('name', ''),
                'user_id': dp_event.get('user_id'),
                'UzytkownikDane': user_name,
                'date': display_date,
                'date_key': date_key,
                'time_from': dp_event.get('time_from', ''),
                'time_to': dp_event.get('time_to', ''),
                'status': dp_event.get('status', ''),
                'DataModyfikacji': dp_event.get('DataModyfikacji', ''),
                'id': dp_event.get('id')
            }
            return local_event
        except Exception as e:
            log_error(f"B≈ÇƒÖd konwersji zdarzenia: {e}")
            return dp_event

    def temporarily_disable_filters(self):
        """Tymczasowo wy≈ÇƒÖcza filtry zdarze≈Ñ aby zapewniƒá wy≈õwietlenie wszystkich danych"""
        # Zapamiƒôtaj obecny stan filtr√≥w
        self._saved_filters = {
            'meetings': self.meetings_checkbox.isChecked() if hasattr(self, 'meetings_checkbox') else True,
            'trainings': self.trainings_checkbox.isChecked() if hasattr(self, 'trainings_checkbox') else True,
            'overtime': self.overtime_checkbox.isChecked() if hasattr(self, 'overtime_checkbox') else True,
            'topic': self.topic_filter.text() if hasattr(self, 'topic_filter') else "",
            'name': self.name_filter.text() if hasattr(self, 'name_filter') else "",
            'date_from': self.date_from.date() if hasattr(self, 'date_from') else None,
            'date_to': self.date_to.date() if hasattr(self, 'date_to') else None
        }

        # Ustaw wszystkie filtry na warto≈õci, kt√≥re pokazujƒÖ wszystkie dane
        if hasattr(self, 'meetings_checkbox'):
            self.meetings_checkbox.setChecked(True)
        if hasattr(self, 'trainings_checkbox'):
            self.trainings_checkbox.setChecked(True)
        if hasattr(self, 'overtime_checkbox'):
            self.overtime_checkbox.setChecked(True)
        if hasattr(self, 'topic_filter'):
            self.topic_filter.setText("")
        if hasattr(self, 'name_filter'):
            self.name_filter.setText("")

        # Daty zostawiamy bez zmian, filtrowanie bƒôdzie nadpisane przez model

        debug_print("Tymczasowo wy≈ÇƒÖczono filtry zdarze≈Ñ")

    def restore_filters(self):
        """Przywraca filtry zdarze≈Ñ do ich poprzedniego stanu"""
        if not hasattr(self, '_saved_filters'):
            return

        # Przywr√≥ƒá filtry do ich poprzedniego stanu
        if hasattr(self, 'meetings_checkbox') and 'meetings' in self._saved_filters:
            self.meetings_checkbox.setChecked(self._saved_filters['meetings'])
        if hasattr(self, 'trainings_checkbox') and 'trainings' in self._saved_filters:
            self.trainings_checkbox.setChecked(self._saved_filters['trainings'])
        if hasattr(self, 'overtime_checkbox') and 'overtime' in self._saved_filters:
            self.overtime_checkbox.setChecked(self._saved_filters['overtime'])
        if hasattr(self, 'topic_filter') and 'topic' in self._saved_filters:
            self.topic_filter.setText(self._saved_filters['topic'])
        if hasattr(self, 'name_filter') and 'name' in self._saved_filters:
            self.name_filter.setText(self._saved_filters['name'])

        # Nie przywracamy dat, aby zapewniƒá sp√≥jno≈õƒá z zaznaczonymi kom√≥rkami

        debug_print("Przywr√≥cono filtry zdarze≈Ñ")

        # Wymu≈õ od≈õwie≈ºenie z nowymi filtrami
        self.filter_events_table()

    def show_email_dialog(self):
        """Zbiera dane zaznaczonych pracownik√≥w i otwiera dialog do wysy≈Çki e-mail."""
        selected_cells = self.get_selected_cells_data()
        if not selected_cells:
            QMessageBox.warning(self, "Brak zaznaczenia", "Proszƒô zaznaczyƒá przynajmniej jednego pracownika.")
            return

        recipients = []
        processed_ids = set()
        for cell_data in selected_cells:
            user_id = cell_data.get('uzytkownik_id')
            nr_kadrowy = cell_data.get('nr_kadrowy', '').strip()
            name = cell_data.get('uzytkownik_dane')

            if user_id not in processed_ids and nr_kadrowy:
                recipients.append({'name': name, 'id': nr_kadrowy})
                processed_ids.add(user_id)

        if not recipients:
            QMessageBox.warning(self, "Brak danych",
                                "≈ªaden z zaznaczonych pracownik√≥w nie ma przypisanego numeru kadrowego.")
            return

        template_path = self.user_settings.get('outlook_template_path', '')

        dialog = EmailDialog(self, recipients, template_path)
        if dialog.exec() == QDialog.Accepted:
            email_details = dialog.get_email_details()

            if email_details['template_path']:
                # U≈ºyj szablonu
                success, message = create_email_from_template(
                    template_path=email_details['template_path'],
                    recipients=email_details['recipients'],
                    send_individually=email_details['send_individually']
                )
            else:
                # U≈ºyj standardowej wiadomo≈õci
                success, message = create_outlook_email(
                    recipients=email_details['recipients'],
                    subject=email_details['subject'],
                    body=email_details['body'],
                    send_individually=email_details['send_individually']
                )

            if success:
                self.statusBar().showMessage("Pomy≈õlnie utworzono wiadomo≈õƒá w programie Outlook.", 4000)
            else:
                QMessageBox.critical(self, "B≈ÇƒÖd Outlook", message)

    def standardize_date(self, date_obj):
        """
        Standaryzuje format daty do 'YYYY-MM-DD' dla por√≥wna≈Ñ
        """
        if not date_obj:
            return ''

        # Je≈õli to ju≈º string, wyciƒÖgnij tylko datƒô
        if isinstance(date_obj, str):
            # Obs≈Çuga r√≥≈ºnych format√≥w
            if 'T' in date_obj:  # Format ISO 'YYYY-MM-DDThh:mm:ss'
                return date_obj.split('T')[0]
            elif ' ' in date_obj:  # Format 'YYYY-MM-DD hh:mm:ss'
                return date_obj.split(' ')[0]
            elif len(date_obj) == 10 and date_obj.count('-') == 2:  # Format 'YYYY-MM-DD'
                return date_obj
            # Je≈õli nie dopasowano do ≈ºadnego formatu, zwr√≥ƒá oryginalny string
            return date_obj

        # Je≈õli to obiekt datetime, skonwertuj na string
        if hasattr(date_obj, 'strftime'):
            return date_obj.strftime('%Y-%m-%d')

        # W przypadku nieznanego typu, zwr√≥ƒá pusty string
        return ''

    # def diagnose_table_view(self):
    #     """Metoda diagnostyczna do sprawdzenia stanu SplitTableView"""
    #     if not hasattr(self, 'table') or not self.table:
    #         log_error("ERROR: Brak obiektu table!")
    #         return
    #
    #     if not hasattr(self, 'schedule_model') or not self.schedule_model:
    #         log_error("ERROR: Brak obiektu schedule_model!")
    #         return
    #
    #     debug_print("\n=== DIAGNOSTYKA TABELI ===")
    #
    #     # Sprawd≈∫ model
    #     debug_print(f"Model ma {self.schedule_model.rowCount()} wierszy i {self.schedule_model.columnCount()} kolumn")
    #     debug_print(f"Widoczne kolumny: {self.schedule_model.get_visible_columns()}")
    #
    #     # Sprawd≈∫ widoki
    #     debug_print(
    #         f"Employees view ma {self.table.employees_view.model().rowCount()} wierszy i {self.table.employees_view.model().columnCount()} kolumn")
    #     debug_print(
    #         f"Schedule view ma {self.table.schedule_view.model().rowCount()} wierszy i {self.table.schedule_view.model().columnCount()} kolumn")
    #
    #     # Sprawd≈∫ kolumny w employees_view
    #     for col in range(self.table.employees_view.model().columnCount()):
    #         hidden = self.table.employees_view.isColumnHidden(col)
    #         width = self.table.employees_view.columnWidth(col)
    #         debug_print(f"Kolumna {col} w employees_view: ukryta={hidden}, szeroko≈õƒá={width}px")
    #
    #     # Sprawd≈∫ przyk≈Çadowe dane w pierwszym wierszu
    #     if self.schedule_model.rowCount() > 0:
    #         debug_print("\nPrzyk≈Çadowe dane z pierwszego wiersza:")
    #         for col in range(len(self.schedule_model.get_visible_columns())):
    #             index = self.schedule_model.index(0, col)
    #             text = self.schedule_model.data(index, Qt.DisplayRole)
    #             debug_print(f"Kolumna {col}: '{text}'")
    #
    #     debug_print("=== KONIEC DIAGNOSTYKI ===\n")

    def diagnose_application_state(self):
        """Wykonuje pe≈ÇnƒÖ diagnostykƒô stanu aplikacji i wy≈õwietla szczeg√≥≈Çowe informacje"""
        try:
            debug_print("\n===== DIAGNOSTYKA STANU APLIKACJI =====")

            # 1. Sprawd≈∫ tabele i dane
            debug_print("\n--- TABELA GRAFIKU ---")
            debug_print(f"Liczba wierszy: {self.table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.table.columnCount()}")

            # Sprawd≈∫ pierwsze 3 wiersze i kolumny dla przyk≈Çadu
            debug_print("\nPrzyk≈Çadowe kom√≥rki z tabeli grafiku:")
            for row in range(min(3, self.table.rowCount())):
                for col in range(min(6, self.table.columnCount())):
                    item = self.table.item(row, col)
                    if item:
                        debug_print(f"[{row},{col}] Tekst: {item.text()}")
                        user_role_data = item.data(Qt.UserRole)
                        user_role_2 = item.data(Qt.UserRole + 2)
                        user_role_3 = item.data(Qt.UserRole + 3)
                        debug_print(
                            f"  UserRole: {type(user_role_data)}, UserRole+2: {user_role_2}, UserRole+3: {user_role_3}")
                        if isinstance(user_role_data, dict):
                            debug_print(f"  Zawarto≈õƒá: {user_role_data}")
                    else:
                        debug_print(f"[{row},{col}] Brak elementu")

            debug_print("\n--- TABELA ZDARZE≈É ---")
            debug_print(f"Liczba wierszy: {self.events_table.rowCount()}")
            debug_print(f"Liczba kolumn: {self.events_table.columnCount()}")

            # Sprawd≈∫ zawarto≈õƒá events_data
            debug_print(
                f"\nLiczba zdarze≈Ñ w events_data: {len(self.events_data) if hasattr(self, 'events_data') else 'Brak'}")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print("Pierwsze zdarzenie:")
                for key, value in self.events_data[0].items():
                    debug_print(f"  {key}: {value}")

            # Sprawd≈∫ pierwsze 3 wiersze tabeli zdarze≈Ñ
            debug_print("\nPrzyk≈Çadowe wiersze z tabeli zdarze≈Ñ:")
            for row in range(min(3, self.events_table.rowCount())):
                row_data = []
                for col in range(self.events_table.columnCount() - 1):  # Pomijamy ostatniƒÖ kolumnƒô z przyciskami
                    item = self.events_table.item(row, col)
                    if item:
                        row_data.append(f"{col}:{item.text()}")
                debug_print(f"Wiersz {row}: {', '.join(row_data)}")

            # 2. Sprawd≈∫ delegaty i style
            debug_print("\n--- DELEGATY I STYLE ---")
            item_delegate = self.table.itemDelegate()
            debug_print(f"Delegat tabeli grafiku: {item_delegate.__class__.__name__}")
            if isinstance(item_delegate, OvertimeItemDelegate):
                debug_print("  Delegat OvertimeItemDelegate poprawnie przypisany")
            else:
                debug_print("  UWAGA: Delegat OvertimeItemDelegate nie jest przypisany!")

            # 3. Sprawd≈∫ filtrowanie danych
            debug_print("\n--- FILTROWANIE DANYCH ---")
            if hasattr(self, 'events_data') and self.events_data:
                debug_print(f"Liczba zdarze≈Ñ przed filtrowaniem: {len(self.events_data)}")
                # Sprawd≈∫, czy metoda filter_events_table jest wywo≈Çywana
                debug_print("Spr√≥buj wykonaƒá filter_events_table:")
                try:
                    self.filter_events_table()
                    debug_print("  Metoda filter_events_table wykonana bez b≈Çƒôd√≥w")
                except Exception as e:
                    debug_print(f"  B≈ÅƒÑD podczas wykonywania filter_events_table: {e}")

            debug_print("\n===== KONIEC DIAGNOSTYKI =====\n")

        except Exception as e:
            debug_print(f"B≈ÅƒÑD podczas diagnostyki: {e}")
            import traceback
            traceback.print_exc()


    def _get_current_event_filter_params(self):
        """
        Pobiera bie≈ºƒÖce parametry filtrowania zdarze≈Ñ.

        Returns:
            dict: Parametry filtrowania
        """
        filter_params = {}

        # Dodaj filtr typ√≥w zdarze≈Ñ
        allowed_types = []
        if hasattr(self, 'meetings_checkbox') and self.meetings_checkbox.isChecked():
            allowed_types.append('Spotkanie')
        if hasattr(self, 'trainings_checkbox') and self.trainings_checkbox.isChecked():
            allowed_types.append('Szkolenie')
        if hasattr(self, 'overtime_checkbox') and self.overtime_checkbox.isChecked():
            allowed_types.append('Nadgodziny')

        if allowed_types:
            filter_params['allowed_types'] = allowed_types

        # Dodaj filtry tematu i nazwy
        topic_filter = self.topic_filter.text().lower() if hasattr(self,
                                                                   'topic_filter') and self.topic_filter.text() else None
        name_filter = self.name_filter.text().lower() if hasattr(self,
                                                                 'name_filter') and self.name_filter.text() else None

        if topic_filter:
            filter_params['topic'] = topic_filter
        if name_filter:
            filter_params['name'] = name_filter

        # Dodaj filtry zakresu dat
        date_from_str = self.date_from.date().toString('yyyy-MM-dd') if hasattr(self, 'date_from') else None
        date_to_str = self.date_to.date().toString('yyyy-MM-dd') if hasattr(self, 'date_to') else None

        if date_from_str:
            filter_params['date_from'] = date_from_str
        if date_to_str:
            filter_params['date_to'] = date_to_str

        return filter_params

    # def find_cell_position(self, user_id, date_str):
    #     """
    #     Znajduje pozycjƒô kom√≥rki dla podanego u≈ºytkownika i daty, korzystajƒÖc z modelu.
    #
    #     Args:
    #         user_id: ID u≈ºytkownika
    #         date_str: Data w formacie YYYY-MM-DD
    #
    #     Returns:
    #         tuple: (wiersz, dzie≈Ñ) lub (-1, -1) je≈õli nie znaleziono
    #     """
    #     if not hasattr(self, 'schedule_model') or not self.schedule_model:
    #         return -1, -1
    #
    #     # Pobierz dzie≈Ñ z daty
    #     try:
    #         year, month, day_str = date_str.split('-')
    #         day = int(day_str)
    #     except:
    #         return -1, -1
    #
    #     # Pobierz liczbƒô wierszy w modelu
    #     row_count = self.schedule_model.rowCount()
    #
    #     # Dla ka≈ºdego wiersza sprawd≈∫, czy odpowiada szukanemu u≈ºytkownikowi
    #     for row in range(row_count):
    #         # Pobierz ID u≈ºytkownika z pierwszej kolumny
    #         index = self.schedule_model.index(row, 0)
    #         user_data = self.schedule_model.data(index, Qt.UserRole)
    #
    #         if isinstance(user_data, dict) and str(user_data.get('uzytkownik_id', '')) == str(user_id):
    #             return row, day
    #
    #     return -1, -1

    def _get_cell_data_for_user_date_pairs(self, user_date_pairs: list) -> list:
        """
        Na podstawie listy par (user_id, date_str) odnajduje i zwraca
        pe≈Çne dane kom√≥rek z modelu grafiku.
        """
        if not self.schedule_model or not user_date_pairs:
            return []

        cells_data_to_return = []
        user_row_map = {str(key[3]): idx for idx, key in enumerate(self.schedule_model._keys)}

        for user_id, date_str in user_date_pairs:
            row = user_row_map.get(str(user_id))
            if row is not None:
                try:
                    day = int(date_str.split('-')[2])
                    col_offset = len(self.schedule_model.get_visible_columns())
                    col = col_offset + day - 1

                    index = self.schedule_model.index(row, col)

                    # --- ZMIANA: Poprawne odwo≈Çanie do ROLE_DATA ---
                    cell_data = self.schedule_model.data(index, ROLE_DATA)

                    if isinstance(cell_data, dict):
                        cells_data_to_return.append(cell_data)
                except (ValueError, IndexError) as e:
                    log_warning(f"Nie uda≈Ço siƒô znale≈∫ƒá danych dla kom√≥rki ({user_id}, {date_str}): {e}")

        return cells_data_to_return

    def cancel_delegations(self):
        debug_print("\\n=== ROZPOCZYNAM OPERACJƒò ODWO≈ÅYWANIA DELEGACJI ===")

        current_data = self.date_combo.currentData()
        if not current_data:
            QMessageBox.warning(self, "Brak danych", "Nie wybrano miesiƒÖca.", QMessageBox.Ok)
            return

        selected_cells_data = self.get_selected_cells_data()
        if not self._can_modify_cells(selected_cells_data):
            return

        if not selected_cells_data:
            QMessageBox.warning(self, "Brak zaznaczenia", "Zaznacz kom√≥rki, dla kt√≥rych chcesz odwo≈Çaƒá delegacje.",
                                QMessageBox.Ok)
            return

        view_state = self._save_view_state()

        user_date_pairs = [(cell.get('uzytkownik_id'), cell.get('date_str')) for cell in selected_cells_data if
                           cell.get('uzytkownik_id') and cell.get('date_str')]
        if not user_date_pairs:
            QMessageBox.information(self, "Brak danych", "Nie znaleziono danych dla zaznaczonych kom√≥rek.",
                                    QMessageBox.Ok)
            return

        events_to_cancel = self._find_events_to_cancel(user_date_pairs)
        if not events_to_cancel:
            QMessageBox.information(self, "Brak delegacji",
                                    "Nie znaleziono delegacji do odwo≈Çania dla zaznaczonych kom√≥rek.", QMessageBox.Ok)
            return

        grouped_events = self._group_events_by_user_date(events_to_cancel)
        delegations_info = self._prepare_delegations_description(grouped_events)
        confirm_message = f"Czy na pewno chcesz odwo≈Çaƒá nastƒôpujƒÖce delegacje?\\n\\n{delegations_info}\\n"
        confirm_message += f"≈ÅƒÖcznie: {len(events_to_cancel)} delegacji dla {len(user_date_pairs)} kom√≥rek"

        reply = QMessageBox.question(self, "Potwierdzenie odwo≈Çania delegacji", confirm_message,
                                     QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if reply != QMessageBox.Yes:
            debug_print("=== OPERACJA ANULOWANA PRZEZ U≈ªYTKOWNIKA ===")
            return

        try:
            canceled_count = self._cancel_delegations(events_to_cancel)

            if canceled_count > 0:
                trainings_to_clear = [evt for evt in events_to_cancel if evt.get('type') == 'Szkolenie']
                if trainings_to_clear:
                    pairs_for_trainings = list(
                        set((e.get('user_id'), e.get('date_key', e.get('date'))) for e in trainings_to_clear))
                    cells_data = self._get_cell_data_for_user_date_pairs(pairs_for_trainings)

                    change_requests = []
                    for cell in cells_data:
                        current_symbol = cell.get('symbol', '')
                        if not current_symbol: continue

                        parsed = parse_symbol(current_symbol)
                        if parsed.get('special_symbol') and parsed.get('special_symbol').upper() == 'S':
                            new_symbol = build_symbol(
                                location=parsed.get('location'), start_hour=parsed.get('start_hour'),
                                work_hours=parsed.get('work_hours'), special_symbol=None
                            )
                            try:
                                date_str = cell['date_str']
                                year, month, _ = map(int, date_str.split('-'))
                                change_requests.append({
                                    'nr_kadrowy': cell['nr_kadrowy'], 'rok': year, 'miesiac': month,
                                    'data': date_str, 'symbol': new_symbol, 'user_id': cell['uzytkownik_id'],
                                    'user_name': cell['uzytkownik_dane']
                                })
                            except (ValueError, KeyError) as e:
                                log_warning(f"Pominiƒôto aktualizacjƒô symbolu 'S': {e}")

                    if change_requests:
                        self._process_and_apply_changes(change_requests, "Usuniƒôto symbol 'S' z {0} kom√≥rek grafiku.")

                affected_pairs = list(
                    set((e.get('user_id'), e.get('date_key', e.get('date'))) for e in events_to_cancel))
                self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)

                self._restore_view_state(view_state)

                self.on_selection_changed()
                QMessageBox.information(self, "Sukces", f"Pomy≈õlnie odwo≈Çano {canceled_count} zdarze≈Ñ.", QMessageBox.Ok)
            else:
                self._restore_view_state(view_state)
                QMessageBox.warning(self, "Brak zmian", "Nie uda≈Ço siƒô odwo≈Çaƒá ≈ºadnej delegacji.", QMessageBox.Ok)

            debug_print(f"=== ZAKO≈ÉCZONO - ODWO≈ÅANO {canceled_count} DELEGACJI ===")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas odwo≈Çywania delegacji: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas odwo≈Çywania delegacji: {str(e)}", QMessageBox.Ok)

    def delete_events_for_cells(self, cells_data: list):
        """
        Wyszukuje wszystkie zdarzenia dla podanych kom√≥rek, prosi o potwierdzenie
        i odwo≈Çuje je. Zwraca True, je≈õli u≈ºytkownik potwierdzi≈Ç usuniƒôcie.
        """
        if not cells_data:
            return False

        # Zbierz unikalne pary (u≈ºytkownik, data) z zaznaczonych kom√≥rek
        user_date_pairs = set()
        for cell_data in cells_data:
            user_id = cell_data.get('uzytkownik_id')
            date_str = cell_data.get('date_str')
            if user_id and date_str:
                user_date_pairs.add((user_id, date_str))

        # Znajd≈∫ wszystkie zdarzenia do odwo≈Çania dla tych par
        events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        if not events_to_cancel:
            # Je≈õli nie ma zdarze≈Ñ do usuniƒôcia, nic wiƒôcej nie r√≥b
            return False

        # Przygotuj i poka≈º okno dialogowe z potwierdzeniem
        grouped_events = self._group_events_by_user_date(events_to_cancel)
        delegations_info = self._prepare_delegations_description(grouped_events)

        reply = QMessageBox.question(
            self,
            "Potwierdzenie usuniƒôcia zdarze≈Ñ",
            f"Wstawienie tego symbolu wymaga odwo≈Çania istniejƒÖcych zdarze≈Ñ (spotka≈Ñ, nadgodzin itp.).\n\n{delegations_info}\nCzy chcesz kontynuowaƒá?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )

        if reply == QMessageBox.Yes:
            # Je≈õli u≈ºytkownik siƒô zgodzi, odwo≈Çaj delegacje
            self._cancel_delegations(events_to_cancel)
            return True
        else:
            # Je≈õli u≈ºytkownik anuluje, zwr√≥ƒá informacjƒô o tym
            self.statusBar().showMessage("Operacja anulowana przez u≈ºytkownika.", 3000)
            return False

    def get_data_from_model(self, row, col):
        """
        Pobiera dane z kom√≥rki modelu na podstawie wierszy i kolumn.

        Args:
            row: Indeks wiersza
            col: Indeks kolumny

        Returns:
            dict: Dane kom√≥rki lub pusty s≈Çownik
        """
        if not hasattr(self, 'schedule_model'):
            return {}

        # Pobierz dane z modelu
        index = self.schedule_model.index(row, col)
        cell_data = self.schedule_model.data(index, Qt.UserRole)

        # Upewnij siƒô, ≈ºe dane sƒÖ s≈Çownikiem
        if not isinstance(cell_data, dict):
            return {}

        return cell_data

    def get_selected_cells_data(self):
        """
        Pobiera dane dla zaznaczonych kom√≥rek z modelu.

        Returns:
            list: Lista danych zaznaczonych kom√≥rek
        """
        if not hasattr(self, 'table') or not self.table:
            return []

        # Deleguj do metody w SplitTableView, kt√≥ra ju≈º obs≈Çuguje model
        return self.table.get_data_for_selected_cells()

    def update_model_after_data_change(self, user_id, date_str):
        """
        Aktualizuje dane w modelu po zmianach w bazie danych.

        Args:
            user_id: ID u≈ºytkownika
            date_str: Data w formacie YYYY-MM-DD
        """
        if not user_id or not date_str:
            return

        # Pobierz rok i miesiƒÖc z daty
        if date_str.count('-') != 2:
            return

        year, month, _ = date_str.split('-')
        try:
            year = int(year)
            month = int(month)
        except ValueError:
            return

        # Pobierz aktualne dane z DataProvider - wymu≈õ od≈õwie≈ºenie cache
        self.data_provider.clear_cache()
        schedule_data = self.data_provider.get_schedule_data(year, month, use_cache=False)

        # Aktualizuj model
        if schedule_data and hasattr(self, 'schedule_model'):
            # Aktualizuj model bezpo≈õrednio
            self.schedule_model.update_data(schedule_data, year, month)

            # Zaktualizuj przefiltrowane dane
            filtered_data = self.filter_processed_data()
            self.schedule_model.update_filtered_data(filtered_data)

            # Od≈õwie≈º widok
            if hasattr(self, 'table'):
                self.table.update()

    def setup_model_connections(self):
        """
        ≈ÅƒÖczy sygna≈Çy modeli z obs≈ÇugƒÖ interfejsu u≈ºytkownika.
        """
        # Po≈ÇƒÖcz zmiany w modelach z aktualizacjƒÖ interfejsu
        if hasattr(self, 'schedule_model'):
            self.schedule_model.dataChanged.connect(self.on_schedule_data_changed)

        if hasattr(self, 'events_model'):
            self.events_model.dataChanged.connect(self.on_events_data_changed)

    def on_schedule_data_changed(self, topLeft, bottomRight):
        """
        Obs≈Çuguje zmianƒô danych w modelu grafiku.

        Args:
            topLeft: Indeks g√≥rnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Od≈õwie≈º widok
        if hasattr(self, 'table'):
            self.table.update()

        # Je≈õli zmieni≈Ço siƒô zaznaczenie, zaktualizuj tabelƒô zdarze≈Ñ
        if self.table.selection_changed.receivers() > 0:
            selected_rows = self.table.get_selected_rows()
            if selected_rows:
                self.on_selection_changed()

    def on_events_data_changed(self, topLeft, bottomRight):
        """
        Obs≈Çuguje zmianƒô danych w modelu zdarze≈Ñ.

        Args:
            topLeft: Indeks g√≥rnego lewego rogu zmienionych danych
            bottomRight: Indeks dolnego prawego rogu zmienionych danych
        """
        # Od≈õwie≈º tabelƒô zdarze≈Ñ
        if hasattr(self, 'events_table'):
            self.events_table.viewport().update()



    def get_selected_schedule_cells(self):
        """Zwraca listƒô zaznaczonych kom√≥rek z siatki grafiku"""
        selected_cells = []
        selected_ranges = self.table.selectedRanges()

        for range_item in selected_ranges:
            for row in range(range_item.topRow(), range_item.bottomRow() + 1):
                for col in range(range_item.leftColumn(), range_item.rightColumn() + 1):
                    # Sprawd≈∫ czy to kom√≥rka z grafikiem
                    if col >= 3:
                        # Pobierz element tabeli
                        cell_item = self.table.item(row, col)
                        if not cell_item:
                            continue

                        # Pobierz dane z kom√≥rki
                        cell_data = self.get_cell_data(cell_item)
                        if not cell_data:
                            continue

                        # Dodaj dane do listy wybranych kom√≥rek
                        selected_cells.append(cell_data)

        return selected_cells

    def group_cells_by_user_and_day(self, cells):
        """Grupuje kom√≥rki wed≈Çug u≈ºytkownika i dnia dla ≈Çatwiejszej edycji"""
        grouped = {}
        for cell in cells:
            # ZMIANA: Dostosuj do nowej struktury danych z modelu
            user_id = cell.get('uzytkownik_id')  # Zmieniono z 'user_id'
            date_str = cell.get('date_str')  # Zmieniono z 'date'

            if not user_id or not date_str:
                continue

            if user_id not in grouped:
                grouped[user_id] = {}

            if date_str not in grouped[user_id]:
                grouped[user_id][date_str] = []

            grouped[user_id][date_str].append(cell)

        return grouped

    def delete_event(self, event_id, event_type):
        """Wersja z weryfikacjƒÖ uprawnie≈Ñ oraz usuwaniem symbolu 'S' z grafiku po odwo≈Çaniu szkolenia."""
        debug_print(f"--- ROZPOCZƒòTO delete_event DLA ID: {event_id}, TYP: {event_type} ---")
        affected_pairs = []
        event_to_delete = None
        for event in (self.events_data or []):
            if event.get('id') == event_id and event.get('type') == event_type:
                user_id = event.get('user_id')
                date_key = event.get('date_key')
                if user_id and date_key:
                    affected_pairs.append((user_id, date_key))
                    event_to_delete = event
                    break

        if not event_to_delete:
            QMessageBox.warning(self, "B≈ÇƒÖd", "Nie mo≈ºna odnale≈∫ƒá zdarzenia do usuniƒôcia.")
            debug_print("[delete_event] Nie znaleziono zdarzenia. Zako≈Ñczono.")
            return

        cells_to_check = self._get_cell_data_for_user_date_pairs(affected_pairs)
        if not self._can_modify_cells(cells_to_check):
            debug_print("[delete_event] Brak uprawnie≈Ñ. Zako≈Ñczono.")
            return

        reply = QMessageBox.question(
            self, "Potwierdzenie",
            f"Czy na pewno chcesz usunƒÖƒá {event_type.lower()} o ID {event_id}?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.Yes
        )

        if reply != QMessageBox.StandardButton.Yes:
            debug_print("[delete_event] U≈ºytkownik anulowa≈Ç operacjƒô. Zako≈Ñczono.")
            return

        # Krok 1: Zapisz stan widoku PRZED jakƒÖkolwiek modyfikacjƒÖ.
        self._state_to_restore = self._save_view_state()
        debug_print(f"[delete_event] Zapisano stan widoku do self._state_to_restore.")

        try:
            # Krok 2: Je≈õli odwo≈Çujemy szkolenie, NAJPIERW zajmij siƒô usuniƒôciem symbolu 'S' z grafiku.
            # Robimy to teraz, gdy dane w `cells_to_check` sƒÖ wciƒÖ≈º aktualne.
            if event_type == 'Szkolenie':
                change_requests = []
                for cell_data in cells_to_check:
                    current_symbol = cell_data.get('symbol', '')
                    if not current_symbol: continue

                    parsed = parse_symbol(current_symbol)
                    if parsed.get('special_symbol') and parsed.get('special_symbol').upper() == 'S':
                        debug_print(
                            f"[delete_event] Znaleziono symbol 'S' w kom√≥rce: {current_symbol}. Przygotowujƒô usuniƒôcie.")
                        new_symbol = build_symbol(
                            location=parsed.get('location'), start_hour=parsed.get('start_hour'),
                            work_hours=parsed.get('work_hours'), special_symbol=None
                        )
                        try:
                            date_str = cell_data['date_str']
                            year, month, _ = map(int, date_str.split('-'))
                            change_requests.append({
                                'nr_kadrowy': cell_data['nr_kadrowy'], 'rok': year, 'miesiac': month,
                                'data': date_str, 'symbol': new_symbol, 'user_id': cell_data['uzytkownik_id'],
                                'user_name': cell_data['uzytkownik_dane']
                            })
                        except (ValueError, KeyError) as e:
                            log_warning(f"Pominiƒôto aktualizacjƒô symbolu 'S' przy usuwaniu zdarzenia: {e}")

                if change_requests:
                    self._process_and_apply_changes(change_requests, "Usuniƒôto symbol 'S' z {0} kom√≥rki grafiku.")

            # Krok 3: Teraz odwo≈Çaj zdarzenie w bazie danych.
            _, user_app_id, _, _, _ = get_modifier_id()
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            table_name = ""
            if event_type == "Spotkanie":
                table_name = SQL_OBJECTS['spotkania']
            elif event_type == "Szkolenie":
                table_name = SQL_OBJECTS['szkolenia']
            elif event_type == "Nadgodziny":
                table_name = SQL_OBJECTS['nadgodziny']
            else:
                conn.close()
                return

            if event_type in ["Spotkanie", "Szkolenie"]:
                query = f"UPDATE {table_name} SET Status = 0, DataDo = NULL, DataOd = Data, Modyfikujacy = ? WHERE Id = ?"
                cursor.execute(query, (user_app_id, event_id))
            else:
                query = f"DELETE FROM {table_name} WHERE Id = ?"
                cursor.execute(query, (event_id,))

            conn.commit()
            conn.close()
            debug_print("[delete_event] Pomy≈õlnie zaktualizowano bazƒô danych (odwo≈Çano zdarzenie).")
            self._update_modification_date()

            # Krok 4: Na samym ko≈Ñcu, zainicjuj od≈õwie≈ºenie danych w interfejsie.
            debug_print(
                "[delete_event] Wywo≈Çujƒô invalidate_complete_cache_for_pairs - za chwilƒô nastƒÖpi refresh i przywr√≥cenie stanu.")
            self.data_provider.invalidate_complete_cache_for_pairs(affected_pairs)
            self.statusBar().showMessage(f"Usuniƒôto zdarzenie o ID {event_id}.", 3000)

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas usuwania zdarzenia: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas usuwania zdarzenia: {str(e)}",
                                 QMessageBox.StandardButton.Ok)
            self._state_to_restore = None
        debug_print(f"--- ZAKO≈ÉCZONO delete_event DLA ID: {event_id} ---")

    def _update_multiple_overtime_locations(self, location_changes):
        """
        Aktualizuje lokalizacjƒô dla wielu wpis√≥w nadgodzin, ka≈ºdy z innƒÖ warto≈õciƒÖ.
        WERSJA POPRAWIONA: Aktualizuje r√≥wnie≈º nazwƒô zdarzenia w interfejsie.
        """
        if not location_changes:
            return True  # Brak zmian do wykonania to nie b≈ÇƒÖd

        location_map = {'h': 1, 's': 3, 'p': 2}

        try:
            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()

            for event_id, new_location_code in location_changes:
                location_value = location_map.get(new_location_code)
                if location_value is None:
                    log_warning(
                        f"Pominiƒôto aktualizacjƒô nadgodzin dla ID {event_id} z powodu nieznanego kodu lokalizacji: {new_location_code}")
                    continue

                query = f"UPDATE {SQL_OBJECTS['nadgodziny']} SET Lokalizacja = ? WHERE Id = ?"
                params = (location_value, event_id)
                debug_print(f"Aktualizujƒô lokalizacjƒô nadgodzin: ID={event_id}, nowa lokalizacja={location_value}")
                cursor.execute(query, params)

            conn.commit()
            conn.close()

            # --- NOWA LOGIKA: Aktualizacja nazwy w modelu danych po pomy≈õlnym zapisie w bazie ---

            # Mapa kod√≥w na pe≈Çne nazwy do wy≈õwietlenia
            location_display_map = {'h': 'Home Office', 's': 'SBC', 'p': 'Przystanek'}

            # Stw√≥rz s≈Çownik zmian dla szybszego wyszukiwania
            changes_map = dict(location_changes)

            # Zaktualizuj g≈Ç√≥wnƒÖ listƒô wszystkich zdarze≈Ñ
            for event in self.all_events_data:
                if event.get('id') in changes_map and event.get('type') == 'Nadgodziny':
                    new_loc_code = changes_map[event['id']]
                    new_loc_name = location_display_map.get(new_loc_code, 'N/A')
                    event['name'] = f"Nadgodziny {new_loc_name}"

            # Zaktualizuj listƒô zdarze≈Ñ aktualnie widocznƒÖ w tabeli
            for event in self.events_data:
                if event.get('id') in changes_map and event.get('type') == 'Nadgodziny':
                    new_loc_code = changes_map[event['id']]
                    new_loc_name = location_display_map.get(new_loc_code, 'N/A')
                    event['name'] = f"Nadgodziny {new_loc_name}"

            # Od≈õwie≈º model tabeli zdarze≈Ñ, aby UI pokaza≈Ç zmiany
            if hasattr(self, 'events_model'):
                self.events_model.update_data(self.events_data)

            debug_print(f"Zaktualizowano {len(location_changes)} wpis√≥w nadgodzin w interfejsie.")
            # --- KONIEC NOWEJ LOGIKI ---

            return True

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji wielu lokalizacji nadgodzin: {e}", exception=e)
            QMessageBox.critical(self, "B≈ÇƒÖd Bazy Danych", f"Nie uda≈Ço siƒô zaktualizowaƒá lokalizacji nadgodzin:\n{e}")
            return False

    def _update_overtime_icon_single(self, user_id, date_str, year, month):
        """
        NOWA METODA: Aktualizuje ikonƒô nadgodzin bez wp≈Çywania na cache innych danych.
        """
        try:
            # 1. Aktualizuj bezpo≈õrednio w modelu grafiku
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonƒô nadgodzin w modelu dla ({user_id}, {date_str})")

            # 2. Wyczy≈õƒá tylko cache ikon dla tej konkretnej kom√≥rki w DataProvider
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla kom√≥rki ({user_id}, {date_str})")

            # 3. Od≈õwie≈º widok grafiku
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas aktualizacji ikony nadgodzin: {e}")

    def _handle_specific_icons_refresh(self, data_type, year, month):
        """Obs≈Çuguje sygna≈Ç o zmianie danych ikon z DataProvider i od≈õwie≈ºa model."""
        if data_type == "icons":
            current_data = self.date_combo.currentData()
            if current_data and current_data == (year, month):
                debug_print(f"[DB] Otrzymano sygna≈Ç od≈õwie≈ºenia ikon dla {year}-{month}. Od≈õwie≈ºam model grafiku.")

                fresh_processed_data = self.data_provider.get_processed_data(
                    year, month, self.import_grupa, self.import_funkcja
                )
                self.processed_data = fresh_processed_data

                # Zamiast wywo≈Çywaƒá filter_data(), kt√≥re powoduje problemy,
                # rƒôcznie przekazujemy przefiltrowane dane do modelu.
                filtered_data = self.filter_processed_data()
                self.schedule_model.update_filtered_data(filtered_data)

                debug_print(
                    f"[DB] W _handle_specific_icons_refresh, sprawdzam flagƒô self._state_to_restore. Jest ona: {'USTAWIONA' if self._state_to_restore else 'PUSTA (None)'}")
                if self._state_to_restore:
                    # Je≈õli istnieje stan do przywr√≥cenia, odtwarzamy go.
                    # Ta funkcja sama zajmie siƒô przywr√≥ceniem sortowania i zaznaczenia.
                    self._restore_view_state(self._state_to_restore)
                    self._state_to_restore = None  # Wyczy≈õƒá flagƒô po u≈ºyciu
                else:
                    # Je≈õli nie ma stanu do przywr√≥cenia, stosujemy domy≈õlne sortowanie z ustawie≈Ñ.
                    debug_print("[DB] Brak stanu do przywr√≥cenia, aplikujƒô sortowanie niestandardowe.")
                    self.apply_custom_sort()

                # Od≈õwie≈ºamy tabelƒô zdarze≈Ñ na samym ko≈Ñcu, gdy zaznaczenie jest ju≈º poprawnie przywr√≥cone.
                self.on_selection_changed()

    def call_add_overtime_procedure_fixed(self, user_id, year, month, date_str, start_time, hours,
                                          settlement_date, is_overdue, overtime_type, location,
                                          nr_kadrowy):
        """
        Dodaje nadgodziny i zapewnia natychmiastowƒÖ, niezawodnƒÖ aktualizacjƒô
        tabeli zdarze≈Ñ oraz ikony w grafiku.
        """
        try:
            # Krok 1: Dodanie rekordu do bazy danych
            location_map = {'h': 1, 'p': 2, 's': 3}
            location_value = location_map.get(location, 1)
            param_value = 1 if overtime_type == 'odpracowanie' else None
            odebrane_value = 1 if overtime_type == 'odbi√≥r' else 0

            from datetime import datetime, timedelta
            start_datetime = datetime.strptime(f"{date_str} {start_time}", "%Y-%m-%d %H:%M")
            end_datetime = start_datetime + timedelta(hours=float(hours))
            end_time = end_datetime.strftime("%H:%M")

            conn = DatabaseConnector.get_connection()
            cursor = conn.cursor()
            params = [
                nr_kadrowy, year, month, date_str, start_datetime, end_datetime,
                settlement_date, is_overdue, odebrane_value, location_value,
                param_value
            ]
            sql = f"{{CALL {SQL_OBJECTS['p_nadgodzinywstawienie']} ({', '.join(['?'] * len(params))})}}"
            cursor.execute(sql, params)
            conn.commit()
            conn.close()

            # Krok 2: Rejestracja w≈Çasnej zmiany i uniewa≈ºnienie cache
            self._update_modification_date()
            self.data_provider.invalidate_complete_cache_for_pairs([(user_id, date_str)])

            # --- NOWA, KLUCZOWA LOGIKA (skopiowana z `delete_event`) ---
            # Krok 3: Bezpo≈õrednia aktualizacja ikony w modelu
            if hasattr(self, 'schedule_model'):
                # Sprawdzamy, jakie zdarzenia istniejƒÖ dla kom√≥rki PO dodaniu nowego
                remaining_events = self.data_provider.get_events_for_user_date(user_id, date_str)

                has_meetings = any(e.get('type') == 'Spotkanie' for e in remaining_events)
                has_trainings = any(e.get('type') == 'Szkolenie' for e in remaining_events)
                has_overtime = any(e.get('type') == 'Nadgodziny' for e in remaining_events)

                # Bezpo≈õrednio aktualizujemy stan ikon w modelu
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_meetings, has_trainings, has_overtime
                )

            # Krok 4: Od≈õwie≈ºenie dolnej tabeli zdarze≈Ñ
            self.on_selection_changed()

            # Zwracamy sukces
            return {
                "success": True,
                "message": "Nadgodziny zosta≈Çy pomy≈õlnie dodane."
            }

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas dodawania nadgodzin: {e}", exception=e)
            return {
                "success": False,
                "message": f"WystƒÖpi≈Ç b≈ÇƒÖd podczas dodawania nadgodzin: {str(e)}"
            }

    def _refresh_data_after_overtime_addition(self, new_id, user_id, date_str, year, month):
        """
        NOWA METODA: Od≈õwie≈ºa dane z bazy po dodaniu nadgodzin
        """
        try:
            debug_print(f"Od≈õwie≈ºam dane po dodaniu nadgodzin ID={new_id}")

            # Upewnij siƒô, ≈ºe column_mapper jest dostƒôpny
            if not hasattr(self, 'column_mapper'):
                from column_mapper import ColumnMapper
                self.column_mapper = ColumnMapper()

            # 1. POBIERZ NOWE ZDARZENIE Z BAZY DANYCH
            new_event = self._fetch_specific_event_from_db(year, month, new_id, 'Nadgodziny')

            if not new_event:
                log_error(f"Nie znaleziono dodanych nadgodzin o ID {new_id} w bazie danych")
                return

            debug_print(f"Pobrano nowe zdarzenie z bazy: {new_event}")

            # 2. AKTUALIZUJ CACHE DATAPROVIDER
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]

                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data")

                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []

                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in
                           container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache")

                # Aktualizuj processed_data - ustaw ikonƒô nadgodzin
                try:
                    day = int(date_str.split('-')[2])
                    for key, user_data in container.processed_data.items():
                        if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonƒô nadgodzin w processed_data")
                            break
                except Exception as e:
                    log_error(f"B≈ÇƒÖd aktualizacji processed_data: {e}")

            # 3. AKTUALIZUJ LOKALNE DANE
            # Konwertuj na lokalny format
            local_event = self._convert_dp_event_to_local(new_event)

            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(local_event)
                    debug_print(f"Dodano nadgodziny do all_events_data")

            # 4. AKTUALIZUJ events_data TYLKO JE≈öLI KOM√ìRKA JEST ZAZNACZONA
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )

                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(local_event)
                        debug_print(f"Dodano nadgodziny do events_data")

                        # Aktualizuj model zdarze≈Ñ
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # 5. AKTUALIZUJ MODEL GRAFIKU
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_cell_icons_directly(
                    user_id, date_str, has_overtime=True
                )
                debug_print(f"Zaktualizowano ikony w schedule_model")

            # 6. WYCZY≈öƒÜ CACHE IKON
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon")

            # 7. OD≈öWIE≈ª WIDOKI
            if hasattr(self, 'table'):
                if hasattr(self.table, 'schedule_view'):
                    self.table.schedule_view.viewport().update()

            if hasattr(self, 'events_table'):
                self.events_table.viewport().update()

            debug_print(f"=== OD≈öWIE≈ªENIE DANYCH ZAKO≈ÉCZONE ===")

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas od≈õwie≈ºania danych: {e}")
            import traceback
            traceback.print_exc()


    def _add_event_to_data_provider(self, new_id, user_id, user_name, date_str, start_time,
                                    end_time, overtime_type, is_overdue, year, month):
        """
        NOWA METODA: Dodaje zdarzenie bezpo≈õrednio do DataProvider i wszystkich cache'y
        """
        try:
            # Utw√≥rz obiekt zdarzenia w formacie DataProvider
            display_date = ".".join(reversed(date_str.split("-")))

            # Status na podstawie typu i flagi zaleg≈Ço≈õci
            if overtime_type == 'wyp≈Çata':
                status = "Wyp≈Çata - zaleg≈Çe" if is_overdue else "Wyp≈Çata"
            elif overtime_type == 'odbi√≥r':
                status = "Odbi√≥r"
            elif overtime_type == 'odpracowanie':
                status = "Odpracowanie"
            else:
                status = "Aktywne"

            # Utw√≥rz zdarzenie w formacie zgodnym z DataProvider
            new_event_dp_format = {
                'event_type': 'Nadgodziny',
                'event_id': new_id,
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'date': date_str,  # DataProvider oczekuje YYYY-MM-DD
                'time_from': f"{start_time}",  # Format z bazy
                'time_to': f"{end_time}",
                'status': 'Wstawione',  # Status w formacie bazy
                'type': 'Nadgodziny',
                'id': new_id,
                'date_display': display_date,
                'date_key': date_str
            }

            # Utw√≥rz zdarzenie w formacie lokalnym
            new_event_local_format = {
                'type': 'Nadgodziny',
                'topic': 'Nadgodziny',
                'name': 'Nadgodziny',
                'user_id': user_id,
                'user_name': user_name,
                'date': display_date,
                'date_key': date_str,
                'time_from': start_time,
                'time_to': end_time,
                'status': status,
                'id': new_id
            }

            # KLUCZOWA ZMIANA 1: Dodaj do cache DataProvider
            month_key = (year, month)
            if hasattr(self.data_provider, 'monthly_cache') and month_key in self.data_provider.monthly_cache:
                container = self.data_provider.monthly_cache[month_key]

                # Dodaj do events_data kontenera
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in container.events_data):
                    container.events_data.append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_data (ID: {new_id})")

                # Dodaj do events_cache kontenera
                cache_key = (user_id, date_str)
                if cache_key not in container.events_cache:
                    container.events_cache[cache_key] = []

                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in
                           container.events_cache[cache_key]):
                    container.events_cache[cache_key].append(new_event_dp_format)
                    debug_print(f"Dodano nadgodziny do DataProvider events_cache (ID: {new_id})")

                # Aktualizuj processed_data - dodaj ikonƒô nadgodzin
                for key, user_data in container.processed_data.items():
                    if str(key[3]) == str(user_id):  # key[3] to uzytkownik_id
                        try:
                            day = int(date_str.split('-')[2])
                            days_data = user_data.setdefault('days', {})
                            day_data = days_data.setdefault(day, {})
                            day_data['nadgodziny'] = 1
                            debug_print(f"Zaktualizowano ikonƒô nadgodzin w processed_data dla {user_id}, dzie≈Ñ {day}")
                            break
                        except:
                            pass

            # KLUCZOWA ZMIANA 2: Dodaj do lokalnych danych
            # Dodaj do all_events_data
            if hasattr(self, 'all_events_data'):
                if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.all_events_data):
                    self.all_events_data.append(new_event_local_format)
                    debug_print(f"Dodano nadgodziny do all_events_data (ID: {new_id})")

            # KLUCZOWA ZMIANA 3: Dodaj do events_data tylko je≈õli kom√≥rka jest zaznaczona
            if hasattr(self, 'events_data'):
                selected_cells = self.table.get_data_for_selected_cells()
                should_add_to_current_view = any(
                    cell.get('uzytkownik_id') == user_id and cell.get('date_str') == date_str
                    for cell in selected_cells
                )

                if should_add_to_current_view:
                    if not any(e.get('id') == new_id and e.get('type') == 'Nadgodziny' for e in self.events_data):
                        self.events_data.append(new_event_local_format)
                        debug_print(f"Dodano nadgodziny do events_data (ID: {new_id})")

                        # Aktualizuj model zdarze≈Ñ
                        if hasattr(self, 'events_model'):
                            self.events_model.update_data(self.events_data)
                            self.filter_events_table()

            # KLUCZOWA ZMIANA 4: Aktualizuj ikonƒô w modelu
            if hasattr(self, 'schedule_model'):
                self.schedule_model.update_event_indicator(user_id, date_str, "Nadgodziny", True)
                debug_print(f"Zaktualizowano ikonƒô nadgodzin w modelu dla ({user_id}, {date_str})")

            # KLUCZOWA ZMIANA 5: Wyczy≈õƒá tylko cache ikon dla tej kom√≥rki (nie ca≈Çy cache)
            if hasattr(self.data_provider, '_icons_cache_by_month'):
                month_key = (year, month)
                if month_key in self.data_provider._icons_cache_by_month:
                    cell_key = (user_id, date_str)
                    month_cache = self.data_provider._icons_cache_by_month[month_key]
                    if cell_key in month_cache:
                        del month_cache[cell_key]
                        debug_print(f"Wyczyszczono cache ikon dla kom√≥rki ({user_id}, {date_str})")

            # Od≈õwie≈º widok
            if hasattr(self, 'table') and hasattr(self.table, 'schedule_view'):
                self.table.schedule_view.viewport().update()

        except Exception as e:
            log_error(f"B≈ÇƒÖd podczas dodawania zdarzenia do DataProvider: {e}")

    def debug_check_event_in_index(self, event_id, event_type='Nadgodziny'):
        """
        Sprawdza, czy zdarzenie o podanym ID istnieje w indeksie zdarze≈Ñ
        i wy≈õwietla informacje diagnostyczne.

        Args:
            event_id: ID zdarzenia
            event_type: Typ zdarzenia (domy≈õlnie 'Nadgodziny')

        Returns:
            bool: True je≈õli znaleziono zdarzenie, False w przeciwnym wypadku
        """
        debug_print(f"\n--- DIAGNOSTYKA INDEKSU ZDARZE≈É ---")
        debug_print(f"Szukam zdarzenia o ID {event_id} i typie {event_type}")

        # Sprawd≈∫ w indeksie zdarze≈Ñ DataProvider
        if hasattr(self.data_provider, 'events_index'):
            # Sprawd≈∫ bezpo≈õrednio przez indeks ID
            event = self.data_provider.events_index.get_event_by_id(event_id)
            if event:
                debug_print(f"ZNALEZIONO w indeksie ID: {event}")
                return True

            # Alternatywnie, przeszukaj wszystkie zdarzenia
            found_in_all = False
            for e in self.data_provider.events_index.all_events:
                if e.get('id') == event_id and e.get('type') == event_type:
                    debug_print(f"ZNALEZIONO w all_events: {e}")
                    found_in_all = True

            # Przeszukaj indeks typ√≥w
            found_in_type_index = False
            type_events = self.data_provider.events_index.type_index.get(event_type, [])
            for e in type_events:
                if e.get('id') == event_id:
                    debug_print(f"ZNALEZIONO w type_index: {e}")
                    found_in_type_index = True

            if not found_in_all and not found_in_type_index:
                debug_print("NIE ZNALEZIONO w indeksie zdarze≈Ñ")
                return False

            return found_in_all or found_in_type_index
        else:
            debug_print("BRAK indeksu zdarze≈Ñ w data_provider")
            return False

    def update_cell_data(self, user_id, date_str, event_type=None, action="update"):
        """
        Aktualizuje dane kom√≥rki i ikony po r√≥≈ºnych operacjach.
        Zoptymalizowana wersja wykorzystujƒÖca precyzyjne aktualizacje.

        Args:
            user_id: ID u≈ºytkownika
            date_str: Data w formacie 'YYYY-MM-DD'
            event_type: Typ zdarzenia (Spotkanie, Szkolenie, Nadgodziny lub None)
            action: Rodzaj operacji - "update", "add", "delete"

        Returns:
            bool: True je≈õli operacja siƒô powiod≈Ça, False w przeciwnym wypadku
        """
        if not user_id or not date_str:
            return False

        # Standardyzuj format daty
        date_str = self.data_provider._standardize_date(date_str)

        # Wyczy≈õƒá cache dla miesiƒÖca tej daty
        if date_str and date_str.count('-') == 2:
            year, month, _ = date_str.split('-')
            self.clear_events_cache(int(year), int(month))

        # Pobierz zdarzenia dla tej pary (u≈ºytkownik, data)
        events = self.data_provider.get_events_for_user_date(user_id, date_str)

        # Sprawd≈∫ typy zdarze≈Ñ
        has_meeting = any(
            e.get('type') == 'Spotkanie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_training = any(
            e.get('type') == 'Szkolenie' and e.get('status') != '0' and e.get('status') != 0 for e in events)
        has_overtime = any(e.get('type') == 'Nadgodziny' for e in events)

        # Aktualizuj wska≈∫niki w modelu - u≈ºywajƒÖc zoptymalizowanej metody
        if hasattr(self, 'schedule_model'):
            if event_type == 'Spotkanie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Szkolenie':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie',
                                                                  is_active=(action != "delete"))
            elif event_type == 'Nadgodziny':
                return self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny',
                                                                  is_active=(action != "delete"))
            else:
                # Aktualizuj wszystkie wska≈∫niki
                result1 = self.schedule_model.update_event_indicator(user_id, date_str, 'Spotkanie', has_meeting)
                result2 = self.schedule_model.update_event_indicator(user_id, date_str, 'Szkolenie', has_training)
                result3 = self.schedule_model.update_event_indicator(user_id, date_str, 'Nadgodziny', has_overtime)
                return result1 or result2 or result3

        return False

    def get_all_valid_symbols(self) -> set:
        """Zwraca zbi√≥r wszystkich prawid≈Çowych symboli specjalnych z za≈Çadowanej konfiguracji."""
        all_symbols = set()
        for category in app_settings.SYMBOL_CATEGORIES.values():
            all_symbols.update(category.keys())
        return all_symbols

    def apply_symbol_from_keyboard(self, special_symbol: str):
        """
        Uproszczona metoda: Aplikuje symbol z klawiatury, delegujƒÖc logikƒô
        do scentralizowanej metody.
        """
        if special_symbol:
            self._apply_special_symbol_to_selection(special_symbol)

    def _apply_special_symbol_to_selection(self, special_symbol: str):
        """
        NOWA, SCENTRALIZOWANA METODA: Wstawia symbol specjalny z uwzglƒôdnieniem
        szczeg√≥≈Çowej logiki dla r√≥l Lider, Lider OUT i Pracownik WPR.
        """
        selected_cells_data = self.table.get_data_for_selected_cells()
        if not selected_cells_data:
            self.statusBar().showMessage("Nie zaznaczono ≈ºadnych kom√≥rek do edycji.", 3000)
            return

        if not self._can_modify_cells(selected_cells_data):
            return

        view_state = self._save_view_state()

        processed_cells_to_modify = []
        for cell_data in selected_cells_data:
            parsed_symbol = parse_symbol(cell_data.get('symbol', ''))
            is_empty_cell = parsed_symbol.get('work_hours') is None

            if is_empty_cell:
                if self.current_user_role in ['Lider', 'Pracownik WPR']:
                    continue
                elif self.current_user_role == 'Lider OUT':
                    try:
                        work_hours = int(float(cell_data.get('etat', 8.0)))
                    except (ValueError, TypeError):
                        work_hours = 8

                    default_shift_symbol = build_symbol(
                        location=cell_data.get('lokalizacja_domyslna', 'h'),
                        start_hour=9,
                        work_hours=work_hours,
                        special_symbol=None
                    )
                    modified_cell = cell_data.copy()
                    modified_cell['symbol'] = default_shift_symbol
                    processed_cells_to_modify.append(modified_cell)
                else:
                    processed_cells_to_modify.append(cell_data)
            else:
                processed_cells_to_modify.append(cell_data)

        if not processed_cells_to_modify:
            QMessageBox.information(self, "Informacja",
                                    "Brak prawid≈Çowych kom√≥rek do modyfikacji dla Twojej roli i zaznaczenia.")
            return

        cells_to_modify_final = []
        skipped_for_dtn = []
        if self.current_user_role in ['Lider', 'Lider OUT']:
            for cell in processed_cells_to_modify:
                target_dept = cell.get('wydzial', '').strip().lower()
                if target_dept == 'dtn' and special_symbol.upper() != 'CO':
                    skipped_for_dtn.append(cell.get('uzytkownik_dane', 'Nieznany'))
                else:
                    cells_to_modify_final.append(cell)
        else:
            cells_to_modify_final = processed_cells_to_modify

        if skipped_for_dtn:
            QMessageBox.warning(self, "Operacja zablokowana",
                                f"Dla wydzia≈Çu DTN dozwolony jest tylko symbol 'CO'.\\n"
                                f"Pominiƒôto zmiany dla: {', '.join(set(skipped_for_dtn))}")

        if not cells_to_modify_final:
            return

        events_to_cancel = []
        if special_symbol.upper() in app_settings.get_absence_symbols():
            user_date_pairs = {(c.get('uzytkownik_id'), c.get('date_str')) for c in cells_to_modify_final}
            events_to_cancel = self._find_events_to_cancel(user_date_pairs)

        reply = QMessageBox.Yes
        if self._should_ask_for_confirmation():
            grouped_changes = self._group_cells_for_symbol_changes(cells_to_modify_final)
            changes_info = self._prepare_symbol_changes_description(grouped_changes, special_symbol)
            complete_info = f"Czy na pewno chcesz wprowadziƒá nastƒôpujƒÖce zmiany?\\n\\n{changes_info}"
            if events_to_cancel:
                grouped_events = self._group_events_by_user_date(events_to_cancel)
                delegations_info = self._prepare_delegations_description(grouped_events)
                complete_info += f"\\n{delegations_info}"
            reply = QMessageBox.question(self, "Potwierdzenie wstawienia symbolu", complete_info,
                                         QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)

        if reply != QMessageBox.Yes:
            self.statusBar().showMessage("Operacja anulowana przez u≈ºytkownika.", 3000)
            return

        if events_to_cancel:
            self.cancel_delegations()

        updated_info, error_messages, skipped_employees = [], [], []

        for cell_data in cells_to_modify_final:
            # --- NOWA LOGIKA: WyjƒÖtek dla Lidera wstawiajƒÖcego 'U' innemu Liderowi ---
            if self.current_user_role == 'Lider' and special_symbol.upper() == 'U':
                target_role = cell_data.get('rola_nazwa', '')
                target_dept = cell_data.get('wydzial', '')
                # Lider mo≈ºe wstawiƒá 'U' tylko innemu Liderowi w tym samym wydziale
                if not (target_role == 'Lider' and target_dept == self.current_user_department):
                    skipped_employees.append(
                        f"{cell_data.get('uzytkownik_dane', 'Nieznany')} (nie jest Liderem w tym samym wydziale)")
                    continue  # Pomi≈Ñ tego pracownika
            # --- KONIEC NOWEJ LOGIKI ---

            permissions = self._get_permission_for_cell(cell_data)
            if not permissions['can_edit_symbol']:
                skipped_employees.append(cell_data.get('uzytkownik_dane', 'Nieznany'))
                continue

            new_symbol = self._predict_new_symbol(cell_data.get('symbol', ''), special_symbol, cell_data)
            try:
                user_id, date_str, nr_kadrowy = cell_data.get('uzytkownik_id'), cell_data.get(
                    'date_str'), cell_data.get('nr_kadrowy')
                year, month, _ = date_str.split('-')
                result = self._call_import_changes_procedure(
                    nr_kadrowy=nr_kadrowy, rok=int(year), miesiac=int(month), data=date_str, symbol=new_symbol
                )
                if result.get('success'):
                    updated_info.append((user_id, date_str, result.get('returned_symbol')))
                else:
                    error_messages.append(
                        f"B≈ÇƒÖd: {cell_data.get('uzytkownik_dane')}: {result.get('message', 'B≈ÇƒÖd zapisu.')}")
            except Exception as e:
                log_error(f"B≈ÇƒÖd w _apply_special_symbol_to_selection: {e}", exception=e)
                error_messages.append(f"B≈ÇƒÖd: {cell_data.get('uzytkownik_dane')}: B≈ÇƒÖd aplikacji: {e}")

        if updated_info:
            self._update_cells_with_new_symbols(updated_info)
            self.statusBar().showMessage(f"Zastosowano symbol '{special_symbol}' dla {len(updated_info)} kom√≥rek.",
                                         4000)

        self._show_symbol_change_results(len(updated_info), len(error_messages), error_messages, events_to_cancel,
                                         skipped_employees)

    def apply_theme_settings(self, theme, font_family, font_size):
        """Stosuje wybrane ustawienia motywu z wykorzystaniem centralnych styl√≥w"""
        # Zapamiƒôtaj wybrane ustawienia
        self.is_dark_theme = (theme == "dark")
        self.current_font = font_family
        self.current_font_size = font_size

        # Zastosuj czcionkƒô do ca≈Çej aplikacji
        font = QFont(font_family, font_size)
        QApplication.setFont(font)

        # Zastosuj g≈Ç√≥wny styl dla ca≈Çego okna aplikacji
        self.setStyleSheet(AppStyles.get_main_window_style(theme))

        # Definicje styl√≥w
        button_style = AppStyles.get_button_style(theme, font_family, font_size)
        combo_style = AppStyles.get_combobox_style(theme)
        line_edit_style = AppStyles.get_line_edit_style(theme)
        list_style = AppStyles.get_list_style(theme)
        date_edit_style = AppStyles.get_date_edit_style(theme)
        checkbox_style = AppStyles.get_checkbox_style(theme)
        table_style = AppStyles.get_table_style(theme)
        left_panel_style = AppStyles.get_left_panel_style(theme)

        # Stosowanie styl√≥w do wszystkich istniejƒÖcych kontrolek
        all_buttons = self.findChildren(QPushButton)
        for button in all_buttons:
            if "FilterClearButton" not in button.objectName():
                button.setStyleSheet(button_style)

        new_icon = self.clear_icon_dark if self.is_dark_theme else self.clear_icon_light
        for button in self.findChildren(QPushButton, "FilterClearButton"):
            button.setIcon(new_icon)

        # Pola wyboru (ComboBox)
        if hasattr(self, 'date_combo'): self.date_combo.setStyleSheet(combo_style)
        if hasattr(self, 'grupa_main_filter_combo'): self.grupa_main_filter_combo.setStyleSheet(combo_style)
        if hasattr(self, 'wydzial_combo'): self.wydzial_combo.setStyleSheet(combo_style)
        if hasattr(self, 'default_location_combo'): self.default_location_combo.setStyleSheet(combo_style)
        if hasattr(self, 'system_czasu_pracy_combo'): self.system_czasu_pracy_combo.setStyleSheet(combo_style)
        if hasattr(self, 'rola_combo'): self.rola_combo.setStyleSheet(combo_style)
        if hasattr(self, 'jezyk_combo'): self.jezyk_combo.setStyleSheet(combo_style)
        if hasattr(self, 'etat_combo'): self.etat_combo.setStyleSheet(combo_style)
        if hasattr(self, 'dtn_combo'): self.dtn_combo.setStyleSheet(combo_style)
        if hasattr(self, 'presence_location_combo'): self.presence_location_combo.setStyleSheet(combo_style)
        if hasattr(self, 'presence_hour_combo'): self.presence_hour_combo.setStyleSheet(combo_style)
        # ZMIANA: Dodanie stylu dla nowego filtra statusu
        if hasattr(self, 'status_filter_combo'): self.status_filter_combo.setStyleSheet(combo_style)

        # Inne kontrolki
        if hasattr(self, '_left_panel'): self._left_panel.setStyleSheet(left_panel_style)
        if hasattr(self, 'przelozony_filter'): self.przelozony_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'uzytkownik_filter'): self.uzytkownik_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'topic_filter'): self.topic_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'name_filter'): self.name_filter.setStyleSheet(line_edit_style)
        if hasattr(self, 'przelozony_list'): self.przelozony_list.setStyleSheet(list_style)
        if hasattr(self, 'uzytkownik_list'): self.uzytkownik_list.setStyleSheet(list_style)
        if hasattr(self, 'date_from'): self.date_from.setStyleSheet(date_edit_style)
        if hasattr(self, 'date_to'): self.date_to.setStyleSheet(date_edit_style)
        if hasattr(self, 'presence_date_edit'): self.presence_date_edit.setStyleSheet(date_edit_style)
        if hasattr(self, 'meetings_checkbox'): self.meetings_checkbox.setStyleSheet(checkbox_style)
        if hasattr(self, 'trainings_checkbox'): self.trainings_checkbox.setStyleSheet(checkbox_style)
        if hasattr(self, 'overtime_checkbox'): self.overtime_checkbox.setStyleSheet(checkbox_style)
        if hasattr(self, 'filter_by_presence_check'): self.filter_by_presence_check.setStyleSheet(checkbox_style)

        # Aktualizacja modeli i tabel
        if hasattr(self, 'schedule_model'): self.schedule_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'events_model'): self.events_model.set_theme(self.is_dark_theme)
        if hasattr(self, 'table'):
            if hasattr(self.table, 'employees_view'): self.table.employees_view.setStyleSheet(table_style)
            if hasattr(self.table, 'schedule_view'): self.table.schedule_view.setStyleSheet(table_style)
        if hasattr(self, 'events_table'): self.events_table.setStyleSheet(table_style)

        if self.staffing_details_win and not self.staffing_details_win.isHidden():
            self.staffing_details_win.set_current_theme(self.is_dark_theme)

        if hasattr(self, 'table'):
            self._apply_dynamic_sizes()

    def save_user_settings_on_exit(self):
        """Zbiera i zapisuje wszystkie ustawienia u≈ºytkownika przy zamykaniu."""
        if not hasattr(self, 'user_settings'):
            return

        # Zbierz dynamiczne ustawienia z UI
        ui_settings = {
            'is_maximized': self.isMaximized(),
            'window_size': (self.size().width(), self.size().height()),
            'last_filters': self.get_current_filters_state(),
            'column_widths': self.table.get_column_widths(),
            'visible_columns': self.visible_columns,
            # DODANE: Jawne zapisanie aktualnych ustawie≈Ñ motywu
            'theme': 'dark' if self.is_dark_theme else 'light',
            'font_family': self.current_font,
            'font_size': self.current_font_size
        }

        # Zaktualizuj g≈Ç√≥wny s≈Çownik ustawie≈Ñ
        self.user_settings.update(ui_settings)

        # Zapisz ca≈Çy s≈Çownik do bazy
        self.settings_db.save_settings(self.user_settings)
        debug_print("Zapisano ustawienia u≈ºytkownika przy zamkniƒôciu.")

    def copy_selection_to_clipboard(self):
        """
        Zbiera dane z zaznaczonych kom√≥rek i kopiuje je do schowka
        w formacie TSV, gotowym do wklejenia w Excelu.
        """
        if not hasattr(self, 'table') or not self.schedule_model:
            return

        selection_model_employees = self.table.employees_view.selectionModel()
        selection_model_schedule = self.table.schedule_view.selectionModel()

        if not selection_model_employees.hasSelection() or not selection_model_schedule.hasSelection():
            self.statusBar().showMessage("Proszƒô zaznaczyƒá wiersze pracownik√≥w oraz kolumny dni do skopiowania.", 3000)
            return

        # Krok 1: Zbierz unikalne, posortowane indeksy wierszy i kolumn
        selected_rows = sorted(list(set(index.row() for index in selection_model_employees.selectedIndexes())))
        selected_schedule_cols = sorted(
            list(set(index.column() for index in selection_model_schedule.selectedIndexes())))

        if not selected_rows or not selected_schedule_cols:
            return

        # Krok 2: Przygotuj nag≈Ç√≥wki
        headers = []
        visible_employee_cols_ids = self.schedule_model.get_visible_columns()
        for col_id in visible_employee_cols_ids:
            # Znajd≈∫ nazwƒô kolumny na podstawie jej ID
            header_name = next((name for id, name, width in self.employee_columns if id == col_id), col_id)
            headers.append(header_name)

        for col in selected_schedule_cols:
            header_text = str(self.schedule_model.headerData(col, Qt.Horizontal, Qt.DisplayRole)).replace('\n', ' ')
            headers.append(header_text)

        clipboard_string = "\t".join(headers) + "\n"

        # Krok 3: Przygotuj wiersze z danymi
        for row in selected_rows:
            row_values = []
            # Dodaj dane pracownik√≥w
            for col_idx in range(len(visible_employee_cols_ids)):
                index = self.schedule_model.index(row, col_idx)
                value = self.schedule_model.data(index, Qt.DisplayRole)
                row_values.append(str(value or ''))

            # Dodaj dane z grafiku
            for col in selected_schedule_cols:
                index = self.schedule_model.index(row, col)
                value = self.schedule_model.data(index, Qt.DisplayRole)
                row_values.append(str(value or ''))

            clipboard_string += "\t".join(row_values) + "\n"

        # Krok 4: Wstaw sformatowany tekst do schowka
        QApplication.clipboard().setText(clipboard_string)
        self.statusBar().showMessage(f"Skopiowano {len(selected_rows)} wierszy do schowka.", 3000)

    def closeEvent(self, event):
        """Obs≈Çuguje zamkniƒôcie aplikacji i zapisuje ustawienia."""
        try:
            # Wywo≈Çaj nowƒÖ metodƒô zapisu
            self.save_user_settings_on_exit()

            debug_print("=== ZAMYKANIE APLIKACJI TEAMFLOW ===")
            self.cleanup_keyboard_filter()
            close_log_file()
        except Exception as e:
            log_error(f"WystƒÖpi≈Ç b≈ÇƒÖd podczas zamykania aplikacji: {e}", exception=e)
        finally:
            event.accept()


if __name__ == "__main__":
    app = QApplication(sys.argv)

    # --- NOWA, BEZPIECZNA SEKWENCJA STARTOWA ---

    # Krok 1: Za≈Çaduj kluczowe ustawienia PRZED utworzeniem g≈Ç√≥wnego okna
    if not load_all_app_settings():
        QMessageBox.critical(None, "B≈ÇƒÖd Krytyczny",
                             "Nie uda≈Ço siƒô za≈Çadowaƒá konfiguracji aplikacji z serwera.\n"
                             "Sprawd≈∫ po≈ÇƒÖczenie z bazƒÖ danych i plik config.ini.\n\n"
                             "Aplikacja nie mo≈ºe zostaƒá uruchomiona.")
        sys.exit(1)

    # Krok 2: Sprawd≈∫ wersjƒô aplikacji PRZED utworzeniem g≈Ç√≥wnego okna
    if parse_version(APP_VERSION) != parse_version(app_settings.REQUIRED_VERSION):
        # Inicjalizujemy logowanie z pustymi ustawieniami, aby ewentualne b≈Çƒôdy mog≈Çy byƒá zapisane
        setup_logging()
        log_error(
            f"Wersja aplikacji jest przestarza≈Ça. Wymagana: {app_settings.REQUIRED_VERSION}, Obecna: {APP_VERSION}")

        # U≈ºywamy QDialog bezpo≈õrednio, bo g≈Ç√≥wne okno jeszcze nie istnieje
        dialog = UpdateRequiredDialog()
        dialog.exec()
        sys.exit(0)  # Zako≈Ñcz normalnie po informacji dla u≈ºytkownika

    # Krok 3: Zainicjuj logowanie (teraz, gdy wiemy, ≈ºe aplikacja mo≈ºe wystartowaƒá)
    try:
        current_windows_user = getpass.getuser().lower()
    except Exception:
        current_windows_user = "unknown_user"

    log_to_file = current_windows_user in app_settings.LOGGING_USERS_FILE
    log_to_console = current_windows_user in app_settings.LOGGING_USERS_CONSOLE
    setup_logging(log_to_file=log_to_file, log_to_console=log_to_console)

    # Krok 4: Je≈õli wszystko jest w porzƒÖdku, utw√≥rz i poka≈º g≈Ç√≥wne okno
    window = WorkScheduleWindow()
    if window.user_settings.get('is_maximized'):
        window.showMaximized()
    else:
        window.show()
    sys.exit(app.exec())
