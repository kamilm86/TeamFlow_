Przepraszam za wcześniejsze nieporozumienia. Skupiłem się na niewłaściwej metodzie. Dziękuję za precyzyjne wskazanie, że zmiany należy wprowadzić w show_add_overtime_dialog.
Przeanalizowałem kod i przygotowałem poprawioną wersję tej konkretnej metody, która prawidłowo oblicza czas rozpoczęcia i zakończenia nadgodzin, zgodnie z Twoimi wytycznymi.
Poprawiona metoda show_add_overtime_dialog
W pliku main.py, w klasie WorkScheduleWindow, proszę zastąpić istniejącą metodę show_add_overtime_dialog poniższym, poprawionym kodem.
# W pliku main.py w klasie WorkScheduleWindow

def show_add_overtime_dialog(self):
    """
    Otwiera dialog do dodawania nadgodzin i zapisuje je w bazie,
    poprawnie formatując daty time_from i time_to jako smalldatetime.
    """
    selected = self.table.selectionModel().selectedIndexes()
    if not selected:
        self.statusBar().showMessage("Proszę zaznaczyć komórkę pracownika i dnia.", 3000)
        return

    # Pobieramy dane tylko z pierwszej zaznaczonej komórki
    cell_data = self.table.get_data_for_selected_cells()[0]
    user_id = cell_data.get('uzytkownik_id')
    date_str = cell_data.get('date_str') # Np. '2025-07-10'

    if not user_id or not date_str:
        self.statusBar().showMessage("Nie można dodać zdarzenia dla tej komórki.", 3000)
        return

    # Używamy uniwersalnego dialogu w trybie dodawania nadgodzin
    dialog = AddOrEditEventDialog(self, event=None, date_str=date_str, user_id=user_id, event_type='Nadgodziny', theme=self.current_theme)
    
    if dialog.exec() == QDialog.Accepted:
        details = dialog.get_event_details()

        # --- KLUCZOWA ZMIANA: Prawidłowe tworzenie obiektów datetime ---
        try:
            # 1. Pobieramy dane z dialogu
            time_part = details['time_from']  # Czas w formacie "HH:MM"
            duration_hours_str = details.get('duration', '0').replace(',', '.')
            duration_hours = float(duration_hours_str)

            # 2. Tworzymy `time_from` jako obiekt datetime
            # Łączymy datę z komórki (np. "2025-07-10") z czasem rozpoczęcia (np. "16:00")
            time_from_dt = datetime.datetime.strptime(f"{date_str} {time_part}", "%Y-%m-%d %H:%M")

            # 3. Obliczamy `time_to` przez dodanie czasu trwania
            time_to_dt = time_from_dt + datetime.timedelta(hours=duration_hours)

        except (ValueError, TypeError) as e:
            log_error(f"Błąd podczas parsowania danych dla nadgodzin w show_add_overtime_dialog: {e}", exception=e)
            QMessageBox.critical(self, "Błąd Danych", "Wprowadzono nieprawidłowy format czasu lub czasu trwania nadgodzin.")
            return
        # --- KONIEC KLUCZOWEJ ZMIANY ---

        # Przygotowanie reszty danych do zapisu
        location_code = details['location']
        description = details['description']
        
        location_display_map = {'h': 'Home Office', 's': 'Stacjonarnie', 'p': 'mPrzystanek'}
        location_db_map = {'h': 1, 's': 3, 'p': 2}
        
        event_name = f"Nadgodziny {location_display_map.get(location_code, 'N/A')}"
        location_db_value = location_db_map.get(location_code)

        # Wywołanie procedury zapisu z poprawnie przygotowanymi obiektami datetime
        success, message = self.data_provider.save_overtime_event(
            user_id=user_id,
            time_from=time_from_dt,
            time_to=time_to_dt,
            location_id=location_db_value,
            name=event_name,
            description=description
        )

        if success:
            self.statusBar().showMessage("Pomyślnie dodano wpis o nadgodzinach.", 4000)
            self.refresh_data() # Odświeżamy dane, aby zobaczyć nowy wpis
        else:
            QMessageBox.warning(self, "Błąd Zapisu", f"Nie udało się zapisać nadgodzin:\n{message}")

